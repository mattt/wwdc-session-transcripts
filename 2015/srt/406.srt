X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:28,136 --> 00:00:28,656 A:middle
>> WIL TURNER: Good morning.

2
00:00:29,286 --> 00:00:32,356 A:middle
And welcome to UI
testing in Xcode.

3
00:00:33,146 --> 00:00:34,046 A:middle
My name is Wil Turner.

4
00:00:34,636 --> 00:00:35,976 A:middle
With me is Brooke Callahan.

5
00:00:36,716 --> 00:00:39,626 A:middle
We both work on the
Xcode developer tools.

6
00:00:40,536 --> 00:00:44,466 A:middle
And I am extremely excited
today because we are sharing

7
00:00:44,466 --> 00:00:48,506 A:middle
with you a huge expansion
of the testing technology

8
00:00:48,506 --> 00:00:50,166 A:middle
in the Xcode developer tools.

9
00:00:51,316 --> 00:00:52,726 A:middle
That is UI testing.

10
00:00:53,196 --> 00:00:57,986 A:middle
With UI testing you can find
user interface elements,

11
00:00:58,546 --> 00:01:03,086 A:middle
interact with them, and validate
the UI properties in state.

12

13
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

14
00:00:58,546 --> 00:01:03,086 A:middle
interact with them, and validate
the UI properties in state.

15
00:01:04,256 --> 00:01:07,756 A:middle
Along with UI testing, we've
introduced UI recording

16
00:01:07,896 --> 00:01:10,796 A:middle
which will allow you
to really rapidly set

17
00:01:10,796 --> 00:01:12,996 A:middle
up UI testing for your projects.

18
00:01:14,256 --> 00:01:17,806 A:middle
Finally, we've updated
the test reports in Xcode,

19
00:01:17,806 --> 00:01:21,516 A:middle
which show the pass and fail and
results of your test outcomes,

20
00:01:21,646 --> 00:01:24,466 A:middle
to accommodate new data
we have with UI testing.

21
00:01:26,166 --> 00:01:29,106 A:middle
So I want to talk about
the core technologies

22
00:01:29,386 --> 00:01:31,566 A:middle
for UI testing, the
first is XCTest.

23
00:01:32,566 --> 00:01:34,616 A:middle
The second is accessibility.

24
00:01:35,766 --> 00:01:38,606 A:middle
So XCTest is Xcode's
testing framework.

25
00:01:38,926 --> 00:01:42,506 A:middle
In it, you create subclasses
for your test cases,

26
00:01:42,856 --> 00:01:46,956 A:middle
you implement test methods, and
you use assertions to validate

27
00:01:47,036 --> 00:01:49,356 A:middle
that your expected
outcomes are holding true.

28
00:01:50,676 --> 00:01:55,056 A:middle
XCtest is integrated with Xcode,
which means you get everything

29
00:01:55,056 --> 00:01:58,536 A:middle
from the ID in terms of
code completion, debugging,

30
00:01:58,536 --> 00:02:01,216 A:middle
and the ability to run
your tests directly

31

32
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

33
00:01:58,536 --> 00:02:01,216 A:middle
and the ability to run
your tests directly

34
00:02:01,306 --> 00:02:04,356 A:middle
from your source code, and
see the results right there.

35
00:02:05,436 --> 00:02:08,656 A:middle
You also get continuous
integration via Xcode Server

36
00:02:08,656 --> 00:02:09,576 A:middle
and Xcodebuild.

37
00:02:10,856 --> 00:02:14,806 A:middle
Finally, XCTest supports
both Swift and Objective-C,

38
00:02:14,906 --> 00:02:16,966 A:middle
so you can choose the
native coding language

39
00:02:17,026 --> 00:02:18,786 A:middle
that you're most
comfortable with.

40
00:02:20,116 --> 00:02:24,196 A:middle
XCTest was introduced in Xcode
5 as a unit testing framework.

41
00:02:24,376 --> 00:02:28,716 A:middle
In Xcode 6, we expanded it to
support performance testing.

42
00:02:29,246 --> 00:02:31,776 A:middle
This allows you to catch
regressions in your code,

43
00:02:31,976 --> 00:02:33,236 A:middle
and ensure that it continues

44
00:02:33,236 --> 00:02:36,306 A:middle
to perform optimally,
release to release.

45
00:02:37,106 --> 00:02:40,886 A:middle
Now in Xcode 7, we've introduced
UI testing which you can use

46
00:02:40,886 --> 00:02:43,086 A:middle
for both correctness
and performance testing.

47
00:02:44,596 --> 00:02:45,366 A:middle
So that's XCTest.

48
00:02:46,016 --> 00:02:47,676 A:middle
Now let's take a look
at Accessibility.

49
00:02:48,576 --> 00:02:51,456 A:middle
Accessibility is the
technology on our platforms,

50
00:02:51,666 --> 00:02:54,786 A:middle
that gives disabled people
the same great experience

51
00:02:54,786 --> 00:02:56,716 A:middle
on our devices and
with our applications

52
00:02:57,056 --> 00:02:58,416 A:middle
that all other users receive.

53
00:02:59,116 --> 00:03:02,336 A:middle
To make Accessibility
work, it offers a rich set

54

55
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

56
00:02:59,116 --> 00:03:02,336 A:middle
To make Accessibility
work, it offers a rich set

57
00:03:02,336 --> 00:03:05,966 A:middle
of semantic data about the UI
that technologies like Voice

58
00:03:05,966 --> 00:03:08,976 A:middle
Over can use to guide users
through the application.

59
00:03:09,676 --> 00:03:13,406 A:middle
UI testing uses that, and
Accessibility is integrated

60
00:03:13,406 --> 00:03:16,536 A:middle
with the UI kit, and app kit,
so, when you use controls

61
00:03:16,536 --> 00:03:19,516 A:middle
from those frameworks, you get
a lot of accessibility support

62
00:03:19,786 --> 00:03:21,336 A:middle
for free, right out of the box.

63
00:03:22,306 --> 00:03:24,206 A:middle
It also provides
APIs that allow you

64
00:03:24,206 --> 00:03:27,256 A:middle
to fine tune the accessibility
data that is exposed.

65
00:03:28,646 --> 00:03:31,016 A:middle
The key about this is
that with UI testing,

66
00:03:31,176 --> 00:03:32,486 A:middle
your tests will interact

67
00:03:32,926 --> 00:03:34,956 A:middle
with the application
just the way a user does.

68
00:03:36,636 --> 00:03:38,496 A:middle
UI testing has a
few requirements

69
00:03:38,646 --> 00:03:39,876 A:middle
that you should understand.

70
00:03:39,946 --> 00:03:44,236 A:middle
The first is it depends
on new features in the OS.

71
00:03:44,236 --> 00:03:48,856 A:middle
For iOS you need iOS 9 and
for OS X you need OS 10.11.

72
00:03:50,746 --> 00:03:52,426 A:middle
UI testing protects
your privacy.

73
00:03:52,856 --> 00:03:57,126 A:middle
And to do so it means your
iOS devices need to be enabled

74
00:03:57,126 --> 00:04:02,546 A:middle
for development and connected
to a trusted host running Xcode.

75

76
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

77
00:03:57,126 --> 00:04:02,546 A:middle
for development and connected
to a trusted host running Xcode.

78
00:04:03,496 --> 00:04:05,746 A:middle
On OS X you'll need
to grant permission

79
00:04:05,746 --> 00:04:09,066 A:middle
to a special Xcode helper app,
and you will be prompted to do

80
00:04:09,066 --> 00:04:12,996 A:middle
so the first time
you run UI tests.

81
00:04:13,246 --> 00:04:15,946 A:middle
Let's take a look at what
you need to get started

82
00:04:16,216 --> 00:04:17,486 A:middle
with UI test in your project.

83
00:04:18,536 --> 00:04:20,826 A:middle
First of all there's a
new Xcode target type.

84
00:04:21,226 --> 00:04:24,596 A:middle
Traditionally, unit tests were
a specific target type in Xcode,

85
00:04:24,916 --> 00:04:27,166 A:middle
and now UI tests are
target type as well.

86
00:04:28,096 --> 00:04:30,876 A:middle
We've also introduced a
large set of set of new APIs

87
00:04:31,066 --> 00:04:35,486 A:middle
for UI test, and of
course UI recording,

88
00:04:35,646 --> 00:04:37,936 A:middle
which will really get
you started quickly.

89
00:04:38,506 --> 00:04:43,856 A:middle
So the Xcode testing targets
support the special requirements

90
00:04:43,966 --> 00:04:45,016 A:middle
that UI tests have.

91
00:04:45,416 --> 00:04:47,726 A:middle
This includes executing
in a separate process

92
00:04:47,726 --> 00:04:49,296 A:middle
from your application
that you are testing.

93
00:04:49,296 --> 00:04:52,616 A:middle
And it also handles the
permission to use Accessibility

94
00:04:52,616 --> 00:04:53,736 A:middle
in the privacy protection.

95
00:04:55,376 --> 00:04:59,346 A:middle
These targets have new templates
for both Cocoa and Cocoa Touch

96
00:04:59,896 --> 00:05:01,916 A:middle
and the assistant for
these will set everything

97

98
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

99
00:04:59,896 --> 00:05:01,916 A:middle
and the assistant for
these will set everything

100
00:05:01,916 --> 00:05:04,156 A:middle
up the way you need
it to get started.

101
00:05:05,116 --> 00:05:08,196 A:middle
There's a target to be tested
setting for UI test bundles

102
00:05:08,236 --> 00:05:10,796 A:middle
that identifies the application
that you are testing.

103
00:05:11,446 --> 00:05:16,486 A:middle
In the new APIs there
are three key classes.

104
00:05:16,946 --> 00:05:18,376 A:middle
The first is applications.

105
00:05:19,556 --> 00:05:20,956 A:middle
The second is elements.

106
00:05:21,106 --> 00:05:23,386 A:middle
And the third is element query.

107
00:05:23,906 --> 00:05:25,976 A:middle
We will take a deep dive

108
00:05:25,976 --> 00:05:28,756 A:middle
into these APIs a little bit
later in the presentation.

109
00:05:30,356 --> 00:05:32,636 A:middle
UI Recording lets you interact

110
00:05:32,636 --> 00:05:34,886 A:middle
with your application
hands-on your device,

111
00:05:34,886 --> 00:05:38,346 A:middle
the simulator, or OS X Mac.

112
00:05:38,636 --> 00:05:42,406 A:middle
While you are doing so, it
generates the code necessary

113
00:05:42,406 --> 00:05:43,966 A:middle
to recreate those interactions.

114
00:05:44,536 --> 00:05:50,256 A:middle
You can do this to create new
tests or expand existing tests.

115
00:05:51,126 --> 00:05:54,446 A:middle
So let's take a look at
what this is all about.

116
00:05:55,056 --> 00:05:56,696 A:middle
Brooke, let's see a quick demo.

117
00:05:58,516 --> 00:06:04,276 A:middle
[Applause]

118

119
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

120
00:05:58,516 --> 00:06:04,276 A:middle
[Applause]

121
00:06:04,776 --> 00:06:05,116 A:middle
>> BROOKE CALLAHAN: Thanks, Wil.

122
00:06:05,606 --> 00:06:07,916 A:middle
So, without further ado.

123
00:06:08,696 --> 00:06:10,246 A:middle
The project I'm going
to be using

124
00:06:10,246 --> 00:06:12,316 A:middle
for the demo today is
the lister application.

125
00:06:12,316 --> 00:06:14,486 A:middle
This is an example project
that you can download

126
00:06:14,486 --> 00:06:15,706 A:middle
from developer.Apple.com.

127
00:06:16,246 --> 00:06:19,306 A:middle
So, let's get started, now it's
got my target configured just

128
00:06:19,306 --> 00:06:21,176 A:middle
the way I want, but the one
part I want to point out is

129
00:06:21,176 --> 00:06:23,656 A:middle
that the target to be tested
is the lister application.

130
00:06:23,656 --> 00:06:25,006 A:middle
This is the one application

131
00:06:25,006 --> 00:06:30,826 A:middle
that my tests will be
able to interact with.

132
00:06:31,036 --> 00:06:35,316 A:middle
So now I've got my
new test class here.

133
00:06:35,886 --> 00:06:40,476 A:middle
And there's a little stub test
method here and a setup function

134
00:06:40,616 --> 00:06:43,336 A:middle
which is going to
call, which is going

135
00:06:43,336 --> 00:06:47,576 A:middle
to launch the application
before my test method is called.

136
00:06:47,576 --> 00:06:49,786 A:middle
And it's going to do that for
all the test methods I add

137
00:06:49,786 --> 00:06:50,416 A:middle
to this class.

138
00:06:51,666 --> 00:06:54,446 A:middle
So Let's add a new test
from the lister app.

139
00:06:54,646 --> 00:06:59,806 A:middle
I'm going to put the keyboard
cursor in the method and click

140
00:06:59,806 --> 00:07:04,586 A:middle
on the record button
down the debug bar.

141

142
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

143
00:06:59,806 --> 00:07:04,586 A:middle
on the record button
down the debug bar.

144
00:07:04,806 --> 00:07:06,356 A:middle
Now, Xcode is launching
my application.

145
00:07:06,926 --> 00:07:07,676 A:middle
And here it is.

146
00:07:08,126 --> 00:07:12,026 A:middle
The lister application allows
me to manage a series of lists.

147
00:07:12,406 --> 00:07:17,366 A:middle
So probably the most common
thing people do is add

148
00:07:17,626 --> 00:07:19,136 A:middle
and remove items
from their list.

149
00:07:19,416 --> 00:07:21,066 A:middle
So I am going to
click here, add item.

150
00:07:21,496 --> 00:07:23,566 A:middle
It looks like we have a lot

151
00:07:23,566 --> 00:07:25,886 A:middle
of health some things
in this grocery list.

152
00:07:25,886 --> 00:07:27,636 A:middle
So I'm going to add cookies.

153
00:07:27,976 --> 00:07:33,216 A:middle
You can see that, as I'm typing,
the source header is updating.

154
00:07:33,216 --> 00:07:36,916 A:middle
If I press delete, it also
removes what I removed

155
00:07:36,916 --> 00:07:37,636 A:middle
from the text field.

156
00:07:38,666 --> 00:07:45,776 A:middle
Next thing I'm going to do
is tap on the cookies item

157
00:07:46,026 --> 00:07:47,046 A:middle
to mark it as completed.

158
00:07:47,586 --> 00:07:49,286 A:middle
And another thing I can do

159
00:07:49,286 --> 00:07:51,816 A:middle
in this application is
remove items from the list.

160
00:07:51,816 --> 00:07:55,366 A:middle
So I'll click on edit,
and then delete cookies,

161
00:07:55,836 --> 00:07:58,296 A:middle
and the delete confirmation
button, and finally done.

162
00:07:59,406 --> 00:08:01,976 A:middle
Great. Now I have a
simple test that adds

163

164
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

165
00:07:59,406 --> 00:08:01,976 A:middle
Great. Now I have a
simple test that adds

166
00:08:01,976 --> 00:08:03,546 A:middle
and removes an item
from the list.

167
00:08:03,546 --> 00:08:04,876 A:middle
So I'll click stop.

168
00:08:05,796 --> 00:08:06,646 A:middle
Let's see that in action.

169
00:08:14,686 --> 00:08:18,026 A:middle
It added the cookies
and it is removing it.

170
00:08:18,726 --> 00:08:19,216 A:middle
And we are done.

171
00:08:20,516 --> 00:08:27,316 A:middle
[Applause]

172
00:08:27,816 --> 00:08:30,626 A:middle
Thanks. As the test
interacts with UI elements,

173
00:08:30,626 --> 00:08:33,586 A:middle
we get implicit validation
that those UI elements exist.

174
00:08:33,905 --> 00:08:36,166 A:middle
But What we don't
get validation of,

175
00:08:36,265 --> 00:08:38,145 A:middle
are things like state
changes in the application.

176
00:08:38,265 --> 00:08:40,856 A:middle
For example, when we tapped
on that cookies button,

177
00:08:41,166 --> 00:08:43,866 A:middle
we don't get any
validation that the state

178
00:08:43,866 --> 00:08:45,166 A:middle
of the button actually changed.

179
00:08:46,436 --> 00:08:49,696 A:middle
And later on in the
test, when it taps

180
00:08:49,696 --> 00:08:52,436 A:middle
on the delete confirmation
button,

181
00:08:52,856 --> 00:08:55,616 A:middle
we know that the delete
confirmation button was tapped.

182
00:08:56,036 --> 00:08:58,936 A:middle
but running the test
doesn't validate

183
00:08:58,936 --> 00:09:01,356 A:middle
that the cookies row
actually is removed.

184

185
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

186
00:08:58,936 --> 00:09:01,356 A:middle
that the cookies row
actually is removed.

187
00:09:02,406 --> 00:09:04,846 A:middle
So to get validation
of those for my test,

188
00:09:04,846 --> 00:09:07,126 A:middle
I want to add some
explicit assertions.

189
00:09:07,156 --> 00:09:11,636 A:middle
First thing I am going
to do is add an assertion

190
00:09:11,676 --> 00:09:15,726 A:middle
that the cookies button here
actually changes its state.

191
00:09:15,806 --> 00:09:17,676 A:middle
To do that, I will
add a new constant.

192
00:09:17,676 --> 00:09:19,706 A:middle
Call this let cookies button.

193
00:09:20,376 --> 00:09:27,436 A:middle
I'm going to change the test
to tap on that constant.

194
00:09:27,436 --> 00:09:31,196 A:middle
Now, to add the assertion I
need some state, some properties

195
00:09:31,196 --> 00:09:35,256 A:middle
of the element to assert on.

196
00:09:35,616 --> 00:09:38,386 A:middle
And cookies button
is XUI element

197
00:09:39,036 --> 00:09:41,456 A:middle
and XUI elements have
a value property.

198
00:09:41,966 --> 00:09:43,836 A:middle
What I'm going to do, is I'm
going to set a breakpoint here,

199
00:09:44,706 --> 00:09:52,676 A:middle
and run the test to that point.

200
00:09:53,056 --> 00:09:54,926 A:middle
So here we have the
test in the state

201
00:09:54,926 --> 00:09:56,646 A:middle
where it's added
the cookies row.

202
00:09:57,416 --> 00:09:59,396 A:middle
And it has yet to
tap on that button.

203
00:09:59,456 --> 00:10:03,316 A:middle
So I'm going to go
in the debugger,

204

205
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

206
00:09:59,456 --> 00:10:03,316 A:middle
So I'm going to go
in the debugger,

207
00:10:03,926 --> 00:10:08,166 A:middle
and print out the value
of this cookies button.

208
00:10:08,166 --> 00:10:08,996 A:middle
Little typo.

209
00:10:13,716 --> 00:10:17,186 A:middle
-- there we go.

210
00:10:17,606 --> 00:10:28,566 A:middle
I can see that the value of the
cookies button is the string

211
00:10:28,916 --> 00:10:30,046 A:middle
with the number zero in it.

212
00:10:32,006 --> 00:10:34,516 A:middle
Next I'm going to
step over that line.

213
00:10:34,696 --> 00:10:36,056 A:middle
So now it's tap the
cookies button.

214
00:10:36,146 --> 00:10:41,126 A:middle
I will print out the value
of it again and now I can see

215
00:10:41,126 --> 00:10:43,886 A:middle
that the value of the button is
the string with the number one.

216
00:10:44,436 --> 00:10:46,166 A:middle
Great. So now I have all
the information that I need

217
00:10:46,446 --> 00:10:51,436 A:middle
to assert that the value of the
button changes when it's tapped.

218
00:10:51,576 --> 00:10:56,416 A:middle
So I'm going to add an assertion
using XCT assert equal.

219
00:10:56,416 --> 00:11:02,296 A:middle
I'll assert that the value

220

221
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

222
00:10:56,416 --> 00:11:02,296 A:middle
I'll assert that the value

223
00:11:02,296 --> 00:11:04,756 A:middle
after the tap is a string
with the number one.

224
00:11:05,196 --> 00:11:07,526 A:middle
The value is in any object.

225
00:11:07,586 --> 00:11:11,546 A:middle
So I am going to need to
assert that this is a string.

226
00:11:11,956 --> 00:11:13,586 A:middle
So I'll use as string.

227
00:11:13,586 --> 00:11:18,326 A:middle
And assert that it's
number one after the tap.

228
00:11:19,006 --> 00:11:21,846 A:middle
And I'll assert that
it is the number string

229
00:11:21,846 --> 00:11:25,716 A:middle
with the number zero
before the tap.

230
00:11:25,716 --> 00:11:30,926 A:middle
And lastly, after the delete
confirmation button is tapped I

231
00:11:30,926 --> 00:11:34,336 A:middle
want to assert that that
cookies row goes away.

232
00:11:34,336 --> 00:11:36,816 A:middle
I'll call XCT assert
equal and assert

233
00:11:37,136 --> 00:11:38,876 A:middle
that the button no
longer exists.

234
00:11:43,636 --> 00:11:46,406 A:middle
Now iIf I run this test again we
should see it does all the same

235
00:11:46,406 --> 00:11:48,176 A:middle
thing but also passing
these assertions.

236
00:11:57,516 --> 00:12:00,626 A:middle
Great, so now I have
just added my first test.

237

238
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

239
00:11:57,516 --> 00:12:00,626 A:middle
Great, so now I have
just added my first test.

240
00:12:01,936 --> 00:12:02,436 A:middle
Back to you, Wil.

241
00:12:03,516 --> 00:12:09,446 A:middle
[Applause]

242
00:12:09,946 --> 00:12:10,946 A:middle
>> WIL TURNER: That
was pretty awesome.

243
00:12:10,946 --> 00:12:13,446 A:middle
You can see just how easily
Brooke took an existing

244
00:12:13,446 --> 00:12:16,836 A:middle
application and used it,
just like he would as a user,

245
00:12:17,426 --> 00:12:19,816 A:middle
and in a handful of
minutes he created a test.

246
00:12:20,226 --> 00:12:22,676 A:middle
He could expand that
test using XCT assert

247
00:12:22,676 --> 00:12:27,136 A:middle
to do some additional validation
and he just added reliability

248
00:12:27,136 --> 00:12:29,256 A:middle
to his project with
minimal effort.

249
00:12:29,916 --> 00:12:32,846 A:middle
That's pretty exciting.

250
00:12:33,216 --> 00:12:36,376 A:middle
So you can see we added
UI testing target,

251
00:12:36,736 --> 00:12:38,926 A:middle
very straightforward just like
all our other other targets,

252
00:12:38,926 --> 00:12:40,426 A:middle
with an assistant and templates.

253
00:12:41,406 --> 00:12:46,636 A:middle
Used recording, interacted with
the app, and it creates the code

254
00:12:46,636 --> 00:12:49,206 A:middle
that uses the elements
and synthesizes the events

255
00:12:49,296 --> 00:12:53,446 A:middle
and then the additional
validation with XCT assert.

256
00:12:55,696 --> 00:12:58,856 A:middle
Let's take a look at
this UI testing API.

257

258
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

259
00:13:00,586 --> 00:13:02,596 A:middle
I mentioned earlier that
there are three classes.

260
00:13:02,846 --> 00:13:05,436 A:middle
They are XCUIApplication,

261
00:13:05,666 --> 00:13:09,466 A:middle
XCUIElement, and
XCUIElementQuery.

262
00:13:10,166 --> 00:13:10,816 A:middle
How do they work?

263
00:13:11,586 --> 00:13:14,606 A:middle
Let's start with a very
simple, something even simpler

264
00:13:14,956 --> 00:13:16,686 A:middle
than Brooke's example.

265
00:13:17,276 --> 00:13:21,076 A:middle
Line-by-line going through here
first I am instantiating my

266
00:13:21,076 --> 00:13:22,126 A:middle
application object.

267
00:13:22,126 --> 00:13:24,856 A:middle
This is a proxy for
my application.

268
00:13:25,606 --> 00:13:26,406 A:middle
Then I launch it.

269
00:13:26,866 --> 00:13:27,936 A:middle
That brings it up for me.

270
00:13:29,376 --> 00:13:32,646 A:middle
And then I use element and
query to find the add button.

271
00:13:33,756 --> 00:13:36,976 A:middle
And then I synthesize the
event that taps on it.

272
00:13:36,976 --> 00:13:40,156 A:middle
Finally, I add in an
assertion just like Brooke did

273
00:13:40,596 --> 00:13:43,016 A:middle
to make sure that the UI
had the expected state

274
00:13:43,156 --> 00:13:45,416 A:middle
at the end of the test.

275
00:13:46,166 --> 00:13:48,916 A:middle
So I mentioned that
UIApplication is a proxy

276
00:13:49,006 --> 00:13:50,246 A:middle
for the tested application.

277
00:13:51,206 --> 00:13:54,126 A:middle
It is independent of the
lifecycle of the launch

278
00:13:54,126 --> 00:13:55,866 A:middle
and termination lifecycle
of your app.

279
00:13:56,256 --> 00:13:58,316 A:middle
Because Your tests are
running in a separate process.

280
00:13:58,756 --> 00:14:01,586 A:middle
You get explicit control
over when the app is launched

281

282
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

283
00:13:58,756 --> 00:14:01,586 A:middle
You get explicit control
over when the app is launched

284
00:14:01,926 --> 00:14:06,466 A:middle
and when it is terminated.

285
00:14:06,466 --> 00:14:09,976 A:middle
When you launch we will
always spawn a new process.

286
00:14:10,246 --> 00:14:13,006 A:middle
So that's something
we do to kind

287
00:14:13,006 --> 00:14:17,076 A:middle
of not give you completely Clean
Slate because you have a lot

288
00:14:17,076 --> 00:14:19,586 A:middle
of state in your application
that it's up to you to control.

289
00:14:19,976 --> 00:14:23,016 A:middle
But by launching a
process clean each time,

290
00:14:23,316 --> 00:14:25,956 A:middle
we help you minimize the number
of variables that you have

291
00:14:25,996 --> 00:14:26,826 A:middle
to deal with in your test.

292
00:14:27,916 --> 00:14:29,556 A:middle
So if it's already running,

293
00:14:29,716 --> 00:14:32,746 A:middle
calling launch will terminate
the previous existing instance.

294
00:14:34,776 --> 00:14:38,466 A:middle
Application is also the starting
point for finding elements.

295
00:14:38,966 --> 00:14:40,266 A:middle
Let's talk about elements.

296
00:14:40,926 --> 00:14:44,906 A:middle
XCUIElement, just like
Application, is a proxy object,

297
00:14:45,226 --> 00:14:47,456 A:middle
but this time for user
interface elements

298
00:14:47,646 --> 00:14:48,906 A:middle
in the tested application.

299
00:14:49,596 --> 00:14:50,826 A:middle
Elements have types.

300
00:14:51,476 --> 00:14:54,196 A:middle
Types are like button, or
cell, or window, and so forth.

301
00:14:54,326 --> 00:14:58,536 A:middle
They have what we call
identifiers, strings of data

302
00:14:58,536 --> 00:15:00,316 A:middle
that we get from the
accessibility system,

303

304
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

305
00:14:58,536 --> 00:15:00,316 A:middle
that we get from the
accessibility system,

306
00:15:00,906 --> 00:15:04,376 A:middle
hich are an identifier or
label or title, so forth.

307
00:15:05,886 --> 00:15:08,656 A:middle
Most of the time you'll find
elements using a combination

308
00:15:08,656 --> 00:15:10,206 A:middle
of the type and the label.

309
00:15:10,206 --> 00:15:12,276 A:middle
For example, if you have
a bullton which is add,

310
00:15:12,276 --> 00:15:16,786 A:middle
you'll look for the button
type with the identifier add.

311
00:15:17,496 --> 00:15:20,436 A:middle
Elements form a hierarchy
in your application.

312
00:15:20,496 --> 00:15:22,996 A:middle
The application is
the root of a tree.

313
00:15:23,296 --> 00:15:25,636 A:middle
If you think back to your
computer science days you'll

314
00:15:25,636 --> 00:15:26,916 A:middle
remember tree data structures.

315
00:15:27,716 --> 00:15:33,026 A:middle
With the lister application we
have this very simple tree here

316
00:15:33,026 --> 00:15:35,036 A:middle
with the application
at the top and we have

317
00:15:35,036 --> 00:15:39,816 A:middle
like the nav bar
and the add button.

318
00:15:39,876 --> 00:15:40,946 A:middle
Groceries label.

319
00:15:41,076 --> 00:15:42,116 A:middle
So on and so forth.

320
00:15:42,696 --> 00:15:44,546 A:middle
So each of these is an element

321
00:15:45,266 --> 00:15:47,376 A:middle
that you can reference
in your tests.

322
00:15:48,056 --> 00:15:50,196 A:middle
These are used by queries.

323
00:15:50,666 --> 00:15:53,466 A:middle
This hierarchy, as well
as type and identifier,

324
00:15:53,626 --> 00:15:54,616 A:middle
to find your elements.

325
00:15:56,376 --> 00:15:58,046 A:middle
Elements, when you
work with them

326
00:15:58,046 --> 00:16:00,166 A:middle
in your test, must be unique.

327

328
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

329
00:15:58,046 --> 00:16:00,166 A:middle
in your test, must be unique.

330
00:16:00,876 --> 00:16:01,726 A:middle
So what does that mean?

331
00:16:02,156 --> 00:16:04,666 A:middle
Well, every one of these
elements is backed by a query.

332
00:16:05,006 --> 00:16:07,856 A:middle
The query has to resolve
to a single instance.

333
00:16:09,206 --> 00:16:11,746 A:middle
Otherwise when we go to
synthesize the events

334
00:16:11,746 --> 00:16:14,406 A:middle
that you tell us to tap but
there's multiple buttons

335
00:16:14,406 --> 00:16:16,596 A:middle
that match that, it
is not deterministic.

336
00:16:16,596 --> 00:16:18,686 A:middle
We can't really know what
you mean for us to do.

337
00:16:19,086 --> 00:16:22,486 A:middle
Similarly, if you ask us for
a property of the element,

338
00:16:22,976 --> 00:16:25,946 A:middle
we don't know which one
did you really mean?

339
00:16:25,946 --> 00:16:27,166 A:middle
Maybe there wasn't one at all.

340
00:16:27,626 --> 00:16:29,706 A:middle
So it's important to the
queries for the elements

341
00:16:29,706 --> 00:16:31,906 A:middle
to resolve to exactly one match.

342
00:16:33,106 --> 00:16:36,636 A:middle
If they don't, when you access
the element we'll raise a

343
00:16:36,636 --> 00:16:37,376 A:middle
failure for that.

344
00:16:38,306 --> 00:16:40,166 A:middle
There is one exception to this,

345
00:16:40,266 --> 00:16:44,086 A:middle
which is an API called the
exists property on XCUIElement.

346
00:16:44,626 --> 00:16:48,186 A:middle
This allows you to test for the
existence of the element safely.

347
00:16:48,756 --> 00:16:50,916 A:middle
You can use this as
Brooke did to verify

348
00:16:50,916 --> 00:16:52,676 A:middle
that the element had
been removed from the UI

349
00:16:52,776 --> 00:16:56,086 A:middle
and you can also use
this to handle cases

350
00:16:56,086 --> 00:16:57,466 A:middle
where you have conditional UI

351
00:16:57,596 --> 00:16:59,386 A:middle
that might display
in some context.

352
00:16:59,386 --> 00:17:02,506 A:middle
For example, if you are
saving a file to a location

353

354
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

355
00:16:59,386 --> 00:17:02,506 A:middle
For example, if you are
saving a file to a location

356
00:17:02,506 --> 00:17:05,425 A:middle
where another file already
exists, you might get some kind

357
00:17:05,425 --> 00:17:06,526 A:middle
of confirmation sheet.

358
00:17:06,945 --> 00:17:08,826 A:middle
That wouldn't be
present all the time.

359
00:17:08,826 --> 00:17:10,476 A:middle
Just the case where
there's these conflicts.

360
00:17:10,476 --> 00:17:13,826 A:middle
You can use an exist
check for those cases.

361
00:17:15,126 --> 00:17:18,256 A:middle
Elements are where event
synthesis APIs live.

362
00:17:18,886 --> 00:17:22,736 A:middle
Event synthesis is how we
simulate user interaction,

363
00:17:22,736 --> 00:17:26,165 A:middle
and do this at the lowest level
of the system so everything goes

364
00:17:26,165 --> 00:17:29,796 A:middle
through the same channels it
would when the user interacts.

365
00:17:29,796 --> 00:17:32,486 A:middle
The APIs for event synthesis
are platform-specific

366
00:17:33,006 --> 00:17:33,986 A:middle
with some exceptions.

367
00:17:34,576 --> 00:17:37,136 A:middle
We have button click,
for example in OS X

368
00:17:37,136 --> 00:17:41,796 A:middle
and the corresponding
is button tap on iOS.

369
00:17:41,796 --> 00:17:44,806 A:middle
We have type text which is
the same on both platforms

370
00:17:44,806 --> 00:17:48,316 A:middle
and takes a string of text.

371
00:17:48,856 --> 00:17:53,176 A:middle
XCUIElementQuery is our API
for specifying elements.

372
00:17:54,136 --> 00:17:58,806 A:middle
Queries resolve to collections
of accessible elements.

373
00:17:58,806 --> 00:18:01,856 A:middle
They can only find elements that
are visible to Accessibility.

374

375
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

376
00:17:58,806 --> 00:18:01,856 A:middle
They can only find elements that
are visible to Accessibility.

377
00:18:02,756 --> 00:18:07,376 A:middle
And they will resolve
to a set of these.

378
00:18:07,596 --> 00:18:08,886 A:middle
That means you can
get the number

379
00:18:08,886 --> 00:18:10,656 A:middle
of matches using
the count property.

380
00:18:10,656 --> 00:18:15,116 A:middle
And you can also
specify distinct elements

381
00:18:15,386 --> 00:18:18,156 A:middle
in that set using
subscripting with an identifier

382
00:18:19,136 --> 00:18:21,076 A:middle
or using an element
at index API.

383
00:18:21,076 --> 00:18:23,906 A:middle
We will look at these
more in a moment.

384
00:18:24,436 --> 00:18:26,496 A:middle
So how do queries work?

385
00:18:27,756 --> 00:18:29,566 A:middle
So I mentioned that
element hierarchy.

386
00:18:30,426 --> 00:18:34,016 A:middle
So the relationships in
that hierarchy are one side

387
00:18:34,016 --> 00:18:34,916 A:middle
of how queries work.

388
00:18:35,126 --> 00:18:36,816 A:middle
The other side is by filtering.

389
00:18:37,836 --> 00:18:40,456 A:middle
Filtering is taking
one set and reducing

390
00:18:40,456 --> 00:18:42,996 A:middle
that set according
to certain criteria.

391
00:18:44,416 --> 00:18:48,206 A:middle
With our lister example again
here is how we might express

392
00:18:48,206 --> 00:18:51,276 A:middle
certain relationships, the
first of which is descendants.

393
00:18:51,276 --> 00:18:54,076 A:middle
In this case I'm
showing the view.

394
00:18:54,756 --> 00:18:57,066 A:middle
All the gold cells
are its descendents.

395
00:18:58,226 --> 00:19:01,366 A:middle
On the other hand children is a
more restrictive relationship.

396

397
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

398
00:18:58,226 --> 00:19:01,366 A:middle
On the other hand children is a
more restrictive relationship.

399
00:19:01,366 --> 00:19:04,906 A:middle
It's just the elements that
are directly below the element

400
00:19:04,906 --> 00:19:05,556 A:middle
you're querying.

401
00:19:05,626 --> 00:19:08,016 A:middle
So, the table's children
are just the cells.

402
00:19:08,976 --> 00:19:11,746 A:middle
The final relationship
we use is containment.

403
00:19:12,176 --> 00:19:14,696 A:middle
This happens to be very
useful when we have cases

404
00:19:14,696 --> 00:19:17,406 A:middle
where the elements, like the
cells, they don't have a lot

405
00:19:17,406 --> 00:19:19,576 A:middle
of data that unique
them from each other,

406
00:19:19,946 --> 00:19:22,116 A:middle
but they contain
elements which are unique.

407
00:19:22,416 --> 00:19:25,226 A:middle
For example, the first cell
contains the groceries label.

408
00:19:26,706 --> 00:19:31,106 A:middle
Filtering lets us take
things like the element type,

409
00:19:32,266 --> 00:19:35,596 A:middle
or its identifiers,
to create queries

410
00:19:35,846 --> 00:19:37,816 A:middle
that filter a previous query.

411
00:19:38,396 --> 00:19:41,976 A:middle
We can also do this with
predicates which will allow us

412
00:19:42,286 --> 00:19:45,316 A:middle
to go beyond the identifiers
to look at the values

413
00:19:45,646 --> 00:19:47,766 A:middle
or do partial matching
such as "begins with"

414
00:19:47,766 --> 00:19:50,576 A:middle
and that sort of thing.

415
00:19:50,576 --> 00:19:54,066 A:middle
We combine relationships and
the filtering in the APIs

416
00:19:54,136 --> 00:19:57,196 A:middle
and the first of which is
descendantsMatchingType.

417
00:19:57,286 --> 00:19:59,166 A:middle
You can figure out
what that does.

418
00:19:59,626 --> 00:20:02,146 A:middle
It find the descendants
that match a certain type.

419

420
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

421
00:19:59,626 --> 00:20:02,146 A:middle
It find the descendants
that match a certain type.

422
00:20:02,556 --> 00:20:05,276 A:middle
This turns out to be the
most common query you'll use.

423
00:20:05,666 --> 00:20:09,106 A:middle
Some examples of this are,
I can find all the buttons

424
00:20:09,106 --> 00:20:11,566 A:middle
in an application
by calling app,

425
00:20:12,256 --> 00:20:13,826 A:middle
descendentsMatchingType button.

426
00:20:15,006 --> 00:20:17,746 A:middle
Similarly I can find
all the cells in a table

427
00:20:18,206 --> 00:20:21,386 A:middle
by telling the table to give me
descendentsMatchingType cell,

428
00:20:22,106 --> 00:20:24,116 A:middle
or, another example,
with menu items.

429
00:20:25,426 --> 00:20:29,076 A:middle
This is such a common query
that we provide convenience API

430
00:20:29,076 --> 00:20:32,096 A:middle
for every one of these types.

431
00:20:32,456 --> 00:20:35,836 A:middle
DescendentsMatchingType
buttons, becomes just buttons.

432
00:20:37,486 --> 00:20:40,326 A:middle
DescendentsMatchingType
cell becomes just cells,

433
00:20:41,216 --> 00:20:43,136 A:middle
and so on and so forth.

434
00:20:44,016 --> 00:20:48,216 A:middle
These convenience APIs help
make your tests very expressive

435
00:20:48,376 --> 00:20:49,346 A:middle
yet concise.

436
00:20:51,516 --> 00:20:56,036 A:middle
[Applause]

437
00:20:56,536 --> 00:20:59,036 A:middle
ChildrenMatchingType is
the other combination

438
00:20:59,036 --> 00:21:00,356 A:middle
of relationships in filtering.

439

440
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

441
00:20:59,036 --> 00:21:00,356 A:middle
of relationships in filtering.

442
00:21:01,066 --> 00:21:03,816 A:middle
So in that, that allows
us to differentiate

443
00:21:03,816 --> 00:21:06,466 A:middle
between descendants, all the
descendants that match a type,

444
00:21:06,636 --> 00:21:08,796 A:middle
and just those that
match, that are children.

445
00:21:10,406 --> 00:21:13,696 A:middle
Again the all buttons
example, is app.buttons,

446
00:21:13,796 --> 00:21:17,086 A:middle
if I want to find just the
buttons that are children

447
00:21:17,086 --> 00:21:19,156 A:middle
of my nav bar, I
can take my nav bar

448
00:21:19,156 --> 00:21:20,696 A:middle
and say childrenMatchingType
button.

449
00:21:21,236 --> 00:21:24,096 A:middle
It is not as common a
query, but there are cases

450
00:21:24,096 --> 00:21:26,496 A:middle
where it becomes very
useful to differentiate.

451
00:21:28,016 --> 00:21:29,766 A:middle
Finally, containing type.

452
00:21:30,366 --> 00:21:34,416 A:middle
This allows us to find elements
by describing their descendants.

453
00:21:35,306 --> 00:21:37,496 A:middle
So in the example
we have the cells

454
00:21:37,576 --> 00:21:40,716 A:middle
that are each somewhat
anonymous.

455
00:21:40,716 --> 00:21:43,076 A:middle
They don't have any
identifying characteristics,

456
00:21:43,696 --> 00:21:45,756 A:middle
but they do contain
unique labels.

457
00:21:46,426 --> 00:21:48,316 A:middle
Labels are also known
as static texts.

458
00:21:49,396 --> 00:21:53,226 A:middle
So here I can form a cell
query which takes the cells

459
00:21:53,286 --> 00:21:56,206 A:middle
and finds the one that is
containing the type static text

460
00:21:56,346 --> 00:21:58,166 A:middle
with the identifier groceries.

461
00:21:58,666 --> 00:21:59,976 A:middle
That will find the
first cell for me.

462

463
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

464
00:22:00,706 --> 00:22:04,836 A:middle
There's also predicate
variant for this API.

465
00:22:05,486 --> 00:22:07,056 A:middle
So those are our three APIs

466
00:22:07,056 --> 00:22:09,306 A:middle
that combine relationships
and filtering.

467
00:22:09,596 --> 00:22:12,046 A:middle
DescendentsMatchingType,
childrenMatchingType,

468
00:22:12,556 --> 00:22:15,526 A:middle
containingType, and of course
all the convenience APIs

469
00:22:15,526 --> 00:22:16,646 A:middle
for descendentsMatchingType.

470
00:22:18,756 --> 00:22:20,676 A:middle
The other powerful
thing about query is

471
00:22:20,676 --> 00:22:22,376 A:middle
that they can be
chained together.

472
00:22:22,746 --> 00:22:26,906 A:middle
So we can take the output of
one query and make it the input

473
00:22:26,906 --> 00:22:29,556 A:middle
of the next, just like you
would pipe commands together

474
00:22:29,556 --> 00:22:30,636 A:middle
on a Unix command line.

475
00:22:31,396 --> 00:22:33,316 A:middle
This is ver powerful,
and lets you build

476
00:22:33,316 --> 00:22:35,706 A:middle
up very complex queries,
again in a way

477
00:22:35,706 --> 00:22:37,146 A:middle
that is concise and expressive.

478
00:22:38,266 --> 00:22:41,496 A:middle
So here we have our
application and I want

479
00:22:41,496 --> 00:22:43,496 A:middle
to find just the
labels in the table.

480
00:22:43,996 --> 00:22:44,946 A:middle
So I start with the app.

481
00:22:45,866 --> 00:22:46,996 A:middle
And then I get the tables.

482
00:22:47,646 --> 00:22:50,016 A:middle
And I ask for static
texts and I'm done.

483
00:22:50,166 --> 00:22:51,316 A:middle
I have those three labels.

484
00:22:53,196 --> 00:22:56,656 A:middle
So queries are sometimes
the end unto themselves.

485
00:22:56,656 --> 00:22:59,426 A:middle
You want to get the count of
the query and maybe assert

486
00:22:59,426 --> 00:23:01,236 A:middle
that you have the right
number of items in there.

487

488
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

489
00:22:59,426 --> 00:23:01,236 A:middle
that you have the right
number of items in there.

490
00:23:01,586 --> 00:23:04,576 A:middle
But often the goal of a
query is to find an element.

491
00:23:04,576 --> 00:23:06,886 A:middle
All of our elements
are backed by a query.

492
00:23:07,346 --> 00:23:10,616 A:middle
To get an element from a
query we provide several

493
00:23:10,616 --> 00:23:11,436 A:middle
different choices.

494
00:23:11,756 --> 00:23:14,776 A:middle
The first is subscripting,
which allows us to take a query

495
00:23:14,776 --> 00:23:17,326 A:middle
and then subscript
using an identifier.

496
00:23:17,596 --> 00:23:19,176 A:middle
That would give me
back an element

497
00:23:19,406 --> 00:23:20,576 A:middle
which is the groceries label.

498
00:23:20,576 --> 00:23:23,826 A:middle
It can also do this
with element and index.

499
00:23:24,076 --> 00:23:26,586 A:middle
If I have a set, maybe
the rows in the table

500
00:23:26,586 --> 00:23:27,856 A:middle
and I want to iterate over them.

501
00:23:27,856 --> 00:23:32,256 A:middle
I could one at a time call
element and index on these.

502
00:23:32,256 --> 00:23:35,206 A:middle
If I have a query which
I know resolves uniquely,

503
00:23:35,496 --> 00:23:38,546 A:middle
hat is to a single thing, maybe
I only have one navigation bar

504
00:23:38,546 --> 00:23:41,346 A:middle
in my application, I can
use the element property

505
00:23:41,626 --> 00:23:45,506 A:middle
to create a new element
backed by that query.

506
00:23:46,666 --> 00:23:48,916 A:middle
So when are queries evaluated?

507
00:23:49,546 --> 00:23:51,396 A:middle
So they are not actually
evaluated just

508
00:23:51,396 --> 00:23:52,366 A:middle
when you create them.

509
00:23:52,426 --> 00:23:54,936 A:middle
They are evaluated on-demand
or as they are needed.

510
00:23:55,686 --> 00:23:59,786 A:middle
This means that with an element,
the query will be evaluated

511

512
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

513
00:24:00,066 --> 00:24:04,206 A:middle
when you synthesize events
or read property values.

514
00:24:04,206 --> 00:24:06,516 A:middle
You can create the element
but until you use it,

515
00:24:06,516 --> 00:24:07,826 A:middle
the query won't be evaluated.

516
00:24:08,536 --> 00:24:12,106 A:middle
Similarly if you create a query
directly it will be evaluated

517
00:24:12,106 --> 00:24:15,216 A:middle
when you get the number of
matches or if you call one

518
00:24:15,216 --> 00:24:16,986 A:middle
of the APIs that
returns all the matches.

519
00:24:16,986 --> 00:24:19,236 A:middle
It will have to be
evaluated at that point

520
00:24:20,266 --> 00:24:23,896 A:middle
and we will reevaluate
queries when the UI changes.

521
00:24:24,216 --> 00:24:27,046 A:middle
So you are always working
with the most current view

522
00:24:27,046 --> 00:24:30,306 A:middle
of the application rather
than data from ten seconds ago

523
00:24:30,306 --> 00:24:32,336 A:middle
or two minutes ago, depending
on the length of your test.

524
00:24:33,946 --> 00:24:36,466 A:middle
So in this way you
can think of queries

525
00:24:36,466 --> 00:24:38,936 A:middle
and elements being
somewhat similar to URLs.

526
00:24:39,636 --> 00:24:42,636 A:middle
They are, with a URL
you can create a URL

527
00:24:42,636 --> 00:24:44,876 A:middle
but it doesn't fetch a
resource immediately.

528
00:24:44,876 --> 00:24:48,386 A:middle
It is not until you actually
go to create your URL request

529
00:24:48,386 --> 00:24:52,386 A:middle
or session that the
actual URL gets resolved.

530
00:24:52,866 --> 00:24:55,216 A:middle
And so even if the
URL was invalid,

531
00:24:55,406 --> 00:24:57,816 A:middle
no error would be
raised until that point.

532
00:24:58,746 --> 00:25:03,406 A:middle
Similarly, queries and elements,
they are just specifications

533

534
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

535
00:24:58,746 --> 00:25:03,406 A:middle
Similarly, queries and elements,
they are just specifications

536
00:25:03,576 --> 00:25:06,136 A:middle
for accessible elements
in the tested application.

537
00:25:06,876 --> 00:25:11,746 A:middle
So creating them doesn't do
anything until you need them

538
00:25:11,866 --> 00:25:13,436 A:middle
and at that point
they are resolved.

539
00:25:14,126 --> 00:25:16,706 A:middle
So that's the API.

540
00:25:17,736 --> 00:25:20,376 A:middle
There's three classes:
The application

541
00:25:20,376 --> 00:25:23,306 A:middle
for launching your
application; elements,

542
00:25:23,736 --> 00:25:26,736 A:middle
which like the application
are proxy objects for elements

543
00:25:26,736 --> 00:25:29,366 A:middle
in your app; and
finally queries,

544
00:25:29,696 --> 00:25:32,586 A:middle
which are more complex
ways to specify elements.

545
00:25:34,356 --> 00:25:36,036 A:middle
So now I want to
talk a little bit

546
00:25:36,036 --> 00:25:37,936 A:middle
about Accessibility
and UI testing.

547
00:25:38,396 --> 00:25:39,336 A:middle
I mentioned earlier

548
00:25:39,646 --> 00:25:43,076 A:middle
that accessibility data is
what makes UI testing possible.

549
00:25:44,596 --> 00:25:48,856 A:middle
So given that, it is not
hard to see how the quality

550
00:25:49,116 --> 00:25:53,356 A:middle
of the accessibility data
really impacts your testing.

551
00:25:53,706 --> 00:25:55,556 A:middle
In fact, the better
the accessibility data

552
00:25:55,556 --> 00:25:58,316 A:middle
for your application, the
easier it is to write tests

553
00:25:58,316 --> 00:26:01,506 A:middle
and the more reliable
those tests are over time.

554

555
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

556
00:25:58,316 --> 00:26:01,506 A:middle
and the more reliable
those tests are over time.

557
00:26:02,136 --> 00:26:05,296 A:middle
So you get a double benefit

558
00:26:05,296 --> 00:26:07,236 A:middle
when you improve
the accessibility

559
00:26:07,236 --> 00:26:08,156 A:middle
in your application.

560
00:26:08,836 --> 00:26:11,086 A:middle
You've not only made it
easier for your own testing

561
00:26:11,296 --> 00:26:13,376 A:middle
but you've improved
the experience for all

562
00:26:13,376 --> 00:26:14,506 A:middle
of our disabled users.

563
00:26:14,916 --> 00:26:17,786 A:middle
I would really encourage you to
keep that in mind when you work

564
00:26:17,786 --> 00:26:19,346 A:middle
with UI testing and
accessibility.

565
00:26:21,436 --> 00:26:23,316 A:middle
Sometimes up's need
to do some debugging.

566
00:26:23,876 --> 00:26:27,536 A:middle
It's an element may not be
accessible, may not be showing

567
00:26:27,536 --> 00:26:29,576 A:middle
up for you even when
you are using recording.

568
00:26:30,456 --> 00:26:32,886 A:middle
That could be because of
the custom view subclass

569
00:26:32,956 --> 00:26:34,816 A:middle
that may not be accessible
by default.

570
00:26:35,526 --> 00:26:38,076 A:middle
Or it's actually not a view.

571
00:26:38,256 --> 00:26:41,526 A:middle
It's a graphics object in a
lower level graphics subsystem

572
00:26:41,526 --> 00:26:43,576 A:middle
such as a layer and
that sort of thing.

573
00:26:44,686 --> 00:26:46,636 A:middle
In other cases, the
element is visible

574
00:26:46,636 --> 00:26:49,026 A:middle
but has poor accessibility data.

575
00:26:49,356 --> 00:26:50,976 A:middle
All those table cells
I was looking

576
00:26:51,076 --> 00:26:54,756 A:middle
at in the containment query,
partly that might have gone away

577
00:26:54,756 --> 00:26:57,356 A:middle
if the cells themselves had
better accessibility data.

578
00:26:58,476 --> 00:27:00,816 A:middle
When this happens, there's
a couple tools I would point

579

580
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

581
00:26:58,476 --> 00:27:00,816 A:middle
When this happens, there's
a couple tools I would point

582
00:27:00,816 --> 00:27:01,106 A:middle
you at.

583
00:27:01,396 --> 00:27:04,006 A:middle
The first of which is
UI recording itself

584
00:27:04,286 --> 00:27:06,796 A:middle
because UI recording will
give you the closest view

585
00:27:07,106 --> 00:27:09,986 A:middle
into how the testing
system sees the elements.

586
00:27:10,416 --> 00:27:13,366 A:middle
But beyond that there's also
great accessibility inspectors

587
00:27:13,366 --> 00:27:14,126 A:middle
on our platform.

588
00:27:14,426 --> 00:27:17,156 A:middle
They'll let you see the
raw accessibility data

589
00:27:17,456 --> 00:27:19,456 A:middle
as it is exposed
by the application.

590
00:27:20,046 --> 00:27:23,576 A:middle
When you need to go
and improve that data,

591
00:27:24,066 --> 00:27:25,996 A:middle
your first stop should
be Interface Builder.

592
00:27:26,606 --> 00:27:31,076 A:middle
Interface Builder has a
great accessibility inspector

593
00:27:31,506 --> 00:27:34,106 A:middle
which allows you to enable
or disable accessibility,

594
00:27:34,366 --> 00:27:37,116 A:middle
set values for the various
accessibility attributes,

595
00:27:37,526 --> 00:27:40,226 A:middle
and configure the traits
which have a direct impact

596
00:27:40,286 --> 00:27:43,366 A:middle
on how the element is expressed
as a type in UI testing.

597
00:27:45,126 --> 00:27:47,466 A:middle
There's also API if you're
working with elements

598
00:27:47,506 --> 00:27:50,316 A:middle
that you can't access
through Interface Builder.

599
00:27:50,896 --> 00:27:53,676 A:middle
You can use APIs
in NSAccessibility

600
00:27:53,736 --> 00:27:57,956 A:middle
and UIAccessibility to directly
control how the element is

601
00:27:57,956 --> 00:27:59,246 A:middle
expressed to Accessibility.

602
00:27:59,886 --> 00:28:04,386 A:middle
So with that in mind,
let's see another demo.

603

604
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

605
00:27:59,886 --> 00:28:04,386 A:middle
So with that in mind,
let's see another demo.

606
00:28:04,856 --> 00:28:05,976 A:middle
This time Brooke
is going to take us

607
00:28:05,976 --> 00:28:09,456 A:middle
through more complex test
cases and also a little bit

608
00:28:09,456 --> 00:28:10,656 A:middle
of accessibility debugging.

609
00:28:11,166 --> 00:28:11,296 A:middle
Brooke?

610
00:28:11,296 --> 00:28:11,556 A:middle
>> BROOKE CALLAHAN: Thanks, Wil.

611
00:28:12,516 --> 00:28:19,396 A:middle
[Applause]

612
00:28:19,896 --> 00:28:22,236 A:middle
>> BROOKE CALLAHAN: So in the
last demo we saw adding a test

613
00:28:22,236 --> 00:28:27,066 A:middle
that can add and remove
an item from the list.

614
00:28:27,596 --> 00:28:30,506 A:middle
So while I'm here I would
like to add some more tests

615
00:28:30,506 --> 00:28:32,006 A:middle
around this area
of user interface.

616
00:28:32,406 --> 00:28:33,586 A:middle
First I'm going to add a test

617
00:28:34,106 --> 00:28:37,846 A:middle
that adds multiple
items to the same list.

618
00:28:38,316 --> 00:28:41,876 A:middle
With this multiple items
with the same name to a list.

619
00:28:42,586 --> 00:28:45,646 A:middle
So to do that I'm going
to copy this code here

620
00:28:45,646 --> 00:28:46,536 A:middle
from the last test.

621
00:28:47,056 --> 00:28:51,926 A:middle
And I'll call this new
test, add to cookies.

622
00:28:53,036 --> 00:28:54,116 A:middle
I'll just paste that code in.

623
00:28:55,306 --> 00:28:59,736 A:middle
Great. Now I have a test
that is going to tap

624
00:28:59,736 --> 00:29:01,746 A:middle
on the groceries label.

625

626
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

627
00:28:59,736 --> 00:29:01,746 A:middle
on the groceries label.

628
00:29:02,456 --> 00:29:05,356 A:middle
Next it is going to add the
new cookies item to the list,

629
00:29:05,756 --> 00:29:08,656 A:middle
and then it is going to
tap on that cookies button

630
00:29:08,656 --> 00:29:12,146 A:middle
in that item, and verify
that it actually gets

631
00:29:12,146 --> 00:29:14,256 A:middle
to that tapped state.

632
00:29:15,126 --> 00:29:16,976 A:middle
So to add the second
item I'm just going

633
00:29:16,976 --> 00:29:17,856 A:middle
to copy this code here.

634
00:29:17,856 --> 00:29:23,816 A:middle
And then to verify that the new
button exists and gets tapped,

635
00:29:24,586 --> 00:29:26,126 A:middle
I'm going to copy that section.

636
00:29:26,676 --> 00:29:34,406 A:middle
So let's run this test
and see how that works.

637
00:29:34,606 --> 00:29:35,836 A:middle
Now let's add the first one.

638
00:29:37,116 --> 00:29:37,626 A:middle
Second one.

639
00:29:38,786 --> 00:29:40,546 A:middle
Ahh, failed an assertion here.

640
00:29:40,906 --> 00:29:44,566 A:middle
So on this line here, where
we are getting the value

641
00:29:44,766 --> 00:29:47,986 A:middle
of the cookies button for
the second time around,

642
00:29:48,636 --> 00:29:49,996 A:middle
we are actually failing
the assertion.

643
00:29:50,426 --> 00:29:52,586 A:middle
Looks like it's failing because
multiple matches are found.

644
00:29:53,036 --> 00:29:55,206 A:middle
I think I have an idea
of what went wrong here.

645
00:29:56,546 --> 00:30:00,246 A:middle
The way that the cookies
button constant is specified,

646

647
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

648
00:29:56,546 --> 00:30:00,246 A:middle
The way that the cookies
button constant is specified,

649
00:30:00,246 --> 00:30:02,646 A:middle
it is just looking for all
the buttons in the table,

650
00:30:02,736 --> 00:30:05,726 A:middle
and giving me one
that's called cookies.

651
00:30:06,206 --> 00:30:07,796 A:middle
By this point in the test,

652
00:30:07,796 --> 00:30:11,226 A:middle
there are two buttons
called cookies in the table.

653
00:30:11,226 --> 00:30:15,136 A:middle
It will find both of them
and there is not going

654
00:30:15,136 --> 00:30:17,946 A:middle
to be one value that
the element can return

655
00:30:17,946 --> 00:30:19,266 A:middle
because there's these
two matches.

656
00:30:20,236 --> 00:30:23,256 A:middle
Now, I only know that because
I just saw the test running.

657
00:30:23,686 --> 00:30:27,346 A:middle
Normally you are not going to be
watching your test as it runs.

658
00:30:28,356 --> 00:30:30,926 A:middle
So we thought we should
provide a way for you

659
00:30:30,926 --> 00:30:33,956 A:middle
to see what the test looks
like when it last ran

660
00:30:34,816 --> 00:30:38,126 A:middle
and we've added this information
to the test reports in Xcode.

661
00:30:39,596 --> 00:30:42,456 A:middle
So if I go to the report
navigator and click

662
00:30:42,456 --> 00:30:43,686 A:middle
on the most recent test report,

663
00:30:44,066 --> 00:30:47,366 A:middle
you can see the test
add to cookies test.

664
00:30:48,336 --> 00:30:51,946 A:middle
If I expand this item, you
can see all of the activities

665
00:30:51,946 --> 00:30:53,376 A:middle
that happen during the test.

666
00:30:54,216 --> 00:30:57,056 A:middle
And down here I see this last
find the cookies button item.

667
00:30:57,326 --> 00:30:58,066 A:middle
There's my failure.

668
00:30:58,066 --> 00:30:59,156 A:middle
Multiple matches found.

669
00:30:59,896 --> 00:31:03,626 A:middle
There's also a quick look button
here, where I can look on that

670

671
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

672
00:30:59,896 --> 00:31:03,626 A:middle
There's also a quick look button
here, where I can look on that

673
00:31:03,626 --> 00:31:05,746 A:middle
and it will show
me the exact state

674
00:31:05,746 --> 00:31:07,246 A:middle
of the application
when that happened.

675
00:31:07,246 --> 00:31:09,516 A:middle
Just like we know
happened, yeah,

676
00:31:09,516 --> 00:31:10,946 A:middle
there's two rows called cookies.

677
00:31:11,516 --> 00:31:13,596 A:middle
One of them is tapped and
one of them is not tapped.

678
00:31:14,516 --> 00:31:18,936 A:middle
[Applause]

679
00:31:19,436 --> 00:31:21,876 A:middle
>> BROOKE CALLAHAN: I am going
to close that and if I want

680
00:31:21,876 --> 00:31:23,506 A:middle
to see the complete
assertion failure,

681
00:31:23,506 --> 00:31:25,426 A:middle
I can go to the log section

682
00:31:26,506 --> 00:31:32,396 A:middle
and on this line I can
expand the log for that test.

683
00:31:32,566 --> 00:31:37,326 A:middle
And here we can see the complete
assertion failure showing the

684
00:31:37,326 --> 00:31:40,176 A:middle
accessibility hierarchy
of both those buttons.

685
00:31:40,776 --> 00:31:44,366 A:middle
And here on the side I can see
that yeah, there's one button

686
00:31:44,366 --> 00:31:46,686 A:middle
that is unchecked and
the other one is checked,

687
00:31:47,666 --> 00:31:49,186 A:middle
just like I expect.

688
00:31:49,996 --> 00:31:51,436 A:middle
Let's go back and fix that test.

689
00:31:52,626 --> 00:31:55,656 A:middle
The easiest way for
me to fix this test is

690
00:31:55,656 --> 00:31:56,556 A:middle
to use recording again.

691
00:31:57,096 --> 00:31:59,576 A:middle
I'll set a breakpoint on this
line right before the assertion

692
00:31:59,576 --> 00:32:11,096 A:middle
failure, and run the
test at that point.

693

694
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

695
00:31:59,576 --> 00:32:11,096 A:middle
failure, and run the
test at that point.

696
00:32:11,316 --> 00:32:11,586 A:middle
All right.

697
00:32:11,656 --> 00:32:14,846 A:middle
So now I've got the application
in exactly the state I need it

698
00:32:14,846 --> 00:32:18,176 A:middle
to be to get the value
of that unchecked button.

699
00:32:18,326 --> 00:32:20,906 A:middle
All I'm going to do is I'm
going to click on recording,

700
00:32:20,906 --> 00:32:25,466 A:middle
tap on that button,
and stop recording.

701
00:32:26,506 --> 00:32:29,416 A:middle
Now I have a way to refer
to that second button.

702
00:32:30,206 --> 00:32:30,806 A:middle
I'm going to clean this

703
00:32:30,806 --> 00:32:33,446 A:middle
up by using the table
constant in both.

704
00:32:33,446 --> 00:32:36,696 A:middle
I'm going to call this
cookies button two,

705
00:32:36,806 --> 00:32:38,866 A:middle
a new constant in my test.

706
00:32:45,306 --> 00:32:47,856 A:middle
And now to fix the test
I'm going to change each

707
00:32:47,856 --> 00:32:49,656 A:middle
of the next three lines
to use that new reference.

708
00:32:53,476 --> 00:32:56,036 A:middle
And when I run the test again,
we should see that it works.

709

710
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

711
00:33:06,896 --> 00:33:07,156 A:middle
Great!

712
00:33:08,516 --> 00:33:13,156 A:middle
[Applause]

713
00:33:13,656 --> 00:33:13,916 A:middle
All right.

714
00:33:14,246 --> 00:33:16,636 A:middle
Now I've got one test that
can add and remove an item

715
00:33:16,636 --> 00:33:18,816 A:middle
from the list and another
test that can add two items

716
00:33:18,816 --> 00:33:21,456 A:middle
to the same list, and
verify they both exist.

717
00:33:21,456 --> 00:33:23,226 A:middle
Now I want to build a test

718
00:33:23,506 --> 00:33:26,296 A:middle
that will remove all
the items from the list.

719
00:33:26,896 --> 00:33:30,856 A:middle
Once again I'm going
to use recording.

720
00:33:30,856 --> 00:33:39,516 A:middle
I am going to tap on groceries,
edit, and then I'm going

721
00:33:39,516 --> 00:33:45,586 A:middle
to remove the apples
row from the test.

722
00:33:45,756 --> 00:33:46,036 A:middle
All right?

723
00:33:46,126 --> 00:33:47,256 A:middle
I'll tap stop recording.

724
00:33:48,026 --> 00:33:53,086 A:middle
So all this much of the test
is pretty much how I want,

725
00:33:53,646 --> 00:33:57,766 A:middle
but what I want to do is, I
want to make my test agnostic

726
00:33:57,766 --> 00:33:59,166 A:middle
to the data of the application.

727
00:33:59,436 --> 00:34:01,766 A:middle
I want it to remove all these
items, but I don't want it

728

729
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

730
00:33:59,436 --> 00:34:01,766 A:middle
I want it to remove all these
items, but I don't want it

731
00:34:01,766 --> 00:34:05,246 A:middle
to actually refer to the
items by their labels.

732
00:34:06,486 --> 00:34:08,286 A:middle
Because that is going to
get kind of wordy here.

733
00:34:08,716 --> 00:34:14,585 A:middle
So first thing I'm going to
do, you see these tokens here,

734
00:34:14,585 --> 00:34:20,565 A:middle
the tokens provide multiple ways
to get to the same UI element.

735
00:34:20,565 --> 00:34:23,846 A:middle
In this case, for that
first delete apples button,

736
00:34:23,846 --> 00:34:27,815 A:middle
I can get to this by calling
table.button delete apples.

737
00:34:28,016 --> 00:34:34,056 A:middle
I can be more specific and say
it's the delete apples button

738
00:34:34,565 --> 00:34:35,676 A:middle
in the cell called apples.

739
00:34:35,716 --> 00:34:38,146 A:middle
So I'm going to use that.

740
00:34:38,146 --> 00:34:45,136 A:middle
And I'm going to double click
on it to convert it to text.

741
00:34:45,136 --> 00:34:48,516 A:middle
So now I've got two rows here

742
00:34:48,596 --> 00:34:50,985 A:middle
where we are getting the
elements the same way.

743
00:34:51,275 --> 00:34:55,156 A:middle
What I would like to do is
get the cell simply by index.

744
00:34:55,156 --> 00:35:00,116 A:middle
I will add a constant called let
cell, table., and set this equal

745

746
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

747
00:34:55,156 --> 00:35:00,116 A:middle
I will add a constant called let
cell, table., and set this equal

748
00:35:00,436 --> 00:35:03,456 A:middle
to table.cells elements index.

749
00:35:03,926 --> 00:35:09,126 A:middle
Since the apples row was index
one, I'm going to use that.

750
00:35:09,506 --> 00:35:17,406 A:middle
I can simply replace these with
the reference to that constant.

751
00:35:17,406 --> 00:35:17,586 A:middle
All right.

752
00:35:17,586 --> 00:35:18,406 A:middle
I'm almost done.

753
00:35:19,536 --> 00:35:22,486 A:middle
The next part I need to change
here is how I'm getting the

754
00:35:22,486 --> 00:35:25,836 A:middle
button out of the cell because
the other rows are not going

755
00:35:25,986 --> 00:35:27,296 A:middle
to have a delete apples button.

756
00:35:27,296 --> 00:35:29,906 A:middle
They will have a delete
oranges button or delete bread.

757
00:35:30,276 --> 00:35:33,306 A:middle
What I need is a way
to find the button

758
00:35:33,846 --> 00:35:35,946 A:middle
where the label starts
with the word delete.

759
00:35:36,626 --> 00:35:41,806 A:middle
To do that I'm going
to use a predicate.

760
00:35:41,886 --> 00:35:45,706 A:middle
So here I'm using
matching predicate

761
00:35:45,836 --> 00:35:49,506 A:middle
to find the button whose label
begins with the word delete.

762
00:35:49,506 --> 00:35:50,226 A:middle
All right.

763
00:35:51,096 --> 00:35:54,866 A:middle
So the last thing I
need to change here,

764
00:35:54,986 --> 00:35:56,776 A:middle
I want to add an
assertion just like before.

765
00:35:56,836 --> 00:35:59,106 A:middle
I want to verify that
that cell goes away

766
00:35:59,106 --> 00:36:00,566 A:middle
after we've removed it.

767

768
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

769
00:35:59,106 --> 00:36:00,566 A:middle
after we've removed it.

770
00:36:00,566 --> 00:36:02,656 A:middle
I am going to use
XCTAssertEqual,

771
00:36:02,656 --> 00:36:06,676 A:middle
and assert that the cells
exist property returns false

772
00:36:06,676 --> 00:36:09,136 A:middle
after we tap that delete
confirmation button.

773
00:36:09,136 --> 00:36:11,756 A:middle
I'm going to run the test now.

774
00:36:12,436 --> 00:36:26,176 A:middle
It is removing the apples
row but failed the assertion.

775
00:36:26,736 --> 00:36:28,886 A:middle
I have an idea what
might be going on here.

776
00:36:30,456 --> 00:36:33,506 A:middle
To show you what is going
on I'll use the debugger.

777
00:36:33,606 --> 00:36:36,216 A:middle
I'll set a breakpoint here
and run the test again,

778
00:36:36,256 --> 00:36:44,946 A:middle
to that same breakpoint.

779
00:36:45,296 --> 00:36:45,596 A:middle
All right.

780
00:36:45,656 --> 00:36:48,876 A:middle
Now in the debugger, I'm going

781
00:36:48,876 --> 00:36:50,636 A:middle
to call debug description
on the cell.

782
00:36:58,556 --> 00:37:01,826 A:middle
So the debug description
has a lot of information

783

784
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

785
00:36:58,556 --> 00:37:01,826 A:middle
So the debug description
has a lot of information

786
00:37:01,826 --> 00:37:03,906 A:middle
about how the cell
is actually resolved.

787
00:37:04,376 --> 00:37:07,116 A:middle
So I can see here
that when I call it,

788
00:37:07,886 --> 00:37:10,646 A:middle
this cell result first
finds the application

789
00:37:12,776 --> 00:37:16,046 A:middle
and then it finds the
table in the application.

790
00:37:17,296 --> 00:37:18,306 A:middle
Then all the cells.

791
00:37:18,306 --> 00:37:21,946 A:middle
And then the element and
index in those cells.

792
00:37:22,596 --> 00:37:24,816 A:middle
I can see that it's actually
finding the oranges row.

793
00:37:25,966 --> 00:37:28,016 A:middle
It looks like what might
be happening here is

794
00:37:29,196 --> 00:37:34,886 A:middle
when we call the exist property
on this element called cell,

795
00:37:35,696 --> 00:37:37,526 A:middle
it is actually re-resolving
itself.

796
00:37:37,866 --> 00:37:41,096 A:middle
Even though we just
removed the apples row

797
00:37:41,096 --> 00:37:45,926 A:middle
from the table there's now
a new cell at index one.

798
00:37:46,836 --> 00:37:49,026 A:middle
So that is no problem.

799
00:37:50,286 --> 00:37:52,986 A:middle
It just means I need to
use a different way to find

800
00:37:53,156 --> 00:37:55,456 A:middle
out whether or not
we've removed the row.

801
00:37:56,026 --> 00:37:57,996 A:middle
So I'm going to add
an assertion,

802
00:37:58,026 --> 00:37:59,936 A:middle
assert that the number of cells

803

804
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

805
00:38:00,156 --> 00:38:03,396 A:middle
in the table goes
down at this point.

806
00:38:03,396 --> 00:38:05,886 A:middle
So I'm going to add a new
constant called "count"

807
00:38:06,466 --> 00:38:11,576 A:middle
and I'll set this equal to the
count of the cells in the table.

808
00:38:12,126 --> 00:38:18,356 A:middle
And then I'll simply assert that
that's equal to count minus 1.

809
00:38:18,356 --> 00:38:22,626 A:middle
Now, the last thing I need
to do, I said this was going

810
00:38:22,626 --> 00:38:24,346 A:middle
to be a remove all items test.

811
00:38:24,346 --> 00:38:31,076 A:middle
I'm going to change it to add
a wild loop and simply do this

812
00:38:31,076 --> 00:38:33,196 A:middle
over and over again as
long as there's more

813
00:38:33,196 --> 00:38:39,016 A:middle
than one cell in the table.

814
00:38:39,186 --> 00:38:40,366 A:middle
Let's run that.

815
00:38:43,576 --> 00:38:49,426 A:middle
So it's removing the
apples row, and oranges.

816
00:38:55,556 --> 00:38:56,256 A:middle
All right.

817
00:38:57,516 --> 00:39:04,096 A:middle
[Applause]

818

819
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

820
00:38:57,516 --> 00:39:04,096 A:middle
[Applause]

821
00:39:04,596 --> 00:39:07,676 A:middle
>> BROOKE CALLAHAN: Last thing
I would like to do is add a test

822
00:39:07,816 --> 00:39:10,626 A:middle
to use that color row that
we saw in the edit UI.

823
00:39:15,216 --> 00:39:20,666 A:middle
And once again I'm going to
use the recorder for this.

824
00:39:21,386 --> 00:39:23,526 A:middle
I'll tap on groceries and edit.

825
00:39:24,066 --> 00:39:29,586 A:middle
Now, the color UI here lets me
change the color for a list.

826
00:39:29,866 --> 00:39:31,316 A:middle
It looks like right
now this list is green.

827
00:39:31,906 --> 00:39:35,726 A:middle
So I'll try changing it
to red or how about blue?

828
00:39:37,776 --> 00:39:40,006 A:middle
Okay, so when I tap on
those buttons it looks

829
00:39:40,006 --> 00:39:42,806 A:middle
like it's not actually
recording what I want.

830
00:39:42,806 --> 00:39:44,946 A:middle
It looks like it's
recording a tap

831
00:39:45,266 --> 00:39:47,826 A:middle
on the static text called
color, which you see over here.

832
00:39:48,566 --> 00:39:51,906 A:middle
So I think what might
be going on here is

833
00:39:51,906 --> 00:39:54,196 A:middle
that these UI elements
simply might not be visible

834
00:39:54,196 --> 00:39:54,956 A:middle
to Accessibility.

835
00:39:54,956 --> 00:39:56,976 A:middle
So I'm going to stop recording,

836
00:39:56,976 --> 00:40:01,696 A:middle
and I can actually use the
accessibility inspector

837

838
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

839
00:39:56,976 --> 00:40:01,696 A:middle
and I can actually use the
accessibility inspector

840
00:40:01,696 --> 00:40:02,616 A:middle
to tell me what's going on.

841
00:40:03,176 --> 00:40:05,706 A:middle
I'll right click on Xcode and
go to open developer tool,

842
00:40:05,736 --> 00:40:06,836 A:middle
accessibility inspector.

843
00:40:08,326 --> 00:40:11,466 A:middle
And the accessibility inspector
provides a lot of information,

844
00:40:11,466 --> 00:40:15,776 A:middle
but all I want to use it for
is ths shortcut, command S7.

845
00:40:15,776 --> 00:40:18,716 A:middle
It will highlight the UI
element that's underneath the

846
00:40:18,716 --> 00:40:19,226 A:middle
mouse cursor.

847
00:40:19,796 --> 00:40:22,976 A:middle
If I put the mouse cursor

848
00:40:22,976 --> 00:40:26,126 A:middle
over the word bread here,
and press command F7.

849
00:40:26,126 --> 00:40:27,336 A:middle
it highlights bread.

850
00:40:28,006 --> 00:40:31,416 A:middle
If I put it over the
delete bread button,

851
00:40:31,776 --> 00:40:33,426 A:middle
you can see that
it highlights that.

852
00:40:35,426 --> 00:40:37,976 A:middle
Now, let's see what happens
if I put the mouse cursor

853
00:40:37,976 --> 00:40:42,136 A:middle
over this yellow color button.

854
00:40:42,276 --> 00:40:44,236 A:middle
Aha! So it highlighted
the whole row.

855
00:40:44,236 --> 00:40:46,916 A:middle
So that pretty much confirms

856
00:40:46,916 --> 00:40:49,656 A:middle
that this UI element is simply
not visible to accessibility.

857
00:40:51,096 --> 00:40:52,466 A:middle
Luckily I can actually
change this,

858
00:40:52,816 --> 00:40:55,306 A:middle
and fix this problem
using the story board.

859
00:40:55,306 --> 00:41:05,316 A:middle
I'll open the story board now.

860

861
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

862
00:40:55,306 --> 00:41:05,316 A:middle
I'll open the story board now.

863
00:41:05,546 --> 00:41:07,866 A:middle
So here I've got the same
buttons in my story board

864
00:41:09,696 --> 00:41:12,856 A:middle
and if I open the
inspector, here I can see

865
00:41:12,856 --> 00:41:17,986 A:middle
that these buttons actually have
a class of color tappable view.

866
00:41:18,276 --> 00:41:19,976 A:middle
I'm familiar with this class.

867
00:41:19,976 --> 00:41:22,506 A:middle
I know it's actually
not UI button.

868
00:41:23,116 --> 00:41:24,436 A:middle
It's custom view.

869
00:41:24,436 --> 00:41:26,566 A:middle
If I go down to the
accessibility part

870
00:41:26,706 --> 00:41:30,296 A:middle
of the inspector, I can see
it's not enabled for them.

871
00:41:30,296 --> 00:41:33,626 A:middle
I have gone through and
added labels for them.

872
00:41:34,276 --> 00:41:37,806 A:middle
To fix this all I need to do
is select all of the buttons.

873
00:41:37,806 --> 00:41:45,346 A:middle
And then I'll check the enabled
for accessibility check box.

874
00:41:45,616 --> 00:41:46,816 A:middle
Since they behave like buttons,

875
00:41:46,816 --> 00:41:48,006 A:middle
I am going to give
these the button trait.

876
00:41:48,546 --> 00:41:48,706 A:middle
All right?

877
00:41:51,336 --> 00:41:54,166 A:middle
Now let's run the
application again.

878

879
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

880
00:42:02,266 --> 00:42:05,806 A:middle
And now I'm going to record
this test one more time.

881
00:42:06,086 --> 00:42:08,626 A:middle
Tap on groceries and edit.

882
00:42:09,486 --> 00:42:12,516 A:middle
Then red. And orange.

883
00:42:12,806 --> 00:42:16,946 A:middle
Yellow, green, blue, and gray.

884
00:42:17,196 --> 00:42:21,486 A:middle
Great. Now it actually
recorded all those.

885
00:42:21,646 --> 00:42:23,966 A:middle
I'll stop recording and
let's run it and see

886
00:42:23,966 --> 00:42:32,996 A:middle
if it can play it back as well.

887
00:42:32,996 --> 00:42:35,946 A:middle
Great. I've fixed
accessibility in my application.

888
00:42:36,666 --> 00:42:38,276 A:middle
And I've also made
it more testable.

889
00:42:38,596 --> 00:42:40,326 A:middle
If I was going to
complete this test,

890
00:42:41,456 --> 00:42:43,886 A:middle
I would probably add
some assertions to verify

891
00:42:43,886 --> 00:42:45,246 A:middle
that the state of
these buttons changes.

892
00:42:45,466 --> 00:42:46,716 A:middle
For now, I'll hand
the stage back to Wil.

893
00:42:47,516 --> 00:42:53,426 A:middle
[Applause]

894
00:42:53,926 --> 00:42:55,366 A:middle
>> WIL TURNER: So that's
really quite awesome,

895
00:42:55,486 --> 00:42:58,916 A:middle
especially just how easy
it was to make this view

896
00:42:58,916 --> 00:43:01,356 A:middle
that previously a Voice Over
user would have had no luck

897

898
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

899
00:42:58,916 --> 00:43:01,356 A:middle
that previously a Voice Over
user would have had no luck

900
00:43:01,356 --> 00:43:04,876 A:middle
with at all and just
with a few quick changes

901
00:43:04,876 --> 00:43:07,186 A:middle
in interface builder
Brooke was able to make

902
00:43:07,216 --> 00:43:09,656 A:middle
that both accessible
and UI testable.

903
00:43:10,266 --> 00:43:15,186 A:middle
So in the demo, some sort
of more advanced UI testing.

904
00:43:15,186 --> 00:43:17,786 A:middle
You saw he had cases where
he dealt with a conflict

905
00:43:17,786 --> 00:43:20,906 A:middle
and a query, and how to
correct those queries,

906
00:43:20,906 --> 00:43:25,296 A:middle
and how to debug it, and also
how he can loop over elements

907
00:43:25,736 --> 00:43:28,826 A:middle
and validate them, and how you
can use the exists property

908
00:43:28,826 --> 00:43:32,456 A:middle
and also highlighted how
queries are reevaluated.

909
00:43:32,696 --> 00:43:35,946 A:middle
They use the criteria that
you created them with.

910
00:43:35,996 --> 00:43:39,256 A:middle
That specification is
what gets reevaluated.

911
00:43:39,686 --> 00:43:41,976 A:middle
We used element at index one.

912
00:43:41,976 --> 00:43:45,056 A:middle
That pointed to the apples
label the first time through.

913
00:43:45,276 --> 00:43:47,436 A:middle
As soon as that was
gone and the UI changed,

914
00:43:47,606 --> 00:43:50,866 A:middle
now that was pointing to the
oranges label.And then finally,

915
00:43:51,576 --> 00:43:52,766 A:middle
how to improve accessibility,

916
00:43:53,016 --> 00:43:57,526 A:middle
and the rewards are truly
fantastic for doing that.

917
00:43:58,256 --> 00:44:01,116 A:middle
Brooke also gave you a
peek at the test reports.

918

919
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

920
00:43:58,256 --> 00:44:01,116 A:middle
Brooke also gave you a
peek at the test reports.

921
00:44:01,116 --> 00:44:03,826 A:middle
We have done some
work in Xcode 7

922
00:44:03,906 --> 00:44:07,366 A:middle
to overhaul them for UI testing.

923
00:44:07,716 --> 00:44:11,096 A:middle
To recap are, the test reports
are where you see the results

924
00:44:11,096 --> 00:44:12,376 A:middle
for all the tests that ran.

925
00:44:12,956 --> 00:44:16,336 A:middle
It shows the pass or the
fail, the failure message,

926
00:44:16,976 --> 00:44:18,266 A:middle
performance metrics

927
00:44:18,266 --> 00:44:20,296 A:middle
for performance tests
are shown in the reports.

928
00:44:21,056 --> 00:44:24,236 A:middle
You get the same UI in
XCode and in Xcode server.

929
00:44:24,366 --> 00:44:26,416 A:middle
It's a consistent
experience regardless

930
00:44:26,416 --> 00:44:28,946 A:middle
of whether you are looking
at integrations or the run

931
00:44:28,946 --> 00:44:30,576 A:middle
that you just did on
your local computer.

932
00:44:31,426 --> 00:44:34,016 A:middle
On Xcode server you also
get per-device results,

933
00:44:34,016 --> 00:44:36,886 A:middle
because you can have the devices
integrating multiple devices

934
00:44:36,886 --> 00:44:37,696 A:middle
at the same time.

935
00:44:38,466 --> 00:44:41,116 A:middle
The additions for UI testing,

936
00:44:41,536 --> 00:44:43,836 A:middle
we collected additional
data during UI testing,

937
00:44:43,836 --> 00:44:45,666 A:middle
and this includes screen shots.

938
00:44:46,316 --> 00:44:50,366 A:middle
You saw how it helped Brooke
debug the conflict in his query

939
00:44:50,366 --> 00:44:53,066 A:middle
by pulling up the screen shot
at the time that query failed.

940
00:44:54,096 --> 00:44:59,126 A:middle
Also, we organized the API calls
into these nested activities

941
00:44:59,126 --> 00:45:02,126 A:middle
that help you understand
how the API call is working.

942

943
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

944
00:44:59,126 --> 00:45:02,126 A:middle
that help you understand
how the API call is working.

945
00:45:02,766 --> 00:45:04,636 A:middle
So let's take a look
at an example of this.

946
00:45:04,986 --> 00:45:06,336 A:middle
This is not the list draft.

947
00:45:06,336 --> 00:45:07,456 A:middle
It is a different application.

948
00:45:07,876 --> 00:45:11,106 A:middle
But I'm going to show you
how there are several steps

949
00:45:11,106 --> 00:45:12,876 A:middle
in the nested activities
breakdown.

950
00:45:13,596 --> 00:45:15,806 A:middle
This example we're
typing into a test field

951
00:45:15,806 --> 00:45:18,876 A:middle
so the high level you
call the API type test.

952
00:45:19,686 --> 00:45:21,206 A:middle
But internally that breaks down.

953
00:45:21,616 --> 00:45:24,246 A:middle
In the first step where we wait
for the application to idle.

954
00:45:24,626 --> 00:45:27,136 A:middle
We're actually observing
the main run loop

955
00:45:27,446 --> 00:45:28,776 A:middle
of the tested application.

956
00:45:29,126 --> 00:45:31,276 A:middle
Because We don't want
to send events to it,

957
00:45:31,616 --> 00:45:33,026 A:middle
when it's busy processing.

958
00:45:33,026 --> 00:45:34,996 A:middle
We want it to be
responsive as possible.

959
00:45:35,726 --> 00:45:41,186 A:middle
Once it's idled we capture the
data we need from Accessibility

960
00:45:41,586 --> 00:45:42,846 A:middle
and we resolve the query,

961
00:45:42,846 --> 00:45:45,066 A:middle
make sure it matches
exactly one thing.

962
00:45:46,166 --> 00:45:48,616 A:middle
Next step, we synthesize
the actual events

963
00:45:48,716 --> 00:45:50,646 A:middle
that insert the text
into that field.

964
00:45:51,616 --> 00:45:55,086 A:middle
Finally, we wait one more time
for the app to idle afterwards.

965
00:45:55,166 --> 00:45:58,226 A:middle
Because, again, we want to
hand off control in a way

966
00:45:58,226 --> 00:46:01,446 A:middle
where things are reliable
and deterministic.

967

968
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

969
00:45:58,226 --> 00:46:01,446 A:middle
where things are reliable
and deterministic.

970
00:46:01,976 --> 00:46:05,586 A:middle
The quick looks are
provided for screen shots

971
00:46:05,586 --> 00:46:07,586 A:middle
that are captured
during critical steps.

972
00:46:07,976 --> 00:46:11,476 A:middle
You can see here is the state
right after I type that text in.

973
00:46:11,736 --> 00:46:14,326 A:middle
Make sure everything looked
just the way you expected.

974
00:46:15,196 --> 00:46:19,986 A:middle
So UI testing is obviously
a huge expansion of the kind

975
00:46:19,986 --> 00:46:22,056 A:middle
of testing you can do
for your applications.

976
00:46:22,436 --> 00:46:24,046 A:middle
So when do you use it, right?

977
00:46:24,466 --> 00:46:26,736 A:middle
We've got unit testing already.

978
00:46:27,116 --> 00:46:30,166 A:middle
UI testing is a complement to
UI testing, not a replacement.

979
00:46:30,556 --> 00:46:33,536 A:middle
You should continue to use unit
testing for your model objects,

980
00:46:33,536 --> 00:46:35,196 A:middle
and your controller logic,

981
00:46:35,536 --> 00:46:38,476 A:middle
because unit testing will more
precisely pinpoint failures

982
00:46:38,476 --> 00:46:39,506 A:middle
when they happen in your code.

983
00:46:40,196 --> 00:46:43,446 A:middle
UI testing allows you to
cover much broader ranges

984
00:46:43,446 --> 00:46:45,726 A:middle
of functionality, but tracking

985
00:46:45,726 --> 00:46:47,346 A:middle
down the failures can
be more challenging.

986
00:46:47,736 --> 00:46:51,156 A:middle
It's a balance in your project,
of finding the right blend

987
00:46:51,186 --> 00:46:53,106 A:middle
between unit testing
and UI testing.

988
00:46:54,796 --> 00:46:56,726 A:middle
Some great candidates
for UI testing.

989
00:46:57,216 --> 00:46:58,136 A:middle
Well, think about your app.

990
00:46:58,186 --> 00:47:00,306 A:middle
You have customers,
you show it to them,

991

992
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

993
00:46:58,186 --> 00:47:00,306 A:middle
You have customers,
you show it to them,

994
00:47:00,306 --> 00:47:02,826 A:middle
and you have little demo
sequences that you show to them,

995
00:47:02,826 --> 00:47:03,776 A:middle
and you walk them
through, "well,

996
00:47:03,776 --> 00:47:05,006 A:middle
here's how you do
this with the app."

997
00:47:05,506 --> 00:47:08,656 A:middle
Demo sequences are great
candidates for UI testing.

998
00:47:08,656 --> 00:47:11,926 A:middle
You'll know nightly
build after nightly build

999
00:47:12,256 --> 00:47:13,746 A:middle
that those demos are
going to work for you.

1000
00:47:14,636 --> 00:47:17,056 A:middle
Second, beyond that,
common workflows.

1001
00:47:17,646 --> 00:47:20,986 A:middle
What the app is used for,
if it's an editing app,

1002
00:47:21,066 --> 00:47:22,426 A:middle
how you edit the documents.

1003
00:47:22,426 --> 00:47:25,916 A:middle
Any custom views you
have in the application.

1004
00:47:26,526 --> 00:47:29,456 A:middle
And finally document-based
workflows, opening and saving.

1005
00:47:29,756 --> 00:47:31,116 A:middle
These are all great
things to automate.

1006
00:47:31,116 --> 00:47:33,596 A:middle
They are really hard to
capture with unit testing.

1007
00:47:33,976 --> 00:47:36,646 A:middle
When they go wrong they
have a huge impact on users.

1008
00:47:38,756 --> 00:47:40,496 A:middle
So UI testing.

1009
00:47:41,576 --> 00:47:42,706 A:middle
New in XCode 7.

1010
00:47:43,776 --> 00:47:45,606 A:middle
Opens up a world
of possibilities

1011
00:47:45,606 --> 00:47:47,796 A:middle
for how you can test
your applications.

1012
00:47:49,266 --> 00:47:51,916 A:middle
In UI testing you
find and interact

1013
00:47:52,146 --> 00:47:55,256 A:middle
with user interface elements
and you synthesize events

1014
00:47:55,296 --> 00:47:57,996 A:middle
that drives them, just
the way a user does.

1015
00:47:58,986 --> 00:48:01,646 A:middle
You can validate the UI
properties and state.

1016

1017
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1018
00:47:58,986 --> 00:48:01,646 A:middle
You can validate the UI
properties and state.

1019
00:48:03,126 --> 00:48:06,616 A:middle
And UI recording lets you
create these tests super quick,

1020
00:48:06,856 --> 00:48:07,646 A:middle
super easy.

1021
00:48:09,196 --> 00:48:11,586 A:middle
Finally, we've overhauled
the test reports

1022
00:48:12,066 --> 00:48:15,566 A:middle
to make you better able to
understand how your tests work

1023
00:48:16,066 --> 00:48:17,666 A:middle
and collect additional
data about them.

1024
00:48:18,666 --> 00:48:19,446 A:middle
So that's UI testing.

1025
00:48:20,516 --> 00:48:27,916 A:middle
[Applause]

1026
00:48:28,416 --> 00:48:30,726 A:middle
>> WIL TURNER: So for more
information we've got great

1027
00:48:30,726 --> 00:48:32,026 A:middle
documentation on XCTest.

1028
00:48:32,236 --> 00:48:35,226 A:middle
You can get to it through Xcode
itself and on our website.

1029
00:48:35,556 --> 00:48:37,866 A:middle
And Accessibility also
has great documentation,

1030
00:48:37,866 --> 00:48:39,056 A:middle
and I encourage you
to check out.

1031
00:48:40,516 --> 00:48:43,286 A:middle
Developer Forums are great
places to raise questions

1032
00:48:43,286 --> 00:48:47,226 A:middle
and trade tips with other users
about how you're using things.

1033
00:48:47,406 --> 00:48:50,346 A:middle
Our evangelist Stefan
Lesser is a great contact

1034
00:48:50,566 --> 00:48:51,506 A:middle
to get you started.

1035
00:48:52,736 --> 00:48:55,546 A:middle
There's some related sessions
if you want to dial back in time

1036
00:48:55,546 --> 00:48:58,036 A:middle
and watch the accessibility
session from yesterday morning,

1037
00:48:58,456 --> 00:49:00,396 A:middle
probably watch the video
on your lunch if you want,

1038

1039
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1040
00:48:58,456 --> 00:49:00,396 A:middle
probably watch the video
on your lunch if you want,

1041
00:49:01,056 --> 00:49:04,466 A:middle
and continuous integration and
code coverage, new technology

1042
00:49:04,796 --> 00:49:07,946 A:middle
in Xcode server, you can
see tomorrow afternoon --

1043
00:49:07,946 --> 00:49:08,706 A:middle
tomorrow morning.

1044
00:49:09,096 --> 00:49:09,976 A:middle
Have great conference,
everybody.

1045
00:49:10,516 --> 00:49:13,500 A:middle
[Applause]

1046
