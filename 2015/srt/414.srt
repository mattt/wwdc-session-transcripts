X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:20,016 --> 00:00:21,046 A:middle
[ Applause ]

2
00:00:21,046 --> 00:00:24,206 A:middle
>> DOUG GREGOR: Thank you.

3
00:00:24,206 --> 00:00:26,056 A:middle
Hello. I'm Doug Gregor.

4
00:00:26,266 --> 00:00:29,366 A:middle
I'm here with my colleague
Bill Dudney, and we will talk

5
00:00:29,366 --> 00:00:32,366 A:middle
about building better apps
with value types in Swift.

6
00:00:32,665 --> 00:00:37,696 A:middle
First, we are going
to start off talking

7
00:00:37,696 --> 00:00:41,256 A:middle
about reference semantics,
and then we will delve

8
00:00:41,316 --> 00:00:44,726 A:middle
through immutability as a
solution to some of the problems

9
00:00:44,726 --> 00:00:46,376 A:middle
that reference semantics pose.

10
00:00:48,036 --> 00:00:51,236 A:middle
Dive into value semantics and
value types, how it works,

11
00:00:51,236 --> 00:00:54,226 A:middle
especially how it works
in Swift, and then talk

12
00:00:54,226 --> 00:00:56,856 A:middle
about using value types in
practice and then the mixing

13
00:00:56,856 --> 00:01:00,116 A:middle
of reference types and value
types together within Swift.

14

15
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

16
00:00:56,856 --> 00:01:00,116 A:middle
of reference types and value
types together within Swift.

17
00:01:01,086 --> 00:01:03,916 A:middle
Let's get started.

18
00:01:04,025 --> 00:01:05,075 A:middle
Reference semantics.

19
00:01:05,676 --> 00:01:07,366 A:middle
So the way into reference
semantics

20
00:01:07,366 --> 00:01:10,086 A:middle
in the Swift world
is to define a class.

21
00:01:11,396 --> 00:01:13,196 A:middle
Here's a very simple
temperature class.

22
00:01:13,796 --> 00:01:16,436 A:middle
We are storing our
temperature value in Celsius.

23
00:01:16,716 --> 00:01:19,206 A:middle
We want to have this nice
computed Fahrenheit property

24
00:01:19,206 --> 00:01:22,576 A:middle
so we can always get to
it with the correct unit.

25
00:01:23,646 --> 00:01:25,696 A:middle
Simple, abstracted
version of a temperature.

26
00:01:26,316 --> 00:01:28,056 A:middle
Let's try to use it
in some simple code.

27
00:01:28,746 --> 00:01:31,886 A:middle
We create a home instance, we
create a temperature instance.

28
00:01:32,236 --> 00:01:35,506 A:middle
We set our thermostat to a
balmy 75 degrees Fahrenheit.

29
00:01:36,886 --> 00:01:39,466 A:middle
Now we decide, oh, it's
getting close to dinnertime

30
00:01:39,466 --> 00:01:40,626 A:middle
and I want to bake some salmon.

31
00:01:40,976 --> 00:01:44,146 A:middle
So I set my oven to 425
degrees and hit Bake.

32
00:01:44,876 --> 00:01:45,456 A:middle
Walk away.

33
00:01:45,546 --> 00:01:49,636 A:middle
Why is it so hot in here?

34
00:01:49,796 --> 00:01:50,416 A:middle
What's going on?

35
00:01:51,866 --> 00:01:52,676 A:middle
You know what happened.

36
00:01:52,736 --> 00:01:55,076 A:middle
We hit this case of
unintended sharing.

37
00:01:55,456 --> 00:01:56,466 A:middle
Think of the object graph.

38
00:01:57,966 --> 00:01:58,966 A:middle
We have our house.

39
00:01:59,056 --> 00:02:00,806 A:middle
It has a thermostat and an oven.

40

41
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

42
00:01:59,056 --> 00:02:00,806 A:middle
It has a thermostat and an oven.

43
00:02:01,166 --> 00:02:03,686 A:middle
We have this temperature
object that temp points to.

44
00:02:04,526 --> 00:02:06,076 A:middle
When we set our thermostat,

45
00:02:06,536 --> 00:02:08,436 A:middle
we wired it to the same
object as the temp.

46
00:02:09,166 --> 00:02:12,476 A:middle
Things look like fine until
we go ahead and do a mutation,

47
00:02:12,806 --> 00:02:14,186 A:middle
and now this unintended

48
00:02:14,186 --> 00:02:18,186 A:middle
or unexpected sharing just
caused us to set our thermostat

49
00:02:18,226 --> 00:02:20,216 A:middle
to 425 degrees Fahrenheit.

50
00:02:21,496 --> 00:02:23,176 A:middle
At this point it was
already game over,

51
00:02:23,176 --> 00:02:26,616 A:middle
but just for good measure let's
wire our thermostat to our oven

52
00:02:26,616 --> 00:02:27,736 A:middle
because we've lost already.

53
00:02:27,776 --> 00:02:32,556 A:middle
So what did we do wrong?

54
00:02:32,556 --> 00:02:34,966 A:middle
In this world where you
have reference semantics,

55
00:02:35,656 --> 00:02:38,456 A:middle
you want to prevent sharing,
and so you do copies.

56
00:02:40,066 --> 00:02:41,786 A:middle
Okay? Let's do this
the right way.

57
00:02:42,696 --> 00:02:45,356 A:middle
Okay. I'm going to
set my temperature

58
00:02:45,356 --> 00:02:47,196 A:middle
to 75 degrees Fahrenheit again.

59
00:02:47,806 --> 00:02:51,816 A:middle
When I set the temperature of my
thermostat, I will cause a copy.

60
00:02:52,146 --> 00:02:53,646 A:middle
So I get a brand new object.

61
00:02:53,906 --> 00:02:56,046 A:middle
That's what my thermostat's
temperature points to.

62
00:02:56,716 --> 00:02:58,686 A:middle
When I go ahead and
change the temperature

63
00:02:58,686 --> 00:03:00,626 A:middle
of my temp variable,
it doesn't affect it.

64

65
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

66
00:02:58,686 --> 00:03:00,626 A:middle
of my temp variable,
it doesn't affect it.

67
00:03:00,896 --> 00:03:01,256 A:middle
That's good.

68
00:03:02,156 --> 00:03:03,926 A:middle
Now I go and set the
oven's temperature,

69
00:03:04,156 --> 00:03:05,326 A:middle
I will make another copy.

70
00:03:06,496 --> 00:03:09,596 A:middle
Now, technically, I don't
need this last copy.

71
00:03:10,216 --> 00:03:13,666 A:middle
It's inefficient to go
waste time allocating memory

72
00:03:13,666 --> 00:03:15,556 A:middle
on the heap to create
this extra copy.

73
00:03:16,286 --> 00:03:18,656 A:middle
But I'm going to be safe because
the last time I missed a copy,

74
00:03:18,986 --> 00:03:19,826 A:middle
I got burned [groaning]!

75
00:03:22,166 --> 00:03:24,216 A:middle
Come on, it's a Friday
session, give me a break!

76
00:03:25,516 --> 00:03:29,696 A:middle
[ Applause ]

77
00:03:30,196 --> 00:03:35,716 A:middle
So we refer to this as defensive
copying, where we copy not

78
00:03:35,716 --> 00:03:38,656 A:middle
because we know we need it,
but because if we do happen

79
00:03:38,656 --> 00:03:41,986 A:middle
to need it now or sometime
down the road, it's really hard

80
00:03:41,986 --> 00:03:43,406 A:middle
to debug these problems.

81
00:03:43,866 --> 00:03:46,236 A:middle
And so it's way too easy

82
00:03:46,236 --> 00:03:49,286 A:middle
to forget a dot copy any time we
assigned a temperature somewhere

83
00:03:49,286 --> 00:03:49,866 A:middle
in our oven.

84
00:03:50,216 --> 00:03:52,866 A:middle
So instead, I will bake
this behavior right

85
00:03:53,606 --> 00:03:55,976 A:middle
into my oven [laughter].

86
00:03:56,146 --> 00:03:56,926 A:middle
All right, I'm done.

87
00:03:56,926 --> 00:03:57,836 A:middle
I'm done. I'm sorry.

88
00:03:58,006 --> 00:03:58,486 A:middle
I'm sorry [applause].

89
00:03:59,486 --> 00:04:01,516 A:middle
Naturally I have to do
this exact same thing

90

91
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

92
00:03:59,486 --> 00:04:01,516 A:middle
Naturally I have to do
this exact same thing

93
00:04:01,516 --> 00:04:02,936 A:middle
for the thermostat, all right?

94
00:04:02,936 --> 00:04:05,066 A:middle
So now we've got a whole bunch
of boilerplate we are copying

95
00:04:05,066 --> 00:04:07,256 A:middle
and pasting, and sooner or
later, you will be knocking

96
00:04:07,256 --> 00:04:09,126 A:middle
on my door asking for a
language feature here.

97
00:04:09,846 --> 00:04:14,206 A:middle
Hold off on that, and let's
talk about where we see copying

98
00:04:14,206 --> 00:04:15,646 A:middle
in Cocoa and Objective-C.

99
00:04:16,666 --> 00:04:18,486 A:middle
So in Cocoa, you
have this notion

100
00:04:18,486 --> 00:04:19,836 A:middle
of the NSCopying protocol.

101
00:04:20,315 --> 00:04:22,866 A:middle
And this codifies
what it means to copy,

102
00:04:23,506 --> 00:04:26,386 A:middle
and you have a whole lot of
data types and this NSstring,

103
00:04:26,446 --> 00:04:28,796 A:middle
NSArray, NSURLRequest, etcetera.

104
00:04:29,056 --> 00:04:31,906 A:middle
These things conform to
NSCopying because you have

105
00:04:31,956 --> 00:04:33,226 A:middle
to copy them to be safe.

106
00:04:33,616 --> 00:04:37,896 A:middle
We are in a system that needs
copying, and so you see a lot

107
00:04:37,896 --> 00:04:40,676 A:middle
of defensive copying for
very, very good reasons.

108
00:04:40,716 --> 00:04:44,756 A:middle
So NSDictionary will defensively
copy the keys you place

109
00:04:44,756 --> 00:04:45,506 A:middle
in the dictionary.

110
00:04:46,366 --> 00:04:49,966 A:middle
Why? Well, if you were to hand
NSDictionary a key to insert it

111
00:04:50,246 --> 00:04:53,736 A:middle
and then go change it in a way
that, say, alters the hash value

112
00:04:53,736 --> 00:04:55,996 A:middle
of it, you will break
all the internal variance

113
00:04:55,996 --> 00:04:58,396 A:middle
of NSDictionary and
blame us for your bugs.

114
00:04:58,396 --> 00:04:59,596 A:middle
We don't really want that.

115

116
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

117
00:05:00,216 --> 00:05:02,846 A:middle
What we really do is
we do defensive copying

118
00:05:02,846 --> 00:05:03,566 A:middle
in NSDictionary.

119
00:05:03,566 --> 00:05:06,626 A:middle
That's the right answer in this
system, but it's unfortunate

120
00:05:06,666 --> 00:05:09,166 A:middle
that we are losing performance

121
00:05:09,166 --> 00:05:10,616 A:middle
because we are doing
these extra copies.

122
00:05:11,736 --> 00:05:14,346 A:middle
Of course, we moved this all
the way down into the level

123
00:05:14,346 --> 00:05:17,146 A:middle
of the language with copy
properties in Objective-C

124
00:05:17,456 --> 00:05:20,746 A:middle
that do defensive copying on
every single assignment to try

125
00:05:20,746 --> 00:05:23,176 A:middle
to prevent these
problems, and it helps,

126
00:05:23,176 --> 00:05:25,106 A:middle
all this defensive
copying helps,

127
00:05:25,186 --> 00:05:26,546 A:middle
but it's never good enough.

128
00:05:26,846 --> 00:05:28,226 A:middle
You still have a ton of bugs.

129
00:05:29,036 --> 00:05:32,086 A:middle
So we have problems with
those reference semantics

130
00:05:32,136 --> 00:05:33,106 A:middle
and there's mutation.

131
00:05:34,356 --> 00:05:36,716 A:middle
Maybe the problem here is
not the reference semantics

132
00:05:36,936 --> 00:05:38,166 A:middle
but the mutation itself.

133
00:05:38,496 --> 00:05:40,066 A:middle
Perhaps we should
move to a world

134
00:05:40,066 --> 00:05:43,306 A:middle
of immutable data structures
with reference semantics.

135
00:05:44,006 --> 00:05:45,126 A:middle
If you go talk to someone

136
00:05:45,126 --> 00:05:48,546 A:middle
in the functional programming
community, they will say, yeah,

137
00:05:48,736 --> 00:05:50,246 A:middle
we have been doing
this for decades!

138
00:05:51,066 --> 00:05:52,926 A:middle
And it does improve
things there.

139
00:05:53,316 --> 00:05:56,386 A:middle
So you can't have unintended
side effects in a world

140
00:05:56,386 --> 00:05:58,826 A:middle
where there are no side effects,

141
00:05:58,896 --> 00:06:01,646 A:middle
and so immutable reference
semantics are a consistent way

142

143
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

144
00:05:58,896 --> 00:06:01,646 A:middle
and so immutable reference
semantics are a consistent way

145
00:06:01,826 --> 00:06:02,766 A:middle
to work in the system.

146
00:06:02,916 --> 00:06:06,666 A:middle
It doesn't have these unintended
consequences, which we ran

147
00:06:06,666 --> 00:06:08,306 A:middle
into in our little
temperature example.

148
00:06:09,296 --> 00:06:13,296 A:middle
The problem is that immutability
has some disadvantages.

149
00:06:13,756 --> 00:06:15,856 A:middle
It can lead to some
awkward interfaces,

150
00:06:16,306 --> 00:06:19,166 A:middle
and part of this is just
the way the languages work,

151
00:06:19,616 --> 00:06:22,506 A:middle
and part of this is that we're
used to living in a world

152
00:06:22,506 --> 00:06:25,376 A:middle
where we can mutate things,
and we think about state

153
00:06:25,376 --> 00:06:27,646 A:middle
and mutating state,
and so thinking

154
00:06:27,646 --> 00:06:29,996 A:middle
in purely a immutable world
can be a little bit weird

155
00:06:29,996 --> 00:06:30,936 A:middle
for us at times.

156
00:06:31,826 --> 00:06:33,776 A:middle
There's also the question
of an efficient mapping

157
00:06:33,776 --> 00:06:35,016 A:middle
down to the machine model.

158
00:06:35,816 --> 00:06:37,766 A:middle
Eventually, you have to
get down to machine code,

159
00:06:37,766 --> 00:06:40,516 A:middle
and you are running on a CPU
that has stateful registers,

160
00:06:40,516 --> 00:06:41,446 A:middle
and stateful caches,

161
00:06:41,446 --> 00:06:43,326 A:middle
and stateful memory,
and stateful storage.

162
00:06:44,356 --> 00:06:48,416 A:middle
It's not always easy to map
an immutable algorithm down to

163
00:06:48,416 --> 00:06:49,796 A:middle
that level efficiently.

164
00:06:50,486 --> 00:06:51,656 A:middle
Let's talk through
a couple of these.

165
00:06:52,166 --> 00:06:54,756 A:middle
We will take this temperature
class of ours and try

166
00:06:54,756 --> 00:06:56,586 A:middle
to make it safer by
making it immutable.

167
00:06:57,386 --> 00:07:00,436 A:middle
So, all we had to do here was
change the stored property

168

169
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

170
00:06:57,386 --> 00:07:00,436 A:middle
So, all we had to do here was
change the stored property

171
00:07:00,436 --> 00:07:03,286 A:middle
Celsius from a var to a let,
and now you can't change it.

172
00:07:03,916 --> 00:07:07,006 A:middle
And then the Fahrenheit computer
property loses its setter.

173
00:07:07,156 --> 00:07:08,296 A:middle
So you can't change the state

174
00:07:08,296 --> 00:07:09,646 A:middle
of temperature no
matter what you do.

175
00:07:09,966 --> 00:07:11,846 A:middle
We add some initializers
for convenience.

176
00:07:12,146 --> 00:07:15,706 A:middle
Okay. Let's talk
about awkwarding.

177
00:07:16,646 --> 00:07:18,066 A:middle
Awkward immutable interfaces.

178
00:07:18,466 --> 00:07:22,586 A:middle
Before, if I wanted to, say,
tweak the temperature of my oven

179
00:07:22,586 --> 00:07:25,356 A:middle
by 10 degrees Fahrenheit,
this was a simple operation.

180
00:07:26,306 --> 00:07:27,006 A:middle
Plus equals 10.

181
00:07:27,186 --> 00:07:27,856 A:middle
That does it.

182
00:07:27,856 --> 00:07:28,216 A:middle
That's it.

183
00:07:29,416 --> 00:07:31,876 A:middle
How would we do this if we
have taken away mutation?

184
00:07:32,206 --> 00:07:35,016 A:middle
Well, we have to go and grab the
temperature object in the oven,

185
00:07:35,656 --> 00:07:39,206 A:middle
create yet another temperature
object that has the new value.

186
00:07:39,206 --> 00:07:40,856 A:middle
All right?

187
00:07:41,106 --> 00:07:42,296 A:middle
So it's a little
bit more awkward.

188
00:07:42,296 --> 00:07:46,686 A:middle
There's more code, and we wasted
time allocating another object

189
00:07:46,686 --> 00:07:47,106 A:middle
on the heap.

190
00:07:47,946 --> 00:07:50,476 A:middle
But in truth, we have not
embraced immutability here

191
00:07:50,796 --> 00:07:54,336 A:middle
because we did an assignment
that mutated the oven itself.

192
00:07:55,196 --> 00:07:57,096 A:middle
If we were embracing the notion

193
00:07:57,096 --> 00:07:59,576 A:middle
of immutable reference
types throughout here,

194

195
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

196
00:08:00,116 --> 00:08:02,366 A:middle
we would be creating a new
temperature to put in a new oven

197
00:08:02,366 --> 00:08:03,536 A:middle
to put in a new home [laughter].

198
00:08:05,716 --> 00:08:11,856 A:middle
Awkward! So let's get a
little bit more theoretical

199
00:08:11,856 --> 00:08:12,346 A:middle
and do some math.

200
00:08:13,286 --> 00:08:17,496 A:middle
So the Sieve of Eratosthenes
is an ancient algorithm

201
00:08:17,496 --> 00:08:18,916 A:middle
for computing prime numbers.

202
00:08:19,446 --> 00:08:22,106 A:middle
It uses mutation and
actually lends itself well

203
00:08:22,106 --> 00:08:24,256 A:middle
to drawing things out in
the dirt with a stick.

204
00:08:24,786 --> 00:08:29,246 A:middle
So this is the implementation of
the mutating version in Swift.

205
00:08:29,246 --> 00:08:31,366 A:middle
We are going to walk through it
so you get the idea behind it.

206
00:08:31,966 --> 00:08:33,546 A:middle
First thing you do:
create an array.

207
00:08:34,696 --> 00:08:36,416 A:middle
Notice the var because we are
going to mutate this array.

208
00:08:36,986 --> 00:08:40,716 A:middle
Notice this array is from
two, first prime number,

209
00:08:41,006 --> 00:08:42,676 A:middle
up through whatever
number you want to compute.

210
00:08:42,676 --> 00:08:43,535 A:middle
We will do 20 here.

211
00:08:44,836 --> 00:08:47,806 A:middle
Now, the outer loop,
each time through it,

212
00:08:47,806 --> 00:08:50,146 A:middle
we will pick the next
number in the array.

213
00:08:51,006 --> 00:08:52,536 A:middle
That number is a
prime number, P.

214
00:08:53,786 --> 00:08:56,546 A:middle
What the inner loop is
going to do is walk over all

215
00:08:56,546 --> 00:09:01,666 A:middle
of the multiples of P,
erasing them from the array

216

217
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

218
00:08:56,546 --> 00:09:01,666 A:middle
of the multiples of P,
erasing them from the array

219
00:09:01,956 --> 00:09:02,856 A:middle
by setting them to zero.

220
00:09:04,166 --> 00:09:05,276 A:middle
Because, of course,
if you are a multiple

221
00:09:05,276 --> 00:09:06,446 A:middle
of a prime number,
you are not prime.

222
00:09:07,516 --> 00:09:08,506 A:middle
Back to the outer loop,

223
00:09:08,506 --> 00:09:11,016 A:middle
we go and grab the next
number, it's a prime number.

224
00:09:11,276 --> 00:09:13,766 A:middle
We erase all of its
multiples from the array.

225
00:09:13,766 --> 00:09:15,486 A:middle
So it's a very, very
simple algorithm.

226
00:09:15,546 --> 00:09:16,686 A:middle
Think of the stick in the dirt.

227
00:09:16,686 --> 00:09:18,486 A:middle
You are just scratching
things out.

228
00:09:19,636 --> 00:09:21,136 A:middle
Once we are done
going through all

229
00:09:21,136 --> 00:09:24,236 A:middle
of our iterations,
we go down here.

230
00:09:24,456 --> 00:09:26,786 A:middle
And we do the last simple
operation, which says,

231
00:09:27,106 --> 00:09:28,986 A:middle
everything that we have not
zeroed out in the array,

232
00:09:28,986 --> 00:09:30,226 A:middle
that's part of our result.

233
00:09:30,226 --> 00:09:32,736 A:middle
So we will do that
with a filter.

234
00:09:32,846 --> 00:09:35,786 A:middle
Simple algorithm,
entirely based on mutation.

235
00:09:36,306 --> 00:09:38,956 A:middle
Now that doesn't mean
you can't express it

236
00:09:39,046 --> 00:09:40,356 A:middle
in a world without mutation.

237
00:09:40,646 --> 00:09:42,186 A:middle
You can. Of course.

238
00:09:42,986 --> 00:09:44,776 A:middle
So to do that, we are
going to use Haskell,

239
00:09:44,776 --> 00:09:46,456 A:middle
because it's a pure
functional language [applause].

240
00:09:48,256 --> 00:09:49,806 A:middle
Yes, I knew people
would love it!

241
00:09:50,276 --> 00:09:50,586 A:middle
All right.

242
00:09:51,586 --> 00:09:53,416 A:middle
So this is the Haskell
formulation.

243
00:09:53,416 --> 00:09:55,986 A:middle
It's -- if you read
Haskell, it's beautiful.

244
00:09:56,836 --> 00:09:57,546 A:middle
It's functional.

245
00:09:57,546 --> 00:09:58,516 A:middle
It doesn't mutate at all.

246
00:09:59,186 --> 00:10:01,106 A:middle
Here's a very similar
implementation because it turns

247

248
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

249
00:09:59,186 --> 00:10:01,106 A:middle
Here's a very similar
implementation because it turns

250
00:10:01,106 --> 00:10:03,676 A:middle
out Swift can do functional
also, and if you want

251
00:10:03,676 --> 00:10:05,666 A:middle
to make it lazy, that's
an exercise to the reader

252
00:10:05,666 --> 00:10:06,796 A:middle
but it's not that much harder.

253
00:10:07,556 --> 00:10:09,726 A:middle
And we're going to walk through
how this algorithm works,

254
00:10:09,766 --> 00:10:11,516 A:middle
because It's very, very similar.

255
00:10:12,036 --> 00:10:16,776 A:middle
We start with our array
of numbers from 2 to 20.

256
00:10:17,356 --> 00:10:21,586 A:middle
In the simple basis case,
if there's no numbers, well,

257
00:10:21,586 --> 00:10:22,636 A:middle
there's no prime
numbers in there.

258
00:10:22,636 --> 00:10:24,046 A:middle
So that's the first
If statement.

259
00:10:24,046 --> 00:10:24,636 A:middle
It's trivial.

260
00:10:25,916 --> 00:10:28,676 A:middle
Otherwise, what you do is we
take out the first number,

261
00:10:28,776 --> 00:10:30,206 A:middle
that's always going to be prime.

262
00:10:30,896 --> 00:10:32,786 A:middle
And separate it from
the remaining numbers.

263
00:10:33,196 --> 00:10:34,876 A:middle
Right? Haskell did this
with pattern matching,

264
00:10:34,876 --> 00:10:35,796 A:middle
and we can do slicing here.

265
00:10:36,786 --> 00:10:39,686 A:middle
Then we take that prime number
and we run a filter operation

266
00:10:39,906 --> 00:10:44,186 A:middle
over all of the elements
here in this remaining array.

267
00:10:45,166 --> 00:10:46,516 A:middle
Copying only those things

268
00:10:46,516 --> 00:10:48,566 A:middle
that aren't multiples
of that prime number.

269
00:10:49,936 --> 00:10:51,356 A:middle
Now we recurse and do it again.

270
00:10:52,106 --> 00:10:54,136 A:middle
Split out the three and this
is our new prime number.

271
00:10:54,516 --> 00:10:55,696 A:middle
Go ahead and run the filter.

272
00:10:56,886 --> 00:11:00,496 A:middle
Eliminate all the multiples of
three, and so on and so forth.

273

274
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

275
00:10:56,886 --> 00:11:00,496 A:middle
Eliminate all the multiples of
three, and so on and so forth.

276
00:11:00,986 --> 00:11:02,286 A:middle
What happens here is you end

277
00:11:02,286 --> 00:11:05,986 A:middle
up building along this left-hand
diagonal the actual prime

278
00:11:05,986 --> 00:11:08,666 A:middle
numbers, and as a result they
all get concatenated together.

279
00:11:10,176 --> 00:11:11,456 A:middle
The idea is similar.

280
00:11:11,706 --> 00:11:12,946 A:middle
It's very, very similar.

281
00:11:13,976 --> 00:11:16,246 A:middle
But it's not the same algorithm

282
00:11:16,246 --> 00:11:20,076 A:middle
because it has different
performance characteristics.

283
00:11:21,236 --> 00:11:23,486 A:middle
So this result comes
from a brilliant paper

284
00:11:23,486 --> 00:11:26,486 A:middle
by Melissa O'Neil called "The
Genuine Sieve of Eratosthenes,"

285
00:11:27,156 --> 00:11:28,996 A:middle
where she showed the
Haskell community

286
00:11:28,996 --> 00:11:32,106 A:middle
that their beloved sieve
was not the real sieve

287
00:11:32,596 --> 00:11:35,616 A:middle
because it did not perform
the same as the real sieve.

288
00:11:36,356 --> 00:11:40,386 A:middle
She goes through much more
complicated implementations

289
00:11:40,386 --> 00:11:43,936 A:middle
in Haskell, that can get back to
the performance characteristics.

290
00:11:44,136 --> 00:11:45,126 A:middle
Read the paper and check it out.

291
00:11:45,126 --> 00:11:45,826 A:middle
It's really cool.

292
00:11:46,056 --> 00:11:48,736 A:middle
I want to give you a taste
of why this is the case.

293
00:11:48,736 --> 00:11:50,646 A:middle
Look at either the
Haskell list comprehension

294
00:11:50,946 --> 00:11:52,966 A:middle
or the equivalent
Swift filter below.

295
00:11:53,456 --> 00:11:59,206 A:middle
In this nonmutating version,
this operation will walk

296
00:11:59,206 --> 00:12:01,896 A:middle
over every single
element in the array

297

298
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

299
00:11:59,206 --> 00:12:01,896 A:middle
over every single
element in the array

300
00:12:02,136 --> 00:12:04,566 A:middle
and do a division operation
to see if it should still be

301
00:12:04,566 --> 00:12:06,726 A:middle
in the next step, to see if
it's a multiple of P or not.

302
00:12:07,666 --> 00:12:11,646 A:middle
In the original mutating
algorithm, we only walked

303
00:12:11,646 --> 00:12:14,936 A:middle
over the multiples of the prime
number and those, of course,

304
00:12:14,936 --> 00:12:16,536 A:middle
become increasingly
sparse as you get

305
00:12:16,536 --> 00:12:17,866 A:middle
to bigger and bigger numbers.

306
00:12:18,016 --> 00:12:20,926 A:middle
So you are visiting fewer
elements, and moreover,

307
00:12:20,926 --> 00:12:23,316 A:middle
you only have to do an addition
to the get to the next element.

308
00:12:23,316 --> 00:12:26,216 A:middle
So you are doing less
work per element.

309
00:12:26,726 --> 00:12:27,606 A:middle
That matters.

310
00:12:28,386 --> 00:12:30,596 A:middle
And the nonmutating
version is not as efficient

311
00:12:30,596 --> 00:12:32,986 A:middle
as the mutating version
without a whole ton of work.

312
00:12:33,586 --> 00:12:35,806 A:middle
Let's bring it back to Cocoa.

313
00:12:36,816 --> 00:12:39,786 A:middle
So you see uses of
immutability in the Cocoa,

314
00:12:39,786 --> 00:12:40,946 A:middle
Cocoa Touch frameworks.

315
00:12:41,436 --> 00:12:42,086 A:middle
There's a lot of them.

316
00:12:42,086 --> 00:12:44,436 A:middle
And that's Date, UI
image, NSNumber, and so on.

317
00:12:44,656 --> 00:12:45,886 A:middle
These are immutable types,

318
00:12:46,106 --> 00:12:48,606 A:middle
and having these immutable
types improves safety.

319
00:12:48,836 --> 00:12:50,176 A:middle
It's a good thing
because you don't have

320
00:12:50,176 --> 00:12:51,046 A:middle
to worrying about copying.

321
00:12:51,366 --> 00:12:52,026 A:middle
You don't have to worry

322
00:12:52,026 --> 00:12:54,576 A:middle
about your sharing having
unintended side effects.

323
00:12:55,536 --> 00:12:58,126 A:middle
But you also see the downsides
there when you work with it.

324
00:12:58,186 --> 00:13:00,816 A:middle
I gave myself a little
task in Objective-C.

325

326
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

327
00:12:58,186 --> 00:13:00,816 A:middle
I gave myself a little
task in Objective-C.

328
00:13:01,206 --> 00:13:05,026 A:middle
I want to create an NSURL by
starting with my home directory

329
00:13:05,026 --> 00:13:07,616 A:middle
and adding successive
path components

330
00:13:07,906 --> 00:13:08,956 A:middle
to get to some directory.

331
00:13:09,836 --> 00:13:11,406 A:middle
And I wanted to do it
without the mutation

332
00:13:11,406 --> 00:13:12,646 A:middle
in the reference semantic world.

333
00:13:13,066 --> 00:13:14,776 A:middle
So I created an NSURL.

334
00:13:15,246 --> 00:13:17,846 A:middle
Each time through the
loop, I create a new URL

335
00:13:17,846 --> 00:13:19,566 A:middle
by appending the
next path component.

336
00:13:20,506 --> 00:13:22,006 A:middle
This is not a great
algorithm, really.

337
00:13:22,706 --> 00:13:25,556 A:middle
Every time through, I'm creating
an NSURL, another object,

338
00:13:25,646 --> 00:13:31,676 A:middle
the old one goes away, and then
the NSURL is going to copy all

339
00:13:31,676 --> 00:13:33,906 A:middle
of the string data each
time through the loop.

340
00:13:34,456 --> 00:13:36,736 A:middle
Not very efficient there.

341
00:13:37,086 --> 00:13:38,976 A:middle
Doug, you are holding it wrong.

342
00:13:39,216 --> 00:13:41,246 A:middle
Really you should be
collecting all these components

343
00:13:41,626 --> 00:13:45,346 A:middle
into an NSArray and then use
file URL with path components.

344
00:13:46,636 --> 00:13:49,536 A:middle
Fine. But, remember, we are
embracing immutability here.

345
00:13:50,556 --> 00:13:53,266 A:middle
So when I create my array,
I will create an NSArray

346
00:13:53,646 --> 00:13:55,226 A:middle
with a particular
object, all right,

347
00:13:55,226 --> 00:13:56,106 A:middle
that's the home directory.

348
00:13:56,516 --> 00:13:59,066 A:middle
Each time through, I
create a new array,

349
00:13:59,626 --> 00:14:00,886 A:middle
adding one more object.

350

351
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

352
00:13:59,626 --> 00:14:00,886 A:middle
adding one more object.

353
00:14:01,356 --> 00:14:02,456 A:middle
I'm still quadratic.

354
00:14:03,026 --> 00:14:04,376 A:middle
I'm still copying the elements.

355
00:14:04,376 --> 00:14:05,486 A:middle
I'm not copying the string data.

356
00:14:05,486 --> 00:14:06,396 A:middle
So it's a little better.

357
00:14:06,696 --> 00:14:07,866 A:middle
I'm still copying the elements.

358
00:14:08,206 --> 00:14:11,726 A:middle
This is why we don't
fully embrace immutability

359
00:14:11,726 --> 00:14:13,726 A:middle
in the world of Cocoa
because it doesn't make sense.

360
00:14:13,726 --> 00:14:15,596 A:middle
Instead, you use mutability

361
00:14:16,096 --> 00:14:18,606 A:middle
in more localized places
where it makes sense.

362
00:14:19,096 --> 00:14:22,336 A:middle
Collect all of your components
into an NSMutable array.

363
00:14:22,946 --> 00:14:25,786 A:middle
Then use file URL with
path components to get back

364
00:14:25,786 --> 00:14:28,046 A:middle
to that immutable NSURL.

365
00:14:29,336 --> 00:14:31,806 A:middle
So immutability is a good thing.

366
00:14:31,846 --> 00:14:34,606 A:middle
It makes the reference semantic
world easier to reason about.

367
00:14:35,296 --> 00:14:38,006 A:middle
But you can't go
completely to immutability

368
00:14:38,296 --> 00:14:39,486 A:middle
or you start to go crazy.

369
00:14:39,886 --> 00:14:43,236 A:middle
So that brings us
to value semantics.

370
00:14:44,216 --> 00:14:46,076 A:middle
With value semantics, we
take a different approach.

371
00:14:46,566 --> 00:14:47,446 A:middle
We like mutation.

372
00:14:47,866 --> 00:14:48,626 A:middle
We think it's valuable.

373
00:14:48,626 --> 00:14:51,466 A:middle
We think it's easy to
use when done correctly.

374
00:14:52,146 --> 00:14:55,486 A:middle
The problem, as we see
it, is the sharing.

375
00:14:56,936 --> 00:14:59,906 A:middle
So you already know how value
semantics work and you demand

376
00:14:59,906 --> 00:15:03,976 A:middle
on it all the time, whether you
are in Objective-C or in Swift.

377

378
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

379
00:14:59,906 --> 00:15:03,976 A:middle
on it all the time, whether you
are in Objective-C or in Swift.

380
00:15:04,046 --> 00:15:05,976 A:middle
The idea is simple: if
you have two variables,

381
00:15:06,506 --> 00:15:09,056 A:middle
the values in those variables
are logically distinct.

382
00:15:10,416 --> 00:15:13,916 A:middle
So I have an integer A, I
copy it over to an integer B.

383
00:15:14,156 --> 00:15:16,466 A:middle
Of course they are
equivalent; it's a copy.

384
00:15:16,886 --> 00:15:18,876 A:middle
I go to mutate B.

385
00:15:19,626 --> 00:15:22,686 A:middle
If I told you that would change
A, you would say I'm crazy.

386
00:15:24,126 --> 00:15:24,896 A:middle
These are integers.

387
00:15:25,096 --> 00:15:26,146 A:middle
They have value semantics

388
00:15:26,146 --> 00:15:29,406 A:middle
in every language we
have ever worked with.

389
00:15:29,616 --> 00:15:31,176 A:middle
Go to CGPoint, for example.

390
00:15:32,916 --> 00:15:36,566 A:middle
Copy from A to B,
mutate B, it's not going

391
00:15:36,566 --> 00:15:37,956 A:middle
to have any effect on A.

392
00:15:38,936 --> 00:15:41,106 A:middle
You are used to this.

393
00:15:41,106 --> 00:15:42,606 A:middle
If CGPoint didn't
behave this way,

394
00:15:42,606 --> 00:15:44,386 A:middle
you would be really,
really surprised.

395
00:15:46,496 --> 00:15:50,276 A:middle
The idea of value semantics is
take this thing we already know

396
00:15:50,276 --> 00:15:53,636 A:middle
and understand for the very
fundamental types, like numbers

397
00:15:53,636 --> 00:15:57,126 A:middle
and small structs containing
numbers, and extend it outward

398
00:15:57,976 --> 00:16:00,456 A:middle
to work with much,
much richer types.

399

400
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

401
00:15:57,976 --> 00:16:00,456 A:middle
to work with much,
much richer types.

402
00:16:00,516 --> 00:16:02,836 A:middle
So in Swift, strings
are value types.

403
00:16:03,526 --> 00:16:07,216 A:middle
You create A, copy from B
to A, go ahead and change B

404
00:16:07,216 --> 00:16:09,516 A:middle
in some way, it won't
have any effect on A.

405
00:16:10,756 --> 00:16:11,706 A:middle
Because it's a value type.

406
00:16:11,706 --> 00:16:13,746 A:middle
A and B are different variables.

407
00:16:13,836 --> 00:16:15,306 A:middle
Therefore, they are
logically distinct.

408
00:16:18,026 --> 00:16:22,256 A:middle
Okay? Why shouldn't the arrays
behave exactly the same way?

409
00:16:23,666 --> 00:16:26,206 A:middle
Create A, copy it
over to B, mutate B.

410
00:16:26,206 --> 00:16:27,186 A:middle
It has no effect on A.

411
00:16:27,186 --> 00:16:29,876 A:middle
They are completely
distinct values.

412
00:16:31,976 --> 00:16:33,826 A:middle
Last one, well, dictionaries,
of course.

413
00:16:33,886 --> 00:16:34,846 A:middle
It's just a collection.

414
00:16:35,396 --> 00:16:37,036 A:middle
You put value semantic
things into it,

415
00:16:37,736 --> 00:16:38,886 A:middle
you get value semantics back.

416
00:16:39,586 --> 00:16:43,316 A:middle
The great thing here is that
value types compose beautifully.

417
00:16:43,676 --> 00:16:46,856 A:middle
So you can build up very rich
abstractions all in the world

418
00:16:46,856 --> 00:16:48,416 A:middle
of value semantics easily.

419
00:16:49,106 --> 00:16:52,396 A:middle
So in Swift, all the fundamental
types -- integers, doubles,

420
00:16:52,466 --> 00:16:55,686 A:middle
strings, characters, et cetera
-- they are all value types.

421
00:16:55,686 --> 00:16:57,316 A:middle
They have this fundamental
behavior,

422
00:16:57,316 --> 00:16:59,036 A:middle
the two variables are
logically distinct.

423
00:16:59,806 --> 00:17:02,056 A:middle
All the collections we
build on top of them --

424

425
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

426
00:16:59,806 --> 00:17:02,056 A:middle
All the collections we
build on top of them --

427
00:17:02,056 --> 00:17:03,436 A:middle
array, set, dictionary --

428
00:17:03,926 --> 00:17:06,246 A:middle
are value types when
they're given value types.

429
00:17:06,736 --> 00:17:09,366 A:middle
And the language
abstractions you use

430
00:17:09,366 --> 00:17:12,576 A:middle
to build your own types --
tuples, structs, and enums --

431
00:17:12,886 --> 00:17:15,806 A:middle
when you put value types into
those, you get value types out.

432
00:17:16,156 --> 00:17:20,516 A:middle
Again, it's very, very easy
to build rich abstractions all

433
00:17:20,516 --> 00:17:21,796 A:middle
in the world of value semantics.

434
00:17:22,836 --> 00:17:25,746 A:middle
Now, there's one more
critical piece to a value type,

435
00:17:26,296 --> 00:17:30,076 A:middle
and that is that you have the
notion of when two values,

436
00:17:30,076 --> 00:17:32,506 A:middle
two variables of value
type, are equivalent.

437
00:17:32,626 --> 00:17:33,846 A:middle
They hold the same value.

438
00:17:33,846 --> 00:17:37,916 A:middle
And the important thing is that
identity is not what matters.

439
00:17:38,826 --> 00:17:40,226 A:middle
Because you can have
any number of copies.

440
00:17:40,226 --> 00:17:42,426 A:middle
What matters is the actual
value that's stored there.

441
00:17:42,426 --> 00:17:44,826 A:middle
It doesn't matter how
you got to that value.

442
00:17:45,226 --> 00:17:47,536 A:middle
I will tell you things that
are really, really silly.

443
00:17:48,376 --> 00:17:50,506 A:middle
Here we have A, we set
it to 5, and we have B

444
00:17:50,506 --> 00:17:51,806 A:middle
and we set it to 2 plus 3.

445
00:17:52,646 --> 00:17:54,276 A:middle
Of course A and B
are equivalent.

446
00:17:55,376 --> 00:17:56,376 A:middle
You work with this all the time.

447
00:17:56,376 --> 00:17:58,896 A:middle
You couldn't understand integers
if they didn't work this way.

448
00:17:59,516 --> 00:18:01,726 A:middle
So just extend that notion out.

449

450
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

451
00:17:59,516 --> 00:18:01,726 A:middle
So just extend that notion out.

452
00:18:02,296 --> 00:18:04,196 A:middle
Of course it's the same
thing for CGPoints,

453
00:18:04,196 --> 00:18:05,146 A:middle
you wouldn't be able
to understand them

454
00:18:05,146 --> 00:18:05,956 A:middle
if it wasn't this way.

455
00:18:07,276 --> 00:18:09,696 A:middle
Why shouldn't strings
behave exactly the same way?

456
00:18:09,696 --> 00:18:13,466 A:middle
It doesn't matter how I get
to the string "Hello, WWDC."

457
00:18:14,576 --> 00:18:17,526 A:middle
The string is the value, and
the equality operator needs

458
00:18:17,526 --> 00:18:18,316 A:middle
to represent that.

459
00:18:19,206 --> 00:18:21,736 A:middle
You can make this
arbitrarily crazy and stupid.

460
00:18:21,736 --> 00:18:24,456 A:middle
So here I will go and do
some sorting operation.

461
00:18:25,086 --> 00:18:26,596 A:middle
What it comes down to though
is that I have two arrays

462
00:18:26,596 --> 00:18:28,816 A:middle
of integers, the integers
have the same values.

463
00:18:29,196 --> 00:18:30,596 A:middle
Therefore, these
things are equivalent.

464
00:18:31,566 --> 00:18:35,336 A:middle
When you're building a value
type, it's extremely important

465
00:18:35,946 --> 00:18:37,756 A:middle
that it conform to the
Equatable protocol.

466
00:18:37,756 --> 00:18:41,076 A:middle
Because every value type out
there should be equatable.

467
00:18:41,726 --> 00:18:44,156 A:middle
That means it has the
equal equal operator

468
00:18:44,316 --> 00:18:46,586 A:middle
to do a comparison,
but that operator has

469
00:18:46,586 --> 00:18:48,266 A:middle
to behave in a sensible way.

470
00:18:48,266 --> 00:18:50,946 A:middle
It needs to be reflexive,
symmetric, and transitive.

471
00:18:51,626 --> 00:18:53,016 A:middle
Why are these properties
important?

472
00:18:53,016 --> 00:18:55,716 A:middle
Because you can't understand
your code unless you have them.

473
00:18:56,676 --> 00:19:00,346 A:middle
If I copy from A to B, well,
I expect that A is equal

474

475
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

476
00:18:56,676 --> 00:19:00,346 A:middle
If I copy from A to B, well,
I expect that A is equal

477
00:19:00,346 --> 00:19:01,626 A:middle
to B and B is equal to A.

478
00:19:01,846 --> 00:19:02,346 A:middle
Of course.

479
00:19:02,346 --> 00:19:03,056 A:middle
Why wouldn't it be?

480
00:19:03,516 --> 00:19:06,186 A:middle
If I then copy B over to
C, well then C and B and A,

481
00:19:06,186 --> 00:19:06,916 A:middle
they're all equivalent.

482
00:19:06,916 --> 00:19:08,926 A:middle
It doesn't matter which I
have because the only thing

483
00:19:08,926 --> 00:19:11,206 A:middle
that matters there is the
value, not the identity.

484
00:19:12,416 --> 00:19:15,396 A:middle
Fortunately, it's very, very
easy to implement these things.

485
00:19:15,816 --> 00:19:20,066 A:middle
I can just say, take CGPoints
and extend it with Equatable

486
00:19:20,066 --> 00:19:21,516 A:middle
and implement the
equality operator,

487
00:19:21,706 --> 00:19:24,136 A:middle
and when you compose value
types out of other value types,

488
00:19:24,246 --> 00:19:26,576 A:middle
generally speaking,
you just have

489
00:19:26,666 --> 00:19:29,126 A:middle
to use the underlying
equal, equal operators

490
00:19:29,126 --> 00:19:30,046 A:middle
of all the value types.

491
00:19:30,556 --> 00:19:32,036 A:middle
All right.

492
00:19:32,256 --> 00:19:34,536 A:middle
Let's bring this back
to our temperature type.

493
00:19:34,766 --> 00:19:36,396 A:middle
We will make it a struct now.

494
00:19:36,396 --> 00:19:38,176 A:middle
We are going to switch
Celsius back

495
00:19:38,176 --> 00:19:40,406 A:middle
to a var to we can mutate it.

496
00:19:41,166 --> 00:19:42,556 A:middle
This now has value semantics.

497
00:19:42,556 --> 00:19:44,286 A:middle
We give it the obvious
equality operator.

498
00:19:44,856 --> 00:19:46,936 A:middle
We go ahead and use this
in our example before.

499
00:19:47,256 --> 00:19:47,706 A:middle
That's fine.

500
00:19:47,706 --> 00:19:49,896 A:middle
We create the home, create the
temperature, set the temperature

501
00:19:49,896 --> 00:19:52,406 A:middle
to 75 degrees Fahrenheit
and whoa!

502
00:19:52,756 --> 00:19:53,876 A:middle
Compiler stops us here.

503
00:19:54,146 --> 00:19:54,826 A:middle
What went on?

504
00:19:55,716 --> 00:19:59,236 A:middle
Well, we are trying to
mutate a property of temp,

505
00:19:59,476 --> 00:20:00,556 A:middle
which is describes as a let.

506

507
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

508
00:19:59,476 --> 00:20:00,556 A:middle
which is describes as a let.

509
00:20:00,556 --> 00:20:01,726 A:middle
It's a constant.

510
00:20:01,786 --> 00:20:02,386 A:middle
It can't change.

511
00:20:03,076 --> 00:20:04,236 A:middle
We will appease the compiler.

512
00:20:04,606 --> 00:20:06,116 A:middle
Change it to var, and
now we can mutate it.

513
00:20:06,626 --> 00:20:08,326 A:middle
And this all works
perfectly fine.

514
00:20:09,606 --> 00:20:10,396 A:middle
Why is it fine?

515
00:20:10,396 --> 00:20:12,776 A:middle
Well, the house points out to
the thermostat in the oven.

516
00:20:12,776 --> 00:20:16,076 A:middle
The thermostat and the oven
both have their own instances

517
00:20:16,076 --> 00:20:17,336 A:middle
of temperature values.

518
00:20:17,336 --> 00:20:19,406 A:middle
They are completely distinct,
they're never shared.

519
00:20:20,086 --> 00:20:21,676 A:middle
They also happen to be
inlined into the struct,

520
00:20:21,676 --> 00:20:23,656 A:middle
and you are getting better
memory usage and performance.

521
00:20:24,856 --> 00:20:25,656 A:middle
This is great.

522
00:20:25,656 --> 00:20:27,966 A:middle
Value semantics have made
our lives easier here.

523
00:20:28,646 --> 00:20:31,346 A:middle
With our example,
let's go all the way

524
00:20:31,436 --> 00:20:33,456 A:middle
and make everything
value semantics.

525
00:20:34,976 --> 00:20:37,366 A:middle
Now, house is a struct that
has a thermostat struct

526
00:20:37,366 --> 00:20:39,906 A:middle
and an oven struct, and the
whole world is value semantics.

527
00:20:40,146 --> 00:20:40,956 A:middle
The changes we need to make

528
00:20:40,956 --> 00:20:45,256 A:middle
to our code is now home can be
mutated because we can go ahead

529
00:20:45,556 --> 00:20:48,086 A:middle
and change the temperature on
the thermostat of the home,

530
00:20:48,496 --> 00:20:49,846 A:middle
right, and that's
a mutation to home

531
00:20:49,846 --> 00:20:51,446 A:middle
and thermostat and
to temperature.

532
00:20:51,936 --> 00:20:57,126 A:middle
Okay. This brings us to
a really important point.

533
00:20:57,586 --> 00:21:00,836 A:middle
Value semantics works
beautifully in Swift

534

535
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

536
00:20:57,586 --> 00:21:00,836 A:middle
Value semantics works
beautifully in Swift

537
00:21:01,226 --> 00:21:04,356 A:middle
because of the way Swift's
immutability model works.

538
00:21:05,006 --> 00:21:08,276 A:middle
When you have a let in
Swift, it's of a value type.

539
00:21:08,746 --> 00:21:12,526 A:middle
It means this value
will never change short

540
00:21:12,526 --> 00:21:14,576 A:middle
of something corrupting
your process' memory.

541
00:21:15,086 --> 00:21:18,446 A:middle
This is a really
strong statement.

542
00:21:19,196 --> 00:21:20,546 A:middle
It means it's very
easy to reason

543
00:21:20,546 --> 00:21:21,566 A:middle
about things that are let.

544
00:21:22,356 --> 00:21:24,216 A:middle
But we still allow mutation.

545
00:21:24,396 --> 00:21:27,386 A:middle
You can use var to say this
variable can be changed.

546
00:21:27,896 --> 00:21:30,016 A:middle
And that's extremely
useful for our algorithms.

547
00:21:31,316 --> 00:21:33,286 A:middle
Note that this change
is very local.

548
00:21:33,466 --> 00:21:36,006 A:middle
I can change this
variable, but it's not going

549
00:21:36,006 --> 00:21:38,426 A:middle
to affect anything else
anywhere in my program

550
00:21:38,646 --> 00:21:41,236 A:middle
until I tell it to, until I
do a mutation somewhere else,

551
00:21:41,806 --> 00:21:44,896 A:middle
which gives you this really
nice controlled mutability.

552
00:21:45,446 --> 00:21:47,776 A:middle
With strong guarantees
elsewhere.

553
00:21:49,016 --> 00:21:51,696 A:middle
One of the nice things here is
when you are using value types

554
00:21:51,696 --> 00:21:54,476 A:middle
of passing them across thread
boundaries, it gives you freedom

555
00:21:54,476 --> 00:21:56,696 A:middle
from race conditions
on those types.

556
00:21:57,166 --> 00:21:58,086 A:middle
So I create numbers.

557
00:21:58,086 --> 00:21:59,816 A:middle
I passed them off
to some process

558
00:21:59,816 --> 00:22:01,586 A:middle
that will do something
asynchronously.

559

560
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

561
00:21:59,816 --> 00:22:01,586 A:middle
that will do something
asynchronously.

562
00:22:02,156 --> 00:22:04,156 A:middle
I mutate numbers locally
and then do it again.

563
00:22:04,596 --> 00:22:08,646 A:middle
With a reference semantic
array, this is a race condition.

564
00:22:08,646 --> 00:22:10,356 A:middle
It's going to blow
up on you sometime.

565
00:22:10,636 --> 00:22:13,226 A:middle
With value semantics, you
are getting copies each time,

566
00:22:13,786 --> 00:22:14,916 A:middle
logical copies each time.

567
00:22:16,086 --> 00:22:17,746 A:middle
And therefore, there
is no race condition.

568
00:22:18,366 --> 00:22:19,576 A:middle
They are not hitting
the same array.

569
00:22:19,576 --> 00:22:21,616 A:middle
All right.

570
00:22:21,616 --> 00:22:23,926 A:middle
Hold on. This sounds like a
performance problem, right?

571
00:22:24,256 --> 00:22:26,816 A:middle
We are doing a copy every
time we pass numbers

572
00:22:26,816 --> 00:22:27,606 A:middle
through a parameter.

573
00:22:28,846 --> 00:22:32,916 A:middle
Okay. One of the important other
pieces of value semantics is

574
00:22:32,916 --> 00:22:34,396 A:middle
that it copies are cheap.

575
00:22:34,876 --> 00:22:37,456 A:middle
By cheap, I mean
constant time cheap.

576
00:22:37,886 --> 00:22:40,886 A:middle
Let's build this up
from fundamentals.

577
00:22:40,886 --> 00:22:42,556 A:middle
So when you have the
fundamental types,

578
00:22:42,556 --> 00:22:45,106 A:middle
the really low-level things
-- integers, doubles, floats,

579
00:22:45,106 --> 00:22:48,176 A:middle
et cetera -- copying
these is cheap.

580
00:22:48,236 --> 00:22:49,656 A:middle
You are copying a
couple of bytes.

581
00:22:49,836 --> 00:22:51,646 A:middle
Usually it happens
in the processor.

582
00:22:52,986 --> 00:22:55,126 A:middle
So then you start
building structs

583
00:22:55,126 --> 00:22:57,206 A:middle
out of doubles and
ints and so on.

584
00:22:57,236 --> 00:22:59,676 A:middle
Like CG points is
built of two CG floats.

585

586
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

587
00:23:00,166 --> 00:23:02,526 A:middle
And any of these
structs, enums or tuples,

588
00:23:02,526 --> 00:23:06,246 A:middle
they have a fixed number
of fields, and copying each

589
00:23:06,246 --> 00:23:08,096 A:middle
of the things in there
is constant time.

590
00:23:08,096 --> 00:23:10,336 A:middle
So copying the whole
thing is constant time.

591
00:23:10,896 --> 00:23:12,396 A:middle
All right.

592
00:23:13,376 --> 00:23:14,776 A:middle
That's great for
fixed-length things.

593
00:23:14,776 --> 00:23:17,396 A:middle
What about extensible
things, strings, arrays,

594
00:23:17,396 --> 00:23:18,546 A:middle
dictionaries, and so on?

595
00:23:19,086 --> 00:23:21,816 A:middle
The way we handle these in the
Swift world is by copy-on-write.

596
00:23:22,836 --> 00:23:24,466 A:middle
So this makes the copy cheap.

597
00:23:24,676 --> 00:23:27,226 A:middle
It's just some fixed number of
reference-counting operations

598
00:23:27,226 --> 00:23:29,596 A:middle
to do a copy of a
copy-on-write value.

599
00:23:29,596 --> 00:23:32,746 A:middle
And then at the point where you
do a mutation, you have a var

600
00:23:32,746 --> 00:23:35,196 A:middle
and then you change
it, then we make a copy

601
00:23:35,196 --> 00:23:36,066 A:middle
and work on the copy.

602
00:23:36,836 --> 00:23:39,306 A:middle
So you have sharing
behind the scenes,

603
00:23:40,666 --> 00:23:42,646 A:middle
but it's not logical sharing

604
00:23:42,646 --> 00:23:45,006 A:middle
but logically these are
still distinct values.

605
00:23:45,226 --> 00:23:47,146 A:middle
This gives you great
performance characteristics

606
00:23:47,416 --> 00:23:50,676 A:middle
from value semantics and is
really a nice programming model.

607
00:23:51,576 --> 00:23:53,606 A:middle
So we really love the value
semantic programming model.

608
00:23:54,266 --> 00:23:57,166 A:middle
Different variables are
logically distinct, always.

609
00:23:58,506 --> 00:24:01,566 A:middle
You have the notion of
mutation, an efficient mutation,

610

611
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

612
00:23:58,506 --> 00:24:01,566 A:middle
You have the notion of
mutation, an efficient mutation,

613
00:24:01,826 --> 00:24:04,036 A:middle
when you want it
locally controlled.

614
00:24:05,416 --> 00:24:07,216 A:middle
But you have these
strong guarantees of let,

615
00:24:07,216 --> 00:24:08,726 A:middle
meaning it will not
change elsewhere.

616
00:24:09,736 --> 00:24:11,936 A:middle
And copies are cheap, which
makes us all work together.

617
00:24:13,256 --> 00:24:13,596 A:middle
All right.

618
00:24:13,626 --> 00:24:15,716 A:middle
With that, I would like to
hand it over to my colleague,

619
00:24:15,716 --> 00:24:18,476 A:middle
Bill Dudney, who will talk
about value types and practice.

620
00:24:19,516 --> 00:24:25,996 A:middle
[ Applause ]

621
00:24:26,496 --> 00:24:27,006 A:middle
>> BILL DUDNEY: Thanks, Doug.

622
00:24:27,876 --> 00:24:28,536 A:middle
Hi, everybody.

623
00:24:28,536 --> 00:24:31,726 A:middle
So now that Doug has filled our
minds with how value types work,

624
00:24:32,056 --> 00:24:34,536 A:middle
how they compare with
reference semantics,

625
00:24:34,636 --> 00:24:38,596 A:middle
let's talk about building a real
example that uses value types.

626
00:24:38,596 --> 00:24:42,636 A:middle
So what we are going to do
is put together an example

627
00:24:42,636 --> 00:24:44,936 A:middle
where we build a
simple diagram made

628
00:24:44,936 --> 00:24:48,306 A:middle
of a couple odifferent value
types, a circle and a polygon.

629
00:24:49,386 --> 00:24:51,406 A:middle
So we will get started
with the circle.

630
00:24:51,916 --> 00:24:54,236 A:middle
It's a center, and a radius.

631
00:24:54,306 --> 00:24:56,056 A:middle
A couple of value types
that come straight

632
00:24:56,056 --> 00:24:57,246 A:middle
out of the standard library.

633
00:24:57,856 --> 00:25:00,766 A:middle
Of course, we want to
implement the equality operator,

634

635
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

636
00:24:57,856 --> 00:25:00,766 A:middle
Of course, we want to
implement the equality operator,

637
00:25:00,766 --> 00:25:02,086 A:middle
the equals equals operator,

638
00:25:02,086 --> 00:25:04,496 A:middle
and we do that by just
comparing those types.

639
00:25:04,496 --> 00:25:06,756 A:middle
Again, since they are built
into the standard library,

640
00:25:07,056 --> 00:25:09,746 A:middle
all we have to do is use
those since we are composing

641
00:25:09,746 --> 00:25:11,806 A:middle
from the simple types that
came out of the library.

642
00:25:12,326 --> 00:25:14,676 A:middle
Next up is the polygon.

643
00:25:15,066 --> 00:25:16,906 A:middle
It has an array of corners,

644
00:25:17,116 --> 00:25:19,836 A:middle
and each of the corners is
just another CG point, which,

645
00:25:19,836 --> 00:25:20,916 A:middle
again, is a value type.

646
00:25:21,326 --> 00:25:23,986 A:middle
So our array is a
value type, and, again,

647
00:25:23,986 --> 00:25:25,606 A:middle
our comparison is
straightforward,

648
00:25:25,726 --> 00:25:27,676 A:middle
just using the equals,
equals operator there

649
00:25:27,676 --> 00:25:29,896 A:middle
to make sure we implement
the Equatable operator.

650
00:25:29,896 --> 00:25:36,296 A:middle
Now what we want to do is put
these types into our diagram,

651
00:25:36,656 --> 00:25:39,116 A:middle
put both polygons and circles.

652
00:25:40,376 --> 00:25:42,526 A:middle
Making an array of
circles is straightforward.

653
00:25:43,506 --> 00:25:46,876 A:middle
Making an array of
polygons is straightforward.

654
00:25:46,876 --> 00:25:49,536 A:middle
So we can make an
array of either type.

655
00:25:49,536 --> 00:25:53,376 A:middle
What we need to do is make
one array that contains both.

656
00:25:54,006 --> 00:25:59,476 A:middle
The mechanism to do that in
Swift is with a protocol.

657
00:25:59,476 --> 00:26:02,176 A:middle
So we will create a
protocol called Drawable.

658

659
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

660
00:25:59,476 --> 00:26:02,176 A:middle
So we will create a
protocol called Drawable.

661
00:26:02,176 --> 00:26:05,416 A:middle
We will make both of
our subtypes implement

662
00:26:05,416 --> 00:26:07,516 A:middle
that protocol, and
then we can put them

663
00:26:07,516 --> 00:26:09,286 A:middle
into an array in our diagram.

664
00:26:10,816 --> 00:26:12,046 A:middle
Tons of great information

665
00:26:12,046 --> 00:26:14,916 A:middle
in this Protocol-Oriented
Programming in Swift talk,

666
00:26:14,916 --> 00:26:17,726 A:middle
which is repeating
again today at 3:30.

667
00:26:18,066 --> 00:26:19,096 A:middle
So if you haven't seen that,

668
00:26:19,096 --> 00:26:21,396 A:middle
I would highly suggest
you take a look

669
00:26:21,396 --> 00:26:23,166 A:middle
at it or catch it on video.

670
00:26:24,086 --> 00:26:27,526 A:middle
So here's our Drawable protocol.

671
00:26:27,816 --> 00:26:31,686 A:middle
Straightforward and simple,
has one method, Draw, on it.

672
00:26:32,276 --> 00:26:34,596 A:middle
And, of course, we want to
implement that on our two types.

673
00:26:34,596 --> 00:26:36,466 A:middle
We will create an
extension of polygon,

674
00:26:36,826 --> 00:26:39,176 A:middle
implement that draw method,
and that's just going to call

675
00:26:39,176 --> 00:26:41,216 A:middle
out to Core Graphics
and draw the polygon.

676
00:26:41,876 --> 00:26:44,496 A:middle
And the same thing
for the circle.

677
00:26:44,496 --> 00:26:47,276 A:middle
So what we are going to do,
just call Core Graphics to build

678
00:26:47,276 --> 00:26:49,316 A:middle
up the representation
of the circle.

679
00:26:49,316 --> 00:26:55,626 A:middle
Now back to out diagram.

680
00:26:55,626 --> 00:26:58,056 A:middle
It's got this array of
drawables called Items.

681
00:26:58,886 --> 00:27:00,756 A:middle
We need to create a
method to add items.

682

683
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

684
00:26:58,886 --> 00:27:00,756 A:middle
We need to create a
method to add items.

685
00:27:00,926 --> 00:27:03,436 A:middle
That's marked as mutating
because that mutates self.

686
00:27:03,436 --> 00:27:08,096 A:middle
We are going to implement the
Draw method to simply iterate

687
00:27:08,096 --> 00:27:10,296 A:middle
through that list of items
and call the Draw method

688
00:27:10,296 --> 00:27:11,856 A:middle
on each item that's in the list.

689
00:27:13,176 --> 00:27:15,056 A:middle
So let's take a look
at it diagrammatically.

690
00:27:15,836 --> 00:27:18,806 A:middle
So we create a diagram,
called doc.

691
00:27:19,766 --> 00:27:21,876 A:middle
We create a polygon and
add that to the array.

692
00:27:23,426 --> 00:27:26,676 A:middle
We create another one, a circle,
and we add that to the array.

693
00:27:26,676 --> 00:27:28,696 A:middle
Now our array has
two drawables in it.

694
00:27:29,466 --> 00:27:30,806 A:middle
Notice they are different types.

695
00:27:31,386 --> 00:27:37,566 A:middle
When we create another document,
by saying doc2 equals doc,

696
00:27:37,716 --> 00:27:40,466 A:middle
we get a logically
distinct, brand-new instance.

697
00:27:40,466 --> 00:27:43,286 A:middle
It's logically separate
from that first instance.

698
00:27:45,076 --> 00:27:50,136 A:middle
I can go back and make changes
to doc2 now, and when I do that,

699
00:27:50,136 --> 00:27:52,326 A:middle
of course, it has
no effect on doc.

700
00:27:52,786 --> 00:27:54,696 A:middle
I change that circle
to a polygon.

701
00:27:55,756 --> 00:28:00,186 A:middle
The array has value semantics
even though the collection

702

703
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

704
00:27:55,756 --> 00:28:00,186 A:middle
The array has value semantics
even though the collection

705
00:28:00,186 --> 00:28:01,186 A:middle
is heterogeneous.

706
00:28:01,256 --> 00:28:05,976 A:middle
So it has the polygon inside,
and the circle is inside

707
00:28:05,976 --> 00:28:07,166 A:middle
that array as a value.

708
00:28:07,826 --> 00:28:15,516 A:middle
So, of course, we want to make
our diagram struct Equatable.

709
00:28:15,936 --> 00:28:17,506 A:middle
So we implement the protocol.

710
00:28:17,506 --> 00:28:19,486 A:middle
And this would be the
straightforward implementation

711
00:28:19,486 --> 00:28:20,486 A:middle
that we would look at doing.

712
00:28:21,176 --> 00:28:23,396 A:middle
However, if we would do that,
the compiler says, "Hey,

713
00:28:23,396 --> 00:28:26,846 A:middle
wait a minute, I don't have
an equals equals operator

714
00:28:27,066 --> 00:28:29,836 A:middle
for these two values on
either side of that equation."

715
00:28:30,166 --> 00:28:31,186 A:middle
Again, I will refer you

716
00:28:31,186 --> 00:28:33,056 A:middle
to the Protocol-Oriented
Programming talk,

717
00:28:33,056 --> 00:28:36,366 A:middle
where we talked through all the
details of how all that works.

718
00:28:36,526 --> 00:28:39,436 A:middle
In this talk, we will focus
on the value semantics.

719
00:28:39,966 --> 00:28:45,536 A:middle
So drawable has a single
method called Draw,

720
00:28:45,536 --> 00:28:48,286 A:middle
our diagram has a
method called Draw.

721
00:28:48,506 --> 00:28:51,586 A:middle
So let's go ahead and turn
our diagram into a drawable.

722
00:28:51,586 --> 00:28:54,516 A:middle
All we have to do is add
that declaration to it.

723
00:28:54,656 --> 00:28:59,046 A:middle
Now our diagram quacks
like a duck and is a duck.

724
00:28:59,736 --> 00:29:02,816 A:middle
So this brings us to
an interesting point.

725

726
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

727
00:28:59,736 --> 00:29:02,816 A:middle
So this brings us to
an interesting point.

728
00:29:02,816 --> 00:29:08,866 A:middle
I can create a new diagram and
add it to my existing diagram.

729
00:29:09,946 --> 00:29:12,246 A:middle
It's got three different
types in there,

730
00:29:12,246 --> 00:29:15,166 A:middle
but they are all
contained inside that array.

731
00:29:16,016 --> 00:29:17,786 A:middle
It's a new instance of Diagram.

732
00:29:19,106 --> 00:29:21,246 A:middle
But I can push it
one further and add

733
00:29:21,246 --> 00:29:23,256 A:middle
that document to the array.

734
00:29:23,646 --> 00:29:25,536 A:middle
Now if this were
reference semantics --

735
00:29:26,416 --> 00:29:27,386 A:middle
let's look at the Draw method.

736
00:29:27,386 --> 00:29:28,996 A:middle
If this were reference
semantics,

737
00:29:29,386 --> 00:29:30,746 A:middle
this would infinite recurse.

738
00:29:31,326 --> 00:29:35,866 A:middle
As I call Draw on my diagram,
it will go through the list

739
00:29:35,866 --> 00:29:37,986 A:middle
of items and find
itself in that list.

740
00:29:37,986 --> 00:29:40,476 A:middle
And so it's going to call Draw
again and infinitely recurse.

741
00:29:41,146 --> 00:29:43,476 A:middle
But, we are using values.

742
00:29:43,776 --> 00:29:48,416 A:middle
So instead of the doc
being added to my diagram,

743
00:29:48,476 --> 00:29:49,866 A:middle
it's completely a separate

744
00:29:49,866 --> 00:29:53,156 A:middle
and distinct instance
because it's a value.

745
00:29:54,336 --> 00:29:55,986 A:middle
So there's no infinite
recursion.

746
00:29:56,246 --> 00:29:59,206 A:middle
I just get two polygons
and two circles drawn.

747
00:29:59,206 --> 00:30:05,146 A:middle
Now that we have talked
about building a tree

748

749
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

750
00:29:59,206 --> 00:30:05,146 A:middle
Now that we have talked
about building a tree

751
00:30:05,146 --> 00:30:06,976 A:middle
of objects purely
out of value types,

752
00:30:07,026 --> 00:30:10,186 A:middle
let's talk about how we mix
value types and reference types.

753
00:30:10,886 --> 00:30:12,256 A:middle
Now in Objective-C, you are used

754
00:30:12,256 --> 00:30:15,906 A:middle
to putting primitive data types
inside your reference types all

755
00:30:15,906 --> 00:30:16,286 A:middle
the time.

756
00:30:16,286 --> 00:30:18,186 A:middle
This is how we build
things in Objective-C.

757
00:30:19,286 --> 00:30:22,496 A:middle
But the flip side introduces
some interesting questions

758
00:30:22,496 --> 00:30:23,606 A:middle
that we have to think through.

759
00:30:25,226 --> 00:30:28,006 A:middle
If we are building a value
type, we want to make sure

760
00:30:28,006 --> 00:30:31,306 A:middle
that that value type
maintains its value semantics,

761
00:30:31,436 --> 00:30:33,926 A:middle
even though it has a
reference inside of it.

762
00:30:34,356 --> 00:30:35,826 A:middle
So if we are going to do that,

763
00:30:35,826 --> 00:30:37,386 A:middle
we have to think
about that question.

764
00:30:37,386 --> 00:30:39,376 A:middle
How do we deal with this fact

765
00:30:39,426 --> 00:30:44,026 A:middle
that two different values might
be pointing to the same thing

766
00:30:44,026 --> 00:30:45,126 A:middle
because it has a
reference in it?

767
00:30:45,126 --> 00:30:46,866 A:middle
So we have to solve
that question.

768
00:30:47,416 --> 00:30:48,426 A:middle
The other thing we have to think

769
00:30:48,426 --> 00:30:51,796 A:middle
through is how is
equality affected by that.

770
00:30:52,026 --> 00:30:53,786 A:middle
So let's start with
a simple example

771
00:30:53,786 --> 00:30:56,856 A:middle
with an immutable
class, UIImage.

772
00:30:57,456 --> 00:31:01,236 A:middle
We will create an image struct
that is going to be a drawable,

773

774
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

775
00:30:57,456 --> 00:31:01,236 A:middle
We will create an image struct
that is going to be a drawable,

776
00:31:01,386 --> 00:31:03,326 A:middle
and it has a reference
to a UIImage.

777
00:31:03,856 --> 00:31:06,286 A:middle
So we create the instance

778
00:31:06,286 --> 00:31:08,666 A:middle
with this beautiful
photograph of San Francisco.

779
00:31:09,726 --> 00:31:13,596 A:middle
And if we create another
one, image 2, so now image

780
00:31:13,596 --> 00:31:16,696 A:middle
and image 2 are both
pointing to the same object.

781
00:31:17,206 --> 00:31:18,836 A:middle
And you look at this and
you think, Bill is going

782
00:31:18,836 --> 00:31:20,816 A:middle
to trick us, and this is going
to be a problem, and it will be

783
00:31:20,816 --> 00:31:21,936 A:middle
like the temperature thing.

784
00:31:22,436 --> 00:31:25,386 A:middle
But it's not because
UIImage is immutable.

785
00:31:25,716 --> 00:31:29,816 A:middle
So we don't have to worry about
image 2 mutating the image

786
00:31:29,816 --> 00:31:30,766 A:middle
that sits underneath it

787
00:31:30,806 --> 00:31:33,646 A:middle
and having the first
image be caught off guard

788
00:31:33,646 --> 00:31:34,486 A:middle
with that change.

789
00:31:35,736 --> 00:31:38,726 A:middle
Of course we want to make
sure we implement the equality

790
00:31:39,586 --> 00:31:41,796 A:middle
and at first blush, you might
look at this and think, okay,

791
00:31:41,796 --> 00:31:43,496 A:middle
I will use the triple
equals operator,

792
00:31:43,496 --> 00:31:46,366 A:middle
which will compare
the reference and see

793
00:31:46,366 --> 00:31:47,796 A:middle
if those references
are the same.

794
00:31:48,356 --> 00:31:51,846 A:middle
Well this would work okay in
this example, but we also have

795
00:31:51,846 --> 00:31:52,986 A:middle
to think through what happens

796
00:31:52,986 --> 00:31:57,766 A:middle
if we create two UI images using
the same underlying bitmap.

797
00:31:58,526 --> 00:32:02,596 A:middle
We want those also to equate to
being equal, and in this case,

798

799
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

800
00:31:58,526 --> 00:32:02,596 A:middle
We want those also to equate to
being equal, and in this case,

801
00:32:02,596 --> 00:32:05,036 A:middle
since we are comparing the
reference, they would not.

802
00:32:05,036 --> 00:32:06,606 A:middle
So this would be falsely saying

803
00:32:06,606 --> 00:32:08,746 A:middle
that these two images
are not the same.

804
00:32:09,236 --> 00:32:12,386 A:middle
So instead what we want to
do is use the Is Equal method

805
00:32:12,896 --> 00:32:16,116 A:middle
that we inherit from NSObject
on UIImage to do the comparison,

806
00:32:16,416 --> 00:32:19,056 A:middle
so we'll be sure that the
reference type gets the right

807
00:32:19,546 --> 00:32:25,206 A:middle
answer on whether or not
it's the same object or not.

808
00:32:25,206 --> 00:32:27,666 A:middle
Let's talk about
using mutable objects.

809
00:32:28,226 --> 00:32:30,266 A:middle
We have a BezierPath here.

810
00:32:31,366 --> 00:32:32,956 A:middle
It also implements Drawable.

811
00:32:33,526 --> 00:32:35,226 A:middle
But its entire implementation
is made

812
00:32:35,226 --> 00:32:37,676 A:middle
up by this mutable
reference type, UIBezierPath.

813
00:32:37,676 --> 00:32:42,706 A:middle
In the reading case, when
we're doing Is Empty,

814
00:32:42,776 --> 00:32:43,726 A:middle
everything is okay.

815
00:32:43,726 --> 00:32:45,886 A:middle
We are not doing any
mutation, so we're not going

816
00:32:45,886 --> 00:32:48,386 A:middle
to mess any other instances up.

817
00:32:49,066 --> 00:32:52,146 A:middle
But on this one below, we have
this Add Line To Point method,

818
00:32:52,456 --> 00:32:54,966 A:middle
and if we have two
BezierPaths pointing to that,

819
00:32:55,316 --> 00:32:56,616 A:middle
it will cause problems.

820
00:32:57,436 --> 00:33:00,716 A:middle
Also notice here, we don't have
the Mutating keyword there.

821

822
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

823
00:32:57,436 --> 00:33:00,716 A:middle
Also notice here, we don't have
the Mutating keyword there.

824
00:33:01,416 --> 00:33:04,636 A:middle
That's a sign that we know we
are mutating because Add Line

825
00:33:04,636 --> 00:33:06,746 A:middle
To Point is there, but the
compiler is not yelling

826
00:33:06,746 --> 00:33:07,326 A:middle
at us about it.

827
00:33:07,526 --> 00:33:09,346 A:middle
That's because path
is a reference type.

828
00:33:09,346 --> 00:33:11,566 A:middle
We will look at that
again in just a moment.

829
00:33:12,656 --> 00:33:16,766 A:middle
So if I have two instances
of BezierPath, both pointing

830
00:33:16,766 --> 00:33:18,866 A:middle
to the same instance
of UIBezierPath

831
00:33:18,866 --> 00:33:22,346 A:middle
through this reference, and I
make this mutation, that's going

832
00:33:22,346 --> 00:33:24,026 A:middle
to catch the other
one off guard.

833
00:33:24,026 --> 00:33:25,666 A:middle
This is a bad situation.

834
00:33:25,666 --> 00:33:27,786 A:middle
We are not maintaining
value semantics.

835
00:33:28,186 --> 00:33:29,726 A:middle
We need to fix that.

836
00:33:30,356 --> 00:33:33,226 A:middle
The way we will fix that
is use copy-on-write,

837
00:33:33,876 --> 00:33:37,446 A:middle
and we want to make sure that
before we write to that path,

838
00:33:37,446 --> 00:33:39,466 A:middle
that we make a copy of it.

839
00:33:40,656 --> 00:33:42,846 A:middle
So to do that, we need
to introduce a couple

840
00:33:42,846 --> 00:33:44,826 A:middle
of new things to our BezierPath.

841
00:33:44,956 --> 00:33:48,936 A:middle
First, we want to make
our path instance private,

842
00:33:49,506 --> 00:33:52,516 A:middle
and next we want to implement
this computed path property

843
00:33:52,956 --> 00:33:55,396 A:middle
for reading and from there
we will return our private

844
00:33:55,396 --> 00:33:56,196 A:middle
instance variable.

845
00:33:56,756 --> 00:33:59,026 A:middle
And we want to make a path

846
00:33:59,406 --> 00:34:02,776 A:middle
for writing computed property
that's marked as mutating,

847

848
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

849
00:33:59,406 --> 00:34:02,776 A:middle
for writing computed property
that's marked as mutating,

850
00:34:03,096 --> 00:34:04,926 A:middle
and that's going to, in
fact, change the state.

851
00:34:04,926 --> 00:34:07,786 A:middle
So we marked it mutating
and we set path equal

852
00:34:07,786 --> 00:34:10,766 A:middle
to a new copy of
our existing path.

853
00:34:11,275 --> 00:34:15,136 A:middle
Now we have both a reading copy
and a way to get a writing copy.

854
00:34:16,315 --> 00:34:18,896 A:middle
And we change our
implementation to reflect that.

855
00:34:18,896 --> 00:34:21,696 A:middle
In the Is Empty method, we
will call our reading copy,

856
00:34:22,025 --> 00:34:23,815 A:middle
and in the mutating
method below,

857
00:34:23,815 --> 00:34:25,166 A:middle
we will call the
path for writing.

858
00:34:25,735 --> 00:34:28,466 A:middle
And the great thing about this
that the compiler is going

859
00:34:28,466 --> 00:34:29,956 A:middle
to yell at us and say, "Hey,

860
00:34:30,356 --> 00:34:33,466 A:middle
that path for writing
property is marked as mutating,

861
00:34:33,806 --> 00:34:36,065 A:middle
and this method is not
marked for mutating."

862
00:34:36,065 --> 00:34:39,076 A:middle
So we are getting help from
the compiler to help us figure

863
00:34:39,076 --> 00:34:41,096 A:middle
out when we are doing
something wrong.

864
00:34:41,795 --> 00:34:46,085 A:middle
Just to look through it
in a diagram, the path,

865
00:34:46,996 --> 00:34:49,545 A:middle
I create another one
by saying Path To.

866
00:34:49,996 --> 00:34:51,156 A:middle
Of course, I can read from it.

867
00:34:51,156 --> 00:34:54,376 A:middle
No issue. And when
I go to write to it,

868
00:34:54,985 --> 00:34:58,966 A:middle
since I'm creating another
instance of BezierPath,

869
00:34:59,566 --> 00:35:02,736 A:middle
path two is none the wiser
that a mutation has happened.

870

871
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

872
00:34:59,566 --> 00:35:02,736 A:middle
path two is none the wiser
that a mutation has happened.

873
00:35:03,096 --> 00:35:06,676 A:middle
So I will not introduce some
unexpected mutation behind

874
00:35:07,996 --> 00:35:08,646 A:middle
path two.

875
00:35:11,046 --> 00:35:14,626 A:middle
So now let's talk about how to
use these things in practice.

876
00:35:15,656 --> 00:35:19,356 A:middle
Here we have our polygon
type, and we are extending

877
00:35:19,356 --> 00:35:21,506 A:middle
that by adding a method
that's going to return

878
00:35:21,506 --> 00:35:24,106 A:middle
to us a BezierPath that
describes that polygon.

879
00:35:24,826 --> 00:35:27,386 A:middle
So we create the BezierPath,
iterate through the points,

880
00:35:27,386 --> 00:35:29,776 A:middle
adding a line two to
each of these points.

881
00:35:30,086 --> 00:35:33,176 A:middle
Now, the downside is
remember that Add Line

882
00:35:33,176 --> 00:35:36,066 A:middle
To Point method is
copying on every call.

883
00:35:36,646 --> 00:35:39,166 A:middle
So this is not going to
perform as well as it might.

884
00:35:40,966 --> 00:35:43,656 A:middle
So instead, what we should
do is create an instance

885
00:35:43,656 --> 00:35:48,986 A:middle
of UIBezierPath and mutate that
mutable reference type in place

886
00:35:49,326 --> 00:35:52,686 A:middle
and when we're done, create a
new instance of our value type

887
00:35:52,826 --> 00:35:54,816 A:middle
with that BezierPath
and return that.

888
00:35:55,216 --> 00:35:57,806 A:middle
That creates only one
copy or only one instance

889
00:35:57,806 --> 00:35:59,926 A:middle
of UIBezierPath instead
of multiple.

890

891
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

892
00:36:00,536 --> 00:36:05,686 A:middle
In Swift, we have a great
feature where we know

893
00:36:05,686 --> 00:36:07,436 A:middle
if objects are uniquely
referenced,

894
00:36:07,436 --> 00:36:09,156 A:middle
and so we can take
advantage of that.

895
00:36:09,156 --> 00:36:11,566 A:middle
This is a similar structure to
what we saw in our BezierPath,

896
00:36:12,196 --> 00:36:15,556 A:middle
and we can use this fact that
we have this uniquely referenced

897
00:36:15,686 --> 00:36:17,636 A:middle
property and we know for a fact

898
00:36:17,716 --> 00:36:18,996 A:middle
that something is
uniquely referenced

899
00:36:18,996 --> 00:36:21,566 A:middle
so we can avoid making
the copies if we know

900
00:36:21,566 --> 00:36:23,836 A:middle
that that reference type
is uniquely referenced.

901
00:36:24,276 --> 00:36:27,566 A:middle
The standard library uses
that feature throughout

902
00:36:27,566 --> 00:36:29,826 A:middle
and does a lot of great
performance optimizations

903
00:36:29,826 --> 00:36:31,006 A:middle
using that.

904
00:36:31,956 --> 00:36:34,616 A:middle
So that's mixing value
types and reference types.

905
00:36:34,616 --> 00:36:38,286 A:middle
You want to make sure that you
maintain value semantics despite

906
00:36:38,286 --> 00:36:42,656 A:middle
the fact that you have these
references to mutable types

907
00:36:42,786 --> 00:36:44,746 A:middle
by using copy-on-write.

908
00:36:45,496 --> 00:36:47,136 A:middle
So now I want to look

909
00:36:47,136 --> 00:36:49,026 A:middle
at a really cool
feature we can do now

910
00:36:49,026 --> 00:36:52,296 A:middle
that we have a model type
implemented as a value,

911
00:36:53,086 --> 00:36:54,726 A:middle
and implement an undo stack.

912
00:36:55,376 --> 00:36:59,056 A:middle
So I'm going to create a diagram
and an array of diagrams.

913
00:36:59,316 --> 00:37:04,896 A:middle
Then with every mutation, I will
add my doc to my diagram array.

914

915
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

916
00:36:59,316 --> 00:37:04,896 A:middle
Then with every mutation, I will
add my doc to my diagram array.

917
00:37:05,246 --> 00:37:06,746 A:middle
So I create it and append.

918
00:37:07,456 --> 00:37:10,706 A:middle
I add a polygon and append
it to the undo stack.

919
00:37:11,616 --> 00:37:14,336 A:middle
I create a circle and append
that to the undo stack.

920
00:37:14,886 --> 00:37:19,606 A:middle
Now in my undo stack I have
three distinct instances

921
00:37:19,666 --> 00:37:20,756 A:middle
of Diagram.

922
00:37:21,066 --> 00:37:23,746 A:middle
These are not references
to the same thing,

923
00:37:23,746 --> 00:37:25,956 A:middle
these are three distinct values.

924
00:37:26,566 --> 00:37:29,386 A:middle
And so, I can implement some
really cool features with this.

925
00:37:29,716 --> 00:37:33,756 A:middle
So imagine this in an app,
and I have a History button.

926
00:37:34,046 --> 00:37:37,206 A:middle
I tap on the History button and
I get the list of all the states

927
00:37:37,206 --> 00:37:40,516 A:middle
of my diagram back
through my undo stack.

928
00:37:41,086 --> 00:37:43,296 A:middle
I can allow the user
to tap on something

929
00:37:43,626 --> 00:37:45,326 A:middle
and essentially go back in time.

930
00:37:45,686 --> 00:37:50,206 A:middle
I don't have to keep anything in
some array of how to undo adding

931
00:37:50,206 --> 00:37:51,356 A:middle
that property or anything.

932
00:37:51,696 --> 00:37:53,716 A:middle
It just goes back to
that previous instance,

933
00:37:53,716 --> 00:37:56,756 A:middle
and that's the one
that gets drawn.

934
00:37:56,936 --> 00:37:59,916 A:middle
This is a super-powerful
feature, and, in fact,

935

936
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

937
00:38:00,316 --> 00:38:03,236 A:middle
Photoshop uses this
extensively to implement all

938
00:38:03,236 --> 00:38:04,186 A:middle
of their history stuff.

939
00:38:05,086 --> 00:38:07,036 A:middle
When you open an
image in Photoshop,

940
00:38:07,226 --> 00:38:08,966 A:middle
what happens behind the scenes?

941
00:38:09,316 --> 00:38:11,576 A:middle
Photoshop slices and
dices that photo,

942
00:38:11,576 --> 00:38:14,506 A:middle
no matter how large it is,
into a bunch of small tiles.

943
00:38:15,116 --> 00:38:18,566 A:middle
Each of those tiles are
values, and the document

944
00:38:18,686 --> 00:38:21,686 A:middle
that contains the
tiles is also a value.

945
00:38:22,116 --> 00:38:24,686 A:middle
Then if I make a change, like
change this person's shirt

946
00:38:24,686 --> 00:38:29,686 A:middle
from purple to green, the
only thing that gets copied

947
00:38:29,686 --> 00:38:33,196 A:middle
in the two instances of
that diagram are the tiles

948
00:38:33,246 --> 00:38:34,996 A:middle
that contain the person's shirt.

949
00:38:35,606 --> 00:38:38,306 A:middle
So even though I have
two distinct documents,

950
00:38:38,386 --> 00:38:42,596 A:middle
the old state and the new
state, the only new data

951
00:38:42,596 --> 00:38:44,596 A:middle
that I have had to
consume as a result

952
00:38:44,596 --> 00:38:47,836 A:middle
of that is the tiles contained
in this person's shirt.

953
00:38:48,486 --> 00:38:52,966 A:middle
So in summary, we have
talked about value types,

954
00:38:53,036 --> 00:38:55,806 A:middle
and what great features they
bring to your applications,

955
00:38:55,866 --> 00:38:59,246 A:middle
compared that to reference types
and showed how value types fix

956
00:38:59,246 --> 00:39:00,376 A:middle
up some of those issues.

957

958
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

959
00:38:59,246 --> 00:39:00,376 A:middle
up some of those issues.

960
00:39:00,906 --> 00:39:03,466 A:middle
We talked through an example
and saw some cool features

961
00:39:03,466 --> 00:39:05,416 A:middle
that you can add to
your applications

962
00:39:05,796 --> 00:39:07,046 A:middle
by using value types.

963
00:39:07,346 --> 00:39:09,356 A:middle
I look forward to seeing
how those things play

964
00:39:09,356 --> 00:39:10,486 A:middle
out in your apps.

965
00:39:11,046 --> 00:39:13,696 A:middle
Some related sessions that
you can catch on video

966
00:39:13,696 --> 00:39:15,456 A:middle
or if you have time
today at 3:30

967
00:39:15,456 --> 00:39:16,896 A:middle
for the protocol-oriented talk.

968
00:39:18,406 --> 00:39:21,496 A:middle
For more information, you can
always email Stephan or go

969
00:39:21,496 --> 00:39:25,156 A:middle
to our forums, and the
documentation also has

970
00:39:25,186 --> 00:39:26,306 A:middle
great information.

971
00:39:27,076 --> 00:39:29,526 A:middle
Thank you very much and I hope
the rest of your WWDC is great.

972
00:39:31,516 --> 00:39:42,900 A:middle
[ Applause ]

973
