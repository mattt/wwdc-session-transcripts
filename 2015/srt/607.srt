X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:22,516 --> 00:00:28,026 A:middle
[ Applause ]

2
00:00:28,526 --> 00:00:30,126 A:middle
>> DAN OMACHI: Good morning,
welcome to the second part

3
00:00:30,126 --> 00:00:31,816 A:middle
of our What's New in
Metal presentation.

4
00:00:32,036 --> 00:00:33,436 A:middle
My name is Dan Omachi.

5
00:00:33,866 --> 00:00:36,616 A:middle
I'm an engineer in Apple's
GPU software frameworks team.

6
00:00:37,206 --> 00:00:40,226 A:middle
Today my colleague Anna
Tikhonova and I will talk

7
00:00:40,226 --> 00:00:42,756 A:middle
about technologies
that build upon Metal,

8
00:00:43,166 --> 00:00:46,266 A:middle
helping you deliver great
rendering experiences

9
00:00:46,376 --> 00:00:49,136 A:middle
on both iOS and OS X.

10
00:00:50,416 --> 00:00:53,506 A:middle
So this is the second
of three sessions

11
00:00:53,606 --> 00:00:56,586 A:middle
at this years WWDC
talking about Metal.

12
00:00:57,546 --> 00:01:01,386 A:middle
In the first session, Rob
Duraf talked about developments

13

14
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

15
00:00:57,546 --> 00:01:01,386 A:middle
In the first session, Rob
Duraf talked about developments

16
00:01:01,386 --> 00:01:03,266 A:middle
in Metal that have
happened in the past year.

17
00:01:04,025 --> 00:01:06,206 A:middle
He also described some
of the new features

18
00:01:06,206 --> 00:01:08,096 A:middle
in Metal we just released.

19
00:01:09,476 --> 00:01:12,686 A:middle
He also described how app
thinning is a great match

20
00:01:12,816 --> 00:01:14,316 A:middle
for your Metal applications.

21
00:01:14,856 --> 00:01:19,496 A:middle
In this session, I will be
up here first to talk to you

22
00:01:19,496 --> 00:01:23,886 A:middle
about MetalKit, convenience
APIs allowing you bring

23
00:01:23,886 --> 00:01:26,556 A:middle
up Metal applications
much more quickly.

24
00:01:27,486 --> 00:01:30,026 A:middle
Then Anna will come up to talk

25
00:01:30,026 --> 00:01:32,356 A:middle
about Metal performance
shaders framework,

26
00:01:32,956 --> 00:01:36,086 A:middle
which offers great shaders

27
00:01:36,806 --> 00:01:40,276 A:middle
for common data parallel
operations available

28
00:01:40,276 --> 00:01:42,666 A:middle
on iOS devices with
an A8 processor.

29
00:01:43,186 --> 00:01:46,636 A:middle
And tomorrow, you
will get a chance

30
00:01:47,036 --> 00:01:50,416 A:middle
to catch the Metal Performance
Optimization Techniques session,

31
00:01:50,886 --> 00:01:54,346 A:middle
where they will introduce
the Metal System Trace Tool

32
00:01:54,926 --> 00:01:57,396 A:middle
and provide you with
some best practices

33
00:01:57,796 --> 00:02:00,356 A:middle
for shipping an efficient
Metal application.

34

35
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

36
00:01:57,796 --> 00:02:00,356 A:middle
for shipping an efficient
Metal application.

37
00:02:00,356 --> 00:02:04,966 A:middle
So let's get started
with Metal kit.

38
00:02:05,226 --> 00:02:08,186 A:middle
Utility functionality
for your Metal apps.

39
00:02:09,616 --> 00:02:13,586 A:middle
So because Metal is a low
level API, there are a number

40
00:02:13,586 --> 00:02:17,616 A:middle
of things you need to do
to get up and running.

41
00:02:17,766 --> 00:02:20,346 A:middle
MetalKit hopes to help with this

42
00:02:20,346 --> 00:02:22,596 A:middle
by providing efficient
implementation

43
00:02:22,856 --> 00:02:24,956 A:middle
for commonly used scenarios.

44
00:02:25,466 --> 00:02:28,576 A:middle
This requires less effort
on your part to get up

45
00:02:28,576 --> 00:02:31,936 A:middle
and rendering and we offer
increased performance

46
00:02:32,056 --> 00:02:35,676 A:middle
and stability over the
standard boilerplate code

47
00:02:35,866 --> 00:02:37,416 A:middle
that you might implement
yourself.

48
00:02:38,156 --> 00:02:41,246 A:middle
There is less maintenance
for you as the burden

49
00:02:41,246 --> 00:02:45,786 A:middle
of that maintenance has
been shifted from you to us.

50
00:02:46,046 --> 00:02:49,966 A:middle
So MetalKit consists of
three main components.

51
00:02:50,926 --> 00:02:53,236 A:middle
First is the MetalKit view.

52
00:02:53,506 --> 00:02:57,656 A:middle
A unified view class
between iOS and OS X

53
00:02:58,206 --> 00:02:59,596 A:middle
for rendering your Metal scenes.

54

55
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

56
00:03:01,126 --> 00:03:05,666 A:middle
Second is the texture loader
which creates texture objects

57
00:03:06,016 --> 00:03:08,576 A:middle
from image files on disk.

58
00:03:09,966 --> 00:03:14,556 A:middle
And finally, Metal kit's model
I/O integration which loads

59
00:03:14,676 --> 00:03:17,176 A:middle
and manages mesh data
from Metal rendering.

60
00:03:20,506 --> 00:03:23,366 A:middle
MetalKit view is
the simplest way

61
00:03:23,486 --> 00:03:25,556 A:middle
to get Metal rendering
on screen.

62
00:03:26,136 --> 00:03:31,746 A:middle
It's a unified class
on both iOS and OS X.

63
00:03:32,006 --> 00:03:34,146 A:middle
It offers pretty much
the same interface

64
00:03:34,406 --> 00:03:37,546 A:middle
on both Operating Systems,
but naturally it's a subclass

65
00:03:37,546 --> 00:03:42,956 A:middle
of UI view for iOS and a
subclass of NS view on OS X.

66
00:03:43,456 --> 00:03:48,126 A:middle
Its main job is to manage
displayable render targets

67
00:03:48,126 --> 00:03:51,276 A:middle
for you, and it creates
render path descriptors

68
00:03:51,326 --> 00:03:53,536 A:middle
for these render
targets automatically.

69
00:03:53,536 --> 00:03:58,906 A:middle
Now, it's super flexible
in terms of the ways

70
00:03:59,276 --> 00:04:02,206 A:middle
that it can execute
your draw code.

71

72
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

73
00:03:59,276 --> 00:04:02,206 A:middle
that it can execute
your draw code.

74
00:04:03,436 --> 00:04:05,676 A:middle
You can use a timer-based mode

75
00:04:06,206 --> 00:04:09,056 A:middle
where it will execute your
draw code at a regular interval

76
00:04:09,456 --> 00:04:11,416 A:middle
in synchronization
with a display,

77
00:04:12,806 --> 00:04:14,366 A:middle
or you can use an
event-based mode

78
00:04:14,366 --> 00:04:16,776 A:middle
which will trigger your
draw code whenever a touch

79
00:04:16,826 --> 00:04:19,836 A:middle
or UI event has occurred, so
you can respond to that event.

80
00:04:21,055 --> 00:04:23,836 A:middle
Finally, you can explicitly
drive your draw code,

81
00:04:24,156 --> 00:04:27,066 A:middle
perhaps in an open loop
on a secondary thread

82
00:04:27,686 --> 00:04:29,096 A:middle
at your own frame rate.

83
00:04:29,726 --> 00:04:35,676 A:middle
So there are two approaches
to using the MetalKit view.

84
00:04:37,146 --> 00:04:39,586 A:middle
The simplest approach is
to implement a delegate

85
00:04:39,716 --> 00:04:42,556 A:middle
to handle your draw
and resize operations.

86
00:04:43,336 --> 00:04:45,756 A:middle
In this case, you would
implement the draw

87
00:04:45,756 --> 00:04:50,386 A:middle
in view method to handle your
per-frame updates including

88
00:04:50,726 --> 00:04:52,456 A:middle
encoding any rendering commands.

89
00:04:53,846 --> 00:04:56,006 A:middle
You would also implement
the view will layout

90
00:04:56,126 --> 00:05:00,836 A:middle
with size method to handle
size changes to your view.

91

92
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

93
00:04:56,126 --> 00:05:00,836 A:middle
with size method to handle
size changes to your view.

94
00:05:01,466 --> 00:05:04,696 A:middle
This is where you might
update your projection matrix

95
00:05:05,016 --> 00:05:06,966 A:middle
or change any texture sizes

96
00:05:06,996 --> 00:05:09,366 A:middle
to better fit your
displayable area.

97
00:05:10,836 --> 00:05:14,566 A:middle
Now, if you have any other
pieces of the view that you need

98
00:05:14,566 --> 00:05:18,536 A:middle
to override, you can
subclass the MetalKit view.

99
00:05:18,926 --> 00:05:20,896 A:middle
And in this case on iOS,

100
00:05:21,666 --> 00:05:23,566 A:middle
you would override
the draw Rect method

101
00:05:25,126 --> 00:05:26,466 A:middle
to handle your per-frame updates

102
00:05:27,336 --> 00:05:30,346 A:middle
and the layout subviews
method to handle resizes.

103
00:05:31,156 --> 00:05:33,706 A:middle
Likewise on OS X
you would handle,

104
00:05:34,106 --> 00:05:36,516 A:middle
you would override these
two methods, the draw Rect

105
00:05:36,516 --> 00:05:38,606 A:middle
and set frame size method.

106
00:05:39,316 --> 00:05:49,756 A:middle
So here is an example of
setting up a view controller

107
00:05:49,946 --> 00:05:53,166 A:middle
that also serves as the
delegate to our view.

108
00:05:54,446 --> 00:05:58,896 A:middle
In the view did load method,
after we received a reference

109
00:05:59,106 --> 00:06:02,976 A:middle
to the view, we will assign
ourself as the delegate,

110

111
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

112
00:05:59,106 --> 00:06:02,976 A:middle
to the view, we will assign
ourself as the delegate,

113
00:06:04,306 --> 00:06:11,516 A:middle
and particularly important on OS
X is that we will need to choose

114
00:06:11,516 --> 00:06:13,376 A:middle
and set a Metal device.

115
00:06:13,976 --> 00:06:18,136 A:middle
Once we are done with
that, we can configure some

116
00:06:18,136 --> 00:06:21,186 A:middle
of the view's properties
including choosing our own

117
00:06:21,186 --> 00:06:23,576 A:middle
custom pixel formats
for the color

118
00:06:23,576 --> 00:06:24,836 A:middle
and depth and stencil buffers.

119
00:06:25,516 --> 00:06:28,496 A:middle
We can use multisampling

120
00:06:28,706 --> 00:06:32,336 A:middle
by increasing the sample count
property to a value above 1,

121
00:06:32,336 --> 00:06:41,036 A:middle
or we can set our
custom clear color.

122
00:06:41,196 --> 00:06:45,626 A:middle
Now, here is a very basic
usage of the MetalKit view

123
00:06:45,796 --> 00:06:48,566 A:middle
in the implementation
of the per frame update.

124
00:06:49,506 --> 00:06:53,336 A:middle
In our drawing view method,
we call the views render,

125
00:06:53,336 --> 00:06:55,466 A:middle
I'm sorry, current
render past descriptor.

126
00:06:55,966 --> 00:06:59,666 A:middle
Now, the first time you access
this property each frame,

127

128
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

129
00:07:00,086 --> 00:07:02,516 A:middle
the view will call
into core animation

130
00:07:02,816 --> 00:07:04,646 A:middle
and get a drawable back,

131
00:07:05,256 --> 00:07:07,406 A:middle
which you can encode
your rendering commands

132
00:07:07,406 --> 00:07:08,076 A:middle
and render to.

133
00:07:08,686 --> 00:07:12,956 A:middle
So we will render our
final render pass,

134
00:07:13,466 --> 00:07:15,196 A:middle
which will show up
in this drawable.

135
00:07:15,726 --> 00:07:18,996 A:middle
And then we will present the
drawable, which is stored

136
00:07:18,996 --> 00:07:20,736 A:middle
in the view's current
drawable property

137
00:07:21,796 --> 00:07:24,866 A:middle
and we will commit
our command buffer.

138
00:07:25,036 --> 00:07:26,776 A:middle
Now, because of its importance

139
00:07:27,296 --> 00:07:30,396 A:middle
in structuring your per-frame
updates, let me take a minute

140
00:07:30,656 --> 00:07:32,896 A:middle
to talk about managing
these drawables.

141
00:07:33,586 --> 00:07:36,906 A:middle
So there are a limited
pool of drawables

142
00:07:37,436 --> 00:07:40,026 A:middle
in this system all
managed by core animation.

143
00:07:41,556 --> 00:07:44,246 A:middle
There are only a few of them
mostly because of their size,

144
00:07:44,246 --> 00:07:45,456 A:middle
they take up some space.

145
00:07:46,556 --> 00:07:49,346 A:middle
Now, these drawables
are concurrently used

146
00:07:49,346 --> 00:07:52,456 A:middle
through many stages of
the display pipeline.

147
00:07:53,916 --> 00:07:55,206 A:middle
Here is roughly how it works.

148
00:07:55,656 --> 00:07:57,706 A:middle
First, your application
encodes commands

149
00:07:57,706 --> 00:07:58,926 A:middle
to be rendered onto
the drawable.

150

151
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

152
00:08:00,016 --> 00:08:02,216 A:middle
It sends that drawable
down to the GPU

153
00:08:02,596 --> 00:08:05,656 A:middle
as your application encodes
commands for the next frame

154
00:08:05,876 --> 00:08:09,766 A:middle
and the GPU renders to that
drawable, and core animation

155
00:08:09,766 --> 00:08:11,666 A:middle
at this stage may do compositing

156
00:08:11,666 --> 00:08:15,026 A:middle
with other layers
into that drawable.

157
00:08:15,636 --> 00:08:19,726 A:middle
And finally, the display
can take the drawable

158
00:08:19,726 --> 00:08:21,016 A:middle
and slap it up onto the screen.

159
00:08:21,966 --> 00:08:24,086 A:middle
Now, the display can't
replace it with anything

160
00:08:24,086 --> 00:08:25,806 A:middle
until another drawable
is available.

161
00:08:26,106 --> 00:08:29,106 A:middle
So if any of these previous
stages are taking a lot of time,

162
00:08:29,416 --> 00:08:31,166 A:middle
it just has to sit
there for awhile.

163
00:08:31,606 --> 00:08:36,876 A:middle
Additionally, the display can't
recycle that drawable back

164
00:08:36,876 --> 00:08:39,015 A:middle
up to your frame until it
has something available.

165
00:08:39,015 --> 00:08:44,986 A:middle
So let's take a look at
your application frame

166
00:08:45,436 --> 00:08:47,456 A:middle
with respect to these drawables.

167
00:08:48,936 --> 00:08:51,796 A:middle
First, you call the MetalKit
views current render past

168
00:08:51,796 --> 00:08:54,166 A:middle
descriptor which
reserves a drawable.

169
00:08:54,166 --> 00:08:59,176 A:middle
Then you will encode rendering
commands that you want

170
00:08:59,176 --> 00:09:02,136 A:middle
into that drawable, and
finally you will present

171

172
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

173
00:08:59,176 --> 00:09:02,136 A:middle
into that drawable, and
finally you will present

174
00:09:02,236 --> 00:09:03,196 A:middle
and commit the drawable

175
00:09:03,396 --> 00:09:06,366 A:middle
which will release it
back to core animation.

176
00:09:06,926 --> 00:09:11,266 A:middle
Now, this is fine if all we
are doing is rendering a single

177
00:09:11,266 --> 00:09:13,156 A:middle
render pass, however,

178
00:09:13,156 --> 00:09:16,246 A:middle
it's likely we will
do other operations

179
00:09:16,856 --> 00:09:24,216 A:middle
such as some app logic, encoding
in offscreen render pass

180
00:09:24,456 --> 00:09:28,076 A:middle
where we don't actually
need the drawable,

181
00:09:28,076 --> 00:09:31,166 A:middle
or running some compute
kernels for physics or whatnot.

182
00:09:31,716 --> 00:09:36,426 A:middle
In this case we are
essentially hogging the drawable

183
00:09:36,426 --> 00:09:39,216 A:middle
from our future self because
in a subsequent frame,

184
00:09:39,216 --> 00:09:41,816 A:middle
we will call this current
render pass descriptor

185
00:09:42,256 --> 00:09:44,996 A:middle
and it will sit there
waiting for a drawable

186
00:09:44,996 --> 00:09:47,176 A:middle
to become available,
which may not be the case

187
00:09:47,176 --> 00:09:50,936 A:middle
because we are doing these other
operations and reserving it

188
00:09:50,936 --> 00:09:52,186 A:middle
for much longer than we need to.

189
00:09:52,606 --> 00:09:54,086 A:middle
So to solve this problem,

190
00:09:54,876 --> 00:09:58,136 A:middle
let's put these operations
before our access

191
00:09:58,246 --> 00:09:59,906 A:middle
to the current render
pass descriptor.

192

193
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

194
00:10:00,436 --> 00:10:04,306 A:middle
Now, let me just note that
this isn't a problem specific

195
00:10:04,396 --> 00:10:05,536 A:middle
to the MetalKit view.

196
00:10:05,896 --> 00:10:08,816 A:middle
You need to be aware of this
issue if you roll your own view

197
00:10:09,066 --> 00:10:11,056 A:middle
in access core animation
directly.

198
00:10:12,126 --> 00:10:17,656 A:middle
So this is information that's
quite useful in any case.

199
00:10:18,526 --> 00:10:20,846 A:middle
Now, here is a more
complete example

200
00:10:20,846 --> 00:10:22,806 A:middle
of our per-frame
rendering update.

201
00:10:23,816 --> 00:10:27,316 A:middle
First, as I described we want to
update our app's render state,

202
00:10:28,046 --> 00:10:29,866 A:middle
encode any offscreen passes,

203
00:10:30,166 --> 00:10:31,986 A:middle
do anything where we
don't need the drawable.

204
00:10:32,576 --> 00:10:36,266 A:middle
And then we can continue
as we did previously,

205
00:10:36,266 --> 00:10:39,256 A:middle
get the current render pass
descriptor, encode our commands

206
00:10:39,256 --> 00:10:41,996 A:middle
for that final pass, and present
and commit our command buffer.

207
00:10:42,996 --> 00:10:46,166 A:middle
The key point is that
these two stages should be

208
00:10:46,166 --> 00:10:48,236 A:middle
as close together as possible.

209
00:10:49,016 --> 00:10:52,166 A:middle
It's a critical section where
we are holding onto a resource

210
00:10:52,736 --> 00:10:57,386 A:middle
and we don't want to hold onto
it any longer than we need to.

211
00:10:57,626 --> 00:10:58,476 A:middle
That's it for the view.

212

213
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

214
00:11:00,216 --> 00:11:01,886 A:middle
Let's move on to
the texture loader.

215
00:11:02,476 --> 00:11:06,036 A:middle
It's textural loading
made simple.

216
00:11:07,096 --> 00:11:11,336 A:middle
You give a reference and
you get back a fully formed

217
00:11:11,666 --> 00:11:12,446 A:middle
Metal Texture.

218
00:11:13,006 --> 00:11:18,586 A:middle
Not only is it simple, it's
fast and fully featured.

219
00:11:19,656 --> 00:11:22,226 A:middle
It asynchronously decodes files

220
00:11:22,976 --> 00:11:26,486 A:middle
and creates textures
on a separate thread.

221
00:11:27,936 --> 00:11:31,376 A:middle
It has support for many common
image file formats including

222
00:11:31,376 --> 00:11:36,076 A:middle
JPG, TIF and PNG and
also supports the PVR

223
00:11:36,336 --> 00:11:38,646 A:middle
and KTX texture file formats.

224
00:11:38,996 --> 00:11:43,026 A:middle
What's interesting about these
formats is that they store data

225
00:11:43,296 --> 00:11:47,166 A:middle
in a raw form that can be
uploaded to your Metal Texture

226
00:11:47,166 --> 00:11:48,516 A:middle
without any conversion.

227
00:11:49,516 --> 00:11:54,996 A:middle
Additionally, you can encode
data for MIT maps for any

228
00:11:55,146 --> 00:11:58,896 A:middle
of the other types of
textures including 3D textures,

229
00:11:59,336 --> 00:12:01,886 A:middle
cube maps, and texture arrays.

230

231
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

232
00:11:59,336 --> 00:12:01,886 A:middle
cube maps, and texture arrays.

233
00:12:05,716 --> 00:12:07,206 A:middle
Its usage is really simple.

234
00:12:08,716 --> 00:12:10,976 A:middle
First, we create a
texture loader object

235
00:12:11,416 --> 00:12:13,386 A:middle
by supplying a device.

236
00:12:14,916 --> 00:12:17,586 A:middle
Then, once we have that
texture loader object,

237
00:12:17,586 --> 00:12:20,356 A:middle
we can create many
textures with it.

238
00:12:21,196 --> 00:12:26,116 A:middle
First, we will give a URL
location of our image file,

239
00:12:26,786 --> 00:12:29,996 A:middle
and we can supply a number of
options including how we want

240
00:12:29,996 --> 00:12:33,886 A:middle
to treat the sRGB information
in the file or whether

241
00:12:33,886 --> 00:12:36,136 A:middle
or not we want to allocate
memory for MIT maps

242
00:12:36,546 --> 00:12:37,866 A:middle
when we create this texture,

243
00:12:38,496 --> 00:12:42,426 A:middle
and finally we will supply
a completion handler block.

244
00:12:42,936 --> 00:12:45,526 A:middle
Now, this block will
get executed as soon

245
00:12:45,526 --> 00:12:48,206 A:middle
as the texture loader has
finished loading the texture

246
00:12:48,276 --> 00:12:49,086 A:middle
and created it.

247
00:12:49,166 --> 00:12:51,056 A:middle
It will pass the texture
handler back to you

248
00:12:51,096 --> 00:12:54,086 A:middle
which you can stash away
for later and render

249
00:12:54,086 --> 00:12:57,166 A:middle
with when you need to.

250
00:12:57,356 --> 00:12:59,396 A:middle
That's very simple,
the texture loader.

251
00:12:59,506 --> 00:13:02,686 A:middle
Let's move on to model I/O.

252

253
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

254
00:12:59,506 --> 00:13:02,686 A:middle
Let's move on to model I/O.

255
00:13:04,496 --> 00:13:07,236 A:middle
So model I/0 is a new
framework introduced

256
00:13:07,236 --> 00:13:09,396 A:middle
with iOS 9 and OS X El Capitan.

257
00:13:11,236 --> 00:13:13,246 A:middle
And one of its key features is

258
00:13:13,246 --> 00:13:17,696 A:middle
that it can load many
model file formats for you.

259
00:13:19,006 --> 00:13:22,336 A:middle
You can create your own
importers and exporters

260
00:13:22,366 --> 00:13:25,056 A:middle
for proprietary formats
if you need to.

261
00:13:25,056 --> 00:13:28,776 A:middle
Some of the cooler
features here are

262
00:13:28,776 --> 00:13:32,806 A:middle
that you can do offline
baking operations.

263
00:13:32,806 --> 00:13:36,286 A:middle
You can create static
ambient occlusion maps,

264
00:13:36,826 --> 00:13:40,856 A:middle
light map generations, it
also includes the Voxelization

265
00:13:40,956 --> 00:13:41,656 A:middle
of your meshes.

266
00:13:42,256 --> 00:13:48,536 A:middle
It provides you a way to
focus on your rendering code

267
00:13:48,536 --> 00:13:49,636 A:middle
and write your shaders.

268
00:13:49,706 --> 00:13:52,346 A:middle
You don't have to deal
with creating some parchers

269
00:13:52,346 --> 00:13:53,766 A:middle
to get some stuff off disk.

270
00:13:53,766 --> 00:13:57,106 A:middle
You have to deal less
with serialization,

271
00:13:57,776 --> 00:14:00,606 A:middle
you just load a model
file with Model I/O,

272

273
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

274
00:13:57,776 --> 00:14:00,606 A:middle
you just load a model
file with Model I/O,

275
00:14:01,636 --> 00:14:03,566 A:middle
put it into some form
you can render it with,

276
00:14:04,246 --> 00:14:06,596 A:middle
and start writing your shaders.

277
00:14:06,596 --> 00:14:12,216 A:middle
So what does MetalKit
provide in this context?

278
00:14:12,216 --> 00:14:15,456 A:middle
It's utilities to efficiently
use model I/O with Metal.

279
00:14:16,796 --> 00:14:19,636 A:middle
It offers optimized
loading of model I/O meshes

280
00:14:19,636 --> 00:14:23,786 A:middle
into Metal buffers, the
encapsulation of mesh data

281
00:14:24,206 --> 00:14:28,606 A:middle
within MetalKit objects, and
there are a number of functions

282
00:14:28,606 --> 00:14:31,676 A:middle
to prepare mesh data
for Metal pipelines.

283
00:14:32,326 --> 00:14:40,356 A:middle
Let me walk you through the
process of loading a model file

284
00:14:41,426 --> 00:14:46,026 A:middle
with model I/O and getting it
rendering on screen with Metal.

285
00:14:46,596 --> 00:14:53,626 A:middle
And here are the
steps we will take.

286
00:14:53,846 --> 00:14:58,986 A:middle
So first, we will create a
Metal render state pipeline

287
00:14:58,986 --> 00:15:01,866 A:middle
that we'll use to create our
mesh, to render our mesh.

288

289
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

290
00:14:58,986 --> 00:15:01,866 A:middle
that we'll use to create our
mesh, to render our mesh.

291
00:15:02,406 --> 00:15:06,256 A:middle
Then we will actually
load the model file

292
00:15:06,336 --> 00:15:09,426 A:middle
by initializing the
model I/O asset.

293
00:15:10,456 --> 00:15:14,506 A:middle
And with that asset, we
will create MetalKit mesh

294
00:15:14,506 --> 00:15:16,076 A:middle
and sub mesh objects.

295
00:15:17,496 --> 00:15:20,416 A:middle
Finally, we will render
those objects with Metal.

296
00:15:22,216 --> 00:15:26,146 A:middle
So let's focus on creating a
Metal Render State Pipeline

297
00:15:27,316 --> 00:15:29,436 A:middle
and we will pay particular
attention

298
00:15:29,756 --> 00:15:33,356 A:middle
to creating a vertex descriptor
that will describe the layout

299
00:15:33,356 --> 00:15:36,326 A:middle
of vertices that we'll
need our mesh to be

300
00:15:36,326 --> 00:15:40,086 A:middle
in to feed our pipeline.

301
00:15:40,086 --> 00:15:43,226 A:middle
Here is the bare bones
of a vertex shader.

302
00:15:45,046 --> 00:15:48,306 A:middle
It uses the stage in
qualifier which basically says

303
00:15:48,306 --> 00:15:51,776 A:middle
that our per vertex
inputs, the layout for them,

304
00:15:52,306 --> 00:15:54,426 A:middle
will be described
outside of the shader

305
00:15:54,426 --> 00:15:58,156 A:middle
in our objective-C code
using a vertex descriptor.

306
00:15:59,626 --> 00:16:02,386 A:middle
It uses this vertex
input structure

307

308
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

309
00:15:59,626 --> 00:16:02,386 A:middle
It uses this vertex
input structure

310
00:16:03,556 --> 00:16:04,706 A:middle
which is defined up here.

311
00:16:06,096 --> 00:16:09,406 A:middle
And the key part of this vertex
input structure are these

312
00:16:09,506 --> 00:16:13,026 A:middle
attributes, the indices here
which we will use to connect

313
00:16:13,026 --> 00:16:16,306 A:middle
up outside inside of
our Objective-C code.

314
00:16:17,136 --> 00:16:22,136 A:middle
Note that these floating-point
vector types define how the data

315
00:16:22,136 --> 00:16:27,456 A:middle
looks within the shader, not
actually how the data looks

316
00:16:27,456 --> 00:16:29,366 A:middle
as it's being fed
into the shader

317
00:16:29,416 --> 00:16:30,686 A:middle
from our Objective-C code.

318
00:16:33,036 --> 00:16:41,226 A:middle
For that, we need to
create a vertex descriptor.

319
00:16:41,796 --> 00:16:46,296 A:middle
Now, I'm going to put this
vertex input structure

320
00:16:46,296 --> 00:16:49,826 A:middle
up here just for reference,
but let me just remind you

321
00:16:49,826 --> 00:16:53,136 A:middle
that it does not define
the layout of the data

322
00:16:53,456 --> 00:16:54,796 A:middle
as it's being fed
into the shader.

323
00:16:54,796 --> 00:16:57,256 A:middle
We are actually creating
the Metal Vertex Descriptor

324
00:16:57,756 --> 00:17:01,146 A:middle
that is down below.

325

326
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

327
00:16:57,756 --> 00:17:01,146 A:middle
that is down below.

328
00:17:01,826 --> 00:17:06,256 A:middle
And for that, what we will
do is for attribute zero,

329
00:17:07,156 --> 00:17:12,796 A:middle
the position will define as
using three floating points,

330
00:17:13,215 --> 00:17:14,876 A:middle
three floating point values.

331
00:17:15,986 --> 00:17:23,756 A:middle
For attribute one, the color
will specify that it's going

332
00:17:23,756 --> 00:17:26,736 A:middle
to be composed of four
unsigned characters,

333
00:17:26,965 --> 00:17:29,666 A:middle
not the four floats above,
four unsigned characters

334
00:17:29,906 --> 00:17:31,396 A:middle
and it will have an offset

335
00:17:32,506 --> 00:17:40,906 A:middle
of 12 bytes immediately
following the position data.

336
00:17:41,086 --> 00:17:46,636 A:middle
Now, for the texture coordinates
in attribute 2, we will define

337
00:17:46,636 --> 00:17:49,026 A:middle
that it uses two half floats.

338
00:17:49,586 --> 00:17:55,756 A:middle
And that it immediately follows
the position and color data

339
00:17:55,836 --> 00:17:57,556 A:middle
with an offset of 16 bytes.

340
00:17:58,056 --> 00:18:02,576 A:middle
And finally, we will
specify that the size

341

342
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

343
00:17:58,056 --> 00:18:02,576 A:middle
And finally, we will
specify that the size

344
00:18:02,576 --> 00:18:05,656 A:middle
of each vertex is 20 bytes
by setting the stride

345
00:18:05,896 --> 00:18:07,646 A:middle
to 20 for that buffer.

346
00:18:11,736 --> 00:18:15,676 A:middle
Now, this defines the
layout of each vertex

347
00:18:15,786 --> 00:18:17,776 A:middle
within our array of vertices.

348
00:18:17,776 --> 00:18:23,386 A:middle
So now that we have got our
Metal Vertex Descriptor,

349
00:18:23,986 --> 00:18:26,046 A:middle
we can assign it to our
render state pipeline,

350
00:18:27,636 --> 00:18:28,426 A:middle
and with that render --

351
00:18:28,526 --> 00:18:31,016 A:middle
excuse me, with the
render pipeline descriptor,

352
00:18:31,306 --> 00:18:34,256 A:middle
we can create a Metal
Render State Pipeline.

353
00:18:35,776 --> 00:18:40,246 A:middle
So let's move on to
actually loading our asset

354
00:18:41,056 --> 00:18:45,646 A:middle
and using model I/O
for that task.

355
00:18:46,326 --> 00:18:49,086 A:middle
And we will actually use the
vertex descriptor we just

356
00:18:49,086 --> 00:18:50,366 A:middle
created in the previous step,

357
00:18:51,336 --> 00:18:55,056 A:middle
along with a MetalKit
mesh buffer object,

358
00:18:55,516 --> 00:18:58,066 A:middle
a mesh buffer allocator object.

359
00:18:58,876 --> 00:19:00,636 A:middle
I will describe a
little bit more

360

361
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

362
00:18:58,876 --> 00:19:00,636 A:middle
I will describe a
little bit more

363
00:19:00,636 --> 00:19:06,456 A:middle
about its importance
as we continue.

364
00:19:06,556 --> 00:19:11,426 A:middle
So the model I/O
vertex descriptor

365
00:19:11,686 --> 00:19:14,506 A:middle
and Metal Vertex
Descriptor are very similar,

366
00:19:15,586 --> 00:19:18,726 A:middle
but while the model I/O vertex
descriptor describes the layouts

367
00:19:18,726 --> 00:19:20,796 A:middle
of vertex attributes
within a mesh,

368
00:19:22,336 --> 00:19:25,076 A:middle
the Metal Vertex Descriptor
describes the layout

369
00:19:25,076 --> 00:19:27,156 A:middle
of vertex attributes
as their input

370
00:19:27,666 --> 00:19:29,166 A:middle
to a render state pipeline.

371
00:19:30,536 --> 00:19:33,696 A:middle
Now, they are intentionally
designed to look similar

372
00:19:34,456 --> 00:19:38,386 A:middle
as they contain attribute
and buffer layout objects,

373
00:19:39,376 --> 00:19:43,396 A:middle
and the reason for this is
it simplifies the translation

374
00:19:43,396 --> 00:19:44,906 A:middle
of one object to another.

375
00:19:47,366 --> 00:19:52,276 A:middle
Now, each attribute in a model
I/O vertex descriptor has an

376
00:19:52,276 --> 00:19:53,866 A:middle
identifying string base name.

377
00:19:54,836 --> 00:19:59,456 A:middle
Model I/O assigns a default
name if one does not exist

378
00:19:59,486 --> 00:20:02,626 A:middle
in the model file or that
model file does not support

379

380
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

381
00:19:59,486 --> 00:20:02,626 A:middle
in the model file or that
model file does not support

382
00:20:02,626 --> 00:20:03,366 A:middle
these names.

383
00:20:04,046 --> 00:20:07,046 A:middle
These names include position,
normal, texture, coordinate,

384
00:20:07,046 --> 00:20:11,046 A:middle
color, et cetera, and
model I/0 defines these

385
00:20:11,046 --> 00:20:14,746 A:middle
with the string based
MDLVertex attribute constants.

386
00:20:15,856 --> 00:20:19,796 A:middle
There are a number of files
including the Alembic file

387
00:20:19,796 --> 00:20:23,136 A:middle
format where you can
customize those names.

388
00:20:23,796 --> 00:20:27,646 A:middle
Be aware if you are changing
the names you will need

389
00:20:27,646 --> 00:20:31,806 A:middle
to access these attributes
with those customized names.

390
00:20:32,406 --> 00:20:39,146 A:middle
So we recommend that you create
a custom model I/O vertex

391
00:20:39,146 --> 00:20:42,366 A:middle
descriptor, because by default
model I/O loads vertices

392
00:20:42,586 --> 00:20:43,816 A:middle
as high-precision

393
00:20:44,066 --> 00:20:48,526 A:middle
yet memory-hungry
floating-point types.

394
00:20:48,526 --> 00:20:52,446 A:middle
This is one of the
advantages of using model I/0.

395
00:20:52,916 --> 00:20:58,976 A:middle
You can actually load a model
format and have the vertex data

396
00:20:58,976 --> 00:21:03,486 A:middle
in any form that you would like
and use model I/0 to massage

397

398
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

399
00:20:58,976 --> 00:21:03,486 A:middle
in any form that you would like
and use model I/0 to massage

400
00:21:03,536 --> 00:21:06,596 A:middle
that data into a format
you can actually use.

401
00:21:07,306 --> 00:21:09,766 A:middle
In this case, we want
to feed the pipelines

402
00:21:10,126 --> 00:21:11,206 A:middle
with the smallest type

403
00:21:11,596 --> 00:21:13,796 A:middle
that meets your precision
requirements.

404
00:21:14,186 --> 00:21:17,686 A:middle
This would improve your
vertex bandwidth efficiency;

405
00:21:18,036 --> 00:21:20,716 A:middle
as you are feeding each
vertex to the pipeline,

406
00:21:21,066 --> 00:21:23,086 A:middle
you don't really want
a bloated vertex.

407
00:21:23,626 --> 00:21:28,756 A:middle
So here is the layout
we defined previously

408
00:21:28,756 --> 00:21:30,906 A:middle
when creating our Metal
Vertex Descriptor.

409
00:21:31,456 --> 00:21:37,186 A:middle
Now, we will create our
model I/O vertex descriptor

410
00:21:37,606 --> 00:21:42,406 A:middle
by calling this MTK model
I/O vertex format from Metal

411
00:21:42,486 --> 00:21:45,426 A:middle
and we will supply our
Metal Vertex Descriptor.

412
00:21:45,716 --> 00:21:51,546 A:middle
This builds the majority of this
model I/O vertex descriptor,

413
00:21:52,376 --> 00:21:55,786 A:middle
yet we still need to tag
each attribute with a name,

414
00:21:55,786 --> 00:21:59,136 A:middle
so model I/O knows what
we are talking about.

415

416
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

417
00:22:00,066 --> 00:22:03,646 A:middle
So for attribute
0, we will tag it

418
00:22:03,646 --> 00:22:06,216 A:middle
with the vertex attribute
position name.

419
00:22:07,446 --> 00:22:10,846 A:middle
And similarly for attribute
1 and 2, we will tag them

420
00:22:10,846 --> 00:22:13,696 A:middle
with a color and texture
coordinate attributes.

421
00:22:17,036 --> 00:22:20,096 A:middle
The other thing we will do here
is we will create a MetalKit

422
00:22:20,356 --> 00:22:24,466 A:middle
mesh buffer allocator and we
will supply a Metal device.

423
00:22:24,996 --> 00:22:29,376 A:middle
Now, what this object does
is it allows model I/0

424
00:22:29,906 --> 00:22:35,116 A:middle
to load vertex data directly
into GPU backed memory.

425
00:22:35,936 --> 00:22:39,056 A:middle
Now, you don't have to use a
MetalKit mesh buffer allocator,

426
00:22:39,856 --> 00:22:44,206 A:middle
but what that will do is it
will allocate system memory

427
00:22:44,676 --> 00:22:49,876 A:middle
for these vertex and index
buffers inside of the mesh.

428
00:22:50,136 --> 00:22:53,596 A:middle
And when you want to actually
render it, we will need to copy

429
00:22:53,626 --> 00:22:56,816 A:middle
from that system memory down
into the GPU backed memory.

430
00:22:56,816 --> 00:23:01,926 A:middle
So for efficiency, it's
really desirable to use one

431

432
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

433
00:22:56,816 --> 00:23:01,926 A:middle
So for efficiency, it's
really desirable to use one

434
00:23:01,926 --> 00:23:05,026 A:middle
of these mesh buffer allocators,
and here is how you use it.

435
00:23:06,106 --> 00:23:09,856 A:middle
Now, we are going to
load our asset file.

436
00:23:10,086 --> 00:23:16,806 A:middle
We will supply the URL location,
the model I/0 vertex descriptor

437
00:23:16,806 --> 00:23:19,996 A:middle
which will tell model I/0
how to lay out each vertex

438
00:23:21,366 --> 00:23:24,406 A:middle
and we will also supply
this mesh buffer allocator

439
00:23:24,996 --> 00:23:28,006 A:middle
so that model I/0 can
load this data directly

440
00:23:28,006 --> 00:23:29,656 A:middle
into GPU backed memory.

441
00:23:30,916 --> 00:23:35,336 A:middle
So now that we have
got our asset,

442
00:23:35,556 --> 00:23:37,986 A:middle
let's actually create
some MetalKit mesh

443
00:23:37,986 --> 00:23:39,146 A:middle
and some mesh objects.

444
00:23:39,146 --> 00:23:43,636 A:middle
So here's an example of an asset

445
00:23:43,636 --> 00:23:47,686 A:middle
that might be created
by model I/0.

446
00:23:47,866 --> 00:23:51,606 A:middle
Inside of an asset, we
might have camera objects,

447
00:23:53,236 --> 00:23:57,616 A:middle
light objects, and
particularly important

448
00:23:57,616 --> 00:23:59,966 A:middle
to us right now are
the mesh objects.

449

450
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

451
00:24:00,346 --> 00:24:03,266 A:middle
Now, MetalKit is
primarily concerned

452
00:24:03,266 --> 00:24:04,166 A:middle
with these mesh objects.

453
00:24:04,166 --> 00:24:07,226 A:middle
It doesn't really deal
directly with the light

454
00:24:07,336 --> 00:24:10,876 A:middle
and camera objects because that
sort of data is very specific

455
00:24:11,166 --> 00:24:13,886 A:middle
to your custom shaders
and your engines.

456
00:24:14,676 --> 00:24:18,246 A:middle
You can actually
introspect into this object

457
00:24:18,246 --> 00:24:20,876 A:middle
or go look inside this object
and grab out that camera

458
00:24:20,876 --> 00:24:23,806 A:middle
and light information to
plug it into your shaders,

459
00:24:24,086 --> 00:24:27,106 A:middle
but MetalKit isn't directly
involved in that process.

460
00:24:28,116 --> 00:24:38,066 A:middle
So what we can do is pass
in this asset directly

461
00:24:38,066 --> 00:24:42,386 A:middle
to this mesh, meshes
from asset class function

462
00:24:42,756 --> 00:24:46,246 A:middle
which will create an
array of MetalKit meshes.

463
00:24:50,636 --> 00:24:54,006 A:middle
Let's take a look at what's
inside this mesh object.

464
00:24:55,276 --> 00:24:57,476 A:middle
So first are these
vertex buffers

465
00:24:57,476 --> 00:25:00,106 A:middle
which includes the
position attributes,

466

467
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

468
00:24:57,476 --> 00:25:00,106 A:middle
which includes the
position attributes,

469
00:25:00,366 --> 00:25:04,006 A:middle
the normal attributes,
textural attributes, et cetera.

470
00:25:04,406 --> 00:25:07,496 A:middle
In our example, we
only needed one array

471
00:25:07,696 --> 00:25:09,366 A:middle
because we interleaved
all of our data.

472
00:25:09,946 --> 00:25:13,696 A:middle
However, you can define the
layout to use multiple arrays,

473
00:25:13,696 --> 00:25:17,216 A:middle
and therefore you would have
multiple vertex buffers.

474
00:25:17,376 --> 00:25:21,326 A:middle
You could define that
attribute 0 would be inside

475
00:25:21,426 --> 00:25:23,966 A:middle
of a single array, so you would
have an array of positions

476
00:25:24,476 --> 00:25:28,156 A:middle
in one array, an array of
texture coordinates in the next,

477
00:25:28,636 --> 00:25:32,056 A:middle
another array with
colors, and so on.

478
00:25:35,276 --> 00:25:37,696 A:middle
The mesh also includes
a vertex descriptor

479
00:25:37,696 --> 00:25:39,336 A:middle
which defines this layout

480
00:25:39,436 --> 00:25:41,896 A:middle
and it's the same object
we just created and passed

481
00:25:41,896 --> 00:25:45,266 A:middle
in when we initialized
our asset.

482
00:25:46,026 --> 00:25:49,716 A:middle
And finally, the mesh contains
a number of sub mesh objects.

483
00:25:50,086 --> 00:25:53,666 A:middle
Now, the key part of each
sub mesh object is this index

484
00:25:53,696 --> 00:25:57,506 A:middle
buffer, which references
vertices inside the

485
00:25:57,506 --> 00:25:59,846 A:middle
vertex buffer.

486

487
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

488
00:26:00,016 --> 00:26:03,076 A:middle
Additionally, there are a number
of properties which you can use

489
00:26:03,566 --> 00:26:08,556 A:middle
to make a draw call with Metal.

490
00:26:08,696 --> 00:26:12,696 A:middle
So now that we have
got our Metal kit mesh

491
00:26:12,696 --> 00:26:21,086 A:middle
and sub mesh objects, let's
go ahead and render them.

492
00:26:21,586 --> 00:26:26,046 A:middle
So first we will iterate
through each vertex buffer.

493
00:26:27,426 --> 00:26:29,796 A:middle
Now, we may have a sparse
array, so we need to make sure

494
00:26:29,796 --> 00:26:32,136 A:middle
that there is actually
something in each buffer,

495
00:26:32,136 --> 00:26:35,956 A:middle
but once we are sure of
that, we can continue on

496
00:26:35,956 --> 00:26:39,716 A:middle
and set the vertex buffer
in our render encoder.

497
00:26:40,696 --> 00:26:43,346 A:middle
Now, the vertex buffer
actually has two properties,

498
00:26:43,556 --> 00:26:47,126 A:middle
the buffer itself, and an
offset within the buffer

499
00:26:47,616 --> 00:26:50,026 A:middle
where your vertex data resides.

500
00:26:50,026 --> 00:26:57,046 A:middle
We also need to supply a buffer
index telling the pipeline

501
00:26:57,546 --> 00:26:59,316 A:middle
exactly where the data is.

502
00:26:59,946 --> 00:27:03,826 A:middle
Now, we will actually
render our mesh.

503

504
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

505
00:26:59,946 --> 00:27:03,826 A:middle
Now, we will actually
render our mesh.

506
00:27:04,756 --> 00:27:06,466 A:middle
We will iterate through
every sub mesh,

507
00:27:07,906 --> 00:27:10,156 A:middle
and make our draw
index primitives call.

508
00:27:11,126 --> 00:27:15,506 A:middle
Note here that the sub mesh
has all of the parameters

509
00:27:15,506 --> 00:27:18,496 A:middle
for this draw index parameter.

510
00:27:20,416 --> 00:27:25,486 A:middle
So today we posted this
MetalKit essentials sample

511
00:27:25,486 --> 00:27:28,696 A:middle
on the WWDC 2015 site.

512
00:27:29,396 --> 00:27:31,356 A:middle
I encourage you to download it.

513
00:27:31,356 --> 00:27:34,116 A:middle
It describes a number of
the techniques I described.

514
00:27:34,506 --> 00:27:38,936 A:middle
It uses model I/0 to load this
little airplane object that's

515
00:27:38,996 --> 00:27:44,666 A:middle
stuffed in an OBJ file and
creates a MetalKit mesh

516
00:27:45,126 --> 00:27:47,226 A:middle
and renders it on screen.

517
00:27:47,526 --> 00:27:51,186 A:middle
So you can get an idea of
exactly how this is all done.

518
00:27:51,686 --> 00:27:55,966 A:middle
So I encourage you
to check that out.

519
00:27:56,226 --> 00:27:58,356 A:middle
So that's it for me,
my name is Dan Omachi,

520
00:27:58,616 --> 00:28:02,076 A:middle
I will be at the Metal Lab
tomorrow if you have questions

521

522
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

523
00:27:58,616 --> 00:28:02,076 A:middle
I will be at the Metal Lab
tomorrow if you have questions

524
00:28:02,076 --> 00:28:03,516 A:middle
about topics I have discussed.

525
00:28:03,516 --> 00:28:07,366 A:middle
I would like to welcome my
colleague, Anna Tikhonova

526
00:28:07,366 --> 00:28:12,336 A:middle
on stage to talk about the Metal
performance shaders frameworks.

527
00:28:12,636 --> 00:28:12,976 A:middle
Thank you.

528
00:28:13,516 --> 00:28:18,546 A:middle
[ Applause ]

529
00:28:19,046 --> 00:28:19,386 A:middle
>> ANNA TIKHONOVA: Good morning.

530
00:28:20,276 --> 00:28:22,676 A:middle
Thank you, Dan, for the
introduction, my name is Anna

531
00:28:23,206 --> 00:28:26,086 A:middle
and I will be talking to you
about Metal performance shaders.

532
00:28:26,266 --> 00:28:26,996 A:middle
Let's get started.

533
00:28:27,946 --> 00:28:29,926 A:middle
So first of all, what is it?

534
00:28:30,406 --> 00:28:34,276 A:middle
It's a framework of optimized
high performance data parallel

535
00:28:34,276 --> 00:28:35,926 A:middle
algorithms for the GPU in Metal.

536
00:28:37,066 --> 00:28:38,156 A:middle
When and why would you use it?

537
00:28:39,136 --> 00:28:41,466 A:middle
If you are writing
C code and you want

538
00:28:41,466 --> 00:28:42,996 A:middle
to add a common sorting
algorithm

539
00:28:42,996 --> 00:28:46,486 A:middle
to your CPU application, you are
very unlikely to implement one

540
00:28:46,486 --> 00:28:49,346 A:middle
from scratch unless it
was out of self-interest.

541
00:28:49,976 --> 00:28:52,736 A:middle
You are a lot more likely to
use the implementation provided

542
00:28:52,736 --> 00:28:56,746 A:middle
to you by the library because
it's already been debugged

543
00:28:56,986 --> 00:28:58,096 A:middle
and optimized for you.

544
00:28:59,006 --> 00:29:02,036 A:middle
Likewise, if you wanted to add
an image processing operation

545

546
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

547
00:28:59,006 --> 00:29:02,036 A:middle
Likewise, if you wanted to add
an image processing operation

548
00:29:02,036 --> 00:29:05,496 A:middle
to your CPU application,
on our platform,

549
00:29:05,496 --> 00:29:07,086 A:middle
you would use the
accelerate framework

550
00:29:07,466 --> 00:29:08,716 A:middle
because it uses vImage.

551
00:29:09,596 --> 00:29:10,796 A:middle
It's a powerful,

552
00:29:10,796 --> 00:29:14,976 A:middle
high-performance tuned image
processing framework for --

553
00:29:16,256 --> 00:29:19,136 A:middle
that utilizes the CPU's
vector processing.

554
00:29:19,656 --> 00:29:21,536 A:middle
These are just a few examples.

555
00:29:22,516 --> 00:29:25,636 A:middle
The point is that there is
a rich environment available

556
00:29:25,636 --> 00:29:26,836 A:middle
for your CPU applications.

557
00:29:27,496 --> 00:29:30,096 A:middle
On the GPU the story
is a bit different,

558
00:29:30,866 --> 00:29:33,366 A:middle
you simply have fewer
options but we would

559
00:29:33,366 --> 00:29:34,466 A:middle
like to change the story.

560
00:29:34,546 --> 00:29:38,136 A:middle
Our goal is to enrich your
Metal programming environment.

561
00:29:38,776 --> 00:29:42,536 A:middle
We have selected a
collection of common filters

562
00:29:42,756 --> 00:29:45,746 A:middle
that we see often used in
graphic processing pipelines

563
00:29:46,066 --> 00:29:47,956 A:middle
in your image processing
applications and games.

564
00:29:49,736 --> 00:29:53,656 A:middle
These algorithms are
optimized for iOS and available

565
00:29:53,906 --> 00:29:55,966 A:middle
in iOS 9 for the A8 processor.

566
00:29:56,996 --> 00:30:00,306 A:middle
The Metal performance shaders
framework has two goals,

567

568
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

569
00:29:56,996 --> 00:30:00,306 A:middle
The Metal performance shaders
framework has two goals,

570
00:30:00,786 --> 00:30:02,956 A:middle
performance and ease of use.

571
00:30:03,336 --> 00:30:05,416 A:middle
It's designed to
integrate easily

572
00:30:05,496 --> 00:30:06,726 A:middle
into your Metal applications.

573
00:30:07,476 --> 00:30:10,136 A:middle
It operates on Metal
resources directly.

574
00:30:10,596 --> 00:30:13,356 A:middle
They are the input
and the output.

575
00:30:13,356 --> 00:30:14,936 A:middle
We are not only giving
you collection

576
00:30:15,206 --> 00:30:18,086 A:middle
of these high performance
optimized awesome kernels --

577
00:30:18,386 --> 00:30:22,156 A:middle
we are giving you that, but
we are also taking care of all

578
00:30:22,156 --> 00:30:24,996 A:middle
of the host code necessary
to launch these kernels.

579
00:30:25,716 --> 00:30:28,756 A:middle
We take care of the
decision-making process of how

580
00:30:28,756 --> 00:30:30,996 A:middle
to split up the work for
parallel computation.

581
00:30:31,556 --> 00:30:35,556 A:middle
The work you have to do to take
advantage of this framework

582
00:30:35,556 --> 00:30:37,656 A:middle
in your applications
usually amounts

583
00:30:37,656 --> 00:30:40,266 A:middle
to only a few lines of code.

584
00:30:40,436 --> 00:30:42,636 A:middle
It's as simple as calling
a library function.

585
00:30:44,226 --> 00:30:46,186 A:middle
So now that I have introduced
the framework to you,

586
00:30:46,366 --> 00:30:48,306 A:middle
let's take a look at the
available operations.

587
00:30:49,296 --> 00:30:52,396 A:middle
Here is a full list and let's
start from the beginning.

588
00:30:52,666 --> 00:30:54,296 A:middle
I will cover just a
few of these actually

589
00:30:54,476 --> 00:30:55,586 A:middle
and I will show you examples.

590
00:30:56,756 --> 00:30:59,806 A:middle
So first, the framework
supports the histogram filter

591
00:30:59,806 --> 00:31:02,726 A:middle
and the histogram equalization
and specification filters.

592

593
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

594
00:30:59,806 --> 00:31:02,726 A:middle
and the histogram equalization
and specification filters.

595
00:31:03,846 --> 00:31:06,116 A:middle
The equalization and
specification filters,

596
00:31:06,566 --> 00:31:10,596 A:middle
they allow you to
change the distribution

597
00:31:10,596 --> 00:31:12,216 A:middle
of color intensities
in your image.

598
00:31:12,446 --> 00:31:15,076 A:middle
The equalization filter
is a special case.

599
00:31:15,536 --> 00:31:16,946 A:middle
It changes the distribution

600
00:31:17,396 --> 00:31:20,016 A:middle
from the current
distribution to the uniform one.

601
00:31:20,736 --> 00:31:23,046 A:middle
And the specification
filter enables you

602
00:31:23,046 --> 00:31:24,866 A:middle
to set any distribution
of your choice.

603
00:31:25,216 --> 00:31:27,606 A:middle
You specify the histogram that
will be used in the filter.

604
00:31:30,576 --> 00:31:34,386 A:middle
This is an example of
the equalization filter.

605
00:31:34,936 --> 00:31:40,186 A:middle
It increases the global
contrast in the image.

606
00:31:40,366 --> 00:31:43,216 A:middle
Here it brings out the rainbow
in the sky quite beautifully.

607
00:31:43,956 --> 00:31:45,446 A:middle
One thing I'd like to mention

608
00:31:45,846 --> 00:31:48,606 A:middle
about these filters is they
are not an end in themselves.

609
00:31:49,496 --> 00:31:51,606 A:middle
They can be used as
an intermediate step

610
00:31:52,026 --> 00:31:53,476 A:middle
in a more complex algorithm.

611
00:31:53,826 --> 00:31:57,336 A:middle
The histogram filter can be
used as an intermediate step

612
00:31:57,336 --> 00:31:58,636 A:middle
in implementing tune mapping,

613
00:31:58,966 --> 00:32:01,646 A:middle
which is a technique commonly
used by graphics developers

614

615
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

616
00:31:58,966 --> 00:32:01,646 A:middle
which is a technique commonly
used by graphics developers

617
00:32:02,096 --> 00:32:05,076 A:middle
to approximate the appearance
of high dynamic range.

618
00:32:05,676 --> 00:32:09,756 A:middle
So moving on, we also
support Lancos resampling.

619
00:32:10,226 --> 00:32:13,456 A:middle
It's a high-quality resampling
algorithm that can used

620
00:32:13,576 --> 00:32:16,476 A:middle
to downscale, upscale,
squeeze, and stretch images.

621
00:32:16,476 --> 00:32:21,906 A:middle
In this example, I
stretched the image vertically

622
00:32:22,086 --> 00:32:24,566 A:middle
and squeezed it horizontally
while preserving all

623
00:32:24,566 --> 00:32:25,506 A:middle
of the image content.

624
00:32:27,396 --> 00:32:29,566 A:middle
You also support the
thresholding filter.

625
00:32:30,156 --> 00:32:31,956 A:middle
It can be used to
find image edges

626
00:32:32,076 --> 00:32:33,486 A:middle
if chained with a Sobel filter.

627
00:32:34,746 --> 00:32:36,296 A:middle
Let's take a look at an example.

628
00:32:36,776 --> 00:32:39,776 A:middle
This is the output of
the thresholding filter,

629
00:32:39,776 --> 00:32:44,926 A:middle
and now it's fed into the Sobel
filter to give you image edges.

630
00:32:46,626 --> 00:32:49,666 A:middle
And finally we support
a whole range

631
00:32:49,666 --> 00:32:52,616 A:middle
of convolution kernels
including general convolution,

632
00:32:52,616 --> 00:32:55,296 A:middle
where you can specify your
own convolution matrix.

633
00:32:55,356 --> 00:32:57,716 A:middle
And we also support
Gaussian blur,

634
00:32:57,936 --> 00:32:59,696 A:middle
box tent, and Sobel filters.

635

636
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

637
00:33:00,196 --> 00:33:03,136 A:middle
My final example will
be of a Gaussian blur.

638
00:33:03,766 --> 00:33:05,326 A:middle
You should all be
very familiar with it;

639
00:33:05,706 --> 00:33:07,076 A:middle
we like to use it in our UI.

640
00:33:07,806 --> 00:33:09,936 A:middle
What if you wanted to
use a Gaussian blur

641
00:33:09,936 --> 00:33:11,426 A:middle
in your own application,

642
00:33:12,366 --> 00:33:15,396 A:middle
the Metal performance shaders
framework makes it very easy.

643
00:33:16,736 --> 00:33:17,616 A:middle
How easy, you ask?

644
00:33:18,716 --> 00:33:20,186 A:middle
I'm building some
anticipation here.

645
00:33:20,666 --> 00:33:23,206 A:middle
It's just two lines of code.

646
00:33:23,536 --> 00:33:28,466 A:middle
You first have to create a blur
filter object, and then you have

647
00:33:28,466 --> 00:33:33,356 A:middle
to encode the filter
to the command buffer.

648
00:33:33,986 --> 00:33:35,796 A:middle
And that's it [applause].

649
00:33:37,466 --> 00:33:38,226 A:middle
Thank you, guys.

650
00:33:40,906 --> 00:33:43,716 A:middle
And one thing I just wanted to
point out again and just note is

651
00:33:43,716 --> 00:33:47,536 A:middle
that this API takes your common
Metal resources as input.

652
00:33:48,146 --> 00:33:50,036 A:middle
Your device, your command
buffer, your textures.

653
00:33:51,096 --> 00:33:53,496 A:middle
These are the Metal resources

654
00:33:53,496 --> 00:33:55,176 A:middle
that you already create
in your application.

655
00:33:55,736 --> 00:33:59,116 A:middle
And now that I have shown
you these two lines of code,

656
00:33:59,536 --> 00:34:01,816 A:middle
let's take a look
at where they plug

657

658
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

659
00:33:59,536 --> 00:34:01,816 A:middle
let's take a look
at where they plug

660
00:34:01,816 --> 00:34:03,926 A:middle
in into your current
Metal work flow.

661
00:34:04,436 --> 00:34:06,336 A:middle
So this is a graphical
representation

662
00:34:06,336 --> 00:34:07,086 A:middle
of your command buffer.

663
00:34:08,436 --> 00:34:10,686 A:middle
It contains all of the
commands you are going

664
00:34:10,686 --> 00:34:11,866 A:middle
to be submitting to the device.

665
00:34:12,716 --> 00:34:14,755 A:middle
You do your work as
you usually would.

666
00:34:15,056 --> 00:34:17,025 A:middle
You render your scene
by issuing draw calls

667
00:34:18,326 --> 00:34:21,206 A:middle
and you do your post processing
effect by dispatching kernels.

668
00:34:21,545 --> 00:34:23,536 A:middle
Now you have decided that one

669
00:34:23,536 --> 00:34:26,136 A:middle
of your post processing effects
is going to be a blur filter.

670
00:34:26,976 --> 00:34:29,576 A:middle
So this is exactly
where it goes.

671
00:34:30,346 --> 00:34:34,315 A:middle
And don't forget that you still
have to submit your commands

672
00:34:34,315 --> 00:34:36,396 A:middle
to the device as
you normally would.

673
00:34:36,396 --> 00:34:37,356 A:middle
Nothing changes here.

674
00:34:38,106 --> 00:34:41,446 A:middle
And now, if you would like
to look at the sample code

675
00:34:41,446 --> 00:34:43,466 A:middle
for the example I was
just going through,

676
00:34:43,466 --> 00:34:44,485 A:middle
you could do so right now.

677
00:34:44,485 --> 00:34:46,295 A:middle
You can go to
developer.Apple.com

678
00:34:46,585 --> 00:34:49,275 A:middle
and download the example called
Metal performance shaders

679
00:34:49,356 --> 00:34:49,926 A:middle
hello world.

680
00:34:51,315 --> 00:34:54,626 A:middle
I've mentioned before that
the Metal performance shaders

681
00:34:54,626 --> 00:34:57,566 A:middle
framework has two goals,
performance and ease of use.

682
00:34:57,666 --> 00:35:00,206 A:middle
I just showed you how
easy it is to use.

683

684
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

685
00:34:57,666 --> 00:35:00,206 A:middle
I just showed you how
easy it is to use.

686
00:35:01,116 --> 00:35:03,056 A:middle
Let's take a quick
look behind the scenes

687
00:35:03,556 --> 00:35:05,416 A:middle
at what's giving you
this performance.

688
00:35:07,676 --> 00:35:10,606 A:middle
For every one of these filters
including the Gaussian blur

689
00:35:10,606 --> 00:35:13,656 A:middle
filter, we had to choose
the right algorithm.

690
00:35:14,106 --> 00:35:18,676 A:middle
The right here means correct
and it has to be the fastest.

691
00:35:19,346 --> 00:35:24,606 A:middle
The fastest for a particular
combination of input data,

692
00:35:24,836 --> 00:35:27,366 A:middle
input parameters,
and device GPU.

693
00:35:28,276 --> 00:35:30,286 A:middle
What do I mean by this?

694
00:35:30,366 --> 00:35:32,686 A:middle
There are multiple ways to
implement Gaussian blur.

695
00:35:32,686 --> 00:35:36,346 A:middle
There are constant
cost, log 2, linear,

696
00:35:36,346 --> 00:35:37,736 A:middle
and brute force algorithms.

697
00:35:39,276 --> 00:35:40,906 A:middle
All of these approaches
have different start

698
00:35:40,906 --> 00:35:42,296 A:middle
up costs and overheads.

699
00:35:42,666 --> 00:35:45,636 A:middle
One approach may work really
well for a small kernel radius

700
00:35:45,976 --> 00:35:48,806 A:middle
but perform very poorly
on a large kernel radius.

701
00:35:49,976 --> 00:35:54,326 A:middle
The point is we had to implement
each one of these approaches

702
00:35:54,406 --> 00:35:57,126 A:middle
and find out experimentally
which one is going

703
00:35:57,126 --> 00:35:59,536 A:middle
to be the fastest for a
particular combination

704
00:35:59,536 --> 00:36:03,956 A:middle
of input problem, input
parameters, and device GPU.

705

706
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

707
00:35:59,536 --> 00:36:03,956 A:middle
of input problem, input
parameters, and device GPU.

708
00:36:03,956 --> 00:36:09,076 A:middle
And after this process, all
of the kernels had to be tuned

709
00:36:09,076 --> 00:36:11,266 A:middle
for such parameters
as your kernel radius,

710
00:36:12,436 --> 00:36:13,456 A:middle
your pixel format,

711
00:36:14,416 --> 00:36:16,936 A:middle
your underlying hardware
architecture's memory hierarchy,

712
00:36:17,326 --> 00:36:19,776 A:middle
and such parameters as
number of pixels per thread

713
00:36:19,776 --> 00:36:20,846 A:middle
and thread group dimensions.

714
00:36:21,206 --> 00:36:23,636 A:middle
This is what determines how to
split up your work in parallel.

715
00:36:23,636 --> 00:36:26,476 A:middle
And finally, I would
like to mention

716
00:36:27,196 --> 00:36:30,626 A:middle
that the framework also performs
CPU optimizations for you.

717
00:36:31,176 --> 00:36:35,016 A:middle
It optimizes program
loading speed.

718
00:36:36,266 --> 00:36:40,546 A:middle
It also reuses intermediate
textures,

719
00:36:41,206 --> 00:36:45,096 A:middle
and finally it does some compute
encoder optimization for you.

720
00:36:45,146 --> 00:36:47,256 A:middle
Specifically, it can defect

721
00:36:47,646 --> 00:36:51,106 A:middle
if you are using multiple
computing coders in a row and if

722
00:36:51,106 --> 00:36:52,416 A:middle
so it will coalesce them.

723
00:36:53,116 --> 00:36:58,896 A:middle
And after we have done all
of these steps for you,

724
00:36:58,896 --> 00:37:01,076 A:middle
that's cool, but what would
this actually look like in terms

725

726
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

727
00:36:58,896 --> 00:37:01,076 A:middle
that's cool, but what would
this actually look like in terms

728
00:37:01,076 --> 00:37:03,776 A:middle
of code, for example, for an
optimized Gaussian blur shader

729
00:37:03,776 --> 00:37:04,736 A:middle
that I just showed you?

730
00:37:07,436 --> 00:37:08,656 A:middle
Well, are you ready for it?

731
00:37:09,686 --> 00:37:11,926 A:middle
Here is the code.

732
00:37:12,436 --> 00:37:13,606 A:middle
So now all of you know how

733
00:37:13,606 --> 00:37:15,726 A:middle
to implement your own
optimized Gaussian blur, right?

734
00:37:16,196 --> 00:37:17,396 A:middle
I bet you didn't
know you were going

735
00:37:17,396 --> 00:37:19,046 A:middle
to learn this in this session.

736
00:37:19,826 --> 00:37:23,016 A:middle
Basically all joking aside,
this is 49 Metal kernels,

737
00:37:23,066 --> 00:37:25,066 A:middle
2,000 lines of kernel code

738
00:37:25,296 --> 00:37:29,756 A:middle
and 821 different Metal
Gaussian blur implementations

739
00:37:30,576 --> 00:37:33,706 A:middle
where each implementation
is some combination

740
00:37:33,706 --> 00:37:37,426 A:middle
of these 49 Metal kernels, so it
looks like a lot of work we did

741
00:37:37,686 --> 00:37:39,566 A:middle
and now you don't have to.

742
00:37:39,566 --> 00:37:40,946 A:middle
Now, let's take a look

743
00:37:40,946 --> 00:37:50,216 A:middle
at the Metal performance
shaders framework in action.

744
00:37:50,316 --> 00:37:53,286 A:middle
So first, I will
demonstrate the performance

745
00:37:53,366 --> 00:37:58,556 A:middle
of a simple textbook separable
Gaussian blur implementation

746
00:37:59,466 --> 00:38:01,486 A:middle
that took only minutes
to write in Metal.

747

748
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

749
00:37:59,466 --> 00:38:01,486 A:middle
that took only minutes
to write in Metal.

750
00:38:01,656 --> 00:38:04,026 A:middle
This is probably something you
would start with if you had

751
00:38:04,026 --> 00:38:05,646 A:middle
to implement your own blur

752
00:38:05,646 --> 00:38:07,806 A:middle
and you didn't have Metal
performance shaders available

753
00:38:07,806 --> 00:38:08,086 A:middle
to you.

754
00:38:08,456 --> 00:38:11,336 A:middle
So now we are happily running
at 60 frames per second

755
00:38:11,336 --> 00:38:12,996 A:middle
but we are not actually
doing any work yet.

756
00:38:13,996 --> 00:38:15,186 A:middle
The sigma value is 0.

757
00:38:15,606 --> 00:38:19,466 A:middle
Let's change the sigma value
to 6 and we are down to

758
00:38:19,466 --> 00:38:21,146 A:middle
about 8 frames per second.

759
00:38:21,956 --> 00:38:23,046 A:middle
Dare we go any further?

760
00:38:23,376 --> 00:38:24,736 A:middle
Let's try a sigma of 20.

761
00:38:25,396 --> 00:38:30,896 A:middle
Okay. And we are down
to 3 frames per second

762
00:38:30,896 --> 00:38:32,176 A:middle
so that's not going to work.

763
00:38:33,006 --> 00:38:34,806 A:middle
Let's switch to the
Metal performance

764
00:38:34,806 --> 00:38:35,956 A:middle
shaders implementation.

765
00:38:36,566 --> 00:38:39,946 A:middle
So now we are back to
60 frames per second,

766
00:38:39,946 --> 00:38:42,626 A:middle
not doing any work, sigma of 6.

767
00:38:43,416 --> 00:38:44,846 A:middle
Still 60 frames per second.

768
00:38:45,576 --> 00:38:46,556 A:middle
Sigma of 20.

769
00:38:47,136 --> 00:38:48,586 A:middle
Still 60 frames per second.

770
00:38:49,876 --> 00:38:53,366 A:middle
And, of course, we had to go
further and really blur it,

771
00:38:53,706 --> 00:38:55,226 A:middle
still at 60 frames per second.

772
00:38:55,226 --> 00:38:56,486 A:middle
So this looks like a winner.

773

774
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

775
00:39:02,516 --> 00:39:12,026 A:middle
[ Applause ]

776
00:39:12,526 --> 00:39:12,656 A:middle
Okay.

777
00:39:13,046 --> 00:39:15,336 A:middle
So your screen refresh
rate is 60 hertz.

778
00:39:17,096 --> 00:39:21,056 A:middle
This means that we are running
at 60 frames we are second,

779
00:39:21,056 --> 00:39:24,956 A:middle
so the performance of this
optimized Gaussian blur shader

780
00:39:24,956 --> 00:39:28,326 A:middle
you have seen in the demo is
capped at 60 frames per second.

781
00:39:28,966 --> 00:39:33,786 A:middle
This means that you have 16.6
milliseconds to draw your frame,

782
00:39:33,786 --> 00:39:36,566 A:middle
and this also includes
any compositing work

783
00:39:36,596 --> 00:39:39,306 A:middle
that your system
might need to do.

784
00:39:39,806 --> 00:39:43,066 A:middle
This chart shows you
the execution time

785
00:39:43,646 --> 00:39:46,616 A:middle
of this optimized Gaussian blur
filter for different values

786
00:39:46,616 --> 00:39:51,096 A:middle
of sigma and as you can see,
the execution time is a lot less

787
00:39:51,246 --> 00:39:52,756 A:middle
than 16.6 milliseconds.

788
00:39:53,436 --> 00:39:56,416 A:middle
So this means that you
still have some extra time

789
00:39:56,416 --> 00:39:57,976 A:middle
to do additional GPU work,

790
00:39:59,496 --> 00:40:02,766 A:middle
and still hit the desired
60 frames per second.

791

792
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

793
00:39:59,496 --> 00:40:02,766 A:middle
and still hit the desired
60 frames per second.

794
00:40:03,416 --> 00:40:07,036 A:middle
And now there are just a
few more details I would

795
00:40:07,036 --> 00:40:07,596 A:middle
like to cover.

796
00:40:08,966 --> 00:40:12,266 A:middle
Sometimes you will need to
work on very large images

797
00:40:12,266 --> 00:40:13,376 A:middle
and you will need to tile them.

798
00:40:14,546 --> 00:40:16,036 A:middle
And sometimes you
will just need to work

799
00:40:16,036 --> 00:40:17,186 A:middle
on a portion of your image.

800
00:40:17,186 --> 00:40:18,976 A:middle
So there is a mechanism
for that.

801
00:40:19,486 --> 00:40:22,616 A:middle
It's called source offset
and destination clip Rect.

802
00:40:23,106 --> 00:40:25,616 A:middle
Clip rect has an
origin and size.

803
00:40:26,206 --> 00:40:28,866 A:middle
It determines the region
of the destination texture,

804
00:40:28,866 --> 00:40:32,416 A:middle
which is going to be
updated by a filter.

805
00:40:32,416 --> 00:40:34,346 A:middle
The source offset
only has an origin.

806
00:40:35,136 --> 00:40:37,356 A:middle
The size is implicit, it's
determined by the clip rect,

807
00:40:37,356 --> 00:40:40,066 A:middle
and it is just an offset
from the upper left corner

808
00:40:40,066 --> 00:40:41,436 A:middle
of your source texture.

809
00:40:42,316 --> 00:40:45,366 A:middle
They work together to
give you the final image.

810
00:40:45,916 --> 00:40:50,716 A:middle
In the Metal performance
shaders framework your source

811
00:40:50,716 --> 00:40:53,646 A:middle
and destination can be
one in the same texture.

812
00:40:54,096 --> 00:40:56,066 A:middle
In this case, the clip rect

813
00:40:56,896 --> 00:40:59,546 A:middle
and source offset work
exactly the same way.

814

815
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

816
00:41:00,126 --> 00:41:06,246 A:middle
When the source and destination
are the same texture,

817
00:41:06,406 --> 00:41:08,246 A:middle
we call it an in
place operation.

818
00:41:08,836 --> 00:41:09,846 A:middle
Use it to save memory.

819
00:41:09,846 --> 00:41:12,386 A:middle
How could you do you
actually encode one

820
00:41:12,386 --> 00:41:13,466 A:middle
of these filters in place?

821
00:41:14,836 --> 00:41:17,936 A:middle
You have to use the encode to
command buffer method that takes

822
00:41:17,936 --> 00:41:20,606 A:middle
in place texture and a fall
by back copy allocator.

823
00:41:22,376 --> 00:41:25,346 A:middle
One thing to keep in mind
here, it's not always possible

824
00:41:25,346 --> 00:41:26,716 A:middle
for the shaders to run in place.

825
00:41:27,076 --> 00:41:28,596 A:middle
It depends on your filter,

826
00:41:28,996 --> 00:41:30,506 A:middle
on the filter parameters
and properties.

827
00:41:31,106 --> 00:41:32,806 A:middle
If you want this operation

828
00:41:32,806 --> 00:41:35,486 A:middle
to always succeed,
use a copy allocator.

829
00:41:35,726 --> 00:41:40,086 A:middle
It will be called automatically,
only in the situation where the

830
00:41:40,086 --> 00:41:41,646 A:middle
in place operation
is not possible.

831
00:41:42,046 --> 00:41:44,866 A:middle
And we will create a new
destination texture for you

832
00:41:46,216 --> 00:41:47,736 A:middle
so that the operation
can proceed

833
00:41:47,736 --> 00:41:49,286 A:middle
out of place if necessary.

834
00:41:50,206 --> 00:41:54,206 A:middle
And here is an example of a
simple fall back copy allocator.

835
00:41:55,826 --> 00:41:58,946 A:middle
This one simply creates
a new destination texture

836
00:41:59,726 --> 00:42:02,886 A:middle
with the same pixel
format and dimensions

837

838
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

839
00:41:59,726 --> 00:42:02,886 A:middle
with the same pixel
format and dimensions

840
00:42:02,886 --> 00:42:04,626 A:middle
as the source texture,
very simple.

841
00:42:05,326 --> 00:42:08,016 A:middle
So now I have shown you
an example before of an

842
00:42:08,016 --> 00:42:10,796 A:middle
in place operation where
you only modified a portion

843
00:42:10,796 --> 00:42:13,976 A:middle
of your destination texture
and everything outside

844
00:42:13,976 --> 00:42:15,866 A:middle
of the clip rect
remained unchanged.

845
00:42:16,226 --> 00:42:18,366 A:middle
You can also do this
in the copy allocator.

846
00:42:19,346 --> 00:42:22,596 A:middle
Just initialize your destination
texture with the contexts

847
00:42:22,596 --> 00:42:23,536 A:middle
of your source texture.

848
00:42:24,136 --> 00:42:28,696 A:middle
And I would also like
to mention that all

849
00:42:28,696 --> 00:42:31,176 A:middle
of the usual Metal
resources such as your device

850
00:42:31,176 --> 00:42:33,316 A:middle
and your command buffer
are available to you

851
00:42:33,316 --> 00:42:34,286 A:middle
in the copy allocator.

852
00:42:34,796 --> 00:42:36,916 A:middle
Now that I have covered
these details,

853
00:42:37,166 --> 00:42:38,286 A:middle
let's jump into the summary.

854
00:42:38,846 --> 00:42:43,296 A:middle
I would like to say please use
the Metal support frameworks,

855
00:42:43,416 --> 00:42:46,416 A:middle
MetalKit and Metal performance
shaders, they are robust,

856
00:42:46,606 --> 00:42:49,716 A:middle
they are optimized, and as I
have shown you, they're easy

857
00:42:49,716 --> 00:42:51,486 A:middle
to integrate into your
Metal applications.

858
00:42:52,026 --> 00:42:54,586 A:middle
They will allow for faster bring
up time of your applications.

859
00:42:54,906 --> 00:42:56,216 A:middle
Now, you can spend the time

860
00:42:56,216 --> 00:42:58,316 A:middle
on making application
unique instead

861
00:42:58,316 --> 00:43:00,626 A:middle
of implementing common tasks.

862

863
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

864
00:42:58,316 --> 00:43:00,626 A:middle
of implementing common tasks.

865
00:43:00,626 --> 00:43:03,566 A:middle
And, of course, as an added
benefit, there is less code

866
00:43:03,566 --> 00:43:04,956 A:middle
for you to write and maintain.

867
00:43:05,736 --> 00:43:07,746 A:middle
And come to our labs,
give us feedback.

868
00:43:07,856 --> 00:43:10,366 A:middle
Let us know how to get
started or give us questions.

869
00:43:10,836 --> 00:43:14,106 A:middle
Let us know if there are new
utilities or shaders you would

870
00:43:14,106 --> 00:43:15,856 A:middle
like to see added to
the support frameworks.

871
00:43:16,466 --> 00:43:19,686 A:middle
You can always find
more information online.

872
00:43:19,786 --> 00:43:22,886 A:middle
We have documentation videos
available, and take advantage

873
00:43:22,886 --> 00:43:25,216 A:middle
of the Apple Developer
Forums and technical support.

874
00:43:25,496 --> 00:43:28,416 A:middle
For general inquiries,
contact our gaming technologies

875
00:43:28,416 --> 00:43:29,706 A:middle
evangelist Allan Schaffer.

876
00:43:31,926 --> 00:43:35,726 A:middle
You can watch the past sessions
online, but if you would

877
00:43:35,726 --> 00:43:38,236 A:middle
like to learn new Metal
performance optimization

878
00:43:38,236 --> 00:43:40,576 A:middle
techniques, come to
our talk tomorrow

879
00:43:40,576 --> 00:43:42,956 A:middle
at 11:00 a.m. Thank you.

880
00:43:44,516 --> 00:43:58,360 A:middle
[ Applause ]

881
