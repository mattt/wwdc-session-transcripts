X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:22,516 --> 00:00:29,546 A:middle
[Applause]

2
00:00:30,046 --> 00:00:32,006 A:middle
>> NIHAR SHARMA: Good
afternoon and welcome

3
00:00:32,006 --> 00:00:33,846 A:middle
to the CloudKit tips
and tricks session.

4
00:00:34,656 --> 00:00:36,816 A:middle
My name is Nihar Sharma
and I'm an engineer

5
00:00:36,816 --> 00:00:38,656 A:middle
on the CloudKit team.

6
00:00:39,076 --> 00:00:41,956 A:middle
I know some of you may be
completely new to our platform

7
00:00:42,226 --> 00:00:43,966 A:middle
and encountering the
CloudKit framework

8
00:00:44,046 --> 00:00:47,526 A:middle
for the first time while
others may already have an app

9
00:00:47,526 --> 00:00:48,086 A:middle
on the Store.

10
00:00:48,616 --> 00:00:51,036 A:middle
This session we will have
something for everyone.

11
00:00:51,456 --> 00:00:52,266 A:middle
Let's jump right in.

12
00:00:53,006 --> 00:00:55,306 A:middle
What is CloudKit?

13
00:00:56,406 --> 00:01:01,036 A:middle
Last year we introduced CloudKit
as a whole new way for you

14

15
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

16
00:00:56,406 --> 00:01:01,036 A:middle
Last year we introduced CloudKit
as a whole new way for you

17
00:01:01,036 --> 00:01:03,986 A:middle
to be able to talk to Apple's
iCloud database servers.

18
00:01:05,016 --> 00:01:08,636 A:middle
With that we gave you a set
of built-in technologies

19
00:01:09,286 --> 00:01:10,516 A:middle
like large file storage.

20
00:01:12,186 --> 00:01:15,286 A:middle
We gave you a privacy
conscious identifier to be able

21
00:01:15,286 --> 00:01:18,196 A:middle
to manage the users
who could now be anyone

22
00:01:18,196 --> 00:01:21,336 A:middle
with an iCloud account.

23
00:01:21,336 --> 00:01:25,926 A:middle
First and foremost, we made
this public facing developer API

24
00:01:26,246 --> 00:01:28,746 A:middle
because we wanted you to be
able to leverage the power

25
00:01:28,746 --> 00:01:31,706 A:middle
of this platform and build
great apps for your users.

26
00:01:32,176 --> 00:01:36,926 A:middle
Last but not the least,
Apple's heavily invested

27
00:01:36,926 --> 00:01:37,766 A:middle
in this technology.

28
00:01:38,146 --> 00:01:40,036 A:middle
Last year alone when
we first shipped,

29
00:01:40,656 --> 00:01:41,566 A:middle
we shipped with a couple

30
00:01:41,566 --> 00:01:43,906 A:middle
of major clients
including iCloud drive

31
00:01:44,086 --> 00:01:48,096 A:middle
and iCloud photo library,
and this year we added a host

32
00:01:48,096 --> 00:01:50,716 A:middle
of new clients like the
Notes app, the news app

33
00:01:51,316 --> 00:01:54,456 A:middle
and WWDC app a lot of you have
been using throughout the week

34
00:01:54,736 --> 00:01:58,176 A:middle
and have in your
hands right now.

35
00:01:58,176 --> 00:02:01,666 A:middle
If all of this sounds unfamiliar
to you, I invite you to go back

36

37
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

38
00:01:58,176 --> 00:02:01,666 A:middle
If all of this sounds unfamiliar
to you, I invite you to go back

39
00:02:01,666 --> 00:02:03,766 A:middle
and take a look at
the intro to CloudKit

40
00:02:03,916 --> 00:02:06,496 A:middle
and Advanced CloudKit sessions
from last year's conference.

41
00:02:06,876 --> 00:02:09,346 A:middle
They are a great resource for
an introduction to the new API,

42
00:02:09,346 --> 00:02:11,846 A:middle
and I highly recommend
you check them out.

43
00:02:12,476 --> 00:02:13,956 A:middle
First things first.

44
00:02:13,956 --> 00:02:16,206 A:middle
A lot of you have been playing

45
00:02:16,246 --> 00:02:18,886 A:middle
with the amazing new
features of Swift 2.

46
00:02:19,286 --> 00:02:22,396 A:middle
I'm pleased to announce
with iOS 9, the experience

47
00:02:22,396 --> 00:02:25,456 A:middle
of using CloudKit from
Swift is much better.

48
00:02:26,486 --> 00:02:28,646 A:middle
Let me give you a
couple of examples

49
00:02:28,646 --> 00:02:29,586 A:middle
of what I'm talking about.

50
00:02:30,256 --> 00:02:34,346 A:middle
Up until now, you had to use
the old set object for key,

51
00:02:34,346 --> 00:02:37,396 A:middle
object for key syntax when
setting and getting values

52
00:02:37,396 --> 00:02:40,386 A:middle
in the CK record, which are the
workhorse of the CloudKit API,

53
00:02:40,386 --> 00:02:44,176 A:middle
but with iOS 9, you can
use the much more familiar

54
00:02:44,176 --> 00:02:46,566 A:middle
and modern dictionary
subscripting syntax

55
00:02:46,776 --> 00:02:48,116 A:middle
when working with CK records.

56
00:02:48,636 --> 00:02:52,736 A:middle
In addition to that, we
have made your CloudKit code

57
00:02:52,896 --> 00:02:56,396 A:middle
from Swift as well as
Objective-C a lot more type safe

58
00:02:56,596 --> 00:02:58,486 A:middle
by adopting nullability
qualifiers

59
00:02:58,676 --> 00:02:59,756 A:middle
and Lightweight generics.

60

61
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

62
00:03:00,416 --> 00:03:05,196 A:middle
Previously you could have set
an array of objects of any type

63
00:03:05,566 --> 00:03:09,066 A:middle
on the records and safe
product of CKRecords operation.

64
00:03:09,726 --> 00:03:14,056 A:middle
Now with the latest tools in
iOS 9, the compiler can warn you

65
00:03:14,056 --> 00:03:16,676 A:middle
when you do that so you
can catch the errors early

66
00:03:16,966 --> 00:03:18,476 A:middle
and write more robust code.

67
00:03:18,476 --> 00:03:23,296 A:middle
So with that, let me
give you a brief recap

68
00:03:23,616 --> 00:03:25,306 A:middle
on the storage architecture
of CloudKit.

69
00:03:25,936 --> 00:03:31,136 A:middle
The top level silo in CloudKit
is called a CloudKit container.

70
00:03:32,246 --> 00:03:35,756 A:middle
It is subdivided
into two databases.

71
00:03:36,276 --> 00:03:39,766 A:middle
The public database, which
is a large soup of all

72
00:03:39,766 --> 00:03:43,136 A:middle
of your apps data shared
among all of your users,

73
00:03:43,686 --> 00:03:46,906 A:middle
and the private database
which is tied

74
00:03:46,906 --> 00:03:48,216 A:middle
to a user's iCloud account.

75
00:03:48,916 --> 00:03:50,496 A:middle
This database will contain data

76
00:03:50,496 --> 00:03:53,266 A:middle
for a particular iCloud
account shared across all

77
00:03:53,266 --> 00:03:54,376 A:middle
of that user's devices.

78
00:03:55,756 --> 00:03:59,366 A:middle
Within each database we have
a further layer of isolation

79
00:03:59,566 --> 00:04:01,036 A:middle
for the records you
store in them,

80

81
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

82
00:03:59,566 --> 00:04:01,036 A:middle
for the records you
store in them,

83
00:04:01,506 --> 00:04:03,106 A:middle
and we call these record zones.

84
00:04:04,516 --> 00:04:08,016 A:middle
They are a way for CloudKit to
offer additional capabilities

85
00:04:08,016 --> 00:04:10,056 A:middle
for the records you store
in them where we can.

86
00:04:10,056 --> 00:04:13,746 A:middle
If the public database has a
single zone called the default

87
00:04:13,746 --> 00:04:15,086 A:middle
zone where all the records live,

88
00:04:15,736 --> 00:04:20,216 A:middle
and the private database
also has one default zone.

89
00:04:20,636 --> 00:04:23,216 A:middle
Along with that, we
give you the capability

90
00:04:23,216 --> 00:04:25,336 A:middle
to create multiple custom zones

91
00:04:25,716 --> 00:04:29,196 A:middle
where you have these additional
capabilities for your records.

92
00:04:30,576 --> 00:04:33,756 A:middle
So with that, let's talk

93
00:04:33,756 --> 00:04:37,426 A:middle
about what we will cover
in our session today.

94
00:04:37,606 --> 00:04:39,386 A:middle
You might remember the
schema from last year.

95
00:04:39,836 --> 00:04:42,876 A:middle
We talked about an
example schema for an app

96
00:04:43,326 --> 00:04:44,686 A:middle
that shows parties with clouds.

97
00:04:45,046 --> 00:04:48,036 A:middle
It had a simple schema where
we had a party record type

98
00:04:48,036 --> 00:04:50,936 A:middle
and clown record type and stored
them in the public database.

99
00:04:51,766 --> 00:04:54,776 A:middle
I thought this year let's
run with this example

100
00:04:55,716 --> 00:04:57,496 A:middle
and develop a couple of
features for this app,

101
00:04:58,286 --> 00:05:00,336 A:middle
example app we'll
call clown central

102

103
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

104
00:04:58,286 --> 00:05:00,336 A:middle
example app we'll
call clown central

105
00:05:00,336 --> 00:05:02,896 A:middle
because it's all about clowns.

106
00:05:03,026 --> 00:05:07,036 A:middle
We will use the example to walk
through a set of tips and tricks

107
00:05:07,196 --> 00:05:09,076 A:middle
that you can use when
working with CloudKit.

108
00:05:09,076 --> 00:05:14,256 A:middle
Our app will have a simplistic
UI where we show the list

109
00:05:14,256 --> 00:05:17,266 A:middle
of parties and a couple of
features that we will walk

110
00:05:17,266 --> 00:05:19,976 A:middle
through together
in this session.

111
00:05:20,136 --> 00:05:23,606 A:middle
Now, through this example, there
are four major areas I want

112
00:05:23,606 --> 00:05:24,236 A:middle
to cover today.

113
00:05:25,676 --> 00:05:27,586 A:middle
Number one is error handling.

114
00:05:28,766 --> 00:05:30,476 A:middle
Last year we told
you a difference

115
00:05:30,476 --> 00:05:33,106 A:middle
between a CloudKit app
that handles errors and one

116
00:05:33,106 --> 00:05:34,966 A:middle
that does not is
not the difference

117
00:05:34,966 --> 00:05:36,756 A:middle
between a great app
and a good one.

118
00:05:37,136 --> 00:05:38,916 A:middle
It's a difference
between a functional app

119
00:05:39,116 --> 00:05:40,456 A:middle
and a completely broken one.

120
00:05:41,046 --> 00:05:42,156 A:middle
We meant it.

121
00:05:42,396 --> 00:05:45,626 A:middle
I would like to walk
you through a set

122
00:05:45,626 --> 00:05:48,416 A:middle
of special error codes you may
encounter when using the API

123
00:05:48,416 --> 00:05:50,696 A:middle
and give you some
general guidelines

124
00:05:50,876 --> 00:05:52,976 A:middle
on how to handle them.

125
00:05:53,396 --> 00:05:56,426 A:middle
With that, we'll start
talking about a couple of tips

126
00:05:56,426 --> 00:05:59,356 A:middle
that you can keep in mind
when maintaining a local cache

127
00:05:59,646 --> 00:06:00,676 A:middle
when working with CloudKit.

128

129
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

130
00:05:59,646 --> 00:06:00,676 A:middle
when working with CloudKit.

131
00:06:01,626 --> 00:06:04,156 A:middle
That will lead us into
talking about how to get set

132
00:06:04,156 --> 00:06:06,946 A:middle
up with subscriptions to
keep our cache up to date,

133
00:06:07,636 --> 00:06:10,096 A:middle
and finally I would
like to talk about a set

134
00:06:10,096 --> 00:06:12,806 A:middle
of general purpose performance
tips that you should keep

135
00:06:12,806 --> 00:06:15,176 A:middle
in mind and adopt
in your apps today.

136
00:06:16,626 --> 00:06:18,636 A:middle
So we've got a ton of
great stuff to cover.

137
00:06:18,636 --> 00:06:21,296 A:middle
Let's jump in and talk
about error handling.

138
00:06:26,276 --> 00:06:27,496 A:middle
The first thing that I would

139
00:06:27,496 --> 00:06:29,616 A:middle
like to do is talk
about accounts.

140
00:06:30,816 --> 00:06:33,076 A:middle
CloudKit does not require you

141
00:06:33,076 --> 00:06:35,136 A:middle
to have an iCloud
account to be used.

142
00:06:35,446 --> 00:06:38,946 A:middle
We allow anonymous read only
access to the public database.

143
00:06:40,036 --> 00:06:41,996 A:middle
Let's say for demonstration
purposes here

144
00:06:41,996 --> 00:06:44,806 A:middle
that the clown central app
will require an iCloud account.

145
00:06:46,206 --> 00:06:47,776 A:middle
We talk about a couple
of features

146
00:06:47,776 --> 00:06:50,926 A:middle
that use the private
database which, by definition,

147
00:06:50,926 --> 00:06:52,766 A:middle
require an authenticated
account.

148
00:06:53,336 --> 00:06:56,116 A:middle
And by default, write access

149
00:06:56,116 --> 00:06:58,076 A:middle
to the database requires
an account as well.

150
00:06:58,656 --> 00:07:03,206 A:middle
As a reminder, the way you
check the account status

151

152
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

153
00:06:58,656 --> 00:07:03,206 A:middle
As a reminder, the way you
check the account status

154
00:07:03,466 --> 00:07:06,016 A:middle
for the current user is by
using the account status

155
00:07:06,016 --> 00:07:11,236 A:middle
with completion handler API,
available on CKContainer.

156
00:07:11,836 --> 00:07:15,086 A:middle
Any errors that you encounter
when working with CloudKit due

157
00:07:15,086 --> 00:07:16,486 A:middle
to authentication will fail

158
00:07:16,486 --> 00:07:20,106 A:middle
with a special error code called
CKErrorNotAuthenticated.

159
00:07:20,916 --> 00:07:23,826 A:middle
The general guideline we
give to handle this error is

160
00:07:23,826 --> 00:07:26,946 A:middle
to recheck the account status.

161
00:07:26,946 --> 00:07:29,256 A:middle
Let's say we have a
missing iCloud account.

162
00:07:30,076 --> 00:07:31,526 A:middle
When you check the
account status,

163
00:07:31,726 --> 00:07:36,026 A:middle
you receive CKAccountStatusNoAccount.

164
00:07:36,356 --> 00:07:40,276 A:middle
Previously you had no way
of knowing when requests

165
00:07:40,276 --> 00:07:42,456 A:middle
that failed due to a
missing account would start

166
00:07:42,456 --> 00:07:43,176 A:middle
succeeding again.

167
00:07:44,236 --> 00:07:47,656 A:middle
For that very purpose with
iOS 9 and OS X El Capitan,

168
00:07:47,926 --> 00:07:50,476 A:middle
we added CKAccountChangeNotification.

169
00:07:50,906 --> 00:07:53,616 A:middle
We will send you this
notification whenever there is a

170
00:07:53,616 --> 00:07:57,136 A:middle
change to the user's account,
for example on log ins, log outs

171
00:07:57,456 --> 00:07:59,826 A:middle
or if the iCloud drive
capability switch is turned

172
00:07:59,826 --> 00:08:02,006 A:middle
on or off.

173

174
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

175
00:07:59,826 --> 00:08:02,006 A:middle
on or off.

176
00:08:02,846 --> 00:08:06,146 A:middle
With that I would like to touch
on a couple of best practices

177
00:08:06,146 --> 00:08:09,106 A:middle
when handling a missing
account in your apps.

178
00:08:09,726 --> 00:08:13,206 A:middle
It might be tempting when
encountering this situation

179
00:08:13,206 --> 00:08:16,506 A:middle
to throw up an alert for the
user telling them they don't

180
00:08:16,506 --> 00:08:18,846 A:middle
have a logged in iCloud
account and can't proceed.

181
00:08:19,546 --> 00:08:21,616 A:middle
This is not helpful to the user

182
00:08:21,616 --> 00:08:25,456 A:middle
because they might dismiss the
alert and retry an operation

183
00:08:25,456 --> 00:08:28,506 A:middle
that led them to see the
alert in the first place.

184
00:08:29,116 --> 00:08:31,536 A:middle
What we recommend instead is

185
00:08:31,536 --> 00:08:35,116 A:middle
that you gracefully
degrade your UI in a way

186
00:08:35,116 --> 00:08:37,246 A:middle
that simply disables
the features of your app

187
00:08:37,736 --> 00:08:41,895 A:middle
that require an account, and
for this purpose you can now use

188
00:08:41,895 --> 00:08:44,396 A:middle
CKAccountChangedNotification
to re-enable that UI,

189
00:08:44,396 --> 00:08:47,346 A:middle
when you receive it,
re-check the account status,

190
00:08:47,346 --> 00:08:49,236 A:middle
and see that one
account is now available.

191
00:08:49,826 --> 00:08:55,176 A:middle
A missing account is not
one of the only conditions

192
00:08:55,176 --> 00:08:59,026 A:middle
under which your operations
might fail temporarily,

193

194
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

195
00:09:00,756 --> 00:09:03,166 A:middle
but may start succeeding at
some point in the future.

196
00:09:04,506 --> 00:09:06,996 A:middle
For example, under
poor network conditions

197
00:09:07,116 --> 00:09:09,876 A:middle
where you might encounter this
error, CKErrorNetworkFailure,

198
00:09:11,346 --> 00:09:13,336 A:middle
or if the CloudKit
servers are busy.

199
00:09:13,516 --> 00:09:14,936 A:middle
Or you might see
one of these errors:

200
00:09:14,936 --> 00:09:18,226 A:middle
CKErrorServiceUnavailable
or CKErrorZoneBusy.

201
00:09:19,206 --> 00:09:24,256 A:middle
When encountering this error, we
want you to retry the operation

202
00:09:24,256 --> 00:09:28,196 A:middle
at a later date, but
you might be wondering

203
00:09:28,426 --> 00:09:29,926 A:middle
when do I retry those
operations?

204
00:09:30,536 --> 00:09:32,896 A:middle
Well, you don't have
to guess at that value.

205
00:09:33,676 --> 00:09:37,776 A:middle
In these errors, user info
dictionaries we return

206
00:09:37,776 --> 00:09:41,946 A:middle
to you a special value under the
key "CKErrorRetryAfterKey."

207
00:09:42,976 --> 00:09:46,246 A:middle
This value is a value of
time in seconds that you need

208
00:09:46,246 --> 00:09:48,516 A:middle
to wait before retrying
that operation.

209
00:09:51,156 --> 00:09:53,476 A:middle
Now, let's take a
similar example

210
00:09:54,066 --> 00:09:57,206 A:middle
where let's say our
app initially had a bug

211
00:09:57,206 --> 00:10:00,356 A:middle
which might have caused it
to send a lot of updates

212

213
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

214
00:09:57,206 --> 00:10:00,356 A:middle
which might have caused it
to send a lot of updates

215
00:10:00,356 --> 00:10:03,246 A:middle
to the server in a very
short amount of time.

216
00:10:03,246 --> 00:10:07,006 A:middle
Let's say if this app made it to
the wild in that way and a lot

217
00:10:07,006 --> 00:10:08,326 A:middle
of users started
hitting that bug,

218
00:10:08,636 --> 00:10:10,426 A:middle
it would overwhelm
the iCloud servers.

219
00:10:11,086 --> 00:10:12,876 A:middle
The way we avoid this is

220
00:10:12,876 --> 00:10:16,826 A:middle
by using a special error
code called CKErrorRequestRateLimited.

221
00:10:18,536 --> 00:10:22,076 A:middle
This is CloudKit's way of
mitigating application bugs

222
00:10:22,186 --> 00:10:24,166 A:middle
from overwhelming
the iCloud servers.

223
00:10:25,836 --> 00:10:30,296 A:middle
Any requests that hit the rate
limited error will not be sent

224
00:10:30,296 --> 00:10:33,456 A:middle
up to the server until a
period of time has elapsed.

225
00:10:34,156 --> 00:10:35,936 A:middle
Once again what is
that period of time?

226
00:10:36,736 --> 00:10:40,496 A:middle
It is given to you by the
CKErrorRetryAfterKey.

227
00:10:42,036 --> 00:10:45,626 A:middle
So when you encounter this
error, look for this key

228
00:10:45,626 --> 00:10:47,116 A:middle
in the errors user
info dictionary.

229
00:10:47,496 --> 00:10:50,046 A:middle
Wait for a period of time,
and retry your request.

230
00:10:50,656 --> 00:10:54,236 A:middle
Now I would like to start
talking about a different class

231
00:10:54,236 --> 00:10:55,996 A:middle
of errors that you
might encounter

232
00:10:56,866 --> 00:10:59,706 A:middle
because of the way your schema
is designed, specifically

233
00:10:59,706 --> 00:11:05,716 A:middle
if your schema allows multiple
users to update the same record

234

235
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

236
00:10:59,706 --> 00:11:05,716 A:middle
if your schema allows multiple
users to update the same record

237
00:11:05,716 --> 00:11:06,706 A:middle
in your Cloud database.

238
00:11:07,746 --> 00:11:10,356 A:middle
So let's say we want to
add a feature to our app

239
00:11:10,686 --> 00:11:13,986 A:middle
where we allow attendees to
add themselves to a party.

240
00:11:15,276 --> 00:11:17,786 A:middle
But unfortunately, when
designing the schema

241
00:11:17,786 --> 00:11:20,926 A:middle
for this feature, we did not
watch last year's advanced

242
00:11:20,926 --> 00:11:21,556 A:middle
CloudKit session.

243
00:11:22,956 --> 00:11:24,606 A:middle
So this is a schema
we came up with.

244
00:11:25,866 --> 00:11:29,336 A:middle
On the party record itself,
we decided to store an array

245
00:11:29,336 --> 00:11:31,446 A:middle
of references to
attendee records

246
00:11:31,496 --> 00:11:32,536 A:middle
that want to join that party.

247
00:11:33,206 --> 00:11:38,776 A:middle
Now, you can see that
every single time we wish

248
00:11:38,776 --> 00:11:41,256 A:middle
to add an attendee to a
particular party, we are going

249
00:11:41,256 --> 00:11:43,576 A:middle
to end up modifying
the same party record.

250
00:11:45,116 --> 00:11:47,646 A:middle
Let's take a look at an
example of what happens

251
00:11:47,966 --> 00:11:53,116 A:middle
when two different users try
to add themselves to a party.

252
00:11:53,296 --> 00:11:55,936 A:middle
Since the WWDC bash
is starting up soon,

253
00:11:56,216 --> 00:12:00,626 A:middle
let's say we saved this
record to CloudKit.

254

255
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

256
00:11:56,216 --> 00:12:00,626 A:middle
let's say we saved this
record to CloudKit.

257
00:12:00,626 --> 00:12:03,456 A:middle
And now before we
get into what happens

258
00:12:03,456 --> 00:12:06,076 A:middle
when two users download this
record, I would like to talk

259
00:12:06,076 --> 00:12:10,466 A:middle
about what are record
change tags.

260
00:12:10,466 --> 00:12:15,796 A:middle
You can think of them as simply
a string that the server uses

261
00:12:15,796 --> 00:12:18,176 A:middle
to identify a particular
version of a record.

262
00:12:18,676 --> 00:12:21,706 A:middle
This version of the
record as it exists

263
00:12:21,706 --> 00:12:24,756 A:middle
on the server is recognized
by the change tag A.

264
00:12:26,026 --> 00:12:29,396 A:middle
We expose this to you as a read
only property on CKRecords,

265
00:12:29,586 --> 00:12:32,556 A:middle
but it will only be populated
on records that have been saved.

266
00:12:34,056 --> 00:12:36,716 A:middle
Let's say two users, John
and Alice, come along

267
00:12:36,716 --> 00:12:38,956 A:middle
and download this particular
version of the record.

268
00:12:39,546 --> 00:12:43,406 A:middle
You can see they receive
the same change tags, A.

269
00:12:43,656 --> 00:12:46,876 A:middle
Now, John adds himself as an
attendee to the party first,

270
00:12:47,586 --> 00:12:50,306 A:middle
goes ahead and tries to save
his record to the server.

271
00:12:51,436 --> 00:12:54,136 A:middle
Now, with the records saved,
we will send the change tag

272
00:12:54,136 --> 00:12:57,076 A:middle
that John had, which
is A, up to the server.

273
00:12:57,076 --> 00:12:59,736 A:middle
And the server sees that
the change tags match

274

275
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

276
00:13:00,616 --> 00:13:02,166 A:middle
and accepts John's modification.

277
00:13:03,376 --> 00:13:06,516 A:middle
Now, since the version of the
server record has changed,

278
00:13:06,776 --> 00:13:09,876 A:middle
the server will generate a new
change tag in this case, B,

279
00:13:10,036 --> 00:13:12,776 A:middle
and send that back to John
in the record save response.

280
00:13:12,776 --> 00:13:17,856 A:middle
Now let's say Alice comes along
and decides to attend the party.

281
00:13:19,436 --> 00:13:22,126 A:middle
She tries the same operation,
adds herself to the array

282
00:13:22,256 --> 00:13:23,906 A:middle
and tries to save her
version of the record.

283
00:13:24,626 --> 00:13:26,736 A:middle
This time you can see
that she will be sending

284
00:13:26,736 --> 00:13:30,476 A:middle
up the old change tag A,
and the server will complain

285
00:13:30,566 --> 00:13:33,516 A:middle
that she is trying to alter a
version of the server record

286
00:13:33,516 --> 00:13:34,666 A:middle
that no longer exists.

287
00:13:35,106 --> 00:13:38,316 A:middle
She encountered a conflict.

288
00:13:38,316 --> 00:13:42,336 A:middle
On her device, the way CloudKit
tells her about this conflict is

289
00:13:42,336 --> 00:13:47,066 A:middle
by a special error code called
CKErrorServerRecordChanged.

290
00:13:48,716 --> 00:13:51,596 A:middle
There's no magic
happening behind the scenes,

291
00:13:51,596 --> 00:13:53,276 A:middle
and we don't make assumptions

292
00:13:53,276 --> 00:13:55,366 A:middle
about how you wish
to resolve conflicts.

293
00:13:55,666 --> 00:13:57,066 A:middle
You are the best
person to do that.

294
00:13:57,566 --> 00:14:01,836 A:middle
So we will try to provide you
with as much useful information

295

296
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

297
00:13:57,566 --> 00:14:01,836 A:middle
So we will try to provide you
with as much useful information

298
00:14:01,836 --> 00:14:04,826 A:middle
as we can for you to resolve
those conflicts yourself.

299
00:14:05,866 --> 00:14:07,836 A:middle
And the first and most
important piece of information

300
00:14:07,836 --> 00:14:11,196 A:middle
that we give you is the
version of the record as it was

301
00:14:11,196 --> 00:14:13,356 A:middle
in the server when an
update was rejected.

302
00:14:14,676 --> 00:14:15,636 A:middle
Where do you find that?

303
00:14:15,906 --> 00:14:18,846 A:middle
You find that once again in the
errors user's info dictionary

304
00:14:19,116 --> 00:14:22,286 A:middle
under the key
CKRecordChangedErrorServerRecordKey.

305
00:14:22,286 --> 00:14:25,016 A:middle
In this case, when we pull it

306
00:14:25,016 --> 00:14:27,236 A:middle
out of the errors
user's info dictionary,

307
00:14:27,436 --> 00:14:29,726 A:middle
we would find the record
as it was in the server

308
00:14:29,956 --> 00:14:33,346 A:middle
with John attending the party
and the new change tag B.

309
00:14:33,946 --> 00:14:37,046 A:middle
Now, in addition to
the server record,

310
00:14:37,456 --> 00:14:40,146 A:middle
we give you back a few
more pieces of information.

311
00:14:42,036 --> 00:14:46,096 A:middle
These include the ancestor
record key which is the record

312
00:14:46,096 --> 00:14:49,426 A:middle
as Alice had before she made
any modifications to it.

313
00:14:50,836 --> 00:14:54,506 A:middle
And the client record key
which will contain the record

314
00:14:54,506 --> 00:14:59,566 A:middle
that Alice tried to
save to the server.

315
00:14:59,736 --> 00:15:01,946 A:middle
Now, what I want to
emphasize here is

316

317
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

318
00:14:59,736 --> 00:15:01,946 A:middle
Now, what I want to
emphasize here is

319
00:15:01,946 --> 00:15:05,496 A:middle
that the most important thing to
do, and what you will be doing

320
00:15:05,496 --> 00:15:07,436 A:middle
in most cases when
resolving a conflict,

321
00:15:07,896 --> 00:15:10,576 A:middle
is trying to save the
modifications that you were

322
00:15:10,576 --> 00:15:12,996 A:middle
in the first place before
you encountered the error

323
00:15:12,996 --> 00:15:15,946 A:middle
but instead on to the
server record returned

324
00:15:15,946 --> 00:15:16,666 A:middle
to you by the error.

325
00:15:17,486 --> 00:15:20,316 A:middle
So in this case, you
take the server record.

326
00:15:20,956 --> 00:15:23,686 A:middle
We'll make the same modification
to it that we were trying

327
00:15:23,686 --> 00:15:26,816 A:middle
to save, which in our case is
simply add Alice as an attendee

328
00:15:26,816 --> 00:15:31,346 A:middle
to the party, include her along
with John, and save this version

329
00:15:31,346 --> 00:15:32,306 A:middle
of the record to the server.

330
00:15:32,836 --> 00:15:37,416 A:middle
You can see that we have the
server's new change tag B.

331
00:15:38,146 --> 00:15:40,716 A:middle
When we save the record
those change tags will match,

332
00:15:40,716 --> 00:15:42,026 A:middle
and the server will
accept the save.

333
00:15:42,576 --> 00:15:47,266 A:middle
Now, a point to note here is

334
00:15:47,266 --> 00:15:50,206 A:middle
that we could have avoided
this entire class of errors

335
00:15:50,416 --> 00:15:52,426 A:middle
if we had used a better
schema for this feature.

336
00:15:53,616 --> 00:15:57,626 A:middle
I'll talk about what that
schema is in a short while.

337
00:15:58,416 --> 00:16:00,216 A:middle
But you can see that trying

338

339
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

340
00:15:58,416 --> 00:16:00,216 A:middle
But you can see that trying

341
00:16:00,216 --> 00:16:03,536 A:middle
to modify the same record every
single time a different user

342
00:16:03,536 --> 00:16:05,646 A:middle
makes that modification
is not the best idea.

343
00:16:06,226 --> 00:16:11,106 A:middle
So talk through this new schema,

344
00:16:11,526 --> 00:16:13,636 A:middle
let's look at CloudKit
operations.

345
00:16:14,966 --> 00:16:19,056 A:middle
We want to add a feature to
our app that allows users

346
00:16:19,056 --> 00:16:20,686 A:middle
to store photos for parties.

347
00:16:22,016 --> 00:16:25,046 A:middle
We need a similar one-to-many
relationship between parties

348
00:16:25,046 --> 00:16:28,056 A:middle
and photos this time, so photos
would be their own record type,

349
00:16:28,846 --> 00:16:32,786 A:middle
but we don't want to store them
on the party record this time.

350
00:16:33,236 --> 00:16:34,286 A:middle
How do we do this?

351
00:16:34,286 --> 00:16:37,646 A:middle
We can save the photo
records with a back reference

352
00:16:37,646 --> 00:16:39,666 A:middle
to the party that they
belong to instead.

353
00:16:40,976 --> 00:16:46,376 A:middle
You can see now when we save
photo records, we don't have

354
00:16:46,376 --> 00:16:49,776 A:middle
to modify the party
record that they belong to.

355
00:16:52,896 --> 00:16:55,416 A:middle
So let's talk about how we
are saving these records.

356
00:16:56,026 --> 00:17:00,846 A:middle
Let's say right now in our app
we are using the convenience

357

358
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

359
00:16:56,026 --> 00:17:00,846 A:middle
Let's say right now in our app
we are using the convenience

360
00:17:00,846 --> 00:17:03,096 A:middle
API, saveRecordWithCompletionHandler

361
00:17:03,096 --> 00:17:06,506 A:middle
to save one photo
record at a time.

362
00:17:06,675 --> 00:17:11,406 A:middle
But users could potentially
store multiple photos at once.

363
00:17:11,465 --> 00:17:14,685 A:middle
In that case, we are currently
using the convenience API

364
00:17:14,826 --> 00:17:17,306 A:middle
in the tight loop to
save multiple records.

365
00:17:18,195 --> 00:17:21,126 A:middle
Let's take a look at what is
happening behind the scenes

366
00:17:21,376 --> 00:17:22,165 A:middle
when we do that.

367
00:17:22,656 --> 00:17:28,096 A:middle
The app calls the convenience
API a bunch of times to be able

368
00:17:28,096 --> 00:17:29,526 A:middle
to save multiple photos.

369
00:17:30,436 --> 00:17:33,336 A:middle
Each one much those in
the system gets wrapped

370
00:17:33,486 --> 00:17:39,796 A:middle
into a CKOperation with a set
of default values, and each one

371
00:17:39,796 --> 00:17:43,046 A:middle
of those operations turns into
at least one network request

372
00:17:43,176 --> 00:17:45,036 A:middle
when we try to save that
record up to the server.

373
00:17:45,836 --> 00:17:48,566 A:middle
We are not going to
overwhelm the server with all

374
00:17:48,566 --> 00:17:52,146 A:middle
of those requests at once, so we
have also created a bottleneck

375
00:17:52,146 --> 00:17:55,106 A:middle
in the system, and the system
sends up a few requests

376
00:17:55,106 --> 00:17:59,086 A:middle
at a time in order to
save those records.

377

378
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

379
00:18:00,106 --> 00:18:02,566 A:middle
Now, in addition
to this bottleneck,

380
00:18:02,566 --> 00:18:05,296 A:middle
there is one more thing
that you should consider.

381
00:18:05,956 --> 00:18:11,626 A:middle
Every single one of those
requests to save one record

382
00:18:11,626 --> 00:18:13,486 A:middle
at a time, for example
in this case,

383
00:18:13,846 --> 00:18:16,316 A:middle
counts against your
network request quota

384
00:18:16,316 --> 00:18:17,716 A:middle
as CloudKit app developers.

385
00:18:19,226 --> 00:18:20,606 A:middle
This is clearly a bad idea.

386
00:18:22,216 --> 00:18:24,906 A:middle
We want to be able to
batch those record updates

387
00:18:25,156 --> 00:18:28,346 A:middle
into one network request, or
at least the minimum number

388
00:18:28,346 --> 00:18:29,736 A:middle
of network requests possible.

389
00:18:30,026 --> 00:18:30,956 A:middle
How do we do that?

390
00:18:31,986 --> 00:18:36,286 A:middle
Well, we do that by using
the CKOperation counterpart

391
00:18:36,286 --> 00:18:37,356 A:middle
to our convenience API.

392
00:18:38,876 --> 00:18:41,956 A:middle
Almost every convenience
API that works on one item

393
00:18:41,956 --> 00:18:45,056 A:middle
at a time has a CKOperation
counterpart

394
00:18:45,196 --> 00:18:46,786 A:middle
that batches record
updates together.

395
00:18:47,426 --> 00:18:50,816 A:middle
In this case we want to use
CKModifyRecordsOperation

396
00:18:51,186 --> 00:18:53,646 A:middle
to be able to save
multiple records at once

397
00:18:54,726 --> 00:18:57,226 A:middle
by providing them as an array
to the record save property.

398
00:18:57,876 --> 00:19:00,996 A:middle
Look at what happens when
we adopt this operation.

399

400
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

401
00:18:57,876 --> 00:19:00,996 A:middle
Look at what happens when
we adopt this operation.

402
00:19:01,496 --> 00:19:04,176 A:middle
Now we can bunch all of
the records that we want

403
00:19:04,206 --> 00:19:05,846 A:middle
to save into one operation.

404
00:19:06,456 --> 00:19:09,626 A:middle
It queues in the system.

405
00:19:09,626 --> 00:19:12,016 A:middle
The system is able to
use the minimum number

406
00:19:12,016 --> 00:19:14,876 A:middle
of requests it needs to be
able to save those records

407
00:19:14,876 --> 00:19:17,846 A:middle
to the server, and we
eliminated the bottleneck.

408
00:19:19,396 --> 00:19:24,216 A:middle
At the same time we've
helped you optimize the use

409
00:19:24,216 --> 00:19:25,156 A:middle
of your request quota.

410
00:19:26,496 --> 00:19:30,436 A:middle
This is an important point I
would like all of you to think

411
00:19:30,436 --> 00:19:32,856 A:middle
about in your apps when
using the convenience API.

412
00:19:33,646 --> 00:19:36,526 A:middle
If you are ever using it
for the same kind of request

413
00:19:36,526 --> 00:19:41,086 A:middle
in multiple places or some
kind of loop, think instead

414
00:19:41,086 --> 00:19:43,136 A:middle
of adopting the CKOperation API

415
00:19:43,136 --> 00:19:44,906 A:middle
that lets you batch
those updates.

416
00:19:44,906 --> 00:19:47,066 A:middle
It will save you
your request quota,

417
00:19:47,066 --> 00:19:50,566 A:middle
and at the same time be more
efficient for the system.

418
00:19:50,566 --> 00:19:51,266 A:middle
All right.

419
00:19:52,456 --> 00:19:55,036 A:middle
Now that we are working
with batches,

420
00:19:55,846 --> 00:19:58,766 A:middle
there is an additional
consideration

421
00:19:58,906 --> 00:20:00,366 A:middle
that we need to think about.

422

423
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

424
00:19:58,906 --> 00:20:00,366 A:middle
that we need to think about.

425
00:20:02,536 --> 00:20:05,836 A:middle
The server imposes
certain limits on the sizes

426
00:20:05,836 --> 00:20:07,906 A:middle
of the batches that
can be sent up at once.

427
00:20:09,776 --> 00:20:14,166 A:middle
These limits include the number
of items in each request,

428
00:20:15,346 --> 00:20:18,316 A:middle
as well as the total
size of the request.

429
00:20:18,526 --> 00:20:21,096 A:middle
The total size of the
request is simply the sum

430
00:20:21,096 --> 00:20:23,746 A:middle
of the key value data that
you set in the records

431
00:20:23,746 --> 00:20:25,026 A:middle
that that belong
to that request.

432
00:20:26,366 --> 00:20:30,086 A:middle
An impportant thing to keep
in mind here is that the size

433
00:20:30,086 --> 00:20:32,526 A:middle
of the data the you are
trying to store as part

434
00:20:32,526 --> 00:20:36,886 A:middle
of bulk stoarage via the CKAsset
API does not count towards this

435
00:20:36,886 --> 00:20:37,636 A:middle
key value data.

436
00:20:38,206 --> 00:20:43,496 A:middle
But if your request were to
trip any one of these limits,

437
00:20:44,616 --> 00:20:47,446 A:middle
you would receive a special
error code called CKErrorLimitExceeded.

438
00:20:49,016 --> 00:20:51,766 A:middle
The general guideline
we give developers

439
00:20:51,766 --> 00:20:54,696 A:middle
to handle this error is simply
divide the number of items

440
00:20:54,696 --> 00:20:58,836 A:middle
in your batch by half and issue
two operations instead of one.

441

442
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

443
00:21:00,086 --> 00:21:03,206 A:middle
And recursively do that if those
operations encounter the same

444
00:21:03,206 --> 00:21:05,926 A:middle
error again.

445
00:21:06,366 --> 00:21:10,636 A:middle
Now, what if only some items
in your batch were to fail?

446
00:21:10,856 --> 00:21:15,076 A:middle
Since the batch consists
of a lot of items

447
00:21:15,076 --> 00:21:18,526 A:middle
but returns only one error to
you, we still want to tell you

448
00:21:18,526 --> 00:21:20,256 A:middle
about every single
one of those errors.

449
00:21:20,996 --> 00:21:25,376 A:middle
We do that by using a special
error code called CKErrorPartialFailure.

450
00:21:27,476 --> 00:21:31,296 A:middle
This is a top level error code
that you don't really want

451
00:21:31,296 --> 00:21:34,636 A:middle
to handle directly,
but once again

452
00:21:35,246 --> 00:21:37,096 A:middle
under the errors
user's info dictionary,

453
00:21:37,096 --> 00:21:40,016 A:middle
if you look under CKPartialErrorsByItemIDKey,

454
00:21:40,106 --> 00:21:42,946 A:middle
we will give you a
dictionary of item IDs

455
00:21:42,946 --> 00:21:47,106 A:middle
to the corresponding
errors from your batch.

456
00:21:47,286 --> 00:21:51,146 A:middle
For example, in this case we
have had one item ID that failed

457
00:21:51,146 --> 00:21:53,826 A:middle
with CKRecord invalid
arguments, and there may

458
00:21:53,826 --> 00:21:56,426 A:middle
or may not be errors for any
other items in your batch.

459
00:21:56,756 --> 00:22:00,516 A:middle
You want to open this up, look
inside the dictionary and handle

460

461
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

462
00:21:56,756 --> 00:22:00,516 A:middle
You want to open this up, look
inside the dictionary and handle

463
00:22:00,516 --> 00:22:01,486 A:middle
that error individually.

464
00:22:03,456 --> 00:22:05,686 A:middle
This situation changes slightly

465
00:22:06,346 --> 00:22:09,536 A:middle
when considering atomic
updates in custom zones.

466
00:22:11,356 --> 00:22:15,626 A:middle
Custom zones, as a
reminder, have the capability

467
00:22:15,626 --> 00:22:17,776 A:middle
for your CKModifyRecordsOperation

468
00:22:17,776 --> 00:22:19,046 A:middle
to issue atomic updates,

469
00:22:19,096 --> 00:22:22,346 A:middle
in which case the server will
either accept the entire batch

470
00:22:22,346 --> 00:22:24,436 A:middle
as one or fail the entire batch.

471
00:22:25,806 --> 00:22:28,526 A:middle
Now, if one item in our
batch, as in this case,

472
00:22:28,526 --> 00:22:31,046 A:middle
would have failed with
CKError invalid arguments,

473
00:22:31,106 --> 00:22:33,656 A:middle
the rest of the item IDs
would also contain an errror

474
00:22:34,036 --> 00:22:36,886 A:middle
with a special error code,
CKErrorBatchRequestFailed.

475
00:22:38,096 --> 00:22:40,066 A:middle
When working with
atomic updates,

476
00:22:40,066 --> 00:22:42,136 A:middle
make sure to look
inside the dictionaries

477
00:22:42,326 --> 00:22:43,966 A:middle
and handle all the
errors that are not

478
00:22:44,066 --> 00:22:47,916 A:middle
in CKErrorBatchRequestFailed.

479
00:22:48,476 --> 00:22:51,766 A:middle
That's storing all of our
photo records up to the Cloud

480
00:22:51,766 --> 00:22:53,916 A:middle
in an optimized manner.

481
00:22:53,916 --> 00:22:57,616 A:middle
Let's talk about the other
half, downloading them.

482
00:22:57,616 --> 00:23:00,116 A:middle
The way we do that is by
using CloudKit queries.

483

484
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

485
00:22:57,616 --> 00:23:00,116 A:middle
The way we do that is by
using CloudKit queries.

486
00:23:00,206 --> 00:23:00,356 A:middle
All right.

487
00:23:01,466 --> 00:23:02,696 A:middle
Downloading photo records

488
00:23:02,696 --> 00:23:06,136 A:middle
for a particular party
has now become really easy

489
00:23:06,136 --> 00:23:08,966 A:middle
with the new schema
that we adopted

490
00:23:08,966 --> 00:23:11,766 A:middle
where photo records reference
the party they belong to.

491
00:23:12,646 --> 00:23:15,556 A:middle
We do that by simply
constructing a CK query

492
00:23:15,866 --> 00:23:17,486 A:middle
that tries to match
that reference

493
00:23:17,706 --> 00:23:21,786 A:middle
to a known party record ID.

494
00:23:22,046 --> 00:23:25,076 A:middle
Now, when we issue our query
to download photos for a party,

495
00:23:25,856 --> 00:23:27,746 A:middle
some parties might
have a lot of photos.

496
00:23:28,046 --> 00:23:31,106 A:middle
Do we really need to
download all of them?

497
00:23:31,106 --> 00:23:35,396 A:middle
Let's take a look at how we
can issue an optimized download

498
00:23:35,396 --> 00:23:37,026 A:middle
for the photos for
a particular party

499
00:23:37,346 --> 00:23:38,946 A:middle
by using CKQueryOperation.

500
00:23:41,996 --> 00:23:44,406 A:middle
The first question
to really answer is:

501
00:23:44,706 --> 00:23:47,656 A:middle
We have no idea how many photos
belong to a particular party.

502
00:23:47,936 --> 00:23:49,306 A:middle
So how many should we download?

503
00:23:49,376 --> 00:23:52,146 A:middle
It doesn't make sense
to download all of them.

504
00:23:53,276 --> 00:23:55,526 A:middle
What makes sense is for our UI

505
00:23:55,526 --> 00:23:57,306 A:middle
to drive the answer
to that question.

506
00:23:58,246 --> 00:24:00,266 A:middle
Now, if you take a look
at our example UI here,

507

508
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

509
00:23:58,246 --> 00:24:00,266 A:middle
Now, if you take a look
at our example UI here,

510
00:24:00,556 --> 00:24:03,436 A:middle
you can see that when we
pull up a particular party,

511
00:24:03,676 --> 00:24:06,366 A:middle
all we see are 20 photos.

512
00:24:07,646 --> 00:24:09,466 A:middle
So it would make a lot of sense

513
00:24:09,526 --> 00:24:13,046 A:middle
if our query only
returned 20 photos to us

514
00:24:13,116 --> 00:24:14,206 A:middle
when we first issued it.

515
00:24:15,176 --> 00:24:18,366 A:middle
We can do just that by using
the results limit property

516
00:24:18,536 --> 00:24:19,736 A:middle
on CKQueryOperation.

517
00:24:20,916 --> 00:24:26,816 A:middle
This property helps a lot for
you to be able to manage items

518
00:24:27,026 --> 00:24:28,386 A:middle
in a particular batch size

519
00:24:28,446 --> 00:24:31,086 A:middle
when you have no idea how
many items might be returned

520
00:24:31,086 --> 00:24:31,856 A:middle
to you in total.

521
00:24:32,466 --> 00:24:35,516 A:middle
So for that reason
it is also available

522
00:24:35,516 --> 00:24:37,736 A:middle
on CKFetchRecordChangesOperation

523
00:24:38,036 --> 00:24:40,056 A:middle
where you maybe returned
a lot of changes,

524
00:24:40,056 --> 00:24:42,526 A:middle
and you have no idea how
many from a custom zone

525
00:24:43,866 --> 00:24:46,576 A:middle
and on CKFetch notification
changes operation

526
00:24:46,576 --> 00:24:47,646 A:middle
for a similar reason.

527
00:24:47,646 --> 00:24:48,306 A:middle
All right.

528
00:24:49,156 --> 00:24:52,656 A:middle
So now we are downloading
just 20 records.

529
00:24:52,986 --> 00:24:53,796 A:middle
That's an improvement.

530
00:24:54,496 --> 00:24:55,986 A:middle
But can we do better?

531
00:24:56,756 --> 00:24:58,456 A:middle
Well, let's take a look at
what we are downloading.

532
00:24:59,266 --> 00:25:02,066 A:middle
Once again we let our UI
answer this question for us.

533

534
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

535
00:24:59,266 --> 00:25:02,066 A:middle
Once again we let our UI
answer this question for us.

536
00:25:02,236 --> 00:25:04,686 A:middle
Whenever we are viewing
a particular party,

537
00:25:04,686 --> 00:25:07,856 A:middle
all we are seeing is
tiny thumbnails, cropped

538
00:25:07,856 --> 00:25:09,806 A:middle
and down scaled photos
for a particular party.

539
00:25:11,136 --> 00:25:14,876 A:middle
But what we've stored
on our photo record

540
00:25:15,116 --> 00:25:18,046 A:middle
that is being downloaded
completely by default

541
00:25:18,046 --> 00:25:22,266 A:middle
for us is probably a high
resolution version of that photo

542
00:25:23,446 --> 00:25:25,526 A:middle
that we've taken with
the amazing cameras

543
00:25:25,526 --> 00:25:26,596 A:middle
on our iOS devices.

544
00:25:27,786 --> 00:25:30,976 A:middle
Well, wouldn't it be great
if we could somehow add

545
00:25:30,976 --> 00:25:33,666 A:middle
that information right
on to our photo record

546
00:25:34,406 --> 00:25:37,746 A:middle
so that we have something that
we can pull down partially,

547
00:25:38,606 --> 00:25:40,376 A:middle
but how do we pull
down partial records?

548
00:25:41,006 --> 00:25:43,656 A:middle
Well, we do that by using
the desired keys property

549
00:25:43,946 --> 00:25:45,166 A:middle
on CKQuery operation.

550
00:25:46,326 --> 00:25:50,216 A:middle
In this case, the desired keys
property will take an array

551
00:25:50,216 --> 00:25:53,026 A:middle
of keys that you wish to
fetch on all the records

552
00:25:53,026 --> 00:25:53,826 A:middle
that match your query.

553
00:25:55,136 --> 00:25:57,366 A:middle
So if we set that just to
be our photo thumbnail,

554
00:25:57,366 --> 00:26:00,406 A:middle
you can see that we have
drastically reduced the amount

555

556
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

557
00:25:57,366 --> 00:26:00,406 A:middle
you can see that we have
drastically reduced the amount

558
00:26:00,406 --> 00:26:02,906 A:middle
of data that we are loading
when our query returns.

559
00:26:05,696 --> 00:26:09,156 A:middle
This is also available on
CKFetch records operation

560
00:26:09,536 --> 00:26:12,346 A:middle
where you may know the
record IDs in advance

561
00:26:12,346 --> 00:26:15,106 A:middle
of the records you are
fetching, but either your UI

562
00:26:15,106 --> 00:26:18,466 A:middle
or some other reason you
only want partial records

563
00:26:18,576 --> 00:26:19,236 A:middle
to be downloaded.

564
00:26:21,406 --> 00:26:24,266 A:middle
As well as on CKFetch
record changes operation

565
00:26:24,396 --> 00:26:27,386 A:middle
which once again by default
downloads the full record

566
00:26:27,796 --> 00:26:29,366 A:middle
for any records that
may have changed.

567
00:26:29,886 --> 00:26:35,106 A:middle
So now that we're displaying
only 20 photos, it makes sense

568
00:26:35,106 --> 00:26:38,236 A:middle
for us to have a certain
ordering on the photos

569
00:26:38,236 --> 00:26:39,786 A:middle
that we are first
displaying to the user.

570
00:26:40,416 --> 00:26:43,266 A:middle
Let's say we want to show
the photos in the order

571
00:26:43,266 --> 00:26:45,516 A:middle
that they have been,
in the order

572
00:26:45,516 --> 00:26:48,076 A:middle
that they were most
recently saved into iCloud.

573
00:26:50,226 --> 00:26:54,686 A:middle
We do that by setting the sort
discriptor right on the CKQuery

574
00:26:54,686 --> 00:26:56,976 A:middle
that we initialized our
CKQuery operation with.

575
00:26:57,586 --> 00:27:01,876 A:middle
You can see here we are
creating a sort descriptor

576

577
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

578
00:26:57,586 --> 00:27:01,876 A:middle
You can see here we are
creating a sort descriptor

579
00:27:01,876 --> 00:27:04,946 A:middle
on the creation date key
which is a system field

580
00:27:05,086 --> 00:27:07,976 A:middle
on all CKRecords that have
been saved to the server.

581
00:27:08,536 --> 00:27:11,096 A:middle
And set that to descending.

582
00:27:11,696 --> 00:27:17,646 A:middle
One thing to keep in mind here,
since this is a system field,

583
00:27:17,906 --> 00:27:21,096 A:middle
you need to ensure that
it's sortable on the server.

584
00:27:21,656 --> 00:27:24,736 A:middle
You do that configuration
via the iCloud dashboard.

585
00:27:25,606 --> 00:27:26,656 A:middle
Make sure to have

586
00:27:26,656 --> 00:27:29,426 A:middle
that configuration set before
those records are saved.

587
00:27:29,926 --> 00:27:34,976 A:middle
Otherwise, the previous records
saved previously are not going

588
00:27:34,976 --> 00:27:37,626 A:middle
to have that index on them.

589
00:27:38,296 --> 00:27:41,136 A:middle
So now that we are
fetching just a small slice

590
00:27:41,206 --> 00:27:43,956 A:middle
of our entire results
set, you may be wondering,

591
00:27:43,956 --> 00:27:45,546 A:middle
how do we show the
user the rest?

592
00:27:45,826 --> 00:27:48,506 A:middle
Say the user starts scrolling
down, and we want to look

593
00:27:48,506 --> 00:27:49,776 A:middle
at the next batch of photos.

594
00:27:51,876 --> 00:27:55,086 A:middle
How do we implement
pagination in this case?

595
00:27:55,676 --> 00:27:58,666 A:middle
Well, we do that by
looking at what we get back

596
00:27:58,736 --> 00:27:59,986 A:middle
in our query completion block.

597

598
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

599
00:28:01,306 --> 00:28:04,976 A:middle
When a query completes, in
addition to all the results

600
00:28:04,976 --> 00:28:06,966 A:middle
that were returned to us
in the progress call backs,

601
00:28:07,256 --> 00:28:09,066 A:middle
we get back a CKQuery cursor.

602
00:28:10,576 --> 00:28:16,906 A:middle
This is an opaque marker for you
to use that shows you your place

603
00:28:16,906 --> 00:28:18,186 A:middle
in the entire results set.

604
00:28:18,936 --> 00:28:21,856 A:middle
So you should store the
query cursor returned to you

605
00:28:21,856 --> 00:28:25,806 A:middle
from the first query
operation, and when you wish

606
00:28:25,806 --> 00:28:28,496 A:middle
to fetch the next
batch of results,

607
00:28:28,936 --> 00:28:32,556 A:middle
initialize another CKQuery
operation using the cursor

608
00:28:32,556 --> 00:28:34,636 A:middle
initializer and pass it,

609
00:28:34,956 --> 00:28:37,296 A:middle
the cursor that you
stored previously.

610
00:28:37,296 --> 00:28:43,386 A:middle
Now, since we are optimizing
our CKQuery operation

611
00:28:43,386 --> 00:28:47,216 A:middle
in this manner, make sure
to set the same desired keys

612
00:28:47,216 --> 00:28:49,976 A:middle
and results limit on the new
query operation once again.

613
00:28:50,976 --> 00:28:54,276 A:middle
That will give you just the
optimized next batch of photos.

614
00:28:56,956 --> 00:28:59,696 A:middle
That was about downloading
records.

615

616
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

617
00:29:01,086 --> 00:29:05,716 A:middle
Now I would like to switch
gears and talk about some tips

618
00:29:05,716 --> 00:29:06,926 A:middle
that you can keep in mind

619
00:29:07,066 --> 00:29:11,376 A:middle
when maintaining a local
cache working with CloudKit.

620
00:29:11,376 --> 00:29:12,736 A:middle
Let's start talking
about a new feature.

621
00:29:13,286 --> 00:29:17,336 A:middle
Let's say we want to add
the ability for users

622
00:29:17,336 --> 00:29:20,416 A:middle
to store small personal
Notes for parties.

623
00:29:20,656 --> 00:29:24,326 A:middle
Now, since these Notes
are going to be personal,

624
00:29:24,946 --> 00:29:27,176 A:middle
we want to store them in
the user's private database.

625
00:29:27,696 --> 00:29:33,596 A:middle
We don't want to fetch these
Notes every single time a user

626
00:29:33,596 --> 00:29:35,716 A:middle
wants to view them
or modify them.

627
00:29:36,446 --> 00:29:38,016 A:middle
We want to make sure
that we have some kind

628
00:29:38,016 --> 00:29:39,786 A:middle
of offline access
for these Notes.

629
00:29:40,256 --> 00:29:45,936 A:middle
And you can see that in this
particular scenario what we

630
00:29:46,206 --> 00:29:50,126 A:middle
actually need is a small
amount of data but on all

631
00:29:50,126 --> 00:29:51,606 A:middle
of a particular user's devices.

632
00:29:52,936 --> 00:29:55,956 A:middle
So it makes a lot of sense for
us to maintain a local cache

633
00:29:56,636 --> 00:30:00,436 A:middle
when working with
CloudKit in this scenario.

634

635
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

636
00:29:56,636 --> 00:30:00,436 A:middle
when working with
CloudKit in this scenario.

637
00:30:00,436 --> 00:30:03,346 A:middle
Let's first talk about how we
can start downloading things

638
00:30:03,346 --> 00:30:04,406 A:middle
from a private database.

639
00:30:05,566 --> 00:30:09,396 A:middle
Now, if you recall, we have the
ability to store custom zones

640
00:30:09,396 --> 00:30:11,866 A:middle
in the private database that
gave us additional capabilities.

641
00:30:13,096 --> 00:30:14,856 A:middle
We go ahead and do just that.

642
00:30:15,366 --> 00:30:18,686 A:middle
Create a new zone in the private
database called the notes zone.

643
00:30:19,926 --> 00:30:21,796 A:middle
And now we have two main ways

644
00:30:22,086 --> 00:30:25,936 A:middle
in which we can start
fetching data from this zone.

645
00:30:26,136 --> 00:30:28,866 A:middle
Once again, we can either
use a CKQuery operation

646
00:30:29,156 --> 00:30:31,126 A:middle
and optimize it just
the way we saw,

647
00:30:31,616 --> 00:30:36,576 A:middle
or we can use delta downloads
via the CKRecords fetch

648
00:30:36,666 --> 00:30:41,236 A:middle
operation which lets us
fetch only the records

649
00:30:41,236 --> 00:30:42,556 A:middle
in the zone that have changed.

650
00:30:43,086 --> 00:30:48,276 A:middle
If you recall, this operation is
only available to work on zones

651
00:30:48,276 --> 00:30:50,036 A:middle
which have the fetch
changes capability.

652
00:30:50,536 --> 00:30:52,226 A:middle
Currently, all custom zones

653
00:30:52,226 --> 00:30:54,406 A:middle
in a private database
do have this capability.

654
00:30:55,936 --> 00:30:57,246 A:middle
Now, if you wish to learn more

655
00:30:57,246 --> 00:31:00,056 A:middle
about how exactly delta
downloads work, I invite you

656

657
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

658
00:30:57,246 --> 00:31:00,056 A:middle
about how exactly delta
downloads work, I invite you

659
00:31:00,056 --> 00:31:01,186 A:middle
to go back and look

660
00:31:01,186 --> 00:31:02,886 A:middle
at the advanced CloudKit
session from last year.

661
00:31:03,216 --> 00:31:06,596 A:middle
It's a great walk through of
how the operation exactly works.

662
00:31:07,126 --> 00:31:10,726 A:middle
Let's say we are using it.

663
00:31:11,236 --> 00:31:12,766 A:middle
We've started fetching
our changes.

664
00:31:13,136 --> 00:31:16,756 A:middle
We have our app objects that
we are storing in some sort

665
00:31:16,756 --> 00:31:18,386 A:middle
of local database,
whether it's core data

666
00:31:18,676 --> 00:31:20,246 A:middle
or any other database
of your choice.

667
00:31:21,166 --> 00:31:24,276 A:middle
That's where we encode
our app objects currently.

668
00:31:25,936 --> 00:31:28,206 A:middle
So here we have a party object.

669
00:31:28,406 --> 00:31:31,776 A:middle
We see we've added the notes
key on it corresponding

670
00:31:32,096 --> 00:31:34,106 A:middle
for that particular user's
Notes for that party.

671
00:31:34,896 --> 00:31:39,266 A:middle
We encode our app object
to our local storage.

672
00:31:39,266 --> 00:31:42,156 A:middle
When working with a
corresponding CKRecords,

673
00:31:42,686 --> 00:31:46,766 A:middle
we want to store those
records up in the Cloud.

674
00:31:46,916 --> 00:31:50,616 A:middle
We might think about
encoding the entire CKRecord

675
00:31:51,446 --> 00:31:55,766 A:middle
so that we have that cached
along with our app object.

676
00:31:56,196 --> 00:31:57,646 A:middle
Let's take a look at
what happens here.

677
00:31:58,036 --> 00:32:00,796 A:middle
You can see that
CKRecord also has all

678

679
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

680
00:31:58,036 --> 00:32:00,796 A:middle
You can see that
CKRecord also has all

681
00:32:00,796 --> 00:32:02,366 A:middle
of the app objects
key set on it.

682
00:32:02,676 --> 00:32:05,796 A:middle
Of course, when we encode
it we are duplicating all

683
00:32:05,796 --> 00:32:06,536 A:middle
of the apps keys.

684
00:32:07,936 --> 00:32:09,976 A:middle
Once we encoded our
app object and now

685
00:32:09,976 --> 00:32:11,446 A:middle
when we are encoding
our CKRecord.

686
00:32:12,266 --> 00:32:15,286 A:middle
This is clearly not
what we want.

687
00:32:16,006 --> 00:32:18,196 A:middle
Well, the orange
fields that you saw

688
00:32:18,196 --> 00:32:21,776 A:middle
on the CKRecord belong
just to the CKRecord.

689
00:32:22,316 --> 00:32:24,546 A:middle
They are the fields
needed by the server

690
00:32:24,546 --> 00:32:26,796 A:middle
to recognize a particular
version of the record.

691
00:32:27,016 --> 00:32:28,536 A:middle
We call them system fields.

692
00:32:29,456 --> 00:32:32,176 A:middle
So what you really want
in this case is a way

693
00:32:32,176 --> 00:32:35,176 A:middle
to encode just the system
fields of the record.

694
00:32:36,096 --> 00:32:39,456 A:middle
And you can do just that by
using the encode system fields

695
00:32:39,456 --> 00:32:41,336 A:middle
with coder API on CKRecord.

696
00:32:42,896 --> 00:32:45,536 A:middle
Now this is all the code
that you need to be able

697
00:32:45,536 --> 00:32:46,846 A:middle
to encode those system fields.

698
00:32:46,846 --> 00:32:50,416 A:middle
I highly recommend that you
reference this if you ever,

699
00:32:50,416 --> 00:32:54,766 A:middle
if the situation arises and
you ever need to look back.

700
00:32:55,016 --> 00:32:56,346 A:middle
Now let's take a
look at what happens

701
00:32:56,346 --> 00:32:58,396 A:middle
when we start encoding
just the system fields.

702
00:32:59,686 --> 00:33:02,636 A:middle
We are efficiently storing
now what is important

703

704
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

705
00:32:59,686 --> 00:33:02,636 A:middle
We are efficiently storing
now what is important

706
00:33:02,636 --> 00:33:07,976 A:middle
about a CKRecord and the
corresponding party object.

707
00:33:08,126 --> 00:33:11,096 A:middle
Now, let's walk through a
scenario of what happens

708
00:33:11,306 --> 00:33:13,166 A:middle
when we try to modify
a party object

709
00:33:13,546 --> 00:33:18,256 A:middle
for which we've stored the
system fields in this manner.

710
00:33:18,416 --> 00:33:22,666 A:middle
For that we use the coder
initializer for CKRecord.

711
00:33:26,796 --> 00:33:28,566 A:middle
So you can see that
when we pull it out,

712
00:33:29,456 --> 00:33:34,706 A:middle
we will get back all the system
fields that we had stored.

713
00:33:34,706 --> 00:33:37,316 A:middle
For brevity I've only shown the
record ID and the change tag

714
00:33:37,656 --> 00:33:40,226 A:middle
which we've already seen.

715
00:33:40,426 --> 00:33:44,406 A:middle
Now on this bare CKRecord it is
completely legitimate for you

716
00:33:44,406 --> 00:33:48,766 A:middle
to set just the keys that
have changed on this record.

717
00:33:49,156 --> 00:33:50,816 A:middle
So let's say we want to
change just the party

718
00:33:51,696 --> 00:33:54,926 A:middle
and make this record
our WWDC bash record.

719
00:33:55,176 --> 00:33:57,186 A:middle
We set the new value
for that key

720
00:33:57,536 --> 00:33:58,996 A:middle
and save the new
record for the server.

721
00:33:59,556 --> 00:34:05,686 A:middle
It is important to note that
you don't always have to set all

722

723
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

724
00:33:59,556 --> 00:34:05,686 A:middle
It is important to note that
you don't always have to set all

725
00:34:05,686 --> 00:34:07,836 A:middle
of the keys that
belong to a record

726
00:34:08,036 --> 00:34:10,186 A:middle
when storing changes
for that record.

727
00:34:10,186 --> 00:34:15,206 A:middle
So now that we are officially
maintaining and storing

728
00:34:15,206 --> 00:34:19,516 A:middle
that local cache, let's talk
about how do we fetch changes

729
00:34:19,596 --> 00:34:23,906 A:middle
from our custom zone in order
to keep that cache up to date?

730
00:34:24,186 --> 00:34:27,545 A:middle
Well, once again we already
have the answer to this

731
00:34:27,606 --> 00:34:31,286 A:middle
by using CKFetch record changes
operation which gives us all

732
00:34:31,286 --> 00:34:32,946 A:middle
of the records that have
changed in our zone.

733
00:34:33,596 --> 00:34:36,946 A:middle
The real question is, when
do we use this operation?

734
00:34:37,565 --> 00:34:40,505 A:middle
Because using this operation
alone does not tell us

735
00:34:40,656 --> 00:34:42,485 A:middle
when our zone has changed.

736
00:34:43,025 --> 00:34:44,446 A:middle
So for that we need

737
00:34:44,446 --> 00:34:49,426 A:middle
to use notifications via
the CKSubscription API.

738
00:34:49,676 --> 00:34:52,585 A:middle
More specifically,
since the changes

739
00:34:52,585 --> 00:34:56,485 A:middle
in the zone are not changes that
you wish to alert a user about,

740
00:34:56,485 --> 00:34:59,576 A:middle
what we really want here
are silent notifications.

741

742
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

743
00:35:01,236 --> 00:35:06,476 A:middle
So in the next section, I would
like to talk to you about how

744
00:35:06,476 --> 00:35:09,426 A:middle
to get up and running with
subscriptions especially

745
00:35:09,426 --> 00:35:11,646 A:middle
when you want to use
silent subscriptions.

746
00:35:12,436 --> 00:35:14,446 A:middle
Let's start with brief recap.

747
00:35:15,136 --> 00:35:16,336 A:middle
What are subscriptions?

748
00:35:17,476 --> 00:35:20,316 A:middle
Subscriptions are per
user persistent queries

749
00:35:20,316 --> 00:35:21,446 A:middle
that you saved to the server.

750
00:35:22,016 --> 00:35:26,016 A:middle
They are a way for
you, for your app

751
00:35:26,156 --> 00:35:29,476 A:middle
to receive remote notifications
per relevant changes.

752
00:35:30,496 --> 00:35:33,266 A:middle
There are two types of
subscriptions, and they differ

753
00:35:33,266 --> 00:35:36,586 A:middle
in the way you define what a
relevant change for you is.

754
00:35:38,336 --> 00:35:41,496 A:middle
Number one, there are
query subscriptions

755
00:35:41,696 --> 00:35:43,216 A:middle
which allow you to
store a predicate.

756
00:35:44,006 --> 00:35:46,406 A:middle
So when the predicate
values to true,

757
00:35:46,606 --> 00:35:47,666 A:middle
that's your relevant change.

758
00:35:48,976 --> 00:35:51,356 A:middle
The second ones are
zone subscriptions

759
00:35:51,356 --> 00:35:53,336 A:middle
where every modification

760
00:35:53,336 --> 00:35:55,636 A:middle
to a zone counts as
a relevant change.

761
00:35:56,226 --> 00:36:02,796 A:middle
So this is clearly what we
want in the case of trying

762

763
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

764
00:35:56,226 --> 00:36:02,796 A:middle
So this is clearly what we
want in the case of trying

765
00:36:02,796 --> 00:36:05,686 A:middle
to get silent notifications
whenever our zone changes.

766
00:36:06,996 --> 00:36:10,746 A:middle
But first, let's walk through
the general setup that you need

767
00:36:11,076 --> 00:36:13,346 A:middle
when handling all kinds
of CloudKit subscriptions.

768
00:36:13,726 --> 00:36:17,316 A:middle
What I would like to
emphasize with this setup is

769
00:36:17,316 --> 00:36:22,216 A:middle
that you still need to go
through the motions of setting

770
00:36:22,216 --> 00:36:24,076 A:middle
up remote notifications

771
00:36:24,236 --> 00:36:26,396 A:middle
as if they were not
coming from CloudKit.

772
00:36:27,546 --> 00:36:28,706 A:middle
Let me show you what
I mean by that.

773
00:36:29,266 --> 00:36:31,956 A:middle
Number one, you still
need the APS capability

774
00:36:31,956 --> 00:36:34,586 A:middle
for the app ID turned on
from the developer portal.

775
00:36:35,256 --> 00:36:38,236 A:middle
This should get automatically
turned on for you when you turn

776
00:36:38,236 --> 00:36:39,416 A:middle
on the CloudKit capability.

777
00:36:39,866 --> 00:36:44,756 A:middle
Number two, you need to set the
APS environment key in your app

778
00:36:44,826 --> 00:36:47,446 A:middle
into a P list for development
while you're testing your app

779
00:36:47,446 --> 00:36:49,276 A:middle
and expecting remote
notifications.

780
00:36:51,476 --> 00:36:52,946 A:middle
Third, you still need

781
00:36:52,946 --> 00:36:55,256 A:middle
to register via the
UI application API.

782
00:36:55,986 --> 00:36:58,956 A:middle
At the very least, you
need to call register

783
00:36:58,956 --> 00:37:02,906 A:middle
for remote notifications
and also call user,

784

785
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

786
00:36:58,956 --> 00:37:02,906 A:middle
for remote notifications
and also call user,

787
00:37:03,036 --> 00:37:05,766 A:middle
register user notification
settings if you are planning

788
00:37:05,766 --> 00:37:10,576 A:middle
to show user notifications
in your app.

789
00:37:11,196 --> 00:37:14,146 A:middle
Now, since we are interested
in silent notifications

790
00:37:14,486 --> 00:37:16,166 A:middle
and we're dealing with
the CloudKit server

791
00:37:16,166 --> 00:37:19,256 A:middle
that sends us notifications,
how do we tell the server

792
00:37:19,966 --> 00:37:21,626 A:middle
that this should be a
silent notification?

793
00:37:22,736 --> 00:37:26,476 A:middle
We do that through
CKNotification info

794
00:37:26,596 --> 00:37:28,316 A:middle
corresponding to
our CK subscription.

795
00:37:28,826 --> 00:37:30,166 A:middle
That is our entry point

796
00:37:30,406 --> 00:37:32,886 A:middle
into telling the CloudKit
server just what kind

797
00:37:32,886 --> 00:37:36,146 A:middle
of a push payload should be
sent and at what priority.

798
00:37:36,516 --> 00:37:37,736 A:middle
Let's talk about priorities.

799
00:37:39,006 --> 00:37:44,426 A:middle
So like I said, we configure
our CKNotification info in a way

800
00:37:44,526 --> 00:37:45,916 A:middle
that tells the CloudKit server

801
00:37:46,156 --> 00:37:48,706 A:middle
that this is a silent
notification and it needs

802
00:37:48,706 --> 00:37:49,846 A:middle
to come at a low priority.

803
00:37:51,776 --> 00:37:54,926 A:middle
The server will send you a high
priority push if you have any

804
00:37:54,926 --> 00:37:57,396 A:middle
of these keys set on your
CK notification info.

805
00:37:57,826 --> 00:38:02,136 A:middle
Whether it's the alert body,
should badge or sound name.

806

807
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

808
00:37:57,826 --> 00:38:02,136 A:middle
Whether it's the alert body,
should badge or sound name.

809
00:38:03,586 --> 00:38:06,316 A:middle
These are what we call UI
keys for your subscription.

810
00:38:06,416 --> 00:38:07,756 A:middle
If you send any one of them,

811
00:38:08,176 --> 00:38:10,716 A:middle
the server sends a high
priority push that is meant

812
00:38:10,716 --> 00:38:11,966 A:middle
to be delivered immediately.

813
00:38:14,036 --> 00:38:17,726 A:middle
All other pushes are sent
at medium priority and count

814
00:38:17,726 --> 00:38:19,026 A:middle
as silent notifications.

815
00:38:21,116 --> 00:38:24,826 A:middle
So let's walk through what is
a silent notification specific

816
00:38:24,826 --> 00:38:28,206 A:middle
setup that you need.

817
00:38:28,956 --> 00:38:30,776 A:middle
Number one, you need to turn

818
00:38:30,776 --> 00:38:33,626 A:middle
on the remote notification
background mode for your app.

819
00:38:34,276 --> 00:38:36,876 A:middle
You do this through the
capabilities pane in Xcode.

820
00:38:37,966 --> 00:38:41,846 A:middle
You should remember
to checkmark that.

821
00:38:42,056 --> 00:38:43,756 A:middle
Number two, you should make sure

822
00:38:43,756 --> 00:38:45,766 A:middle
that you implement
the application

823
00:38:45,766 --> 00:38:47,346 A:middle
that you receive
remote notification,

824
00:38:47,706 --> 00:38:49,666 A:middle
fetch completion
handler notification

825
00:38:49,666 --> 00:38:51,016 A:middle
of the application delegate API.

826
00:38:52,696 --> 00:38:55,696 A:middle
The other version is not going
to be called in the background.

827
00:38:55,696 --> 00:38:58,456 A:middle
Make sure when you are
expecting silent notifications,

828
00:38:58,456 --> 00:38:59,966 A:middle
you have implemented
this version.

829

830
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

831
00:39:00,536 --> 00:39:06,366 A:middle
And third, once again now we
need to tell the CloudKit server

832
00:39:06,366 --> 00:39:08,236 A:middle
that this is going
to be a silent push,

833
00:39:08,786 --> 00:39:10,746 A:middle
how do we configure our
CKNotification info?

834
00:39:11,256 --> 00:39:14,446 A:middle
First and most importantly,

835
00:39:14,446 --> 00:39:17,516 A:middle
you should set the 'should send
content available' property

836
00:39:17,516 --> 00:39:17,986 A:middle
to true.

837
00:39:18,786 --> 00:39:20,296 A:middle
It tells the CloudKit server

838
00:39:20,296 --> 00:39:22,706 A:middle
that in your push payload it
should include the content

839
00:39:22,706 --> 00:39:24,766 A:middle
available key.

840
00:39:26,056 --> 00:39:29,766 A:middle
Secondly you should not
set any of the UI keys

841
00:39:29,766 --> 00:39:32,796 A:middle
that we just talked about
on that CKNotification info.

842
00:39:33,506 --> 00:39:35,466 A:middle
Setting any one of
these properties along

843
00:39:35,466 --> 00:39:38,206 A:middle
with should send content
available is not a supported

844
00:39:38,206 --> 00:39:40,716 A:middle
configuration and will result
in an error on the server.

845
00:39:43,216 --> 00:39:46,606 A:middle
So now let's talk about
silent push delivery.

846
00:39:46,606 --> 00:39:49,196 A:middle
We've configured everything,
we are expecting pushes.

847
00:39:49,566 --> 00:39:51,966 A:middle
When do we get them?

848
00:39:52,406 --> 00:39:55,606 A:middle
Since these notifications are
not meant to alert the user

849
00:39:55,606 --> 00:39:58,836 A:middle
in any way, they
are sent at a time

850
00:39:58,836 --> 00:40:00,326 A:middle
that is opportune
for the system.

851

852
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

853
00:39:58,836 --> 00:40:00,326 A:middle
that is opportune
for the system.

854
00:40:00,826 --> 00:40:03,806 A:middle
The system considers a variety
of factors when deciding

855
00:40:03,806 --> 00:40:04,896 A:middle
when they should get delivered.

856
00:40:05,516 --> 00:40:10,556 A:middle
And push delivery in
general is best effort.

857
00:40:11,636 --> 00:40:14,336 A:middle
What I mean by that is that
pushes could get coalesced

858
00:40:14,656 --> 00:40:17,276 A:middle
or even dropped depending on
the conditions of a device.

859
00:40:17,966 --> 00:40:21,426 A:middle
For example, if a device was
in airplane mode when a flurry

860
00:40:21,426 --> 00:40:24,416 A:middle
of pushes was expected,
coming out of airplane mode,

861
00:40:24,446 --> 00:40:27,516 A:middle
the Apple push notification
server will only send the device

862
00:40:27,556 --> 00:40:31,546 A:middle
the last push that was
meant to be received on it.

863
00:40:31,806 --> 00:40:34,976 A:middle
Now, we have ways to mitigate
this because we are dealing

864
00:40:34,976 --> 00:40:36,456 A:middle
with CloudKit notifications.

865
00:40:37,486 --> 00:40:42,656 A:middle
In particular, CloudKit server
stores all of the notifications

866
00:40:42,656 --> 00:40:44,646 A:middle
that were meant to be
delivered to your device

867
00:40:44,746 --> 00:40:46,846 A:middle
in what we call a
notification collection.

868
00:40:47,996 --> 00:40:50,846 A:middle
So when you do receive
a silent notification,

869
00:40:51,076 --> 00:40:53,796 A:middle
you should make sure
to fetch changes

870
00:40:53,796 --> 00:40:55,226 A:middle
from this notification
collection,

871
00:40:55,316 --> 00:40:58,886 A:middle
and you do that via the CKFetch
notification changes operation.

872
00:40:59,486 --> 00:41:04,566 A:middle
So now we are getting silent
notifications, we are checking

873

874
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

875
00:40:59,486 --> 00:41:04,566 A:middle
So now we are getting silent
notifications, we are checking

876
00:41:04,666 --> 00:41:06,416 A:middle
if there are any
notifications that we've missed,

877
00:41:07,146 --> 00:41:09,096 A:middle
and we know that
our zone has changed

878
00:41:09,096 --> 00:41:11,566 A:middle
which is the reason we got the
notification in the first place.

879
00:41:12,036 --> 00:41:15,736 A:middle
This is where we use CKFetch
record changes operation

880
00:41:15,826 --> 00:41:17,366 A:middle
to see what has changed
in our zone.

881
00:41:18,436 --> 00:41:22,446 A:middle
But once again like we've
talked about before,

882
00:41:22,446 --> 00:41:24,926 A:middle
we have no idea how many
things changed in that zone.

883
00:41:25,706 --> 00:41:28,056 A:middle
So potentially this could
be a long running operation.

884
00:41:28,376 --> 00:41:31,176 A:middle
If you need a little more time
for that operation to complete,

885
00:41:31,686 --> 00:41:32,816 A:middle
I recommend that you look

886
00:41:32,816 --> 00:41:35,436 A:middle
into the background task
API on UI application.

887
00:41:36,996 --> 00:41:39,776 A:middle
This will let you get
that extra time in order

888
00:41:39,776 --> 00:41:43,786 A:middle
for your operation to complete.

889
00:41:44,136 --> 00:41:46,346 A:middle
Now, before we start
talking about notifications,

890
00:41:46,926 --> 00:41:50,536 A:middle
in iOS 8 we introduced
an entirely new category

891
00:41:50,796 --> 00:41:53,426 A:middle
of notifications called
interactive notifications

892
00:41:53,646 --> 00:41:57,696 A:middle
which allow a user to interact
with pushes from banner,

893
00:41:57,786 --> 00:41:59,616 A:middle
alert or from a notification
center.

894

895
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

896
00:42:01,046 --> 00:42:03,776 A:middle
And we have had a lot of
requests from you to be able

897
00:42:03,776 --> 00:42:06,206 A:middle
to configure interactive
notifications with CloudKit.

898
00:42:06,716 --> 00:42:09,156 A:middle
I'm pleased to announce
with iOS 9 you can do just

899
00:42:09,156 --> 00:42:10,966 A:middle
that with minimal
amount of setup.

900
00:42:11,416 --> 00:42:15,116 A:middle
Once again if you just set
the new category property

901
00:42:15,396 --> 00:42:19,506 A:middle
on CKNotification
info, it corresponds

902
00:42:19,506 --> 00:42:21,426 A:middle
to the identifier
you that registered

903
00:42:21,936 --> 00:42:24,406 A:middle
with UI mutable notification
categories

904
00:42:24,546 --> 00:42:26,576 A:middle
when registering user
notification settings.

905
00:42:27,496 --> 00:42:29,916 A:middle
That is all the setup you
need to get up and running

906
00:42:29,916 --> 00:42:31,696 A:middle
with interactive
notifications with CloudKit.

907
00:42:32,516 --> 00:42:38,856 A:middle
[Applause]

908
00:42:39,356 --> 00:42:39,896 A:middle
>> NIHAR SHARMA: Thank you.

909
00:42:40,586 --> 00:42:43,526 A:middle
And with that, I would
like to start talking

910
00:42:43,526 --> 00:42:46,106 A:middle
about a general set
of performance tips

911
00:42:46,196 --> 00:42:49,116 A:middle
that you should keep in mind
and use in your apps today

912
00:42:49,296 --> 00:42:51,886 A:middle
when working with CloudKit.

913
00:42:52,336 --> 00:42:56,736 A:middle
CloudKit is a highly
asynchronous API.

914
00:42:56,966 --> 00:43:00,436 A:middle
Most operations talk over the
network, and it is very common

915

916
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

917
00:42:56,966 --> 00:43:00,436 A:middle
Most operations talk over the
network, and it is very common

918
00:43:00,436 --> 00:43:03,756 A:middle
to run into situations where you
have a set of dependent tasks

919
00:43:04,306 --> 00:43:06,706 A:middle
and you want to maintain
some sort of ordering

920
00:43:06,796 --> 00:43:09,286 A:middle
in which they complete.

921
00:43:09,756 --> 00:43:15,056 A:middle
Now, when implementing
task management for these,

922
00:43:15,366 --> 00:43:18,796 A:middle
there are a couple of goals,
a couple of high level goals

923
00:43:18,796 --> 00:43:21,906 A:middle
that we would like
you to keep in mind.

924
00:43:22,056 --> 00:43:23,966 A:middle
Number one, obviously

925
00:43:24,276 --> 00:43:27,536 A:middle
that whatever technique
you employ allows you

926
00:43:27,536 --> 00:43:30,536 A:middle
to implement great error
handling for every single one

927
00:43:30,536 --> 00:43:33,296 A:middle
of your CloudKit tasks.

928
00:43:33,456 --> 00:43:35,966 A:middle
Secondly, since these are
asynchronous operations,

929
00:43:35,966 --> 00:43:38,536 A:middle
you should make sure to
never end up in a situation

930
00:43:38,536 --> 00:43:39,866 A:middle
where you block the main thread

931
00:43:40,276 --> 00:43:41,836 A:middle
and degrade their
UI performance.

932
00:43:42,376 --> 00:43:47,536 A:middle
And last but not the least, as
developers you want to make sure

933
00:43:47,926 --> 00:43:51,236 A:middle
that your task management
scheme is, lets you end

934
00:43:51,236 --> 00:43:54,376 A:middle
up with maintainable code
that is easy to reason about,

935
00:43:54,376 --> 00:43:56,986 A:middle
debug and extend as you add
new features to your app.

936
00:43:57,726 --> 00:44:01,316 A:middle
Let's take a look at a couple
of ways where we do this

937

938
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

939
00:43:57,726 --> 00:44:01,316 A:middle
Let's take a look at a couple
of ways where we do this

940
00:44:01,686 --> 00:44:03,826 A:middle
and some dos and don'ts.

941
00:44:05,636 --> 00:44:09,236 A:middle
The number one don't is
nesting convenience API calls.

942
00:44:09,886 --> 00:44:14,146 A:middle
Let's take a simple example.

943
00:44:14,296 --> 00:44:17,076 A:middle
If we had to modify one
of the attendee records

944
00:44:17,206 --> 00:44:20,086 A:middle
in the old schema that we
saw, once again never use

945
00:44:20,086 --> 00:44:21,356 A:middle
that schema in the real world.

946
00:44:21,796 --> 00:44:24,046 A:middle
But if you had to modify
the attendee record,

947
00:44:24,046 --> 00:44:25,416 A:middle
this is what you
would have to do

948
00:44:25,416 --> 00:44:27,036 A:middle
when using convenience
API calls.

949
00:44:27,386 --> 00:44:30,066 A:middle
You would first fetch
record with ID and try

950
00:44:30,066 --> 00:44:31,106 A:middle
to fetch the party record

951
00:44:31,106 --> 00:44:33,176 A:middle
that you know the
attendees are part of,

952
00:44:33,836 --> 00:44:36,716 A:middle
then pull out the record
ID for the attendee

953
00:44:36,926 --> 00:44:41,526 A:middle
from the attendees array, and
then make your modification

954
00:44:41,526 --> 00:44:44,256 A:middle
to the attendee's record, and
then try to save that record.

955
00:44:45,246 --> 00:44:48,166 A:middle
This is trying to
modify one record

956
00:44:48,566 --> 00:44:50,086 A:middle
with one set of dependencies.

957
00:44:50,296 --> 00:44:52,366 A:middle
You can see we have
ended up with code

958
00:44:52,846 --> 00:45:00,426 A:middle
that is just a mangled piece
of soup where you have no idea

959

960
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

961
00:44:52,846 --> 00:45:00,426 A:middle
that is just a mangled piece
of soup where you have no idea

962
00:45:00,556 --> 00:45:03,656 A:middle
where to handle which
error and how best

963
00:45:03,656 --> 00:45:05,116 A:middle
to retry those operations.

964
00:45:06,096 --> 00:45:09,486 A:middle
In addition to that, there
is an additional point

965
00:45:09,486 --> 00:45:10,176 A:middle
of concern here.

966
00:45:11,386 --> 00:45:14,836 A:middle
Let's say that we issue these
operations due to some sort

967
00:45:14,836 --> 00:45:16,296 A:middle
of user action in our app.

968
00:45:17,336 --> 00:45:20,716 A:middle
Now, if a subsequent
user action were

969
00:45:20,716 --> 00:45:22,916 A:middle
to render these tasks
unnecessary,

970
00:45:23,216 --> 00:45:25,676 A:middle
once you've enqueued
them, you have no way

971
00:45:25,676 --> 00:45:26,696 A:middle
to cancel these tasks.

972
00:45:27,676 --> 00:45:30,206 A:middle
So if they are potentially
long running, you are stuck

973
00:45:30,236 --> 00:45:34,256 A:middle
with them running, you are
stuck waiting for them.

974
00:45:34,476 --> 00:45:36,566 A:middle
We recommend that you
never use this approach

975
00:45:36,686 --> 00:45:40,666 A:middle
when managing dependent
tasks especially if you need

976
00:45:40,666 --> 00:45:43,526 A:middle
to make the same modification
for a batch of records.

977
00:45:45,356 --> 00:45:48,156 A:middle
Now, another technique that
we see is to simply get rid

978
00:45:48,156 --> 00:45:50,686 A:middle
of the asynchronous
nature of the API perhaps

979
00:45:50,806 --> 00:45:54,656 A:middle
by introducing a
semaphore and waiting on it.

980
00:45:55,076 --> 00:45:57,236 A:middle
This can get hairy in a
couple of situations too.

981
00:45:58,126 --> 00:46:00,956 A:middle
You should almost
never try to do this.

982

983
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

984
00:45:58,126 --> 00:46:00,956 A:middle
You should almost
never try to do this.

985
00:46:02,176 --> 00:46:06,316 A:middle
If you do, you should keep
in mind that especially

986
00:46:06,316 --> 00:46:08,546 A:middle
if you wait forever for
operations to complete,

987
00:46:08,546 --> 00:46:10,916 A:middle
it it is very easy
for you to end

988
00:46:10,916 --> 00:46:12,686 A:middle
up with circular
dependencies that end

989
00:46:12,686 --> 00:46:15,726 A:middle
up causing a deadlock
in your app.

990
00:46:15,726 --> 00:46:19,226 A:middle
Or if you were to ever use
this practice on a main thread,

991
00:46:19,846 --> 00:46:23,176 A:middle
this will block your UI
right away on an operation

992
00:46:23,176 --> 00:46:25,406 A:middle
that is likely waiting
on the network and result

993
00:46:25,406 --> 00:46:26,806 A:middle
in a terrible user experience.

994
00:46:28,636 --> 00:46:30,806 A:middle
So we don't really recommend it.

995
00:46:33,596 --> 00:46:36,456 A:middle
What we do recommend is
for you to take a look

996
00:46:36,456 --> 00:46:40,336 A:middle
at the dependency management
API that NSOperation offers.

997
00:46:41,576 --> 00:46:43,186 A:middle
This is what I mean by that API.

998
00:46:44,076 --> 00:46:47,316 A:middle
NSOperation lets you easily
add and remove dependencies

999
00:46:47,316 --> 00:46:48,866 A:middle
between other NSOperations.

1000
00:46:49,396 --> 00:46:53,776 A:middle
Let's take a look at how
this works with CKOperations

1001
00:46:53,826 --> 00:46:55,866 A:middle
that are a subclass
of NSOperations.

1002
00:46:57,856 --> 00:47:01,156 A:middle
If we have two dependent
fetch records operations

1003

1004
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1005
00:46:57,856 --> 00:47:01,156 A:middle
If we have two dependent
fetch records operations

1006
00:47:01,706 --> 00:47:05,206 A:middle
and the second one should not
begin before the first one is

1007
00:47:05,206 --> 00:47:09,046 A:middle
completed, all you need to do is
set up both of those operations

1008
00:47:09,596 --> 00:47:13,096 A:middle
and add the first fetch as
a dependency on the second

1009
00:47:13,096 --> 00:47:14,936 A:middle
and enqueue both of
those operations.

1010
00:47:15,926 --> 00:47:19,816 A:middle
This will guarantee that the
second fetch does not start

1011
00:47:20,136 --> 00:47:21,546 A:middle
before the first
fetch is finished.

1012
00:47:22,536 --> 00:47:25,586 A:middle
You can see this offers
you a logical way to think

1013
00:47:25,586 --> 00:47:27,916 A:middle
about the errors for
particular operations

1014
00:47:28,246 --> 00:47:30,976 A:middle
and at the same time
manage dependencies for them

1015
00:47:31,096 --> 00:47:34,086 A:middle
in a convenient manner.

1016
00:47:34,716 --> 00:47:37,886 A:middle
Now, when thinking
about NSOperations

1017
00:47:37,886 --> 00:47:39,476 A:middle
from a performance context,

1018
00:47:40,936 --> 00:47:44,056 A:middle
there is an additional
distinction that I would

1019
00:47:44,056 --> 00:47:45,366 A:middle
like you guys to think about.

1020
00:47:46,796 --> 00:47:49,256 A:middle
Not all NSOperations
are created equal.

1021
00:47:50,026 --> 00:47:51,396 A:middle
Some of them may
have been created

1022
00:47:51,396 --> 00:47:53,196 A:middle
because of an explicit
user action

1023
00:47:53,196 --> 00:47:56,556 A:middle
in your apps while others may
represent background tasks

1024
00:47:56,746 --> 00:47:58,026 A:middle
that are of lower priority.

1025
00:47:59,396 --> 00:48:02,246 A:middle
To indicate this notion
of relative importance

1026

1027
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1028
00:47:59,396 --> 00:48:02,246 A:middle
To indicate this notion
of relative importance

1029
00:48:02,246 --> 00:48:04,146 A:middle
between NSOperations
to the system,

1030
00:48:04,506 --> 00:48:07,236 A:middle
in iOS 8 we introduced
the quality

1031
00:48:07,236 --> 00:48:09,646 A:middle
of service property
on NSOperations.

1032
00:48:11,056 --> 00:48:14,916 A:middle
This property lets you indicate
the nature and importance

1033
00:48:14,916 --> 00:48:17,596 A:middle
of work encapsulated
by your NSOperation.

1034
00:48:18,806 --> 00:48:21,276 A:middle
These are the various
service levels

1035
00:48:21,276 --> 00:48:24,676 A:middle
that this property can take,
and I recommend that you check

1036
00:48:24,676 --> 00:48:26,936 A:middle
out the documentation for
a description of each one

1037
00:48:26,936 --> 00:48:28,686 A:middle
of these values and
their significance.

1038
00:48:29,466 --> 00:48:32,086 A:middle
But what is important to keep
in mind here is that each

1039
00:48:32,086 --> 00:48:35,206 A:middle
of these service values
directly affects the priority

1040
00:48:35,206 --> 00:48:38,946 A:middle
with which the NSOperation is
allocated system resources,

1041
00:48:39,356 --> 00:48:43,166 A:middle
like CPU time, disk resources,
as well as network resources.

1042
00:48:45,086 --> 00:48:49,976 A:middle
Now, with CloudKit last year, we
wanted to give you a similar way

1043
00:48:49,976 --> 00:48:53,276 A:middle
to be able to opt your
lower priority CKOperations

1044
00:48:53,466 --> 00:48:55,196 A:middle
into discretionary
network behavior.

1045
00:48:56,336 --> 00:48:57,916 A:middle
What we mean by that, is

1046
00:48:57,916 --> 00:49:01,326 A:middle
that for your nonuser
initiated tasks, for example,

1047

1048
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1049
00:48:57,916 --> 00:49:01,326 A:middle
that for your nonuser
initiated tasks, for example,

1050
00:49:01,766 --> 00:49:04,416 A:middle
pre-fetching content for
the user like we just went

1051
00:49:04,416 --> 00:49:07,326 A:middle
through by using CKRecords
fetch record changes operation

1052
00:49:07,326 --> 00:49:09,386 A:middle
in response to silent
notifications.

1053
00:49:10,306 --> 00:49:13,236 A:middle
You want those tasks to opt
into discretionary behavior

1054
00:49:13,236 --> 00:49:16,356 A:middle
so that the system waits
for an opportune time

1055
00:49:16,936 --> 00:49:18,616 A:middle
to perform those
network requests.

1056
00:49:19,776 --> 00:49:22,376 A:middle
The system takes a variety
of factors into account

1057
00:49:22,586 --> 00:49:25,436 A:middle
when deciding when to
perform them, for exmple,

1058
00:49:26,146 --> 00:49:27,536 A:middle
cellular connectivity.

1059
00:49:27,946 --> 00:49:31,936 A:middle
The system might wait
for network connectivity

1060
00:49:31,936 --> 00:49:35,546 A:middle
to improve before sending
out those requests.

1061
00:49:35,546 --> 00:49:36,786 A:middle
Also power conditions.

1062
00:49:37,276 --> 00:49:38,796 A:middle
If a user is running
low on battery

1063
00:49:39,036 --> 00:49:41,956 A:middle
or the device is not currently
charging, the system will wait

1064
00:49:41,956 --> 00:49:45,236 A:middle
for power conditions to improve
before sending those requests.

1065
00:49:46,176 --> 00:49:49,816 A:middle
We did this by exposing the
user background session property

1066
00:49:49,896 --> 00:49:50,896 A:middle
on CKOperations.

1067
00:49:52,096 --> 00:49:58,796 A:middle
With iOS 9 we saw an opportunity
here to greatly simplify

1068
00:49:59,086 --> 00:50:03,496 A:middle
and unify these things, these
two concepts by using quality

1069

1070
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1071
00:49:59,086 --> 00:50:03,496 A:middle
and unify these things, these
two concepts by using quality

1072
00:50:03,496 --> 00:50:06,616 A:middle
of service to infer
your network behavior,

1073
00:50:06,956 --> 00:50:09,946 A:middle
and at the same time
pull in everything else

1074
00:50:09,946 --> 00:50:12,646 A:middle
that a given service level
already indicates to the system.

1075
00:50:13,466 --> 00:50:14,756 A:middle
So we are doing just that.

1076
00:50:16,296 --> 00:50:18,526 A:middle
By deprecating the user's
background session property

1077
00:50:19,116 --> 00:50:22,146 A:middle
and recommending that you start
setting quality of service

1078
00:50:22,326 --> 00:50:24,086 A:middle
on all of your CKOperations.

1079
00:50:25,776 --> 00:50:29,776 A:middle
Now, in the context of network
behavior, you can set either

1080
00:50:29,776 --> 00:50:33,456 A:middle
of the service levels user
interactive or user initiated

1081
00:50:33,456 --> 00:50:35,746 A:middle
to opt out of this
discretionary behavior.

1082
00:50:38,376 --> 00:50:41,156 A:middle
And for discretionary behavior,

1083
00:50:41,156 --> 00:50:43,776 A:middle
you can either set
the value utility

1084
00:50:44,816 --> 00:50:45,956 A:middle
in which case we will try

1085
00:50:45,956 --> 00:50:49,526 A:middle
to infer whether you should be
opted into discretionary based

1086
00:50:49,526 --> 00:50:53,966 A:middle
on whether the requesting app is
foreground or not or background

1087
00:50:54,756 --> 00:50:57,396 A:middle
which will always result in
discretionary network behavior.

1088
00:50:57,896 --> 00:51:03,126 A:middle
Please keep in mind that if
you build your apps with iOS 9

1089

1090
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1091
00:50:57,896 --> 00:51:03,126 A:middle
Please keep in mind that if
you build your apps with iOS 9

1092
00:51:03,126 --> 00:51:05,436 A:middle
and OS X El Capitan or later,

1093
00:51:06,466 --> 00:51:09,796 A:middle
all new CKOperations will
have the background quality

1094
00:51:09,796 --> 00:51:10,956 A:middle
of service by default.

1095
00:51:11,826 --> 00:51:15,186 A:middle
You should make sure that you
audit all of your CKOperations,

1096
00:51:16,166 --> 00:51:17,546 A:middle
take a look at what
is the importance

1097
00:51:17,546 --> 00:51:18,736 A:middle
of work that they represent.

1098
00:51:19,076 --> 00:51:20,486 A:middle
Be a good systems citizen

1099
00:51:20,726 --> 00:51:24,946 A:middle
and set the appropriate
QS values on them.

1100
00:51:25,206 --> 00:51:26,976 A:middle
NSOperation is very
powerful API,

1101
00:51:27,216 --> 00:51:28,796 A:middle
and there's a lot more
you can do with it.

1102
00:51:29,556 --> 00:51:32,816 A:middle
If you want to learn more, I
highly recommend that you go

1103
00:51:32,816 --> 00:51:35,696 A:middle
to the advanced NSOperation
session tomorrow morning

1104
00:51:36,396 --> 00:51:38,216 A:middle
in Presidio.

1105
00:51:38,216 --> 00:51:43,086 A:middle
In summary, I'd like to
reiterate that error handling

1106
00:51:43,086 --> 00:51:45,006 A:middle
for your CloudKit code is vital.

1107
00:51:45,336 --> 00:51:48,846 A:middle
It is as important as any
feature, and we would like you

1108
00:51:48,846 --> 00:51:51,156 A:middle
to take a look, go back
today and take a look

1109
00:51:51,156 --> 00:51:53,336 A:middle
at all your operations,
see what kinds

1110
00:51:53,336 --> 00:51:54,386 A:middle
of errors have you been hitting,

1111
00:51:54,666 --> 00:51:56,926 A:middle
and if you followed the
general guidelines we talked

1112
00:51:56,926 --> 00:52:00,336 A:middle
about today in handling them.

1113

1114
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1115
00:51:56,926 --> 00:52:00,336 A:middle
about today in handling them.

1116
00:52:00,526 --> 00:52:03,036 A:middle
Number two, start
batching your requests.

1117
00:52:03,306 --> 00:52:06,966 A:middle
Whenever you see your app
using the convenience API,

1118
00:52:07,426 --> 00:52:10,506 A:middle
working on one item
at a time and doing

1119
00:52:10,506 --> 00:52:11,386 A:middle
that in multiple places,

1120
00:52:11,386 --> 00:52:14,816 A:middle
think with about using the
CKOperation version of that API

1121
00:52:15,506 --> 00:52:16,716 A:middle
and batching those requests up.

1122
00:52:17,226 --> 00:52:19,176 A:middle
You will not only
improve the efficiency

1123
00:52:19,536 --> 00:52:22,496 A:middle
that your operations execute
with in the system in general,

1124
00:52:22,896 --> 00:52:25,526 A:middle
you will also save your
own network request quota.

1125
00:52:27,456 --> 00:52:29,426 A:middle
Think about schema tradeoffs.

1126
00:52:29,606 --> 00:52:33,596 A:middle
We've seen two cases where
our schema tradeoffs came --

1127
00:52:33,596 --> 00:52:38,336 A:middle
let us take advantage
of optimizations.

1128
00:52:38,496 --> 00:52:41,376 A:middle
For example when we
added the thumbnail key

1129
00:52:41,376 --> 00:52:45,546 A:middle
to our photo record, we were
able to optimize our download

1130
00:52:45,546 --> 00:52:48,156 A:middle
by just downloading
the data that we need.

1131
00:52:48,906 --> 00:52:52,036 A:middle
And in another case we were
able to avoid an entire class

1132
00:52:52,036 --> 00:52:56,896 A:middle
of errors when we avoided the
same party record being modified

1133
00:52:57,076 --> 00:52:58,486 A:middle
when photo records
were stored on it.

1134
00:52:59,096 --> 00:53:01,276 A:middle
So think about your
schema carefully

1135

1136
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1137
00:52:59,096 --> 00:53:01,276 A:middle
So think about your
schema carefully

1138
00:53:02,336 --> 00:53:03,366 A:middle
when designing features.

1139
00:53:03,916 --> 00:53:08,356 A:middle
And last but not the least,
configure your CKOperations.

1140
00:53:08,356 --> 00:53:11,206 A:middle
They have, they are
a very powerful API

1141
00:53:11,206 --> 00:53:14,066 A:middle
and they offer a ton of
optimizations you can make

1142
00:53:14,236 --> 00:53:16,676 A:middle
to the actual network
request that gets sent

1143
00:53:16,676 --> 00:53:17,876 A:middle
to the CloudKit servers.

1144
00:53:19,816 --> 00:53:22,886 A:middle
For more information please
check out our documentation

1145
00:53:22,886 --> 00:53:25,036 A:middle
on developer.Apple.com/CloudKit.

1146
00:53:25,766 --> 00:53:28,716 A:middle
For all the other questions and
answers, the technical support,

1147
00:53:28,716 --> 00:53:31,886 A:middle
the forums and the CK support
site are a great place.

1148
00:53:32,276 --> 00:53:35,466 A:middle
For general queries, please
e-mail CloudKit@Apple.com.

1149
00:53:36,246 --> 00:53:38,996 A:middle
We have had some great
related sessions this week.

1150
00:53:38,996 --> 00:53:41,206 A:middle
I invite you to check them
out when you go back today

1151
00:53:41,526 --> 00:53:44,096 A:middle
to Learn all that's
new with Web services

1152
00:53:44,546 --> 00:53:45,926 A:middle
and what else is
new in CloudKit.

1153
00:53:46,976 --> 00:53:49,326 A:middle
We have one more Lab
coming up tomorrow morning

1154
00:53:49,326 --> 00:53:51,136 A:middle
at 9 in Frameworks lab D.

1155
00:53:51,136 --> 00:53:54,316 A:middle
Bring your questions and
we'd be happy to answer them.

1156
00:53:54,886 --> 00:53:55,196 A:middle
Thank you.

1157
00:53:56,516 --> 00:54:00,500 A:middle
[Applause]

1158
