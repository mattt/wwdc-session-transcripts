X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:23,516 --> 00:00:29,486 A:middle
[Applause]

2
00:00:29,986 --> 00:00:31,616 A:middle
>> PRABHAKAR LAKHERA:
Thank you and good morning.

3
00:00:32,656 --> 00:00:36,046 A:middle
Welcome to Your App and Next
Generation Network session.

4
00:00:36,996 --> 00:00:40,306 A:middle
I am Prabhakar Lakhera and
with me I have my colleague

5
00:00:40,406 --> 00:00:41,036 A:middle
Stuart Cheshire.

6
00:00:42,746 --> 00:00:44,896 A:middle
And this session
is in two parts.

7
00:00:44,896 --> 00:00:49,936 A:middle
For the first topic I
will talk about IPv6,

8
00:00:50,436 --> 00:00:53,556 A:middle
and for the second topic
Stuart will talk about how

9
00:00:53,556 --> 00:00:55,866 A:middle
to make your applications
run faster.

10
00:00:57,476 --> 00:01:02,586 A:middle
We will start off
with IPv6 first.

11

12
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

13
00:00:57,476 --> 00:01:02,586 A:middle
We will start off
with IPv6 first.

14
00:01:02,776 --> 00:01:04,426 A:middle
Now, what's new in IPv6?

15
00:01:05,796 --> 00:01:09,826 A:middle
IPv6 RFC was published
almost 17 years back.

16
00:01:11,086 --> 00:01:15,836 A:middle
So you must be wondering, why
are we talking about IPv6 now?

17
00:01:17,596 --> 00:01:23,236 A:middle
We are seeing more and more of
IPv6 deployment in enterprise

18
00:01:23,366 --> 00:01:25,196 A:middle
and cellular networks.

19
00:01:26,056 --> 00:01:27,806 A:middle
And you want to make sure

20
00:01:27,866 --> 00:01:30,986 A:middle
that your applications
work in those networks.

21
00:01:31,286 --> 00:01:36,776 A:middle
That is the reason we will also
be mandating your applications

22
00:01:36,776 --> 00:01:38,206 A:middle
to be IPv6 compliant.

23
00:01:38,876 --> 00:01:41,896 A:middle
Now, we will talk more about
that and what it means to you

24
00:01:41,896 --> 00:01:44,376 A:middle
as developers, but
before we do that,

25
00:01:44,966 --> 00:01:46,936 A:middle
let's begin with
a bit of history.

26
00:01:47,436 --> 00:01:53,386 A:middle
Now, a long, long time ago,
client devices had real

27
00:01:53,446 --> 00:01:57,946 A:middle
and unique IPv4 addresses;
these were the good olden days

28
00:01:57,946 --> 00:02:00,226 A:middle
and you had end-to-end
network connectivity.

29

30
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

31
00:01:57,946 --> 00:02:00,226 A:middle
and you had end-to-end
network connectivity.

32
00:02:01,536 --> 00:02:04,056 A:middle
However, we soon realized
that we were running

33
00:02:04,056 --> 00:02:06,406 A:middle
out of IPv4 addresses
way too fast.

34
00:02:07,276 --> 00:02:09,496 A:middle
So we added a NAT in the middle.

35
00:02:10,946 --> 00:02:15,226 A:middle
Now, this works, but the
larger scale NAT device is both

36
00:02:15,226 --> 00:02:17,146 A:middle
expensive and fragile.

37
00:02:18,606 --> 00:02:21,796 A:middle
So carriers are now deploying
IPv6 in their network.

38
00:02:21,796 --> 00:02:29,266 A:middle
Now, with this, they again have
end-to-end network connectivity

39
00:02:29,326 --> 00:02:33,236 A:middle
and there's no translation
needed in the data path.

40
00:02:33,406 --> 00:02:35,976 A:middle
I will now show you how
IPv6 deployment looks

41
00:02:36,276 --> 00:02:39,236 A:middle
for three major cellular
carriers in the USA.

42
00:02:39,636 --> 00:02:43,546 A:middle
Now, two things are
obvious here.

43
00:02:44,266 --> 00:02:47,826 A:middle
One, all the lines are going up.

44
00:02:48,436 --> 00:02:51,296 A:middle
And second, more than half

45
00:02:51,296 --> 00:02:53,246 A:middle
of the subscribers
are now connecting

46
00:02:53,246 --> 00:02:55,756 A:middle
to cellular data
networks over IPv6.

47
00:02:57,116 --> 00:02:58,376 A:middle
So that's great, right?

48
00:02:59,316 --> 00:03:01,206 A:middle
Turns out it's actually worse

49

50
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

51
00:02:59,316 --> 00:03:01,206 A:middle
Turns out it's actually worse

52
00:03:01,206 --> 00:03:03,336 A:middle
for cellular carriers
than it was before.

53
00:03:04,286 --> 00:03:09,636 A:middle
And the reason is now they are
having to support both IPv4

54
00:03:10,036 --> 00:03:12,156 A:middle
as well as IPv6 in
their network.

55
00:03:13,416 --> 00:03:16,816 A:middle
So what they really want
to do is to drop IPv4

56
00:03:17,116 --> 00:03:18,286 A:middle
from their access network.

57
00:03:19,246 --> 00:03:21,726 A:middle
Now, when you do that,
you lose connectivity

58
00:03:21,726 --> 00:03:23,896 A:middle
to the IPv4-only
part of the Internet,

59
00:03:24,376 --> 00:03:25,616 A:middle
which is still in majority.

60
00:03:27,676 --> 00:03:31,806 A:middle
So now they have deployed DNS64
and NAT64 in their network,

61
00:03:32,306 --> 00:03:35,246 A:middle
and the way it works
is when the application

62
00:03:35,246 --> 00:03:37,906 A:middle
on the client device
makes a hostname query

63
00:03:38,206 --> 00:03:41,836 A:middle
to get the IPv6 address
for an IPv4-only server,

64
00:03:42,616 --> 00:03:47,186 A:middle
DNS64 and the network
synthesizes an IPv6 address

65
00:03:47,186 --> 00:03:48,826 A:middle
and gives it back to
the client device.

66
00:03:49,106 --> 00:03:53,956 A:middle
Now that the client device has
this IPv6 address to work with,

67
00:03:54,236 --> 00:03:56,316 A:middle
it can start writing
traffic to the network.

68
00:03:57,636 --> 00:03:59,986 A:middle
The network itself is
configured in a way

69

70
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

71
00:04:00,046 --> 00:04:03,696 A:middle
that search packets get
shorted to the NAT64 engine,

72
00:04:04,226 --> 00:04:08,376 A:middle
which then translates
IPv6 traffic to IPv4

73
00:04:08,646 --> 00:04:09,906 A:middle
and vice versa on the way back.

74
00:04:10,436 --> 00:04:14,366 A:middle
Now, the important
thing to note here is

75
00:04:14,366 --> 00:04:17,676 A:middle
that to the applications
running on the client device,

76
00:04:18,546 --> 00:04:23,716 A:middle
your IPv4-only server looks
like an IPv6-only server.

77
00:04:24,556 --> 00:04:27,396 A:middle
And this is important
because till now,

78
00:04:27,396 --> 00:04:29,076 A:middle
some of you in the room
may have been thinking

79
00:04:29,076 --> 00:04:32,466 A:middle
that my server is only
configured for IPv4,

80
00:04:32,786 --> 00:04:34,336 A:middle
so I do not need to test

81
00:04:34,336 --> 00:04:37,596 A:middle
for a client accessing
it over an IPv6 network.

82
00:04:39,046 --> 00:04:40,746 A:middle
Your assumption just got broken.

83
00:04:41,246 --> 00:04:43,626 A:middle
Now the transition to this type

84
00:04:43,626 --> 00:04:46,756 A:middle
of network will happen very
soon, and when it happens,

85
00:04:47,756 --> 00:04:50,606 A:middle
we want it to be an
absolutely seamless experience

86
00:04:50,606 --> 00:04:51,336 A:middle
for our consumers.

87
00:04:52,286 --> 00:04:58,896 A:middle
And that is the reason your
app has to be IPv6 compliant,

88

89
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

90
00:05:00,206 --> 00:05:02,686 A:middle
and this will be an app
submission requirement.

91
00:05:04,176 --> 00:05:06,506 A:middle
So great, we have a new app
submission requirement, right?

92
00:05:06,506 --> 00:05:09,686 A:middle
And you must be wondering
how do I test my application

93
00:05:09,686 --> 00:05:10,356 A:middle
for this network?

94
00:05:11,016 --> 00:05:13,296 A:middle
Where will I find this
NAT64 type of network?

95
00:05:14,336 --> 00:05:16,686 A:middle
I have a great news
for all of you.

96
00:05:18,776 --> 00:05:22,736 A:middle
Starting today, with just
your Mac devices on top

97
00:05:22,736 --> 00:05:27,066 A:middle
of IPv4 connectivity, you can
create your very own NAT64

98
00:05:27,066 --> 00:05:29,576 A:middle
networks and start
testing your applications.

99
00:05:29,786 --> 00:05:33,566 A:middle
Now, this feature is meant
to be used by the developers,

100
00:05:33,776 --> 00:05:37,396 A:middle
so it's somewhat hidden, and to
make it visible, all you have

101
00:05:37,396 --> 00:05:44,366 A:middle
to do is to Option-click on
Sharing, then Option-click

102
00:05:44,366 --> 00:05:48,006 A:middle
on Internet Sharing, and now you
will see everything looks just

103
00:05:48,006 --> 00:05:48,536 A:middle
the same.

104
00:05:49,446 --> 00:05:51,436 A:middle
But there's a new
checkbox here that says

105
00:05:51,846 --> 00:05:53,616 A:middle
"Create NAT64 Network."

106
00:05:53,616 --> 00:05:58,206 A:middle
So you check that, you
choose your interfaces

107
00:05:58,206 --> 00:06:02,146 A:middle
for Internet sharing, and now
you can host this NAT64 network

108

109
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

110
00:05:58,206 --> 00:06:02,146 A:middle
for Internet sharing, and now
you can host this NAT64 network

111
00:06:03,236 --> 00:06:04,886 A:middle
and start testing
your applications.

112
00:06:05,776 --> 00:06:09,936 A:middle
Now, for the example here,
I have my IPv4 connectivity

113
00:06:10,066 --> 00:06:12,436 A:middle
on the Internet and
I'm sharing this

114
00:06:12,436 --> 00:06:17,566 A:middle
as an IPv6-only access
network with NAT64/DNS64

115
00:06:17,676 --> 00:06:18,766 A:middle
on my Wi-Fi interface.

116
00:06:19,826 --> 00:06:25,286 A:middle
So when I start it, I see that
the Wi-Fi icon has grayed out

117
00:06:25,286 --> 00:06:27,806 A:middle
and it has an arrow pointing up.

118
00:06:29,056 --> 00:06:31,796 A:middle
That means now the
Wi-Fi interface is

119
00:06:31,796 --> 00:06:33,836 A:middle
in access point mode.

120
00:06:34,536 --> 00:06:37,916 A:middle
What that really means is now
it's hosting a Wi-Fi hotspot,

121
00:06:37,916 --> 00:06:40,056 A:middle
and you can connect your
other client devices

122
00:06:40,206 --> 00:06:41,606 A:middle
and start testing
your applications.

123
00:06:42,486 --> 00:06:46,456 A:middle
Now, a typical test bed
will look like this.

124
00:06:46,676 --> 00:06:49,856 A:middle
Now, here I have my IPv4
Internet connectivity

125
00:06:50,066 --> 00:06:54,136 A:middle
on the WAN side, my iMac has
the DNS64/NAT64 engine running

126
00:06:54,136 --> 00:06:58,836 A:middle
on it, and it is hosting an IPv6
network on the Wi-Fi interface.

127

128
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

129
00:07:00,096 --> 00:07:03,246 A:middle
Now the application that you
want to test is either installed

130
00:07:03,246 --> 00:07:04,666 A:middle
in one of the client machines,

131
00:07:05,196 --> 00:07:07,076 A:middle
or you could very
well be testing it

132
00:07:07,076 --> 00:07:08,726 A:middle
on a simulator that's running

133
00:07:08,726 --> 00:07:11,236 A:middle
on another Mac device
that's a client

134
00:07:11,236 --> 00:07:12,776 A:middle
of this Internet
sharing environment.

135
00:07:13,196 --> 00:07:18,516 A:middle
So now that we have made testing
easy for you, for this type

136
00:07:18,516 --> 00:07:21,816 A:middle
of network, what we
really want you to do is

137
00:07:21,856 --> 00:07:25,356 A:middle
to make sure it is part of
your development process.

138
00:07:26,166 --> 00:07:28,826 A:middle
That is, any time you are
writing a new application,

139
00:07:29,126 --> 00:07:31,396 A:middle
or you are writing an
update for your application,

140
00:07:31,786 --> 00:07:33,126 A:middle
make sure you are testing

141
00:07:33,126 --> 00:07:36,906 A:middle
for NAT64 network
environment before you submit

142
00:07:36,906 --> 00:07:37,686 A:middle
your applications.

143
00:07:37,976 --> 00:07:44,036 A:middle
Now, the good news is for
almost 70% of you, you will see

144
00:07:44,036 --> 00:07:46,496 A:middle
that your applications
are working just fine.

145
00:07:46,776 --> 00:07:47,956 A:middle
And that's great, right?

146
00:07:48,736 --> 00:07:50,436 A:middle
Just keep testing
your applications,

147
00:07:50,726 --> 00:07:54,066 A:middle
release after release and make
sure there's no regression.

148
00:07:54,616 --> 00:07:58,576 A:middle
But for almost a third
of you, you will see

149
00:07:58,576 --> 00:08:01,846 A:middle
that either your application
is severely limited

150

151
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

152
00:07:58,576 --> 00:08:01,846 A:middle
that either your application
is severely limited

153
00:08:01,846 --> 00:08:05,746 A:middle
in a NAT64 network environment
or it does not work at all.

154
00:08:07,206 --> 00:08:09,966 A:middle
Now, fortunately, most of
the issues are simple to fix,

155
00:08:10,716 --> 00:08:18,746 A:middle
and here's a sample list.

156
00:08:18,926 --> 00:08:23,346 A:middle
Now, if you are using only
IPv4-only data structures

157
00:08:23,346 --> 00:08:28,196 A:middle
or IPv4-only APIs, or
you are using an API

158
00:08:28,196 --> 00:08:30,706 A:middle
that supports both
IPv4 and IPv6,

159
00:08:31,346 --> 00:08:34,416 A:middle
but maybe you're passing
an argument that says

160
00:08:34,885 --> 00:08:38,586 A:middle
that only get me
results for IPv4,

161
00:08:38,586 --> 00:08:43,655 A:middle
all of these things will make
your application IPv4 only.

162
00:08:44,216 --> 00:08:46,486 A:middle
And what that means
is it will not work

163
00:08:46,486 --> 00:08:48,906 A:middle
in an IPv6-only access
network environment.

164
00:08:49,426 --> 00:08:53,496 A:middle
Now, there's another interesting
thing that we have seen

165
00:08:53,496 --> 00:08:56,256 A:middle
with some of these
applications that do not work,

166
00:08:57,786 --> 00:09:00,216 A:middle
that sometimes there's a
preflight check that checks

167

168
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

169
00:08:57,786 --> 00:09:00,216 A:middle
that sometimes there's a
preflight check that checks

170
00:09:00,216 --> 00:09:03,886 A:middle
for IPv4 connectivity even
before attempting a connection.

171
00:09:05,046 --> 00:09:09,566 A:middle
And that is the reason sometimes
you get errors like this.

172
00:09:10,516 --> 00:09:14,716 A:middle
So in this case, my iPhone
was actually connected

173
00:09:14,716 --> 00:09:17,736 A:middle
to the NAT64 network I had
just created on my Mac device,

174
00:09:18,476 --> 00:09:20,726 A:middle
and I could browse
Internet with Safari,

175
00:09:20,726 --> 00:09:22,856 A:middle
I could stream videos, music...

176
00:09:23,666 --> 00:09:25,226 A:middle
I had my Internet connectivity,

177
00:09:25,666 --> 00:09:29,156 A:middle
but for some reason this
application thinks I have no

178
00:09:29,156 --> 00:09:30,576 A:middle
Internet connectivity
whatsoever.

179
00:09:31,296 --> 00:09:34,366 A:middle
And if you read the
error message it says

180
00:09:34,366 --> 00:09:37,886 A:middle
that my device is in
airplane mode, but if you look

181
00:09:37,886 --> 00:09:40,636 A:middle
at the top bar, that's
not the case, right?

182
00:09:42,066 --> 00:09:43,956 A:middle
So what's going on here?

183
00:09:44,416 --> 00:09:47,346 A:middle
It's precisely the application
making a preflight check

184
00:09:47,376 --> 00:09:50,816 A:middle
to check for IPv4 connectivity,
and if you remember,

185
00:09:51,276 --> 00:09:54,426 A:middle
in IPv6-only access
network like NAT64 network,

186
00:09:55,066 --> 00:09:57,596 A:middle
you do not have IPv4
connectivity;

187
00:09:57,656 --> 00:10:01,156 A:middle
the entire world looks like
an IPv6-only world to you.

188

189
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

190
00:09:57,656 --> 00:10:01,156 A:middle
the entire world looks like
an IPv6-only world to you.

191
00:10:01,546 --> 00:10:05,286 A:middle
Even the IPv4-only server
looks like an IPv6-only server.

192
00:10:05,666 --> 00:10:07,446 A:middle
So if you do this
check, it will fail.

193
00:10:08,386 --> 00:10:11,056 A:middle
Now, in this case,
application is saying retry.

194
00:10:11,056 --> 00:10:14,006 A:middle
So I retried and it gave
me the same error message,

195
00:10:14,366 --> 00:10:16,606 A:middle
and then I retried again,
and the same error message.

196
00:10:17,236 --> 00:10:19,406 A:middle
And it never went off,
and I was just stuck

197
00:10:19,406 --> 00:10:20,296 A:middle
with this application.

198
00:10:21,226 --> 00:10:22,836 A:middle
So, what are the
recommendations?

199
00:10:23,226 --> 00:10:26,596 A:middle
Well, just attempt a connection.

200
00:10:27,966 --> 00:10:30,156 A:middle
Right? If it connects,
that's great.

201
00:10:30,156 --> 00:10:33,416 A:middle
If it does not, then
handle that case gracefully.

202
00:10:34,656 --> 00:10:36,606 A:middle
The second recommendation
would be

203
00:10:36,606 --> 00:10:40,466 A:middle
to use higher networking
frameworks like NSURLSession

204
00:10:41,036 --> 00:10:47,076 A:middle
or CFNetwork API, and
the reason is networking

205
00:10:48,016 --> 00:10:50,456 A:middle
with multihome devices
like iPhone

206
00:10:51,346 --> 00:10:54,456 A:middle
and Mac devices can
be somewhat complex.

207
00:10:54,956 --> 00:10:57,836 A:middle
Like for iPhone, you
have Wi-Fi interface

208
00:10:57,836 --> 00:10:59,396 A:middle
and you have cellular interface.

209
00:10:59,586 --> 00:11:02,176 A:middle
And with Mac devices, you
may have multiple Ethernet

210

211
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

212
00:10:59,586 --> 00:11:02,176 A:middle
And with Mac devices, you
may have multiple Ethernet

213
00:11:02,176 --> 00:11:04,726 A:middle
interfaces, and you have
a Wi-Fi interface also,

214
00:11:05,186 --> 00:11:07,466 A:middle
and at a given time, you
may have different kinds

215
00:11:07,466 --> 00:11:09,886 A:middle
of connectivity to
all these interfaces.

216
00:11:11,366 --> 00:11:16,126 A:middle
Now, which interface you use
and how to connect which type

217
00:11:16,126 --> 00:11:18,326 A:middle
of connectivity do you use
for a given destination,

218
00:11:18,886 --> 00:11:22,096 A:middle
writing that code yourself
can be a lot tedious.

219
00:11:22,726 --> 00:11:25,566 A:middle
So please use higher
networking frameworks.

220
00:11:25,896 --> 00:11:29,276 A:middle
It will make your application
code a lot cleaner and simpler.

221
00:11:29,276 --> 00:11:34,426 A:middle
Now if for some reason you
cannot use a higher networking

222
00:11:34,426 --> 00:11:37,186 A:middle
framework and if you are
having to work with sockets,

223
00:11:37,346 --> 00:11:42,786 A:middle
we will definitely recommend you
to read RFC 4038, and it talks

224
00:11:42,786 --> 00:11:45,776 A:middle
about in great length how
to write your applications

225
00:11:46,026 --> 00:11:47,916 A:middle
in a way that's address-family
agnostic.

226
00:11:50,296 --> 00:11:54,366 A:middle
Now, our final recommendation
would be to use hostnames

227
00:11:54,366 --> 00:11:57,106 A:middle
when possible and not to
use IP address literals,

228
00:11:57,286 --> 00:11:58,676 A:middle
whether IPv4 or IPv6.

229
00:11:58,676 --> 00:12:02,266 A:middle
When you are writing
your very own protocol,

230

231
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

232
00:11:58,676 --> 00:12:02,266 A:middle
When you are writing
your very own protocol,

233
00:12:02,266 --> 00:12:04,506 A:middle
a proprietary protocol, or
when you are writing your

234
00:12:04,506 --> 00:12:08,156 A:middle
application, make sure you are
not using IP address literals

235
00:12:08,556 --> 00:12:09,746 A:middle
but preferring hostnames.

236
00:12:10,216 --> 00:12:11,626 A:middle
And the reason is, remember,

237
00:12:11,986 --> 00:12:14,376 A:middle
in a NAT64/DNS64
network environment,

238
00:12:15,466 --> 00:12:18,106 A:middle
the client device first has
to make a DNS query, right?

239
00:12:18,406 --> 00:12:20,526 A:middle
To get the IPv6 address
for the IPv4 server.

240
00:12:20,656 --> 00:12:22,936 A:middle
So you have to work
with the hostname.

241
00:12:23,246 --> 00:12:25,526 A:middle
If you are working with
an IPv4 address literal,

242
00:12:26,116 --> 00:12:28,426 A:middle
the client device will
not make that DNS query,

243
00:12:28,726 --> 00:12:32,546 A:middle
and the DNS64 network will not
synthesize the IPv6 address

244
00:12:32,546 --> 00:12:32,856 A:middle
for you.

245
00:12:33,416 --> 00:12:39,266 A:middle
So, given that, we do understand
that sometimes there's no way

246
00:12:39,266 --> 00:12:44,416 A:middle
to avoid working with an
IPv4 address, and an example

247
00:12:44,416 --> 00:12:45,506 A:middle
of that would be Safari.

248
00:12:46,096 --> 00:12:48,676 A:middle
So you go to a web page,
it loads up just fine.

249
00:12:49,266 --> 00:12:52,356 A:middle
But within the web page,
there may be some other links,

250
00:12:52,906 --> 00:12:57,326 A:middle
and some of those links may
have IPv4 addresses embedded.

251
00:12:59,166 --> 00:13:02,276 A:middle
Now, before today, on
Safari if you clicked on one

252

253
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

254
00:12:59,166 --> 00:13:02,276 A:middle
Now, before today, on
Safari if you clicked on one

255
00:13:02,276 --> 00:13:04,726 A:middle
such link, it would not load up.

256
00:13:05,696 --> 00:13:13,236 A:middle
Starting iOS 9 and OS X 10.11,
not only Safari but any user

257
00:13:13,236 --> 00:13:18,956 A:middle
of NSURLSession or CFNetwork
API will be able to work even

258
00:13:18,956 --> 00:13:23,266 A:middle
with IPv4 address literals
in a NAT64/DNS64 network.

259
00:13:24,596 --> 00:13:26,746 A:middle
The way it works is when
you are using hostnames,

260
00:13:27,536 --> 00:13:30,816 A:middle
the DNS64 in the network is
synthesizing IPv6 addresses

261
00:13:30,816 --> 00:13:31,396 A:middle
for you.

262
00:13:32,546 --> 00:13:35,866 A:middle
But when you are working
with an IPv4 address literal

263
00:13:35,866 --> 00:13:38,126 A:middle
and using one of the
higher networking API,

264
00:13:39,016 --> 00:13:42,826 A:middle
the OS is discovering what
the network would have done

265
00:13:42,896 --> 00:13:45,526 A:middle
and how it would have
synthesized an IPv6 address

266
00:13:45,526 --> 00:13:47,696 A:middle
for you, and it will
do that locally.

267
00:13:48,276 --> 00:13:51,586 A:middle
So this is another reason
why you should be working

268
00:13:51,586 --> 00:13:53,016 A:middle
with higher network frameworks.

269
00:13:53,016 --> 00:13:56,446 A:middle
So please do that.

270
00:13:56,656 --> 00:14:00,936 A:middle
Now, with these data points
and with the new tool,

271

272
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

273
00:13:56,656 --> 00:14:00,936 A:middle
Now, with these data points
and with the new tool,

274
00:14:01,276 --> 00:14:04,396 A:middle
we really hope that you will
be able to find and fix issues

275
00:14:04,396 --> 00:14:05,496 A:middle
with your applications.

276
00:14:07,406 --> 00:14:12,036 A:middle
Now, what we want you to do
is after this session is over,

277
00:14:12,426 --> 00:14:14,826 A:middle
install the seed build
on your Mac devices

278
00:14:15,226 --> 00:14:17,916 A:middle
and start creating your
very own NAT64 networks,

279
00:14:18,156 --> 00:14:20,306 A:middle
and then use them to
test your applications.

280
00:14:21,496 --> 00:14:24,786 A:middle
Now, remember this will be an
app submission requirement.

281
00:14:25,716 --> 00:14:29,246 A:middle
So please take this message to
other developers who are not

282
00:14:29,246 --> 00:14:31,676 A:middle
in this session and also
take this message back

283
00:14:31,676 --> 00:14:34,696 A:middle
to your company and make sure
you are doing NAT64 testing

284
00:14:35,016 --> 00:14:35,896 A:middle
for your applications.

285
00:14:36,336 --> 00:14:43,036 A:middle
Now, with that, I now invite
Stuart Cheshire to talk

286
00:14:43,036 --> 00:14:45,346 A:middle
about other networking
features we have for you

287
00:14:45,746 --> 00:14:48,106 A:middle
that make your applications
faster

288
00:14:48,446 --> 00:14:50,486 A:middle
and be more responsive
to the users.

289
00:14:51,256 --> 00:14:51,856 A:middle
Stuart?

290
00:14:52,516 --> 00:14:58,636 A:middle
[Applause]

291
00:14:59,136 --> 00:14:59,916 A:middle
>> STUART CHESHIRE:
Thank you, Prabhakar.

292

293
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

294
00:15:02,546 --> 00:15:06,406 A:middle
What I want to talk about now
is making your applications

295
00:15:06,406 --> 00:15:07,076 A:middle
run faster.

296
00:15:09,116 --> 00:15:10,536 A:middle
In the last couple of decades,

297
00:15:10,606 --> 00:15:14,076 A:middle
we have seen a phenomenal
increase in network throughput.

298
00:15:15,036 --> 00:15:19,056 A:middle
I remember a time when the
56-kilobit modem was the latest

299
00:15:19,056 --> 00:15:21,366 A:middle
technology; now we
live in a world

300
00:15:21,366 --> 00:15:24,676 A:middle
where 50 megabits per
second is quite commonplace.

301
00:15:25,596 --> 00:15:27,776 A:middle
But things don't feel a
thousand times faster.

302
00:15:28,616 --> 00:15:31,056 A:middle
We still spend a lot
of time sitting waiting

303
00:15:31,056 --> 00:15:32,136 A:middle
for a web page to load.

304
00:15:32,426 --> 00:15:33,146 A:middle
And why is that?

305
00:15:34,716 --> 00:15:38,296 A:middle
It's because our industry
has put a huge focus

306
00:15:38,396 --> 00:15:39,956 A:middle
on increasing throughput

307
00:15:41,166 --> 00:15:44,986 A:middle
and it has sorely neglected
the other sources of delay.

308
00:15:46,156 --> 00:15:48,016 A:middle
The speed of light
hasn't gotten any faster

309
00:15:48,916 --> 00:15:52,006 A:middle
and we can't do anything about
that, but there are other areas

310
00:15:52,006 --> 00:15:54,286 A:middle
of delay that we can
fix and it's time

311
00:15:54,286 --> 00:15:55,346 A:middle
for us to start doing that.

312
00:15:56,176 --> 00:15:58,486 A:middle
So that's what I'm going
to talk about today.

313
00:15:59,316 --> 00:16:03,286 A:middle
I'm going to talk about
four sources of delay

314

315
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

316
00:15:59,316 --> 00:16:03,286 A:middle
I'm going to talk about
four sources of delay

317
00:16:03,906 --> 00:16:05,806 A:middle
when users are using
your applications.

318
00:16:06,976 --> 00:16:09,776 A:middle
The first one is the
delay that happens

319
00:16:10,056 --> 00:16:12,936 A:middle
when you have weak
Wi-Fi connectivity,

320
00:16:13,306 --> 00:16:14,986 A:middle
and connection attempts
are not succeeding.

321
00:16:15,976 --> 00:16:19,896 A:middle
The second area is a technique
called Explicit Congestion

322
00:16:19,896 --> 00:16:21,936 A:middle
Notification, which along

323
00:16:21,936 --> 00:16:25,916 A:middle
with smart queuing reduces
delays in the network.

324
00:16:27,036 --> 00:16:32,096 A:middle
The TCP NOTSENT Low-Water
Mark option reduces delays

325
00:16:32,516 --> 00:16:35,556 A:middle
in the sending machine, and
then we are going to finish

326
00:16:35,556 --> 00:16:36,976 A:middle
up with a sneak peek

327
00:16:37,096 --> 00:16:39,916 A:middle
of an exciting new technology
called TCP Fast Open.

328
00:16:40,746 --> 00:16:44,226 A:middle
So let's start off with
reliable network fallback.

329
00:16:45,406 --> 00:16:48,706 A:middle
I'm sure everybody in this
room has had the experience

330
00:16:48,986 --> 00:16:52,276 A:middle
at the end of the
day: They leave work.

331
00:16:52,576 --> 00:16:53,976 A:middle
They go out to their car.

332
00:16:54,096 --> 00:16:55,046 A:middle
They pull out their phone.

333
00:16:55,736 --> 00:17:01,856 A:middle
You want to check maps, weather
forecast, email, whatever,

334

335
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

336
00:16:55,736 --> 00:17:01,856 A:middle
You want to check maps, weather
forecast, email, whatever,

337
00:17:02,046 --> 00:17:04,496 A:middle
and you are staring at the
phone and it's not loading

338
00:17:04,576 --> 00:17:06,695 A:middle
and it's not loading and
you are walking to your car,

339
00:17:06,695 --> 00:17:08,786 A:middle
and it's still not loading
and you get frustrated,

340
00:17:08,786 --> 00:17:11,356 A:middle
you go into Settings,
you turn Wi-Fi off.

341
00:17:11,556 --> 00:17:12,756 A:middle
Now you're on LTE and bam!

342
00:17:12,756 --> 00:17:13,846 A:middle
The page loads.

343
00:17:15,076 --> 00:17:17,165 A:middle
And then you forget
to turn Wi-Fi back on,

344
00:17:17,165 --> 00:17:19,536 A:middle
and a week later you've got
a huge cellular data bill

345
00:17:19,536 --> 00:17:20,205 A:middle
that you didn't want.

346
00:17:20,386 --> 00:17:22,715 A:middle
Well, that's not a
good user experience.

347
00:17:23,366 --> 00:17:28,156 A:middle
What we are doing now is we
have some intelligent logic

348
00:17:28,465 --> 00:17:30,166 A:middle
about doing parallel
connections.

349
00:17:31,016 --> 00:17:33,346 A:middle
So if your iPhone
thinks it's on Wi-Fi,

350
00:17:34,806 --> 00:17:38,326 A:middle
but the TCP connection setup
attempt is not succeeding,

351
00:17:38,906 --> 00:17:44,636 A:middle
then very rapidly, it will
initiate a second parallel

352
00:17:44,666 --> 00:17:47,356 A:middle
connection over cellular data.

353
00:17:47,426 --> 00:17:49,996 A:middle
Now, it won't kill
the Wi-Fi connection.

354
00:17:49,996 --> 00:17:50,976 A:middle
It won't give up on it.

355
00:17:50,976 --> 00:17:54,186 A:middle
It will let that one continue
to run in parallel and if

356
00:17:54,186 --> 00:17:56,496 A:middle
that one completes
first, that's great.

357
00:17:56,706 --> 00:17:58,126 A:middle
You have a connection
over Wi-Fi.

358
00:17:58,126 --> 00:18:02,396 A:middle
But if it doesn't, and the
cellular connection completes

359

360
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

361
00:17:58,126 --> 00:18:02,396 A:middle
But if it doesn't, and the
cellular connection completes

362
00:18:02,396 --> 00:18:05,536 A:middle
first, then that's the
connection your application will

363
00:18:05,536 --> 00:18:10,186 A:middle
get with a delay so short, the
user won't notice anything odd.

364
00:18:10,186 --> 00:18:13,636 A:middle
Of course, we only
use this for apps

365
00:18:13,676 --> 00:18:15,456 A:middle
that are allowed to
use cellular data.

366
00:18:15,966 --> 00:18:17,676 A:middle
If the user has gone
into the settings

367
00:18:17,676 --> 00:18:19,796 A:middle
and turned off mobile
data for that app,

368
00:18:19,846 --> 00:18:20,886 A:middle
we won't do the fallback.

369
00:18:22,056 --> 00:18:25,166 A:middle
And if we do fall back, then
we hide the Wi-Fi indicator,

370
00:18:25,606 --> 00:18:28,506 A:middle
so now the user knows they
are not on Wi-Fi anymore.

371
00:18:29,026 --> 00:18:32,936 A:middle
This is something
that you get for free,

372
00:18:33,346 --> 00:18:36,636 A:middle
as long as you are using
the higher layer APIs,

373
00:18:37,306 --> 00:18:40,966 A:middle
and you should see no difference
in your applications apart

374
00:18:40,966 --> 00:18:42,646 A:middle
from a better user experience.

375
00:18:44,016 --> 00:18:45,896 A:middle
There's one additional
thing you can do,

376
00:18:46,816 --> 00:18:50,616 A:middle
and that is when you are
running over cellular,

377
00:18:52,106 --> 00:18:54,686 A:middle
whether you started on cellular
or whether you fell back

378
00:18:54,686 --> 00:18:56,356 A:middle
to cellular, doesn't matter.

379
00:18:56,356 --> 00:19:01,056 A:middle
The user can walk back in range
of Wi-Fi and at that point,

380

381
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

382
00:18:56,356 --> 00:19:01,056 A:middle
The user can walk back in range
of Wi-Fi and at that point,

383
00:19:01,286 --> 00:19:04,046 A:middle
if you pay attention to the
Better Route notification,

384
00:19:04,626 --> 00:19:06,676 A:middle
you can then decide
what to do about that.

385
00:19:07,356 --> 00:19:09,976 A:middle
You may want to tear down
the connections you have

386
00:19:09,976 --> 00:19:15,066 A:middle
and reconnect over Wi-Fi,
or if you are 99% of the way

387
00:19:15,116 --> 00:19:17,436 A:middle
through sending an email,
you may want to just let

388
00:19:17,436 --> 00:19:19,636 A:middle
that complete, but
by paying attention

389
00:19:19,636 --> 00:19:21,176 A:middle
to the Better Route
notification,

390
00:19:21,466 --> 00:19:23,116 A:middle
you can make an intelligent
decision

391
00:19:23,426 --> 00:19:26,336 A:middle
that minimizes the
user's cellular data bill.

392
00:19:27,316 --> 00:19:33,476 A:middle
My next topic is
delays in the network.

393
00:19:35,006 --> 00:19:39,646 A:middle
And this is something that came
out of work I did on Apple TV.

394
00:19:39,646 --> 00:19:43,376 A:middle
We are working on trying to
make Apple TV more responsive

395
00:19:43,726 --> 00:19:45,676 A:middle
and understanding where
the delays came from.

396
00:19:46,406 --> 00:19:49,196 A:middle
And I expect everybody
in this room has heard

397
00:19:49,196 --> 00:19:50,226 A:middle
about bufferbloat.

398
00:19:51,376 --> 00:19:54,756 A:middle
I did some experiments, and
I want to share the results

399
00:19:54,756 --> 00:19:56,116 A:middle
of those experiments with you

400
00:19:56,406 --> 00:20:00,366 A:middle
so you can understand too how
critically important it is

401

402
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

403
00:19:56,406 --> 00:20:00,366 A:middle
so you can understand too how
critically important it is

404
00:20:00,366 --> 00:20:02,316 A:middle
for all of our applications
and products

405
00:20:02,626 --> 00:20:04,356 A:middle
that we fix bufferbloat
in the network.

406
00:20:05,696 --> 00:20:09,206 A:middle
I tested a simulated
network environment

407
00:20:09,676 --> 00:20:14,516 A:middle
with a 10-megabit downstream
connection, which is plenty

408
00:20:14,516 --> 00:20:18,506 A:middle
for watching streaming
video, and first I'm going

409
00:20:18,506 --> 00:20:24,656 A:middle
to show you the results using
a representative network setup,

410
00:20:25,186 --> 00:20:28,046 A:middle
a simpleminded first-in,
first-out queue

411
00:20:28,416 --> 00:20:30,586 A:middle
where packets are buffered
until the queue is full

412
00:20:30,586 --> 00:20:34,236 A:middle
and can't hold anymore, and then
the new arrivals get dropped.

413
00:20:35,016 --> 00:20:38,416 A:middle
This is very typical of
consumer home gateways today.

414
00:20:38,446 --> 00:20:42,326 A:middle
And then I will show you a
comparison using smarter queuing

415
00:20:42,326 --> 00:20:42,866 A:middle
and ECN.

416
00:20:44,536 --> 00:20:48,086 A:middle
I'm going to show you some
plots generated using tcptrace.

417
00:20:49,026 --> 00:20:52,486 A:middle
I expect many people in this
room have used tcptrace,

418
00:20:52,826 --> 00:20:56,346 A:middle
but if you haven't, I
strongly urge you to go

419
00:20:56,346 --> 00:20:58,896 A:middle
to TCPtrace.org and download it.

420
00:20:59,786 --> 00:21:02,846 A:middle
If you are working
on networking code,

421

422
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

423
00:20:59,786 --> 00:21:02,846 A:middle
If you are working
on networking code,

424
00:21:03,366 --> 00:21:06,226 A:middle
and you are not using tcptrace
to look at your packets,

425
00:21:06,566 --> 00:21:10,676 A:middle
then you have no way to
really know what is going on

426
00:21:10,916 --> 00:21:13,116 A:middle
or understand the
performance characteristics

427
00:21:13,326 --> 00:21:15,376 A:middle
of your app and your protocol.

428
00:21:16,086 --> 00:21:19,766 A:middle
When we write apps, we pay
attention to the memory usage.

429
00:21:20,496 --> 00:21:24,196 A:middle
We profile the code to find
out what's taking the CPU

430
00:21:24,616 --> 00:21:26,586 A:middle
and then we optimize
the code that needs it

431
00:21:26,726 --> 00:21:29,746 A:middle
to improve CPU efficiency
and improve battery life.

432
00:21:31,176 --> 00:21:36,246 A:middle
To do those things, to care
that much about CPU and memory,

433
00:21:36,756 --> 00:21:39,756 A:middle
but neglect the networking
part doesn't make any sense.

434
00:21:39,886 --> 00:21:43,596 A:middle
And tcptrace is the tool
that lets you do similar kind

435
00:21:43,596 --> 00:21:45,936 A:middle
of profiling and analysis
of your network traffic.

436
00:21:45,936 --> 00:21:51,836 A:middle
Here's a TCP trace of
the first 10 seconds

437
00:21:52,126 --> 00:21:53,496 A:middle
of some streaming video.

438
00:21:53,956 --> 00:21:56,246 A:middle
For those of you who haven't
looked at tcptrace before,

439
00:21:56,246 --> 00:21:58,256 A:middle
I will give a quick overview.

440
00:21:58,966 --> 00:22:01,766 A:middle
The little white lines
represent data packets.

441

442
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

443
00:21:58,966 --> 00:22:01,766 A:middle
The little white lines
represent data packets.

444
00:22:02,816 --> 00:22:07,396 A:middle
The horizontal position of that
white line tells you the moment

445
00:22:07,396 --> 00:22:08,926 A:middle
in time where the
packet was captured.

446
00:22:10,016 --> 00:22:15,076 A:middle
The height of the white line
tells you how many bytes

447
00:22:15,076 --> 00:22:18,346 A:middle
of payload are in the packets,
and the vertical position

448
00:22:18,346 --> 00:22:21,816 A:middle
of where that line appears
tells you where those bytes fall

449
00:22:22,186 --> 00:22:25,936 A:middle
within the overall logical
TCP sequence number space.

450
00:22:26,996 --> 00:22:30,256 A:middle
So here we can see a stream of
packets being sent out in order,

451
00:22:30,966 --> 00:22:33,276 A:middle
spaced a few microseconds apart.

452
00:22:34,656 --> 00:22:37,426 A:middle
One round trip later, we
get the acknowledgment back

453
00:22:37,426 --> 00:22:39,166 A:middle
from the receiver
saying it was received.

454
00:22:40,346 --> 00:22:44,036 A:middle
And that green line is the
cumulative acknowledgment line.

455
00:22:44,496 --> 00:22:47,516 A:middle
Everything up to and including
the green line has been

456
00:22:47,516 --> 00:22:48,806 A:middle
acknowledged by the receiver.

457
00:22:49,626 --> 00:22:53,786 A:middle
So we should never see any white
packets below the green line.

458
00:22:54,416 --> 00:22:55,556 A:middle
That would indicate a bug,

459
00:22:56,356 --> 00:22:59,106 A:middle
and we don't see any white
packets below the line,

460
00:22:59,106 --> 00:22:59,696 A:middle
so that's good.

461
00:22:59,736 --> 00:23:04,596 A:middle
The yellow line indicates
the receive window.

462

463
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

464
00:22:59,736 --> 00:23:04,596 A:middle
The yellow line indicates
the receive window.

465
00:23:05,286 --> 00:23:06,906 A:middle
When you open up
a TCP connection,

466
00:23:06,906 --> 00:23:10,406 A:middle
the receiver indicates how
much RAM it has put aside

467
00:23:11,586 --> 00:23:16,526 A:middle
for your data, and you should
not exceed the amount of RAM

468
00:23:16,526 --> 00:23:17,886 A:middle
that you have been allocated.

469
00:23:18,546 --> 00:23:22,036 A:middle
If we see any white packets
above the yellow line,

470
00:23:22,346 --> 00:23:24,156 A:middle
then that would be
a bug, and we don't.

471
00:23:24,376 --> 00:23:27,046 A:middle
So that's good.

472
00:23:27,716 --> 00:23:30,906 A:middle
This looks look a
relatively nice,

473
00:23:30,986 --> 00:23:33,486 A:middle
straight line data transfer.

474
00:23:33,486 --> 00:23:37,086 A:middle
The slope of that curve is
exactly 10 megabits per second,

475
00:23:37,816 --> 00:23:41,996 A:middle
which is what we expect,
but every few seconds,

476
00:23:42,086 --> 00:23:43,706 A:middle
we see something
like this going on.

477
00:23:44,236 --> 00:23:48,576 A:middle
So let's zoom in and
take a closer look

478
00:23:48,806 --> 00:23:51,016 A:middle
at what's going on down there.

479
00:23:52,616 --> 00:23:56,216 A:middle
There is so much information
on these TCP trace plots,

480
00:23:56,736 --> 00:23:59,636 A:middle
I could spend an hour just
talking about this one slide.

481
00:23:59,986 --> 00:24:01,686 A:middle
But we don't have time for that,

482

483
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

484
00:23:59,986 --> 00:24:01,686 A:middle
But we don't have time for that,

485
00:24:02,056 --> 00:24:06,216 A:middle
so I will just cover some
highlights that jump out just

486
00:24:06,216 --> 00:24:07,786 A:middle
with a glance at this plot.

487
00:24:09,296 --> 00:24:14,426 A:middle
One is the white packet
line is kind of pulling away

488
00:24:15,246 --> 00:24:16,986 A:middle
from the green ack line.

489
00:24:17,726 --> 00:24:20,906 A:middle
What that means is the rate
that we are injecting data

490
00:24:20,906 --> 00:24:25,696 A:middle
into the network is faster
than the rate data is coming

491
00:24:25,786 --> 00:24:27,606 A:middle
out of the other side
and being acknowledged.

492
00:24:28,066 --> 00:24:30,836 A:middle
Well, if we are putting
it in faster

493
00:24:30,836 --> 00:24:33,976 A:middle
than we are pulling it
out, something has got

494
00:24:33,976 --> 00:24:34,866 A:middle
to be going somewhere.

495
00:24:35,396 --> 00:24:40,526 A:middle
It's sitting in buffers and
we can see that the amount

496
00:24:40,686 --> 00:24:44,606 A:middle
of stale data sitting in buffers
in the network is growing.

497
00:24:45,246 --> 00:24:47,426 A:middle
And because the amount
of buffering is growing,

498
00:24:47,856 --> 00:24:51,676 A:middle
that means the round trip delay
between when a packet is sent

499
00:24:51,756 --> 00:24:54,456 A:middle
and when it's acknowledged
is getting longer.

500
00:24:55,226 --> 00:24:58,296 A:middle
When we have so much buffered

501
00:24:58,336 --> 00:25:01,096 A:middle
that the gateway
can't buffer anymore,

502

503
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

504
00:24:58,336 --> 00:25:01,096 A:middle
that the gateway
can't buffer anymore,

505
00:25:01,316 --> 00:25:02,666 A:middle
we start losing packets.

506
00:25:03,236 --> 00:25:08,126 A:middle
And then this mess happens, and
it really is quite a big mess,

507
00:25:08,436 --> 00:25:13,176 A:middle
because packets are coming into
the tail of the queue faster

508
00:25:13,256 --> 00:25:18,206 A:middle
than the queue is draining, and
we get a packet, we lose it,

509
00:25:18,726 --> 00:25:20,116 A:middle
we get another one, we lose it.

510
00:25:20,396 --> 00:25:22,936 A:middle
The queue drains a bit, we
get a packet, we accept it.

511
00:25:23,486 --> 00:25:27,286 A:middle
So, at the tail end of
the queue, it's carnage.

512
00:25:27,346 --> 00:25:29,066 A:middle
It's get a packet,
lose one, lose one,

513
00:25:29,066 --> 00:25:30,676 A:middle
lose one, get one, lose one.

514
00:25:31,846 --> 00:25:33,226 A:middle
But over at the front
of the queue,

515
00:25:33,716 --> 00:25:38,046 A:middle
we've got 200 packets queued up,
in order, they are neatly going

516
00:25:38,046 --> 00:25:40,206 A:middle
out over that 10-megabit
bottleneck link,

517
00:25:40,326 --> 00:25:42,776 A:middle
in order, no gaps, no problem.

518
00:25:43,176 --> 00:25:45,936 A:middle
It's only after that
entire queue has drained

519
00:25:46,396 --> 00:25:48,396 A:middle
that we actually
witness the results

520
00:25:48,396 --> 00:25:50,876 A:middle
of that packet loss
carnage at the receiver;

521
00:25:51,796 --> 00:25:54,986 A:middle
that gets reflected back to the
sender in the selective acks

522
00:25:55,336 --> 00:25:56,616 A:middle
and the recovery starts.

523
00:25:57,066 --> 00:25:59,766 A:middle
So this is a big mess.

524

525
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

526
00:26:01,496 --> 00:26:04,246 A:middle
Because of the way
networking APIs work,

527
00:26:04,856 --> 00:26:06,256 A:middle
data has to be delivered
in order.

528
00:26:07,626 --> 00:26:10,766 A:middle
If you lose one packet, then
all the packets that arrive

529
00:26:10,766 --> 00:26:12,786 A:middle
after it get delayed
in the kernel

530
00:26:13,026 --> 00:26:14,616 A:middle
until the gap has
been filled in.

531
00:26:15,076 --> 00:26:17,926 A:middle
Now, there are good
reasons for this.

532
00:26:18,146 --> 00:26:21,126 A:middle
People have talked many times
about out-of-order delivery,

533
00:26:21,516 --> 00:26:24,346 A:middle
but it turns out with almost
all applications it's hard

534
00:26:24,346 --> 00:26:25,626 A:middle
to use data out of order.

535
00:26:25,916 --> 00:26:29,946 A:middle
If you are trying to decode
H.264 video, having frames

536
00:26:29,946 --> 00:26:33,186 A:middle
that depend on an I-frame you
don't have is not helpful.

537
00:26:33,546 --> 00:26:37,706 A:middle
So it turns out that in-order
delivery really is the model

538
00:26:37,736 --> 00:26:38,856 A:middle
that applications want.

539
00:26:39,416 --> 00:26:42,346 A:middle
Because of that in-order
delivery,

540
00:26:42,806 --> 00:26:45,396 A:middle
we get these long plateaus
where no data is delivered.

541
00:26:46,186 --> 00:26:49,536 A:middle
And for the Apple TV,
video playback process,

542
00:26:50,046 --> 00:26:52,846 A:middle
that equals a period
of starvation

543
00:26:53,016 --> 00:26:54,166 A:middle
where it's getting no data.

544
00:26:54,816 --> 00:26:58,096 A:middle
And because we don't
want the video to freeze,

545
00:26:58,826 --> 00:27:01,586 A:middle
that's why all streaming
video applications need a

546

547
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

548
00:26:58,826 --> 00:27:01,586 A:middle
that's why all streaming
video applications need a

549
00:27:01,586 --> 00:27:02,426 A:middle
playback buffer.

550
00:27:03,456 --> 00:27:06,626 A:middle
And having a big
playback buffer is why

551
00:27:06,726 --> 00:27:08,266 A:middle
when you watch a
streaming video,

552
00:27:08,596 --> 00:27:10,976 A:middle
you see that spinning wheel
saying buffering, buffering,

553
00:27:10,976 --> 00:27:14,316 A:middle
buffering, because it has to
fill up the playback buffer

554
00:27:14,416 --> 00:27:18,226 A:middle
so that it can weather the
storms when no data arrives

555
00:27:18,226 --> 00:27:19,226 A:middle
for a long period of time.

556
00:27:20,236 --> 00:27:23,286 A:middle
When the missing packet
arrives, we then fill in the gap

557
00:27:23,486 --> 00:27:24,756 A:middle
and deliver it all at once.

558
00:27:26,596 --> 00:27:30,886 A:middle
That puts an excessive burden
on the network receiving thread

559
00:27:31,516 --> 00:27:36,086 A:middle
which takes away CPU time from
the video playback threads,

560
00:27:36,676 --> 00:27:38,496 A:middle
and that results
in the stuttering

561
00:27:38,816 --> 00:27:40,436 A:middle
of the smooth video playback.

562
00:27:40,436 --> 00:27:43,526 A:middle
So that's bad.

563
00:27:43,736 --> 00:27:48,736 A:middle
So this uneven delivery in the
network has bad consequences

564
00:27:48,846 --> 00:27:51,026 A:middle
for a device like Apple
TV; when we are trying

565
00:27:51,026 --> 00:27:54,726 A:middle
to make a very affordable,
cost-effective device,

566
00:27:55,546 --> 00:27:59,126 A:middle
these long plateaus
of starvation equate

567
00:27:59,356 --> 00:28:02,556 A:middle
to needing more RAM in the
device for more buffering

568

569
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

570
00:27:59,356 --> 00:28:02,556 A:middle
to needing more RAM in the
device for more buffering

571
00:28:03,206 --> 00:28:07,406 A:middle
and slower video start-up
and a poor user experience.

572
00:28:08,786 --> 00:28:13,056 A:middle
And these spikes in delivery
result in needing a faster CPU

573
00:28:13,056 --> 00:28:15,556 A:middle
in the device than we
otherwise might have needed,

574
00:28:15,816 --> 00:28:16,936 A:middle
which pushes the price up.

575
00:28:17,416 --> 00:28:24,306 A:middle
So this uneven delivery is very
damaging for streaming video.

576
00:28:25,666 --> 00:28:27,736 A:middle
One interesting thing
to note, though:

577
00:28:28,166 --> 00:28:33,966 A:middle
If you visually track the
slope of the yellow ack line --

578
00:28:34,376 --> 00:28:37,116 A:middle
the yellow window line
and the green ack line,

579
00:28:37,646 --> 00:28:40,986 A:middle
you'll see that at the end of
the trace, they pretty much end

580
00:28:40,986 --> 00:28:44,266 A:middle
up back where they should have
been, if no loss had happened

581
00:28:44,766 --> 00:28:47,546 A:middle
because TCP does do an
awesome job of filling

582
00:28:47,546 --> 00:28:51,166 A:middle
in exactly what needs to be
retransmitted, exactly once,

583
00:28:51,706 --> 00:28:53,176 A:middle
and not retransmitting anything

584
00:28:53,176 --> 00:28:54,726 A:middle
that didn't need to
be retransmitted.

585
00:28:55,186 --> 00:28:56,926 A:middle
So it gets back to where
it should have been.

586
00:28:57,916 --> 00:29:00,746 A:middle
If you measure this
network using Iperf and look

587

588
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

589
00:28:57,916 --> 00:29:00,746 A:middle
If you measure this
network using Iperf and look

590
00:29:00,746 --> 00:29:01,866 A:middle
at the number that comes out,

591
00:29:01,866 --> 00:29:04,196 A:middle
it will tell you 10
megabits per second,

592
00:29:04,556 --> 00:29:07,336 A:middle
and you will say thumbs up, my
network is working perfectly.

593
00:29:08,416 --> 00:29:11,036 A:middle
But distilling all
of this information

594
00:29:11,036 --> 00:29:15,406 A:middle
down to a single figure
loses all the subtlety

595
00:29:15,636 --> 00:29:22,156 A:middle
of what's really going
on on the network.

596
00:29:22,156 --> 00:29:25,976 A:middle
So now that I understood
what was going on

597
00:29:25,976 --> 00:29:27,936 A:middle
and causing the sluggish
performance,

598
00:29:28,666 --> 00:29:30,996 A:middle
I decided to experiment
with a smarter network.

599
00:29:31,586 --> 00:29:35,136 A:middle
For this experiment, I used a
smart cueing algorithm called

600
00:29:35,136 --> 00:29:38,056 A:middle
CoDel, which is short
for Controlled Delay.

601
00:29:39,316 --> 00:29:42,006 A:middle
The way it works is
instead of filling the queue

602
00:29:42,006 --> 00:29:45,796 A:middle
until it overflows and loses
data, it monitors the state

603
00:29:45,796 --> 00:29:51,986 A:middle
of the queue and as soon
as a standing queue starts

604
00:29:51,986 --> 00:29:56,866 A:middle
to build up, then it considers
that to be a sign of congestion.

605
00:29:57,766 --> 00:30:01,766 A:middle
And when I say congestion, a
lot of people think I'm talking

606

607
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

608
00:29:57,766 --> 00:30:01,766 A:middle
And when I say congestion, a
lot of people think I'm talking

609
00:30:01,766 --> 00:30:03,416 A:middle
about something that
happens rarely

610
00:30:03,416 --> 00:30:05,656 A:middle
at peak times, and it's not.

611
00:30:05,656 --> 00:30:09,116 A:middle
It's important to
understand that in networking,

612
00:30:09,626 --> 00:30:12,316 A:middle
congestion is what
happens all the time.

613
00:30:12,856 --> 00:30:14,516 A:middle
It's the steady state
of the network.

614
00:30:14,576 --> 00:30:17,336 A:middle
It's the job of any
transport protocol like TCP

615
00:30:18,096 --> 00:30:20,836 A:middle
to maximize its use
of the network,

616
00:30:21,306 --> 00:30:23,856 A:middle
to find out how much
the network can carry

617
00:30:24,336 --> 00:30:26,596 A:middle
and make the best use of that.

618
00:30:26,596 --> 00:30:28,346 A:middle
And the way a transport
protocol does

619
00:30:28,346 --> 00:30:33,006 A:middle
that is it sends data faster
and faster and faster.

620
00:30:33,006 --> 00:30:35,496 A:middle
It keeps probing and it
keeps trying a bit more,

621
00:30:35,986 --> 00:30:38,006 A:middle
until it loses a
packet, and then it knows

622
00:30:38,006 --> 00:30:39,586 A:middle
that was too much
and it backs off.

623
00:30:40,026 --> 00:30:43,346 A:middle
So it's constantly doing
this hunting to track

624
00:30:43,346 --> 00:30:45,166 A:middle
to find the right rate and what

625
00:30:45,166 --> 00:30:47,456 A:middle
that means is it's
always pushing the network

626
00:30:47,456 --> 00:30:49,636 A:middle
into congestion, and
then backing off,

627
00:30:49,636 --> 00:30:51,606 A:middle
and then congestion
and backing off.

628
00:30:52,456 --> 00:30:55,996 A:middle
What CoDel does is not wait
until things have gotten really,

629
00:30:55,996 --> 00:30:58,626 A:middle
really bad before it
signals congestion.

630
00:30:59,336 --> 00:31:01,976 A:middle
As soon as the first
sign of it starts

631

632
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

633
00:30:59,336 --> 00:31:01,976 A:middle
As soon as the first
sign of it starts

634
00:31:01,976 --> 00:31:05,156 A:middle
to happen, it tells the sender.

635
00:31:06,156 --> 00:31:09,436 A:middle
The other thing that I did for
this experiment was instead

636
00:31:09,436 --> 00:31:12,106 A:middle
of indicating congestion
by losing packets,

637
00:31:12,176 --> 00:31:13,686 A:middle
which requires a retransmission,

638
00:31:14,266 --> 00:31:16,636 A:middle
we used a new technology
called Explicit Congestion

639
00:31:16,636 --> 00:31:19,916 A:middle
Notification, and that way
the smart queuing algorithm,

640
00:31:19,916 --> 00:31:22,496 A:middle
instead of dropping the
packet, it sets a bit

641
00:31:22,866 --> 00:31:26,206 A:middle
in the IP header saying
congestion experienced.

642
00:31:26,856 --> 00:31:30,026 A:middle
That is echoed back to
the sender and it responds

643
00:31:30,026 --> 00:31:33,046 A:middle
by slowing down without
the destructive effects

644
00:31:33,046 --> 00:31:33,886 A:middle
of a packet loss.

645
00:31:34,466 --> 00:31:41,926 A:middle
So this is our graph of the
same data transfer, using CoDel

646
00:31:42,076 --> 00:31:46,176 A:middle
and ECN, and if I zoom in to
the same part we were looking

647
00:31:46,176 --> 00:31:49,426 A:middle
at before, you can
see an absolutely

648
00:31:49,516 --> 00:31:50,506 A:middle
phenomenal difference.

649
00:31:50,956 --> 00:31:52,646 A:middle
When I was doing
these experiments,

650
00:31:52,946 --> 00:31:56,206 A:middle
I had planned a week to do
the work and gather the data,

651
00:31:56,916 --> 00:31:59,416 A:middle
and I was finished
after two hours.

652
00:31:59,746 --> 00:32:02,286 A:middle
I did one plot with the
standard configuration

653

654
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

655
00:31:59,746 --> 00:32:02,286 A:middle
I did one plot with the
standard configuration

656
00:32:02,286 --> 00:32:03,576 A:middle
and one plot with CoDel.

657
00:32:03,796 --> 00:32:06,766 A:middle
This is my first experimental
run that I'm showing you.

658
00:32:06,766 --> 00:32:10,076 A:middle
I was expecting to have to
tweak parameters and retry

659
00:32:10,076 --> 00:32:11,506 A:middle
and rerun the experiment.

660
00:32:12,156 --> 00:32:16,446 A:middle
No. This is -- the
difference is that obvious,

661
00:32:16,586 --> 00:32:18,216 A:middle
that one trial was all it took.

662
00:32:18,976 --> 00:32:19,726 A:middle
I'm hearing applause.

663
00:32:19,726 --> 00:32:19,976 A:middle
Thank you.

664
00:32:20,516 --> 00:32:25,866 A:middle
[Applause]

665
00:32:26,366 --> 00:32:28,946 A:middle
We have no plateaus
of starvation.

666
00:32:28,986 --> 00:32:31,396 A:middle
We have no spikes
of peak delivery.

667
00:32:32,056 --> 00:32:35,396 A:middle
Every time the slightest
hint of a queue builds up,

668
00:32:35,956 --> 00:32:38,086 A:middle
we get these little
polite nudges

669
00:32:38,086 --> 00:32:40,326 A:middle
from the CoDel algorithm
saying slow down.

670
00:32:40,806 --> 00:32:44,606 A:middle
The CWR on that plot is
Congestion Window Reduced.

671
00:32:44,606 --> 00:32:47,026 A:middle
That's TCP's acknowledgment
saying message received

672
00:32:47,026 --> 00:32:48,836 A:middle
and understood; I
have slowed down.

673
00:32:49,646 --> 00:32:50,706 A:middle
Absolutely wonderful!

674
00:32:52,366 --> 00:32:56,136 A:middle
So, simple summary, CoDel

675
00:32:56,136 --> 00:32:58,516 A:middle
and other smart cueing
algorithms are great.

676
00:32:58,846 --> 00:32:59,846 A:middle
ECN are great.

677

678
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

679
00:33:00,626 --> 00:33:02,446 A:middle
Put them together,
it's totally awesome.

680
00:33:05,506 --> 00:33:07,606 A:middle
So if it's so great,
where is it?

681
00:33:08,226 --> 00:33:11,826 A:middle
Well, historically, packet loss

682
00:33:11,826 --> 00:33:14,736 A:middle
and retransmission has
not caused big problems

683
00:33:14,786 --> 00:33:17,416 A:middle
for the traditional
networking applications

684
00:33:17,416 --> 00:33:19,166 A:middle
like file transfer
and sending email.

685
00:33:21,636 --> 00:33:24,896 A:middle
When you transfer a
file, the transport layer

686
00:33:24,896 --> 00:33:28,336 A:middle
in principle could send
the first packet last

687
00:33:28,336 --> 00:33:31,156 A:middle
and the last packet first and
all the ones in the middle

688
00:33:31,156 --> 00:33:33,676 A:middle
in a random order; as
long as they all get there

689
00:33:33,676 --> 00:33:34,486 A:middle
and they are reassembled

690
00:33:34,486 --> 00:33:36,176 A:middle
in the correct order
you have your file,

691
00:33:36,176 --> 00:33:37,306 A:middle
and that's all you care about.

692
00:33:38,076 --> 00:33:41,966 A:middle
But when you are watching
streaming video, you don't want

693
00:33:41,966 --> 00:33:45,796 A:middle
to see the end first,
and the start last.

694
00:33:46,306 --> 00:33:47,506 A:middle
You want it in order.

695
00:33:47,956 --> 00:33:51,566 A:middle
So in order delivery has become
a much more pressing problem,

696
00:33:51,566 --> 00:33:54,286 A:middle
now that we are using the
Internet for streaming video.

697
00:33:57,196 --> 00:33:59,866 A:middle
One way I characterize
this is that we used

698
00:33:59,866 --> 00:34:03,096 A:middle
to have applications like
clicking send on an email,

699

700
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

701
00:33:59,866 --> 00:34:03,096 A:middle
to have applications like
clicking send on an email,

702
00:34:03,726 --> 00:34:06,236 A:middle
where you have a
predetermined amount of data

703
00:34:07,106 --> 00:34:09,306 A:middle
and how long it takes
to send it is variable.

704
00:34:10,266 --> 00:34:13,436 A:middle
Basically, the time you'd
like the network to take

705
00:34:13,436 --> 00:34:16,386 A:middle
to send your email is
as little as possible.

706
00:34:17,025 --> 00:34:19,176 A:middle
There's really no such thing
as sending an email too fast.

707
00:34:20,076 --> 00:34:22,106 A:middle
So the time is variable.

708
00:34:22,106 --> 00:34:23,146 A:middle
You would like it to be fast.

709
00:34:23,466 --> 00:34:25,196 A:middle
Now we have applications

710
00:34:25,196 --> 00:34:29,126 A:middle
where you are watching
a two-hour movie,

711
00:34:29,416 --> 00:34:30,886 A:middle
streaming over the Internet.

712
00:34:32,186 --> 00:34:35,556 A:middle
It doesn't help to watch it in
half an hour or in eight hours.

713
00:34:35,755 --> 00:34:37,196 A:middle
It has to take two hours.

714
00:34:38,045 --> 00:34:40,056 A:middle
So now we have adaptive
applications

715
00:34:40,056 --> 00:34:42,696 A:middle
where the time is fixed
but the amount of data

716
00:34:42,696 --> 00:34:45,116 A:middle
that could be sent in
that time has to adjust

717
00:34:45,226 --> 00:34:47,025 A:middle
to accommodate the
network conditions.

718
00:34:50,295 --> 00:34:51,386 A:middle
Where are we now?

719
00:34:52,116 --> 00:34:55,246 A:middle
Well, amazingly, because
it is in Linux and turned

720
00:34:55,246 --> 00:34:59,556 A:middle
on by default, more than half
of the top million web servers

721
00:34:59,556 --> 00:35:01,516 A:middle
in the world already
support ECN,

722

723
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

724
00:34:59,556 --> 00:35:01,516 A:middle
in the world already
support ECN,

725
00:35:02,176 --> 00:35:04,546 A:middle
which is phenomenal adoption

726
00:35:04,546 --> 00:35:05,976 A:middle
for a technology
that no one is using.

727
00:35:06,516 --> 00:35:09,546 A:middle
[Laughter]

728
00:35:10,046 --> 00:35:14,786 A:middle
Clients. Well, the clients are
not asking for ECN connections.

729
00:35:14,786 --> 00:35:18,286 A:middle
They are not requesting ECN
because pretty much none

730
00:35:18,286 --> 00:35:20,706 A:middle
of the Internet supports
ECN marking.

731
00:35:21,006 --> 00:35:24,746 A:middle
So if you turn on that option,
there might be some risk

732
00:35:24,746 --> 00:35:27,646 A:middle
of exposing bugs and
there's no immediate benefit.

733
00:35:29,626 --> 00:35:30,666 A:middle
What are the routers doing?

734
00:35:30,776 --> 00:35:33,626 A:middle
Well, none of the routers are
doing marking because none

735
00:35:33,626 --> 00:35:36,646 A:middle
of the clients are asking for
it, so why put engineering

736
00:35:36,646 --> 00:35:39,086 A:middle
into something that might have
risk that no one is asking for?

737
00:35:39,346 --> 00:35:41,736 A:middle
Well, I'm happy to
announce today

738
00:35:41,736 --> 00:35:43,306 A:middle
that Apple is taking
the initiative

739
00:35:43,596 --> 00:35:44,746 A:middle
to break this log jam.

740
00:35:45,226 --> 00:35:50,236 A:middle
In the seeds that you all have,
ECN is now turned on by default

741
00:35:50,606 --> 00:35:54,976 A:middle
for all TCP connections
for all applications.

742
00:35:55,516 --> 00:36:01,406 A:middle
[Applause]

743

744
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

745
00:35:55,516 --> 00:36:01,406 A:middle
[Applause]

746
00:36:01,906 --> 00:36:05,436 A:middle
We're not expecting to see
any problems; in our testing,

747
00:36:05,926 --> 00:36:07,226 A:middle
everything has gone smoothly.

748
00:36:07,696 --> 00:36:10,536 A:middle
I have been running it on my
own laptop for a long time;

749
00:36:11,676 --> 00:36:14,806 A:middle
of course, we want to
hear your experience.

750
00:36:14,976 --> 00:36:19,396 A:middle
Please take the seed builds, run
them on your networks at home,

751
00:36:20,056 --> 00:36:24,506 A:middle
at work, in your hotel, at
the airport, and as usual,

752
00:36:24,506 --> 00:36:26,636 A:middle
if you find any bugs,
please report them to Apple.

753
00:36:27,426 --> 00:36:30,346 A:middle
If we are successful, in a few
months' time we could have a

754
00:36:30,436 --> 00:36:35,156 A:middle
billion devices running ECN, and
that should be enough incentive

755
00:36:35,156 --> 00:36:37,236 A:middle
for the ISPs to start
offering that service.

756
00:36:37,806 --> 00:36:43,026 A:middle
Now we are going to move
on from network delays

757
00:36:43,326 --> 00:36:45,326 A:middle
to end system delays.

758
00:36:46,316 --> 00:36:50,506 A:middle
Like many advances in
technology, this was borne

759
00:36:50,506 --> 00:36:53,446 A:middle
out of a personal
pain point for me.

760
00:36:54,676 --> 00:36:59,336 A:middle
I use screen sharing to
connect to my Mac at home,

761
00:36:59,916 --> 00:37:01,236 A:middle
and it's absolutely wonderful.

762

763
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

764
00:36:59,916 --> 00:37:01,236 A:middle
and it's absolutely wonderful.

765
00:37:01,856 --> 00:37:03,526 A:middle
Being able to control
it remotely,

766
00:37:03,526 --> 00:37:05,346 A:middle
being able to access data on it,

767
00:37:06,036 --> 00:37:11,556 A:middle
being able to start a long video
transcode going that I want

768
00:37:11,556 --> 00:37:13,086 A:middle
to have finished
when I get back home:

769
00:37:13,746 --> 00:37:14,946 A:middle
these are all wonderful things.

770
00:37:15,996 --> 00:37:18,406 A:middle
And at the time I was
doing these experiments,

771
00:37:19,896 --> 00:37:23,136 A:middle
I had a fairly slow DSL line.

772
00:37:24,006 --> 00:37:27,236 A:middle
And, of course, DSL
is asymmetric.

773
00:37:27,656 --> 00:37:30,596 A:middle
It's typically ten times faster
in the downstream direction

774
00:37:30,596 --> 00:37:31,906 A:middle
than the upstream direction,

775
00:37:32,766 --> 00:37:34,766 A:middle
and when you are doing screen
sharing, the data is coming

776
00:37:35,186 --> 00:37:37,396 A:middle
in the wrong direction
in that sense.

777
00:37:37,546 --> 00:37:41,716 A:middle
So it's kind of to be
expected it will be a bit slow.

778
00:37:42,546 --> 00:37:45,066 A:middle
It's like the famous joke
about the dancing bear:

779
00:37:45,386 --> 00:37:47,346 A:middle
when you see a dancing
bear, you are not supposed

780
00:37:47,346 --> 00:37:49,196 A:middle
to be impressed that
it dances well.

781
00:37:49,316 --> 00:37:51,396 A:middle
You are supposed to be
impressed that it dances at all.

782
00:37:52,186 --> 00:37:58,216 A:middle
So for many years, like many
of us, I kind of suffered

783
00:37:58,216 --> 00:38:04,626 A:middle
with this painful, barely usable
experience, and I would find

784

785
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

786
00:37:58,216 --> 00:38:04,626 A:middle
with this painful, barely usable
experience, and I would find

787
00:38:04,676 --> 00:38:08,306 A:middle
that when I clicked on a menu,
it took three or four seconds

788
00:38:08,306 --> 00:38:10,786 A:middle
for the menu to appear,
and after a few minutes

789
00:38:10,786 --> 00:38:14,386 A:middle
of using the computer this way,
it's really, really frustrating.

790
00:38:14,466 --> 00:38:16,466 A:middle
There were times it felt
like it would be quicker

791
00:38:16,466 --> 00:38:19,596 A:middle
to drive home and do it.

792
00:38:19,816 --> 00:38:22,636 A:middle
And I had been working
on bufferbloat

793
00:38:23,256 --> 00:38:25,596 A:middle
and excessive queuing
in the network.

794
00:38:25,986 --> 00:38:28,626 A:middle
So naturally, that was
the first thing I blamed,

795
00:38:29,096 --> 00:38:30,656 A:middle
and I started digging in.

796
00:38:30,896 --> 00:38:32,396 A:middle
I started investigating.

797
00:38:32,726 --> 00:38:35,366 A:middle
I was all ready to be
thoroughly indignant

798
00:38:35,366 --> 00:38:37,896 A:middle
about this stupid DSL
modem that had all

799
00:38:37,896 --> 00:38:39,526 A:middle
of this excessive
bufferbloat in it.

800
00:38:40,156 --> 00:38:41,446 A:middle
And I pinged the machine,

801
00:38:42,176 --> 00:38:44,406 A:middle
and the ping time
was 35 milliseconds,

802
00:38:45,276 --> 00:38:46,666 A:middle
but when I click the mouse,

803
00:38:46,666 --> 00:38:48,736 A:middle
it takes 3 seconds
for a menu to appear.

804
00:38:49,796 --> 00:38:52,986 A:middle
So now I'm realizing this is
not as obvious as I thought.

805
00:38:53,686 --> 00:38:55,176 A:middle
Where is the delay coming from?

806
00:38:56,016 --> 00:38:59,136 A:middle
Well, I did some investigation.

807

808
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

809
00:39:00,626 --> 00:39:04,206 A:middle
The default socket send buffer
at that time was 120 kilobytes,

810
00:39:04,636 --> 00:39:08,236 A:middle
my throughput was about
50 kilobytes a second,

811
00:39:08,236 --> 00:39:10,246 A:middle
so that's about 2.5 seconds,

812
00:39:10,466 --> 00:39:12,106 A:middle
which was about the
delay I was seeing.

813
00:39:14,046 --> 00:39:17,246 A:middle
Now, the socket send buffer
serves a very important purpose.

814
00:39:18,496 --> 00:39:21,486 A:middle
When we use a transport
protocol like TCP,

815
00:39:21,486 --> 00:39:25,706 A:middle
if it just sent one packet and
waited for the acknowledgment

816
00:39:25,706 --> 00:39:27,816 A:middle
and one packet and waited
for the acknowledgment,

817
00:39:27,816 --> 00:39:29,516 A:middle
we would get terrible
performance.

818
00:39:29,906 --> 00:39:32,996 A:middle
We need multiple packets in
flight; we need enough packets

819
00:39:32,996 --> 00:39:37,106 A:middle
in flight to fill the bandwidth
delay product of that path

820
00:39:37,766 --> 00:39:40,906 A:middle
to the destination and
back, and those packets have

821
00:39:40,906 --> 00:39:43,336 A:middle
to be buffered so
that if they are lost,

822
00:39:43,406 --> 00:39:44,596 A:middle
they can be retransmitted.

823
00:39:45,076 --> 00:39:47,256 A:middle
That's all good and
useful and necessary

824
00:39:47,586 --> 00:39:50,296 A:middle
to maximize the throughput
of that connection.

825
00:39:51,096 --> 00:39:53,486 A:middle
But any excess buffering

826
00:39:53,486 --> 00:39:57,876 A:middle
above that requirement just
adds delay for no benefit.

827
00:39:58,056 --> 00:39:59,356 A:middle
It doesn't help the throughput.

828
00:39:59,856 --> 00:40:00,776 A:middle
It just adds delay.

829

830
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

831
00:39:59,856 --> 00:40:00,776 A:middle
It just adds delay.

832
00:40:01,626 --> 00:40:04,386 A:middle
And we end up with something
that looks like this.

833
00:40:05,206 --> 00:40:08,756 A:middle
We have a little bit of data
in flight, which is buffered,

834
00:40:08,976 --> 00:40:10,556 A:middle
in case it needs to
be retransmitted,

835
00:40:11,206 --> 00:40:15,196 A:middle
and we have a whole lot, just
sitting in the kernel waiting

836
00:40:15,196 --> 00:40:19,006 A:middle
for its turn to go out.

837
00:40:19,936 --> 00:40:22,986 A:middle
Well, this was an
eye-opening revelation for me.

838
00:40:23,536 --> 00:40:25,536 A:middle
There aren't just
delays in the network.

839
00:40:25,536 --> 00:40:27,766 A:middle
There are big delays in
the hosts themselves.

840
00:40:29,786 --> 00:40:33,076 A:middle
Screen sharing would grab a
frame, put it in the buffer,

841
00:40:33,276 --> 00:40:35,416 A:middle
grab a frame, put it in
the buffer, grab a frame,

842
00:40:35,536 --> 00:40:38,586 A:middle
put it in the buffer, and then
the kernel would let those

843
00:40:38,586 --> 00:40:42,196 A:middle
frames mature like a fine
wine before it was time

844
00:40:42,196 --> 00:40:43,406 A:middle
to put them out on the network.

845
00:40:44,031 --> 00:40:46,031 A:middle
[Laughter]

846
00:40:46,046 --> 00:40:51,596 A:middle
Because of that, we came up with
the TCP NOTSENT low-water mark

847
00:40:51,596 --> 00:40:52,296 A:middle
socket option.

848
00:40:53,116 --> 00:40:54,486 A:middle
When you send that option,

849
00:40:55,606 --> 00:40:58,636 A:middle
the socket send buffer
remains unchanged.

850
00:40:59,496 --> 00:41:02,706 A:middle
The difference is that kevent

851

852
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

853
00:40:59,496 --> 00:41:02,706 A:middle
The difference is that kevent

854
00:41:03,316 --> 00:41:07,756 A:middle
or your run loop will not report
the socket as being writable

855
00:41:08,126 --> 00:41:10,646 A:middle
until the unsent
data has drained

856
00:41:10,646 --> 00:41:13,106 A:middle
to some fairly low
threshold, typically 8

857
00:41:13,106 --> 00:41:14,806 A:middle
or 16 kilobytes works well.

858
00:41:15,816 --> 00:41:17,486 A:middle
When the socket becomes
writable,

859
00:41:18,046 --> 00:41:23,206 A:middle
you then write a single useful
atomic chunk into the buffer.

860
00:41:23,946 --> 00:41:27,656 A:middle
You don't loop, cramming as
much data into the kernel

861
00:41:27,656 --> 00:41:29,696 A:middle
as it can take, because
RAM is cheap these days,

862
00:41:29,696 --> 00:41:30,476 A:middle
it can take a lot.

863
00:41:31,526 --> 00:41:33,366 A:middle
You just write a sensible unit.

864
00:41:33,636 --> 00:41:36,356 A:middle
And in the case of screen
sharing, that's one frame.

865
00:41:37,226 --> 00:41:38,926 A:middle
And now the picture
looks like this.

866
00:41:40,026 --> 00:41:42,106 A:middle
We have data in flight,
that's buffered.

867
00:41:42,436 --> 00:41:44,686 A:middle
We have a little bit waiting
for its turn to go out.

868
00:41:45,726 --> 00:41:48,206 A:middle
As that drains and
reaches the threshold,

869
00:41:49,136 --> 00:41:50,456 A:middle
the socket becomes writable.

870
00:41:51,166 --> 00:41:53,176 A:middle
We write a single chunk and let

871
00:41:53,176 --> 00:41:54,766 A:middle
that drain before
we write some more.

872
00:41:55,496 --> 00:41:57,436 A:middle
So with that, I would
like to show you a demo

873
00:41:57,436 --> 00:41:57,976 A:middle
of this in action.

874

875
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

876
00:42:07,086 --> 00:42:08,506 A:middle
Here I'm using screen sharing

877
00:42:08,876 --> 00:42:11,496 A:middle
from this machine,
connecting to this.

878
00:42:12,436 --> 00:42:15,726 A:middle
I'm using a gateway running
sarawert [assumed spelling]

879
00:42:15,886 --> 00:42:18,376 A:middle
to simulate a DSL
performance connection.

880
00:42:20,296 --> 00:42:24,976 A:middle
And let's bring up
a Terminal window.

881
00:42:32,266 --> 00:42:33,086 A:middle
Okay, there we go.

882
00:42:34,976 --> 00:42:36,656 A:middle
I'm going to move this window.

883
00:42:37,806 --> 00:42:40,706 A:middle
You can see the mouse
pointer move

884
00:42:40,946 --> 00:42:42,416 A:middle
because it's generated locally.

885
00:42:42,826 --> 00:42:45,766 A:middle
The actual graphical updates are
generated by the remote machine.

886
00:42:46,216 --> 00:42:48,466 A:middle
So let's move this
window over here.

887
00:42:48,466 --> 00:42:50,316 A:middle
No, not over here.

888
00:42:50,316 --> 00:42:53,316 A:middle
So let's move it -- actually,
no I like it back where it is.

889
00:42:53,316 --> 00:42:54,306 A:middle
Hands off the keyboard.

890
00:42:55,516 --> 00:43:01,696 A:middle
[Laughter]

891

892
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

893
00:42:55,516 --> 00:43:01,696 A:middle
[Laughter]

894
00:43:02,196 --> 00:43:04,436 A:middle
Let's pull down some
menus: Shell.

895
00:43:06,686 --> 00:43:09,416 A:middle
There we go.

896
00:43:09,646 --> 00:43:11,186 A:middle
Let's look at Edit.

897
00:43:11,416 --> 00:43:12,666 A:middle
No, maybe View.

898
00:43:18,576 --> 00:43:21,556 A:middle
If this feels like a demo
that's going painfully badly,

899
00:43:21,796 --> 00:43:23,446 A:middle
this is what my life
was like trying

900
00:43:23,446 --> 00:43:24,896 A:middle
to use my computer remotely.

901
00:43:25,426 --> 00:43:28,836 A:middle
It takes the patience of a
saint to put up with this.

902
00:43:31,066 --> 00:43:37,056 A:middle
Well, now I have a new option.

903
00:43:37,056 --> 00:43:41,176 A:middle
Let's turn on the not
sent low-water mark,

904
00:43:42,726 --> 00:43:50,076 A:middle
and once we reconnect,

905
00:43:50,076 --> 00:43:53,086 A:middle
now I will try dragging
this window around.

906
00:43:54,516 --> 00:44:04,966 A:middle
[Applause]

907

908
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

909
00:43:54,516 --> 00:44:04,966 A:middle
[Applause]

910
00:44:05,466 --> 00:44:05,816 A:middle
Thank you.

911
00:44:06,436 --> 00:44:13,416 A:middle
And that was years of suffering
unusable screen-sharing

912
00:44:13,416 --> 00:44:16,706 A:middle
connections just for the
sake of a silly oversight

913
00:44:16,916 --> 00:44:18,946 A:middle
in the BSD networking stack.

914
00:44:19,776 --> 00:44:26,276 A:middle
The great news is that
we have fixed this.

915
00:44:27,226 --> 00:44:36,196 A:middle
It is available in -- it's now
being used by screen sharing

916
00:44:36,326 --> 00:44:39,786 A:middle
in the last software update
in 10.10.3, so if you noticed

917
00:44:39,786 --> 00:44:42,116 A:middle
that screen sharing seemed
to get a lot more snappy,

918
00:44:42,646 --> 00:44:44,366 A:middle
then this is the reason why.

919
00:44:44,996 --> 00:44:49,586 A:middle
It's used by AirPlay, and
it's available in Linux too

920
00:44:50,146 --> 00:44:52,386 A:middle
because this option
applies at the source

921
00:44:52,386 --> 00:44:54,166 A:middle
of the data on the sending side.

922
00:44:54,636 --> 00:44:57,356 A:middle
So for those of you who
are running Linux servers,

923
00:44:57,696 --> 00:45:02,866 A:middle
this option is available
for your servers too.

924

925
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

926
00:44:57,696 --> 00:45:02,866 A:middle
this option is available
for your servers too.

927
00:45:03,176 --> 00:45:06,716 A:middle
The benefit of this delay
reduction is really obvious

928
00:45:06,826 --> 00:45:08,226 A:middle
for real-time applications.

929
00:45:09,856 --> 00:45:13,896 A:middle
And we started making
slides for this presentation

930
00:45:14,006 --> 00:45:15,136 A:middle
where we had two columns.

931
00:45:15,136 --> 00:45:18,356 A:middle
We had the apps that should
use the low-water mark option

932
00:45:18,416 --> 00:45:19,506 A:middle
and the apps that shouldn't.

933
00:45:20,276 --> 00:45:23,606 A:middle
And we couldn't think of any
to go in the shouldn't column.

934
00:45:24,386 --> 00:45:26,606 A:middle
Every time we thought
of a traditional app

935
00:45:26,606 --> 00:45:28,586 A:middle
like file transfer, well,
that doesn't need it.

936
00:45:29,126 --> 00:45:31,976 A:middle
We realized you've
had that experience

937
00:45:31,976 --> 00:45:33,786 A:middle
where you change your
mind about a file transfer

938
00:45:33,786 --> 00:45:35,576 A:middle
and you press Control-C
and it seems to take

939
00:45:35,576 --> 00:45:37,106 A:middle
about 30 seconds to cancel.

940
00:45:37,976 --> 00:45:40,526 A:middle
It's because it had
over-committed all of this data

941
00:45:40,526 --> 00:45:42,606 A:middle
into the kernel and it had
to wait for it to drain

942
00:45:43,006 --> 00:45:44,506 A:middle
because there's no way
to change your mind.

943
00:45:45,016 --> 00:45:48,176 A:middle
So, yeah, actually, file
transfer does not benefit

944
00:45:48,176 --> 00:45:51,946 A:middle
from over-committing data,
and we couldn't think

945
00:45:51,946 --> 00:45:53,856 A:middle
of any application
that does benefit

946
00:45:53,856 --> 00:45:55,626 A:middle
from over-stuffing the kernel.

947
00:45:55,946 --> 00:46:00,836 A:middle
So once we had that
realization, we decided starting

948

949
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

950
00:45:55,946 --> 00:46:00,836 A:middle
So once we had that
realization, we decided starting

951
00:46:00,836 --> 00:46:04,686 A:middle
in the next seed, this option
will be turned on automatically

952
00:46:05,566 --> 00:46:09,766 A:middle
for all connections using
the higher layer NSURLSession

953
00:46:09,766 --> 00:46:11,546 A:middle
and CFNetwork APIs.

954
00:46:12,696 --> 00:46:15,776 A:middle
All you have to do to
make best use of this is

955
00:46:15,776 --> 00:46:20,606 A:middle
when your socket becomes
writable, don't loop writing

956
00:46:20,606 --> 00:46:23,086 A:middle
as much data as you can
until you get an EWOULDBLOCK.

957
00:46:23,446 --> 00:46:26,856 A:middle
Just write a sensible-sized
unit, and then wait

958
00:46:27,126 --> 00:46:28,426 A:middle
to be told it's time for more.

959
00:46:28,836 --> 00:46:31,606 A:middle
And that way if the user
has changed their mind

960
00:46:31,606 --> 00:46:33,686 A:middle
or something else has
changed about the environment,

961
00:46:33,686 --> 00:46:36,946 A:middle
next time you find your
socket is writable,

962
00:46:37,256 --> 00:46:39,466 A:middle
you can make an intelligent
decision.

963
00:46:40,456 --> 00:46:42,886 A:middle
You can do just-in-time
data generation

964
00:46:43,196 --> 00:46:47,116 A:middle
where you generate the data
so it is as fresh as possible

965
00:46:47,116 --> 00:46:48,656 A:middle
and based on the
current information,

966
00:46:49,046 --> 00:46:51,906 A:middle
not based on the information
from five or ten seconds ago.

967
00:46:52,486 --> 00:46:58,426 A:middle
And that brings me to our
final part of the presentation,

968
00:46:59,336 --> 00:47:01,416 A:middle
and that is a sneak peek

969

970
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

971
00:46:59,336 --> 00:47:01,416 A:middle
and that is a sneak peek

972
00:47:02,096 --> 00:47:06,416 A:middle
of a brand-new technology
called TCP Fast Open.

973
00:47:07,236 --> 00:47:14,516 A:middle
The way TCP traditionally works
is this: we do one round trip

974
00:47:15,076 --> 00:47:16,506 A:middle
to set up the TCP connection.

975
00:47:17,356 --> 00:47:18,746 A:middle
And then we do a
second round trip

976
00:47:19,396 --> 00:47:21,666 A:middle
to send the request
and get the response.

977
00:47:22,766 --> 00:47:27,056 A:middle
TCP Fast Open combines
the connection setup

978
00:47:27,056 --> 00:47:30,036 A:middle
and the data exchange
into one packet exchange.

979
00:47:31,216 --> 00:47:34,466 A:middle
This is not turned on by
default for all applications

980
00:47:34,566 --> 00:47:37,406 A:middle
and there's a reason for that.

981
00:47:37,636 --> 00:47:39,606 A:middle
There is a caveat you
need to be aware of,

982
00:47:40,026 --> 00:47:43,486 A:middle
and that is that this is only
safe for idempotent data.

983
00:47:43,796 --> 00:47:47,736 A:middle
I'll explain what that means.

984
00:47:47,906 --> 00:47:52,426 A:middle
When you use a TFO
operation, the handshake

985
00:47:52,426 --> 00:47:55,556 A:middle
and data are combined, the
server gets the message,

986
00:47:55,556 --> 00:47:57,946 A:middle
the server acts on that,
sends you the response,

987
00:47:58,336 --> 00:47:59,586 A:middle
and then you close
the connection.

988

989
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

990
00:48:00,686 --> 00:48:05,566 A:middle
But the service model of the
Internet doesn't guarantee

991
00:48:05,916 --> 00:48:08,536 A:middle
that packets can't
be duplicated.

992
00:48:09,366 --> 00:48:12,916 A:middle
The success of the
Internet has been due

993
00:48:12,916 --> 00:48:14,306 A:middle
to a very simple service model,

994
00:48:14,736 --> 00:48:18,446 A:middle
which is deliver the
packets fast and cheap.

995
00:48:19,146 --> 00:48:21,136 A:middle
And don't worry about
them being in order.

996
00:48:21,926 --> 00:48:24,296 A:middle
Don't worry if some get
corrupted, some get lost,

997
00:48:24,346 --> 00:48:26,916 A:middle
some get duplicated,
just be fast and cheap.

998
00:48:27,776 --> 00:48:30,816 A:middle
And the end systems are
smart enough to deal

999
00:48:30,816 --> 00:48:31,886 A:middle
with that network model.

1000
00:48:33,456 --> 00:48:35,566 A:middle
Packets can be duplicated
for many reasons.

1001
00:48:35,566 --> 00:48:37,446 A:middle
It could just be
a bug in a router,

1002
00:48:37,996 --> 00:48:40,736 A:middle
it could be Wi-Fi link
layer retransmission

1003
00:48:41,636 --> 00:48:43,876 A:middle
that accidentally
sends the packet twice.

1004
00:48:44,276 --> 00:48:46,706 A:middle
It could be end-system
retransmission:

1005
00:48:46,706 --> 00:48:50,396 A:middle
If you send a packet and
don't get an acknowledgment

1006
00:48:50,966 --> 00:48:52,896 A:middle
because the acknowledgment
was lost, perhaps,

1007
00:48:53,316 --> 00:48:54,786 A:middle
you will then retransmit
the packet

1008
00:48:55,296 --> 00:48:56,946 A:middle
and then immediately
you've got two copies

1009
00:48:56,946 --> 00:48:58,276 A:middle
of the same packet
in the network.

1010
00:48:58,786 --> 00:49:02,956 A:middle
Well, if one of those copies is
delayed and shows up much later,

1011

1012
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1013
00:48:58,786 --> 00:49:02,956 A:middle
Well, if one of those copies is
delayed and shows up much later,

1014
00:49:03,716 --> 00:49:06,496 A:middle
then to the server that looks

1015
00:49:06,496 --> 00:49:09,766 A:middle
like a perfectly
valid TFO request,

1016
00:49:10,156 --> 00:49:12,776 A:middle
and whatever the operation
was, it will do it again.

1017
00:49:13,646 --> 00:49:16,996 A:middle
If that operation was
sending you a JPEG image,

1018
00:49:17,336 --> 00:49:19,076 A:middle
doing it twice may
be no big deal.

1019
00:49:20,046 --> 00:49:23,726 A:middle
If that operation was sending
you a pair of shoes from Zappos,

1020
00:49:24,176 --> 00:49:26,006 A:middle
then doing it twice might
not be what you want.

1021
00:49:26,456 --> 00:49:31,196 A:middle
So this is something where you
have to intelligently decide

1022
00:49:31,316 --> 00:49:32,756 A:middle
when it's appropriate and safe

1023
00:49:33,076 --> 00:49:35,396 A:middle
and when it's not
for your application.

1024
00:49:36,626 --> 00:49:41,426 A:middle
You use this through the
connectx system call.

1025
00:49:42,346 --> 00:49:48,086 A:middle
This is a sneak peek technology
preview for the early adopters.

1026
00:49:49,136 --> 00:49:51,986 A:middle
Later, we will look
at how to expose this

1027
00:49:51,986 --> 00:49:52,846 A:middle
through the higher level APIs

1028
00:49:52,846 --> 00:49:55,616 A:middle
but now it's only
available through connectx.

1029
00:49:56,456 --> 00:49:59,776 A:middle
The server you are talking to
has to support TFO as well,

1030
00:49:59,776 --> 00:50:03,536 A:middle
and the application
has to opt in.

1031

1032
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1033
00:49:59,776 --> 00:50:03,536 A:middle
and the application
has to opt in.

1034
00:50:03,536 --> 00:50:06,546 A:middle
For those of you running Linux
servers, if you have the very,

1035
00:50:06,546 --> 00:50:09,686 A:middle
very latest Linux kernel as
of a couple of weeks ago,

1036
00:50:10,096 --> 00:50:15,836 A:middle
that now supports the
standard ITF, TFO,

1037
00:50:16,116 --> 00:50:18,676 A:middle
TCP option code,
the same as OS X.

1038
00:50:19,236 --> 00:50:24,196 A:middle
So to wrap up what we
would like you to remember

1039
00:50:24,196 --> 00:50:28,586 A:middle
from today's session,
wherever you can,

1040
00:50:29,256 --> 00:50:32,356 A:middle
use the highest layer
network API as possible

1041
00:50:32,886 --> 00:50:36,286 A:middle
and that way you get the
full benefit of all the work

1042
00:50:36,286 --> 00:50:38,016 A:middle
that those APIs can do for you.

1043
00:50:39,576 --> 00:50:42,956 A:middle
You absolutely must be
testing on a NAT64 network

1044
00:50:43,076 --> 00:50:44,586 A:middle
for your applications,

1045
00:50:45,206 --> 00:50:48,666 A:middle
and thankfully we have made
it really, really easy for you

1046
00:50:48,666 --> 00:50:52,396 A:middle
to do that with just
an Option click.

1047
00:50:52,596 --> 00:50:57,256 A:middle
Reliable network fallback will
give your customers a better

1048
00:50:57,256 --> 00:50:59,286 A:middle
user experience with
your applications.

1049

1050
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1051
00:51:00,526 --> 00:51:04,246 A:middle
What you can do is pay attention
to the Better Route notification

1052
00:51:04,506 --> 00:51:07,056 A:middle
so that you migrate back to
Wi-Fi when it's available.

1053
00:51:08,856 --> 00:51:13,096 A:middle
Explicit Congestion Notification
is a new feature for the seed.

1054
00:51:14,476 --> 00:51:17,646 A:middle
It will enable the
Internet to move

1055
00:51:17,646 --> 00:51:21,476 A:middle
to this much more
responsive mode of operation

1056
00:51:21,796 --> 00:51:24,756 A:middle
with lower queuing
and lower packet loss.

1057
00:51:25,406 --> 00:51:28,116 A:middle
So we would like you to test
that and report any problems.

1058
00:51:29,486 --> 00:51:32,836 A:middle
The TCP NOTSENT Low-Water mark
is something that you can set

1059
00:51:32,836 --> 00:51:36,636 A:middle
for yourself as a socket
option or get for free starting

1060
00:51:36,636 --> 00:51:39,506 A:middle
in the next seed, and that
will reduce the amount

1061
00:51:39,506 --> 00:51:41,726 A:middle
of stagnant data buffered
in the sending machine.

1062
00:51:42,706 --> 00:51:46,856 A:middle
And then finally, for the people
excited about TCP Fast Open,

1063
00:51:46,856 --> 00:51:48,076 A:middle
we've made that available too.

1064
00:51:49,896 --> 00:51:51,286 A:middle
There's a bunch of sources

1065
00:51:51,286 --> 00:51:53,006 A:middle
of good documentation
that you can look at.

1066
00:51:53,626 --> 00:51:55,906 A:middle
I'm not expecting anybody
to write down these URLs;

1067
00:51:55,906 --> 00:51:57,806 A:middle
you can click those
in the PDF version.

1068
00:51:59,066 --> 00:52:03,066 A:middle
There are some good forums
where you can ask questions

1069

1070
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1071
00:51:59,066 --> 00:52:03,066 A:middle
There are some good forums
where you can ask questions

1072
00:52:03,066 --> 00:52:04,176 A:middle
and have discussions

1073
00:52:04,666 --> 00:52:06,596 A:middle
with questions you
have about networking.

1074
00:52:09,586 --> 00:52:11,586 A:middle
I encourage you to
watch the videos

1075
00:52:11,586 --> 00:52:14,976 A:middle
of the NSURLSession presentation

1076
00:52:15,196 --> 00:52:19,626 A:middle
and the Network Extensions
presentation and, of course,

1077
00:52:20,326 --> 00:52:23,626 A:middle
come and join us in person after
lunch in the networking lab

1078
00:52:23,766 --> 00:52:25,276 A:middle
and we can answer all
of your questions there.

1079
00:52:25,746 --> 00:52:25,936 A:middle
Thank you.

1080
00:52:26,516 --> 00:52:32,500 A:middle
[Applause]

1081
