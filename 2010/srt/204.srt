1
00:00:06,620 --> 00:00:09,130
>> Welcome to Creating Secure Applications.

1
2
00:00:09,130 --> 00:00:10,600
I'm Matt Murphy.

2
3
00:00:10,600 --> 00:00:13,210
I'm an engineer on the Product Security Team.

3
4
00:00:13,210 --> 00:00:14,810
Thank you for coming.

4
5
00:00:15,980 --> 00:00:18,960
So why are you here?

5
6
00:00:18,960 --> 00:00:23,650
You probably know if you're in the audience
but, you know, it helps to go over it.

6
7
00:00:23,650 --> 00:00:27,640
So you're here because you want to avoid
the consequences of security issues.

7
8
00:00:27,640 --> 00:00:31,890
Things like negative press, lost revenue, and so on.

8
9
00:00:31,890 --> 00:00:34,570
You realize that security is a complicated business.

9
10
00:00:34,570 --> 00:00:41,610
We're dealing with more and more connected devices, you
know, things like MacBooks, iPhones, iPads and so on.

10
11
00:00:41,610 --> 00:00:45,190
And those environments demand a
lot of special care and attention.

11
12
00:00:45,190 --> 00:00:49,260
You're here because you wanted to determine
the optimal ways to prevent security issues.

12
13
00:00:49,260 --> 00:00:53,650
And if you're developing for our
platform, who better to ask?

13
14
00:00:53,650 --> 00:01:00,360
Finally, you want to maximize the benefits in terms of
security with your available resources because we all know

14
15
00:01:00,360 --> 00:01:04,330
that security is not really what you want to
do unless you're writing security software.

15
16
00:01:04,330 --> 00:01:08,390
You want to develop cool applications
and cool features for your customers.

16
17
00:01:08,390 --> 00:01:13,180
And finally, if you make a security
mistake, it's really expensive.

17
18
00:01:13,180 --> 00:01:14,780
Believe me, we know.

18
19
00:01:14,780 --> 00:01:17,580
[ Laughter ]

19
20
00:01:17,580 --> 00:01:24,350
>> So in this part of presentation, I'm going
to cover some design tips for secure software.

20
21
00:01:24,350 --> 00:01:29,820
I'm going to give you some tools that you
can use to help find bugs in your code.

21
22
00:01:29,820 --> 00:01:34,310
And some tips to avoid frequently seen security issues.

22
23
00:01:34,310 --> 00:01:40,280
And then later on, I'm going to hand it over to David who
will discuss a little bit about Objective-C and Cocoa

23
24
00:01:40,280 --> 00:01:45,360
and we'll also give you some practical examples of how
to apply some of the theoretical stuff that I'm going

24
25
00:01:45,360 --> 00:01:49,190
to discuss in the first part of the presentation.

25
26
00:01:49,190 --> 00:01:53,770
So the discussion will flow in
term of the Security Lifecycle.

26
27
00:01:53,770 --> 00:02:03,220
The four distinct components of a secure piece
of software--design, code, test, and maintain.

27
28
00:02:03,220 --> 00:02:12,860
Now, we're not going to cover the maintenance part
here. That is, as we say, an exercise to the reader.

28
29
00:02:12,860 --> 00:02:18,640
But that involves things like fixing bugs
and delivering fixes to you customers.

29
30
00:02:18,640 --> 00:02:22,900
Now, this is what I'm going to cover in
the design portion of the discussion.

30
31
00:02:22,900 --> 00:02:28,570
Now, as you'll note in the last bullet, there's quite
a bit of information about designing security software

31
32
00:02:28,570 --> 00:02:30,620
that we don't have time to cover in an hour.

32
33
00:02:30,620 --> 00:02:35,980
So we encourage you to look at the Secure Coding
Guide which is available on Apple Developer web site.

33
34
00:02:35,980 --> 00:02:40,320
And contrary to its name, it actually
has some very useful design tips as well

34
35
00:02:40,320 --> 00:02:42,510
as cutting instructions that you can use.

35
36
00:02:42,510 --> 00:02:47,710
First, we're going to talk a little
bit about privilege separation.

36
37
00:02:47,710 --> 00:02:54,230
Now, privilege separation is the art,
shall we say, of separating your code

37
38
00:02:54,230 --> 00:02:57,440
into privileged and non-privileged components.

38
39
00:02:57,440 --> 00:03:01,680
So that an ordinary user like me
can walk up to your Mac and use it.

39
40
00:03:01,680 --> 00:03:07,190
The first thing you want to know about
supporting privilege separation is what not to do.

40
41
00:03:07,190 --> 00:03:14,000
And the first thing you want to not do is you want to
not use the AuthorizationExecuteWithPrivileges API,

41
42
00:03:14,000 --> 00:03:18,700
because I've seen many, many developers
say, "Oh, but this is so easy."

42
43
00:03:18,700 --> 00:03:23,970
And they use it and they introduce security bugs
or they introduce complexity into their software.

43
44
00:03:23,970 --> 00:03:28,560
What you want to do instead is want to factor
privilege code into a background service.

44
45
00:03:28,560 --> 00:03:32,590
And we'll discuss that in a little more detail here.

45
46
00:03:32,590 --> 00:03:40,480
So you want to use launchd and you want to use the
service management APIs to set up your background service,

46
47
00:03:40,480 --> 00:03:46,170
things like SMJobBless, SMJobSubmit, those
are good reference points for you to look

47
48
00:03:46,170 --> 00:03:49,730
out if you're looking at writing privilege code.

48
49
00:03:49,730 --> 00:03:57,320
You can also see, the SampleD example which gives you
a starting point for how to write a launchd service.

49
50
00:03:57,320 --> 00:03:59,490
And it's available from the Apple Developer web site.

50
51
00:03:59,490 --> 00:04:07,130
Next, we want to cover a little bit about reduced
privilege, which is sort of practical consequence

51
52
00:04:07,130 --> 00:04:12,360
of privilege separation but it's important enough
that it gets its own section and here's why.

52
53
00:04:12,360 --> 00:04:15,910
The most important thing about
running with reduced privilege

53
54
00:04:15,910 --> 00:04:19,200
on the Mac OS is you want to test as a standard user.

54
55
00:04:19,200 --> 00:04:23,890
So many developers don't do this and they unwittingly
introduce dependencies that require the users

55
56
00:04:23,890 --> 00:04:26,520
to run as administrators to run their software.

56
57
00:04:26,520 --> 00:04:27,610
You don't want to do that.

57
58
00:04:27,610 --> 00:04:31,520
It is important for you to be a part of
good security posture as it is for you

58
59
00:04:31,520 --> 00:04:34,000
to avoid introducing bugs in your own code.

59
60
00:04:34,000 --> 00:04:39,160
When you're testing as a standard user,
your application should just work.

60
61
00:04:39,160 --> 00:04:44,620
I should be able to walk up to it and that should work the
same as a standard user as it would as an administrator

61
62
00:04:44,620 --> 00:04:49,870
with perhaps a few exceptions if you have
really truly privileged functionality.

62
63
00:04:49,870 --> 00:04:54,500
If that doesn't happen, you found
a bug and you should fix that bug

63
64
00:04:54,500 --> 00:04:58,450
because your user should be able to
run your software as a standard user.

64
65
00:04:58,450 --> 00:05:03,390
Now, a corollary to that is you don't want to rely
on the special capabilities of administrators.

65
66
00:05:03,390 --> 00:05:08,980
These are usually things like places on the file system
that you can modify when you're running as an administrator.

66
67
00:05:08,980 --> 00:05:14,030
And obviously, you can't if you're
a standard user as we just noted.

67
68
00:05:14,030 --> 00:05:19,960
But also these kinds of things might
break in the future for administrators.

68
69
00:05:19,960 --> 00:05:25,660
So we're constantly tightening the permissions of
the file system and what administrator users can do

69
70
00:05:25,660 --> 00:05:29,950
without explicitly authorizing
and gaining elevated privilege.

70
71
00:05:29,950 --> 00:05:35,730
So what I mean when I say places
on the file system you can write

71
72
00:05:35,730 --> 00:05:40,570
to /Applications including your own application bundle.

72
73
00:05:40,570 --> 00:05:45,660
If you have one user who installs you
application for example and another user

73
74
00:05:45,660 --> 00:05:48,390
who runs it, it won't be writable to that other user.

74
75
00:05:48,390 --> 00:05:54,660
Also, you know, the administrator of the system may
change the permissions on your bundle to be tighter.

75
76
00:05:54,660 --> 00:05:57,060
For example, the ownership may be root.

76
77
00:05:57,060 --> 00:06:02,270
And if your application attempts to write
into that bundle, that is going to break.

77
78
00:06:02,270 --> 00:06:07,650
/Applications/Utilities unless you are writing
and you're are installing a system utility.

78
79
00:06:07,650 --> 00:06:10,900
If you're writing a system utility
you don't want to be modifying things

79
80
00:06:10,900 --> 00:06:14,720
in that directory at runtime, only at install time.

80
81
00:06:14,720 --> 00:06:16,720
/Library and its sub-directories.

81
82
00:06:16,720 --> 00:06:24,460
Now, that's a huge list but there're a couple of common
culprits that we see people write to all the time.

82
83
00:06:24,460 --> 00:06:30,580
One is /Library/Application Support
and the other is /Library/Preferences.

83
84
00:06:30,580 --> 00:06:33,200
But as I mentioned there's quite a few others.

84
85
00:06:33,200 --> 00:06:40,080
So there are several reasons why you might write to one
of those directories and they're not always obvious.

85
86
00:06:40,080 --> 00:06:45,320
So three of the most common problems that we see
that prevent applications from running properly

86
87
00:06:45,320 --> 00:06:51,580
in a reduced privilege environment are
registration, things like serial numbers

87
88
00:06:51,580 --> 00:06:56,770
and license keys are installed in a
global directory at the first run.

88
89
00:06:56,770 --> 00:07:02,090
And so if the person running your application
is a standard user-- oops, that just broke.

89
90
00:07:02,090 --> 00:07:07,240
What you should do instead is if your--
you're going to ask for a serial number

90
91
00:07:07,240 --> 00:07:10,240
or license key during your application's launch.

91
92
00:07:10,240 --> 00:07:15,220
You should do it at the install time because your
installer has privilege and then you can save that file

92
93
00:07:15,220 --> 00:07:20,770
and then every run of the application can
simply consult it and make sure that it's there.

93
94
00:07:21,780 --> 00:07:24,520
Second, things like global preferences.

94
95
00:07:24,520 --> 00:07:30,790
A lot of applications rely on /Library/Preferences,
for example, being writable as I mentioned previously.

95
96
00:07:30,790 --> 00:07:34,890
And this will break-- you know, if
you're running as a non-administrator.

96
97
00:07:34,890 --> 00:07:41,330
So if you have a preference that you truly want
to have in effect for all users of the system

97
98
00:07:41,330 --> 00:07:46,750
and you want standard users to be able to use
your application, you should have a background job

98
99
00:07:46,750 --> 00:07:49,360
and you should protect it with authorization as necessary.

99
100
00:07:49,360 --> 00:07:55,440
Again, you can use launchd in the service
management APIs to facilitate that.

100
101
00:07:55,440 --> 00:08:01,750
Finally, and this is the most complicated
one, is the case of a custom installer.

101
102
00:08:01,750 --> 00:08:08,740
We'll see an application that you just double click and
run and it throws a bunch of files around somewhere.

102
103
00:08:08,740 --> 00:08:15,610
And most of the time that works because the user is
running as an administrator but it doesn't always.

103
104
00:08:15,610 --> 00:08:20,180
So what you want to do if you're
going to write an installer.

104
105
00:08:20,180 --> 00:08:24,690
The first thing we recommend that you do, obviously,
is use PackageMaker and the Apple Installer

105
106
00:08:24,690 --> 00:08:28,050
or one of the third party installers
that's already available.

106
107
00:08:28,050 --> 00:08:33,180
But if you need to write a custom
installer and some people do,

107
108
00:08:33,180 --> 00:08:42,710
you can also have your custom installer UI use the installer
command under the hood, basically, making your installer UI

108
109
00:08:42,710 --> 00:08:45,450
around the package system that's already there.

109
110
00:08:45,450 --> 00:08:51,780
And finally, if you can't do that, you can run
your-- you can run your installer as a launchd job

110
111
00:08:51,780 --> 00:08:54,480
and then remove it when the install completes.

111
112
00:08:54,480 --> 00:09:00,380
Now, that's a little bit hackie but it will work
for you and it will get around the privilege issue

112
113
00:09:00,380 --> 00:09:06,130
and allow your application to run properly in a reduced
privilege environment which is really important.

113
114
00:09:06,130 --> 00:09:09,670
Next, I'm going to talk a little bit about avoiding setuid.

114
115
00:09:09,670 --> 00:09:16,860
And setuid is a security curse
because it's an attacker's dream.

115
116
00:09:16,860 --> 00:09:25,200
So the attacker controls tons of things that are input to a
setuid program file descriptors, the environment, and so on.

116
117
00:09:25,200 --> 00:09:32,330
And because of the way setuid works, there can be
bugs in your code that can be exploited by an attacker

117
118
00:09:32,330 --> 00:09:38,580
or there can be bugs in third party code or
even our code that you expose by being setuid.

118
119
00:09:38,580 --> 00:09:45,400
A great many of the system frameworks for example,
don't expect to be loaded into a setuid binary.

119
120
00:09:45,400 --> 00:09:49,610
You don't want to write self-repairing tools.

120
121
00:09:49,610 --> 00:09:52,380
We've seen self-repairing tools written many, many times.

121
122
00:09:52,380 --> 00:09:56,100
Hey, if I don't have the setuid bit
AuthorizationExecuteWithPrivileges

122
123
00:09:56,100 --> 00:09:58,000
and then I'll restore the setuid bit.

123
124
00:09:58,000 --> 00:09:58,590
That's great.

124
125
00:09:58,590 --> 00:10:00,300
Right? No.

125
126
00:10:00,300 --> 00:10:02,010
Please don't do it.

126
127
00:10:02,010 --> 00:10:06,440
A local user can alter your self-repairing
binary because usually

127
128
00:10:06,440 --> 00:10:09,440
if the setuid bit is gone, the permissions are wrong.

128
129
00:10:09,440 --> 00:10:16,560
And once the local user can do that, your self-repair
will happily set the setuid bit on that modified binary

129
130
00:10:16,560 --> 00:10:19,470
and elevate the malicious code
to root the next time it runs.

130
131
00:10:19,470 --> 00:10:20,760
It is great for an attacker.

131
132
00:10:20,760 --> 00:10:23,040
Not so great for the user.

132
133
00:10:23,040 --> 00:10:28,690
So what you want to do instead of self-repairing tool is
you want to have an installer package and you want to have

133
134
00:10:28,690 --> 00:10:35,130
that installer package set the setuid bit on your file
at install time requesting RootAuthorization to do so.

134
135
00:10:35,130 --> 00:10:38,730
So that it does not subvert the privilege model.

135
136
00:10:38,730 --> 00:10:44,650
Now, to give you an idea of why we want you to
avoid setuid, we have a little diagram here.

136
137
00:10:44,650 --> 00:10:47,730
Now, to user a setuid is very simple interaction.

137
138
00:10:47,730 --> 00:10:48,750
Hey, I run a tool.

138
139
00:10:48,750 --> 00:10:49,570
It does something.

139
140
00:10:49,570 --> 00:10:52,130
I don't even really know what it does but it works.

140
141
00:10:52,130 --> 00:10:55,440
So you might not even realize that
you're running such a tool.

141
142
00:10:55,440 --> 00:10:58,130
Now to an attacker, it's a lot more interesting.

142
143
00:10:58,130 --> 00:11:06,280
An attacker has control of I/O and your setiud
tool, command-line arguments, environment variables,

143
144
00:11:06,280 --> 00:11:18,370
the working directory, file descriptors, the file mode
mask, the emask, interval timers, signal mask, mach ports,

144
145
00:11:18,370 --> 00:11:21,080
and there's more that I couldn't fit the diagram.

145
146
00:11:21,080 --> 00:11:24,870
So, you know, it is a very complicated interaction.

146
147
00:11:24,870 --> 00:11:26,120
You don't want to do it.

147
148
00:11:26,120 --> 00:11:32,070
So finally, and perhaps the most important point of
the security design discussion for a network task

148
149
00:11:32,070 --> 00:11:35,880
and particularly those of you developing
on iPhone is to protect data in transit.

149
150
00:11:35,880 --> 00:11:40,480
You have to assume users of applications
are mobile, as I mentioned before.

150
151
00:11:40,480 --> 00:11:44,170
You know, MacBooks, iPhones, iPod touches, iPads.

151
152
00:11:44,170 --> 00:11:52,390
The days where users are sitting on a desktop, they're not
quite long gone yet but they're on the way out the door.

152
153
00:11:52,390 --> 00:11:57,350
So you have to be suspicious of things like the
Domain Name System and the local network in general.

153
154
00:11:57,350 --> 00:12:01,500
Now, you know, if I am sitting at
Starbucks and I'm running your application,

154
155
00:12:01,500 --> 00:12:03,490
you know, I think, I think I am pretty safe.

155
156
00:12:03,490 --> 00:12:09,500
You know, I am on a network that I know and, you know,
I am sipping my latte and having great, great time.

156
157
00:12:09,500 --> 00:12:13,870
But what's bad about those networks is that they can be--

157
158
00:12:13,870 --> 00:12:18,640
traffic on those networks can be monitored
and can be tampered with by third party

158
159
00:12:18,640 --> 00:12:24,540
from the network relatively easily and there
are a lot of third parties on those networks.

159
160
00:12:24,540 --> 00:12:26,610
So what you want to do is any kind of sensitive data

160
161
00:12:26,610 --> 00:12:29,980
that your application is transmitting
or receiving protects it with SSL.

161
162
00:12:29,980 --> 00:12:32,910
Now, there are two really easy ways to do that.

162
163
00:12:32,910 --> 00:12:41,750
One is NSURLConnection with an https: URL and the
other is CFReadStream with the SSL extensions.

163
164
00:12:41,750 --> 00:12:46,610
Now, here is something you don't want to
do if you're protecting data in transit.

164
165
00:12:46,610 --> 00:12:49,190
Don't disable chain validation.

165
166
00:12:49,190 --> 00:12:54,090
Now, that's really important because if you disable chain
validation, you've basically told the certificate system,

166
167
00:12:54,090 --> 00:12:56,750
"Hey, any certificate is acceptable here.

167
168
00:12:56,750 --> 00:13:00,240
I don't care where it came from, anything."

168
169
00:13:00,240 --> 00:13:06,090
So I can get a certificate, present it to your
application and the system will say, "Sure, OK."

169
170
00:13:06,090 --> 00:13:07,780
So here's what that looks like.

170
171
00:13:07,780 --> 00:13:11,160
I wanted to give you an example
because I've seen it recommended a lot

171
172
00:13:11,160 --> 00:13:15,220
and people don't call it disabling
chain validation but that's what it is.

172
173
00:13:15,220 --> 00:13:20,240
And so if you see code the sets this constant
a kCFStreamSSLValidatesCertificateChain,

173
174
00:13:20,240 --> 00:13:24,230
yes I know it is a mouthful, to false, no.

174
175
00:13:24,230 --> 00:13:28,010
You need to rethink the design angle there.

175
176
00:13:28,010 --> 00:13:35,950
Now, the one case that you may want to do this is if you
are expecting to use a self sign-certificate for example.

176
177
00:13:35,950 --> 00:13:42,180
But you have to validate specifically that the
certificate you've been presented is the one you expected

177
178
00:13:42,180 --> 00:13:44,560
and that is a very complicated process.

178
179
00:13:44,560 --> 00:13:48,650
But you cannot simply disable chain
validation and plug and go.

179
180
00:13:48,650 --> 00:13:53,960
You will have introduced a vulnerability
and you'll have effectively neutered SSL.

180
181
00:13:53,960 --> 00:14:00,210
It's also important-- you know, this isn't necessarily
sensitive data per se, but it's integrity critical.

181
182
00:14:00,210 --> 00:14:05,760
So if you have code or other content that your
application will download on demand such as updates,

182
183
00:14:05,760 --> 00:14:11,110
it's really important that you sign that stuff
so that the application can verify, "Hey,

183
184
00:14:11,110 --> 00:14:14,260
this hasn't been manipulated in transit."

184
185
00:14:14,260 --> 00:14:19,830
It's very important when you're doing code
signing that you verify the signing certificate,

185
186
00:14:19,830 --> 00:14:24,150
because this poses a similar problem
to chain validation in SSL.

186
187
00:14:24,150 --> 00:14:28,560
Anyone can get a code signing certificate
and say, "Hey, this code is signed by me."

187
188
00:14:28,560 --> 00:14:33,040
I can get a certificate that says,
"Hey, Matthew Murphy signed this code."

188
189
00:14:33,040 --> 00:14:37,430
And your application will accept
it unless you explicitly validate

189
190
00:14:37,430 --> 00:14:40,980
that you've received a signature
from a particular certificate.

190
191
00:14:40,980 --> 00:14:44,170
You don't want me signing out on
packages for your applications.

191
192
00:14:44,170 --> 00:14:51,790
Trust me. So now we have talked a little bit about,
you know, designing your application securely.

192
193
00:14:51,790 --> 00:14:55,720
So there are some coding tips that I wanted to cover next.

193
194
00:14:55,720 --> 00:14:58,780
And we're going to talk about a few
different things in the coding section.

194
195
00:14:58,780 --> 00:15:02,000
But again, highly recommend reading the Secure Coding Guide.

195
196
00:15:02,000 --> 00:15:03,800
I really like it.

196
197
00:15:03,800 --> 00:15:06,020
It's great stuff.

197
198
00:15:06,020 --> 00:15:08,600
First, let's talk a little bit about safe file handling.

198
199
00:15:08,600 --> 00:15:14,810
Now the biggest part of safe file handling is
using a safe temporary or cache file directory.

199
200
00:15:14,810 --> 00:15:16,120
Now what do I mean by safe?

200
201
00:15:16,120 --> 00:15:20,840
Well, you can get them from confstr or NSTemporaryDirectory.

201
202
00:15:20,840 --> 00:15:24,790
Those are going to be good safe
directories for your application to use.

202
203
00:15:24,790 --> 00:15:26,380
Now what's an unsafe directory?

203
204
00:15:26,380 --> 00:15:35,010
It's a world-writable directory, something like say,
/tmp or /Library/Caches where other users can dump files

204
205
00:15:35,010 --> 00:15:39,090
and can potentially interfere with
your applications expectations.

205
206
00:15:39,090 --> 00:15:43,920
If you have to use these directories, these
world-writable directories--and be very, very careful--

206
207
00:15:43,920 --> 00:15:50,660
it's important to note that the higher level APIs like
the writeToFile method on NSString and NSDictionary

207
208
00:15:50,660 --> 00:15:55,450
and NSFileManager, those are not safe
to use in a world-writable directory.

208
209
00:15:55,450 --> 00:15:57,490
You'll introduce race conditions.

209
210
00:15:57,490 --> 00:16:01,580
So what you have to do is you have
to use a lower level open API.

210
211
00:16:01,580 --> 00:16:05,530
It's also important to note that
you can't open existing files

211
212
00:16:05,530 --> 00:16:09,390
in a world-writable directory in a security critical way.

212
213
00:16:09,390 --> 00:16:15,540
You have to create those files yourself to ensure
that you're manipulating the file you expect.

213
214
00:16:15,540 --> 00:16:19,030
And you have to use the exclusive flag
I've highlighted on the slide here

214
215
00:16:19,030 --> 00:16:22,480
to ensure that you don't follow links for example.

215
216
00:16:23,490 --> 00:16:26,810
Next let's cover a little bit about permissions.

216
217
00:16:26,810 --> 00:16:32,650
Now on the Mac like most Unix-like platforms,
files are actually world-readable by default.

217
218
00:16:32,650 --> 00:16:36,640
Now this stuns some people but the
most important thing to note here is

218
219
00:16:36,640 --> 00:16:42,110
that the directory structure is largely what
controls-- what controls access to a file.

219
220
00:16:42,110 --> 00:16:48,520
If you can't execute through the parent directory of a
particular file, you can't see the file much less read it.

220
221
00:16:48,520 --> 00:16:53,150
However, world-read permissions
are not appropriate for everything.

221
222
00:16:53,150 --> 00:16:59,340
So if you have a file where world-read permissions
aren't appropriate or simply aren't necessary,

222
223
00:16:59,340 --> 00:17:03,330
we encourage you to set tighter
permissions when you're creating a file.

223
224
00:17:04,480 --> 00:17:09,240
Please, please, please, please, please,
avoid creating world-writable files.

224
225
00:17:09,240 --> 00:17:11,110
Don't do it.

225
226
00:17:11,110 --> 00:17:16,150
The reason why you don't want to do it is
because it's subject to race conditions.

226
227
00:17:16,150 --> 00:17:19,410
Your file can be deleted and replaced for example.

227
228
00:17:19,410 --> 00:17:23,680
It can be substituted with a link and your program
will follow the link and so on and so forth.

228
229
00:17:23,680 --> 00:17:28,680
Also, an unprivileged user can simply
destroy the file if they want to,

229
230
00:17:28,680 --> 00:17:31,690
which is not good for your application stability.

230
231
00:17:31,690 --> 00:17:36,860
What you want to do instead, again, you want to have a
background service that your application can make calls

231
232
00:17:36,860 --> 00:17:44,270
to when it runs as any user that will edit a file under the
hood and you don't want to have that file be world-writable.

232
233
00:17:44,270 --> 00:17:48,060
Next, I'm going to talk a little bit about bounds checking.

233
234
00:17:48,060 --> 00:17:51,750
So bounds checking is a classic
defensive programming technique

234
235
00:17:51,750 --> 00:17:55,500
and it's designed to stop buffer overflow vulnerabilities.

235
236
00:17:55,500 --> 00:18:00,490
Buffer overflow is a bug where you have a piece of data
that's too large for the memory buffer you've allocated

236
237
00:18:00,490 --> 00:18:04,320
into it and your application attempts to copy it anyway.

237
238
00:18:04,320 --> 00:18:10,360
So you have to perform a lot of sanity checks
on any kind of untrusted or unvalidated input,

238
239
00:18:10,360 --> 00:18:13,540
things that come off the network from files and so on.

239
240
00:18:13,540 --> 00:18:17,120
And you have to use the safe string functions.

240
241
00:18:17,120 --> 00:18:30,260
The safe string functions are listed here for you, things
like strlcat, strlcpy, snprintf and vsnprintf, and fgets.

241
242
00:18:30,260 --> 00:18:37,760
Also the functions that we recommend you avoid using
are on the left under the X here, strcat, strcpy.

242
243
00:18:37,760 --> 00:18:42,400
Now you may be surprised to see
strncat and strncpy on that list.

243
244
00:18:42,400 --> 00:18:48,600
Gee, I thought those were bounded functions and they are
but they're bounded in such a way that makes it really easy

244
245
00:18:48,600 --> 00:18:52,920
to introduce security bugs and we'll
show you that on the next slide.

245
246
00:18:52,920 --> 00:19:00,500
But also on the list are obvious suspects like
sprintf and vsprintf, and of course the gets function,

246
247
00:19:00,500 --> 00:19:04,920
which is the source of one of the oldest
compiler warnings in the book for security.

247
248
00:19:04,920 --> 00:19:09,990
Now to give you an example of what I mean and
why we don't recommend you use this strncpy

248
249
00:19:09,990 --> 00:19:12,980
and strncat functions, consider this example.

249
250
00:19:12,980 --> 00:19:17,120
Here we have a 5 byte destination
buffer and a 6 byte string.

250
251
00:19:17,120 --> 00:19:21,530
Obviously, if we copy the entire string into the
destination buffer, we're going to cause an overflow.

251
252
00:19:21,530 --> 00:19:23,110
This is not good.

252
253
00:19:23,110 --> 00:19:27,440
So here we have three prospective copies that we can make.

253
254
00:19:27,440 --> 00:19:33,080
Of this source string into this
destination buffer one, using each function.

254
255
00:19:33,080 --> 00:19:35,230
First let's look at strcpy.

255
256
00:19:35,230 --> 00:19:38,940
Notice how it copies right on pass the end of the buffer.

256
257
00:19:38,940 --> 00:19:44,100
So you've just corrupted memory and potentially
allowed an attacker to execute arbitrary code.

257
258
00:19:44,100 --> 00:19:49,840
Not good. Now let's look at strncpy and see what it does.

258
259
00:19:49,840 --> 00:19:53,610
Notice how it copies 5 bytes but the last byte is the E.

259
260
00:19:53,610 --> 00:19:55,770
There's no null terminator.

260
261
00:19:55,770 --> 00:19:58,950
That's not good either because the
next time you manipulate that string,

261
262
00:19:58,950 --> 00:20:00,660
you're going to get a read right off the end of it.

262
263
00:20:00,660 --> 00:20:03,580
And you may even introduce an exploitable security hole.

263
264
00:20:03,580 --> 00:20:05,740
Now let's look at what strlcpy does.

264
265
00:20:05,740 --> 00:20:10,870
You can see it also copies only 5 bytes, but the
last byte is the null terminator so that you end

265
266
00:20:10,870 --> 00:20:13,920
up with a properly terminated string
and this is why we recommend

266
267
00:20:13,920 --> 00:20:17,770
that you use strlcpy instead of
strncpy and strcat and strlcat.

267
268
00:20:17,770 --> 00:20:22,590
Next let's cover a little bit about integer overflows.

268
269
00:20:22,590 --> 00:20:27,060
Now, an integer overflow occurs when an
arithmetic operation produces a value that's larger

269
270
00:20:27,060 --> 00:20:28,480
than an integer type can hold.

270
271
00:20:28,480 --> 00:20:31,330
Now that's a big complicated dictionary definition.

271
272
00:20:31,330 --> 00:20:33,800
So let's explain it with a little bit of code.

272
273
00:20:33,800 --> 00:20:39,230
Here, we have a structure that has an N entries
value in it, that is potentially hostile.

273
274
00:20:39,230 --> 00:20:41,410
We'll say it came from the network.

274
275
00:20:41,410 --> 00:20:47,000
And then we have an NSData initializer
which says dataWithLength, N entries times,

275
276
00:20:47,000 --> 00:20:50,140
you know, this size up here which is a constant.

276
277
00:20:50,140 --> 00:20:54,680
Now if that N entries is really,
really large that integer will overflow

277
278
00:20:54,680 --> 00:21:00,360
and the allocation will be unexpectedly
small then the memcpy down here which is done

278
279
00:21:00,360 --> 00:21:04,630
in a loop will copy right on past
the end of the allocated buffer.

279
280
00:21:04,630 --> 00:21:11,140
To show you exactly why that happens, here's an example
of what we get if we specify a particular large value.

280
281
00:21:11,140 --> 00:21:15,770
And you can see we have an editor
here that has 33 significant bits.

281
282
00:21:15,770 --> 00:21:22,670
So the 1 that would be at the high end of that integer
simply gets truncated away and we end up with a four

282
283
00:21:22,670 --> 00:21:27,480
by allocation and into which we're
copying tens of millions of entries.

283
284
00:21:27,480 --> 00:21:29,430
That's not good.

284
285
00:21:29,430 --> 00:21:34,300
So what we recommend that you do to avoid
integer overflows is use our checkint API

285
286
00:21:34,300 --> 00:21:37,270
which has been available since Leopard.

286
287
00:21:37,270 --> 00:21:42,840
So you can see the code now includes the
checkint.h but the meat of it is down here

287
288
00:21:42,840 --> 00:21:50,250
where we have this check_uint32_mul function which
will set an error condition bit in the error value

288
289
00:21:50,250 --> 00:21:54,310
if the multiplication results in an overflow.

289
290
00:21:54,310 --> 00:21:59,550
Now you can see it says CHECKINT_NO_ERROR
here so we can succeed.

290
291
00:21:59,550 --> 00:22:02,570
Now we know this multiplication was safe.

291
292
00:22:02,570 --> 00:22:04,860
So that's integer overflows.

292
293
00:22:04,860 --> 00:22:10,090
Now I can give you a little bit of background on
how to test your application through security.

293
294
00:22:10,090 --> 00:22:12,700
Now, there're obviously two components of testing.

294
295
00:22:12,700 --> 00:22:16,170
One of which is manual auditing and
David will cover a little bit more

295
296
00:22:16,170 --> 00:22:18,490
about manual auditing in his section of the talk.

296
297
00:22:18,490 --> 00:22:22,480
But I want to give you some useful automated testing tools.

297
298
00:22:22,480 --> 00:22:25,820
So we're going to cover two different type of tools.

298
299
00:22:25,820 --> 00:22:29,960
We're going to cover static analysis
and we're going to cover fuzzing.

299
300
00:22:29,960 --> 00:22:33,040
So the Developer Tools include a static analyzer for you.

300
301
00:22:33,040 --> 00:22:38,100
You can run it with Build and Analyze menu item in Xcode.

301
302
00:22:38,100 --> 00:22:41,950
Checks your code for some really
common bugs, memory management issues,

302
303
00:22:41,950 --> 00:22:44,520
things like reference counting, that sort of thing.

303
304
00:22:44,520 --> 00:22:49,160
A small subset of buffer overflows, it
won't catch them all, which is important

304
305
00:22:49,160 --> 00:22:55,130
and some non-security bugs, things
like dead stores and so on.

305
306
00:22:55,130 --> 00:23:02,300
There's really detailed warnings when it finds a bug that
help you document the data flow through your application.

306
307
00:23:02,300 --> 00:23:09,950
The rules aren't very detailed yet, but we're
improving them with each updates the Developer Tools.

307
308
00:23:09,950 --> 00:23:14,140
So you can see an example here of
where the analyzer has found a bug.

308
309
00:23:14,140 --> 00:23:23,860
I have an NSString value that I don't initialize and I pass
to NSLog and then I built my code with Build and Analyze.

309
310
00:23:23,860 --> 00:23:28,420
So Build and Analyze has flagged this and said,
"Hey, you declared this but didn't initialize it

310
311
00:23:28,420 --> 00:23:30,970
and then you passed it to a by value function.

311
312
00:23:30,970 --> 00:23:36,680
Now this example is obviously pretty contrive
but the analyzer can catch some more details

312
313
00:23:36,680 --> 00:23:40,490
and more sophisticated example of this same type of bug.

313
314
00:23:40,490 --> 00:23:44,160
So the important thing about the analyzer
is that we recommend you use it often.

314
315
00:23:44,160 --> 00:23:48,140
If you run it all the time, you're going
to catch any new bugs that you introduced,

315
316
00:23:48,140 --> 00:23:51,570
at least bugs that the analyzer, again, has rules to catch.

316
317
00:23:51,570 --> 00:23:52,690
So that's important.

317
318
00:23:52,690 --> 00:23:54,040
Also, we keep adding rules.

318
319
00:23:54,040 --> 00:23:55,710
So even if your code isn't changing.

319
320
00:23:55,710 --> 00:24:00,650
It's important that you run this periodically
to get the benefit of the new rules.

320
321
00:24:00,650 --> 00:24:03,290
There's a project configuration option that you can use

321
322
00:24:03,290 --> 00:24:07,930
that will let you run the analyzer
with every build of your project.

322
323
00:24:07,930 --> 00:24:10,380
And you can see that here in this screen shot.

323
324
00:24:10,380 --> 00:24:14,860
In the build options, there's a pretty self
explanatory option called the Runs Static Analyzer

324
325
00:24:14,860 --> 00:24:20,150
and you can see I have checked it in my project
which has made it turn fold because it's non-default.

325
326
00:24:20,150 --> 00:24:25,990
But when I build my project now,
the analyzer will run automatically.

326
327
00:24:25,990 --> 00:24:31,480
Other important class of automated testing for
you to be doing with your software is fuzzing.

327
328
00:24:31,480 --> 00:24:34,440
So fuzzing is where you subtly alter valid program inputs.

328
329
00:24:34,440 --> 00:24:40,070
If I have data that comes from a file or from
the network, great candidates for fuzzing.

329
330
00:24:40,070 --> 00:24:46,040
It doesn't have to complicated, change a bit
here, right there, a couple of bytes there,

330
331
00:24:46,040 --> 00:24:50,850
you've got a fuzz file that could
potentially cause havoc in your application.

331
332
00:24:50,850 --> 00:24:55,960
And as you might guess, the most likely thing that your
application is going to do if you find a bug is crash.

332
333
00:24:55,960 --> 00:24:59,970
So if it crashes, there you go, you found a bug.

333
334
00:24:59,970 --> 00:25:04,850
And our CrashWrangler tool can help you prioritize
to determine which of those bugs are important

334
335
00:25:04,850 --> 00:25:08,430
for you or most important for you to fix.

335
336
00:25:08,430 --> 00:25:14,090
So you can run CrashWrangler with either crash logs
or with a live target and that is an application,

336
337
00:25:14,090 --> 00:25:16,990
it's running and it's being hit with data.

337
338
00:25:16,990 --> 00:25:23,710
And it has a heuristic for identifying exploitable
bugs things like out of bounds rights, double freeze,

338
339
00:25:23,710 --> 00:25:27,360
so on so forth, from nonexploitable simple crashes.

339
340
00:25:27,360 --> 00:25:31,660
Things like null pointer to your references and the like.

340
341
00:25:31,660 --> 00:25:38,210
And you can download it from the Apple Developer website
at connect.apple.com you just search for CrashWrangler.

341
342
00:25:38,210 --> 00:25:42,600
And it's available for you to use today.

342
343
00:25:42,600 --> 00:25:47,470
So we've covered three of the four
pieces of the security life cycle.

343
344
00:25:47,470 --> 00:25:51,190
We've covered design, we've covered
code and we've covered testing.

344
345
00:25:51,190 --> 00:25:58,760
And now I want to hand it over to David for a little
more detail on practical applications of these things

345
346
00:25:58,760 --> 00:26:02,560
and what you can do with Cocoa and Objective-C specifically.

346
347
00:26:02,560 --> 00:26:05,990
[ Applause ]

347
348
00:26:05,990 --> 00:26:09,790
>> Hi I'm David Remahl and I'm a product security engineer.

348
349
00:26:09,790 --> 00:26:13,940
I think it will be instructive to
try to apply some of the techniques

349
350
00:26:13,940 --> 00:26:17,630
that Matt has talked about to a real world application.

350
351
00:26:17,630 --> 00:26:22,770
And the application we'll be talking
about today is called Naivete.

351
352
00:26:22,770 --> 00:26:29,500
It's a magical and revolutionary feed reader for Atom feeds.

352
353
00:26:30,810 --> 00:26:37,090
It supports some of the Atom feeds on the
web, it's not perfect yet, it's a version 1.0.

353
354
00:26:37,090 --> 00:26:44,160
It has a ground breaking feature that's an industry first,
it's document-based using the Cocoa document architecture.

354
355
00:26:44,160 --> 00:26:49,860
It opens this new URL format that we've invented naive:.

355
356
00:26:49,860 --> 00:26:55,970
It has a gorgeous icon and if it
crashes that's a feature not a bug.

356
357
00:26:55,970 --> 00:27:01,810
Now I don't anticipate that the App
Store reviewers will take that excuse.

357
358
00:27:01,810 --> 00:27:12,730
And that's why we've put this program app on the sample
code sites for WWDC as an example of code not to write.

358
359
00:27:12,730 --> 00:27:17,000
So now I want to demo some of the
features of this application.

359
360
00:27:17,000 --> 00:27:19,630
Let's start it here from the dark.

360
361
00:27:19,630 --> 00:27:25,460
It opens up a blank document, and it
has these bookmarks pop-up where we can

361
362
00:27:25,460 --> 00:27:30,100
for example load the hot news feed from apple.com.

362
363
00:27:30,100 --> 00:27:35,020
Here we go, it's a simple RSS reader or Atom in this case.

363
364
00:27:35,020 --> 00:27:38,120
You select the stories in the source list here.

364
365
00:27:38,120 --> 00:27:49,620
It even supports sorting on the dates or the title
and if you hit a link it will open it up in Safari.

365
366
00:27:49,620 --> 00:27:58,270
I also prepared a feature feed that demonstrates
some other unique features of this application.

366
367
00:27:58,270 --> 00:28:04,510
It supports HTML5 and the proof of that is this.

367
368
00:28:04,510 --> 00:28:10,040
[ Laughter ]

368
369
00:28:10,040 --> 00:28:15,330
>> If you load an Atom feed that contains a
podcast file it supports downloading that so

369
370
00:28:15,330 --> 00:28:23,750
if I hit download here you'll see the podcast file arrived
in my Downloads folder and that works for pictures as well.

370
371
00:28:23,750 --> 00:28:29,150
Oh, I forgot to show you the document support.

371
372
00:28:29,150 --> 00:28:31,230
If I save this--

372
373
00:28:32,510 --> 00:28:38,190
[ Pause ]

373
374
00:28:38,190 --> 00:28:44,980
>> Here's the file, if we close this
you'll be right back at this feed.

374
375
00:28:46,120 --> 00:28:53,570
Now let's go back to the slides and think
about the security of this application.

375
376
00:28:53,570 --> 00:28:57,830
So as we're going through this part
of the presentation we'll be filling

376
377
00:28:57,830 --> 00:29:01,310
out this security scorecard for the application.

377
378
00:29:01,310 --> 00:29:06,310
I'll be returning to this periodically
and will see how it fairs.

378
379
00:29:06,310 --> 00:29:10,680
It's important when you're developing
an application as early as possible,

379
380
00:29:10,680 --> 00:29:18,570
at the design phase to understand the attacks and the
environment that your application will be exposed to.

380
381
00:29:18,570 --> 00:29:20,880
And we call this the attack surface.

381
382
00:29:20,880 --> 00:29:26,830
And one way of understanding the attack surface is
to enumerate the entry points to the application.

382
383
00:29:26,830 --> 00:29:29,850
In this case we have the naive: URLs.

383
384
00:29:29,850 --> 00:29:37,530
If I click on a naive link in Safari, it
will open up that feed in the application.

384
385
00:29:37,530 --> 00:29:46,350
Documents, users love to share documents among each other
so that's a way that an attacker might attack the user.

385
386
00:29:46,350 --> 00:29:53,900
Feeds of course are downloaded from the web and could
potentially be used in attacks against the application.

386
387
00:29:53,900 --> 00:29:57,650
And finally in this case, we support enclosures.

387
388
00:29:59,300 --> 00:30:08,320
In order to understand the attacks that might be used
against us, one way is to enumerate the APIs that we use.

388
389
00:30:08,320 --> 00:30:12,650
In this case, the stories are loaded in the WebView.

389
390
00:30:12,650 --> 00:30:16,100
It's-- you need to know that a WebView--
that the entire security modeling

390
391
00:30:16,100 --> 00:30:19,770
of the WebView is based on the document origin.

391
392
00:30:19,770 --> 00:30:28,640
Since this deals with HTML and other web formats,
we need to be concerned with cross-site scripting.

392
393
00:30:28,640 --> 00:30:36,420
This is normally an issue that web application
developers or browser vendors are tasked to solve.

393
394
00:30:36,420 --> 00:30:43,450
But when we make connected applications that embed WebViews
for either for internal use or for viewing web contents,

394
395
00:30:43,450 --> 00:30:52,000
then cross-site scripting becomes important to
desktop or iPhone iOS application developers.

395
396
00:30:52,000 --> 00:30:57,120
External links, we, of course, need to be
careful when we're dealing with those.

396
397
00:30:57,120 --> 00:31:00,460
And we could fill an entire session on WebKit security.

397
398
00:31:00,460 --> 00:31:05,060
So this will be some of the things we focus on today.

398
399
00:31:05,060 --> 00:31:12,410
URL handlers naturally have to be written to expect
some malicious input and do careful input validation.

399
400
00:31:12,410 --> 00:31:16,940
And we also need-- for the documents, we
need to think about the serialization format

400
401
00:31:16,940 --> 00:31:20,720
and make sure that that's aptly chosen to be secure.

401
402
00:31:20,720 --> 00:31:28,260
And as Matt has often referred you to the Secure
Coding Guide, this is where you will find the source

402
403
00:31:28,260 --> 00:31:32,730
of security concentrations for the APIs that you are using.

403
404
00:31:32,730 --> 00:31:37,290
So let's go back to the application and see
how it fares against some of these attacks.

404
405
00:31:37,290 --> 00:31:44,680
I've prepared an attack feed here that tests
some of the attacks we were talking about.

405
406
00:31:44,680 --> 00:31:52,640
So as you've seen, the application
handles links from feed contents.

406
407
00:31:52,640 --> 00:31:57,650
But what if someone would try to link
to an application on the local disk?

407
408
00:31:57,650 --> 00:32:02,760
I've prepared this item here, and when I
click this link, we will see what happens.

408
409
00:32:02,760 --> 00:32:09,260
Uh-oh. That launched the application, and that's
probably not something we intended in this application

409
410
00:32:09,260 --> 00:32:13,380
because we wanted it to open up in Safari.

410
411
00:32:13,380 --> 00:32:16,670
So we've found a bug.

411
412
00:32:16,670 --> 00:32:20,160
Let's go to the code and fix that.

412
413
00:32:20,160 --> 00:32:28,760
So when the user clicks on a link in the
WebView, this Web Policy Delegate gets evoked.

413
414
00:32:28,760 --> 00:32:35,250
And we see here that if the source of the
navigation was a user click, then we do this.

414
415
00:32:35,250 --> 00:32:40,190
We use NSWorkspace openURL to open the URL of the request.

415
416
00:32:40,190 --> 00:32:48,580
And if you read the NSWorkspace documentation,
you'll see that openURL has a dual purpose.

416
417
00:32:48,580 --> 00:32:53,430
One is to open safe URLs like as HTTP or AFP.

417
418
00:32:53,430 --> 00:32:57,290
And another is to open local files.

418
419
00:32:57,290 --> 00:33:04,180
So it's one of the recommended APIs
for opening up a local document.

419
420
00:33:04,180 --> 00:33:11,880
In this case, we only want the safe case, and
we want to handle the file URLs separately.

420
421
00:33:11,880 --> 00:33:17,750
So I've written some code here
that addresses this vulnerability.

421
422
00:33:17,750 --> 00:33:23,140
We check whether the scheme of the
URL is equal to the file scheme.

422
423
00:33:23,140 --> 00:33:29,900
And if so, we select the file and the finder
instead of opening it up through NSWorkspace.

423
424
00:33:29,900 --> 00:33:32,510
So we build and run this.

424
425
00:33:32,510 --> 00:33:44,040
[ Pause ]

425
426
00:33:44,040 --> 00:33:49,340
>> Attacks, and now, the file gets
selected instead, which is what we want.

426
427
00:33:49,340 --> 00:33:52,780
There is a bug still in this code.

427
428
00:33:52,780 --> 00:33:58,170
I don't know if you spotted it, but here's a hint.

428
429
00:33:58,170 --> 00:34:00,190
Someone saw it?

429
430
00:34:00,190 --> 00:34:06,220
So if the scheme starts with all capital
letters, then we still have a bug.

430
431
00:34:06,220 --> 00:34:11,710
And we could solve this by doing
a case insensitive comparison.

431
432
00:34:11,710 --> 00:34:20,770
But a better way is to use the NSURL API as
filed URL, which handles all these cases,

432
433
00:34:20,770 --> 00:34:24,170
regardless of capitalization or future changes or whatever.

433
434
00:34:24,170 --> 00:34:26,510
It will do the right thing.

434
435
00:34:26,510 --> 00:34:34,200
[ Pause ]

435
436
00:34:34,200 --> 00:34:36,670
>> Now we handle that case correctly too.

436
437
00:34:38,280 --> 00:34:45,180
I mentioned JavaScript injection
and the importance of the origin.

437
438
00:34:45,180 --> 00:34:52,400
In this case, I've wrote a great script that
tries to first print the origin of the document,

438
439
00:34:52,400 --> 00:34:55,520
and we see that it's served from an applewebdata URL.

439
440
00:34:55,520 --> 00:35:01,030
And then it tries to get the EDC
password database or any other local file.

440
441
00:35:01,030 --> 00:35:08,920
And since applewebdata live file is handled especially
by WebKit, it was allowed to get this database.

441
442
00:35:08,920 --> 00:35:11,160
And it could, potentially upload it to the web.

442
443
00:35:11,160 --> 00:35:16,510
In order to fix this we need to
do something about the origin.

443
444
00:35:16,510 --> 00:35:23,250
[ Pause ]

444
445
00:35:23,250 --> 00:35:31,040
>> So we're using this API loadHTMLString passing in the
feed contents, and then we pass and analyze the base URL.

445
446
00:35:31,040 --> 00:35:40,790
What we want to do is to pass in the URL of the original
feed, and that's available as this property on the document.

446
447
00:35:40,790 --> 00:35:44,510
So now, if we try this exploit again.

447
448
00:35:44,510 --> 00:35:49,210
[ Pause ]

448
449
00:35:49,210 --> 00:35:58,010
>> The origin is now an http: URL, and it was no longer
able to access the user database, which is what we want.

449
450
00:35:58,010 --> 00:36:03,270
The fourth attack I want to talk
about now is against enclosures.

450
451
00:36:03,270 --> 00:36:10,480
So I'm sure you've seen this feature in Safari
where it tags files with the download source.

451
452
00:36:10,480 --> 00:36:19,360
So when I downloaded this file in Safari, this is a shell
script, and when I start it, the user gets this warning.

452
453
00:36:19,360 --> 00:36:23,490
So if he wasn't expecting a shell
script, maybe an image or something,

453
454
00:36:23,490 --> 00:36:28,390
then he is alerted to that something, something is strange.

454
455
00:36:28,390 --> 00:36:32,210
Let's see if we get the same support from Naivete.

455
456
00:36:32,210 --> 00:36:33,510
Downloading closure

456
457
00:36:33,510 --> 00:36:40,060
[ Pause ]

457
458
00:36:40,060 --> 00:36:42,050
>> Running arbitrary code.

458
459
00:36:42,050 --> 00:36:42,730
>> Yeah, so--

459
460
00:36:42,730 --> 00:36:43,950
[ Laughter ]

460
461
00:36:43,950 --> 00:36:49,500
>> This shell script just ran without
warning the user at all.

461
462
00:36:49,500 --> 00:36:51,280
Fortunately, the face is very simple.

462
463
00:36:51,280 --> 00:36:56,510
You just go into the info.plist
and check the file quarantine flag.

463
464
00:36:56,510 --> 00:37:14,090
[ Pause ]

464
465
00:37:14,090 --> 00:37:15,270
>> So, there is the warning.

465
466
00:37:15,270 --> 00:37:18,690
If every bug was this easy to fix, we'd all be out of work.

466
467
00:37:18,690 --> 00:37:19,200
[ Laughter ]

467
468
00:37:19,200 --> 00:37:26,510
>> So let's go back to the slides
and look at the Score Card.

468
469
00:37:26,510 --> 00:37:30,540
Well, we had a fail for the Cross-Site Scripting initially.

469
470
00:37:30,540 --> 00:37:37,320
Local URLs, both of the applewebdata variety
and the file variety, were mishandled,

470
471
00:37:37,320 --> 00:37:42,070
and it didn't provide adequate protections against Trojans.

471
472
00:37:42,070 --> 00:37:49,600
File URLs are special, both to
the WebView and to NSWorkspace.

472
473
00:37:49,600 --> 00:37:55,380
And the lesson of this is partially to be
aware of that fact, but to read the document--

473
474
00:37:55,380 --> 00:38:03,400
API documentation of every API you are using and
understand the security consequences of the documentation.

474
475
00:38:03,400 --> 00:38:10,300
And finally, if your application downloads
files, you should be using file quarantine.

475
476
00:38:10,300 --> 00:38:19,150
And the simple info.plist fix provides most of the
security benefits, and it's very easy to turn on.

476
477
00:38:19,150 --> 00:38:24,640
But if you want to provide the user with even
more information, such as the source of the file,

477
478
00:38:24,640 --> 00:38:29,190
then you can use the Launch Services API on the slide.

478
479
00:38:29,190 --> 00:38:31,750
Next talk-- let's talk about file formats.

479
480
00:38:31,750 --> 00:38:37,810
You can consider file formats and documents from two levels.

480
481
00:38:37,810 --> 00:38:43,590
First, there's the semantic content, which is the
information that you want to encode in your document.

481
482
00:38:43,590 --> 00:38:51,080
And then there's the serialization format, which describes
how this semantic contents match the bytes on disk.

482
483
00:38:51,080 --> 00:38:55,100
So what signifies a secure serialization format?

483
484
00:38:55,100 --> 00:39:03,620
First of all, we want it to be simple and predictable
because security issues tend to thrive in complexity.

484
485
00:39:03,620 --> 00:39:08,750
We want the attack surface to be small,
and that means that we don't want--

485
486
00:39:08,750 --> 00:39:15,110
we want as few lines of code to be running basically,
because there will be fewer lines to have bugs in them.

486
487
00:39:15,110 --> 00:39:21,250
And we want to be sure that the format
parser was written to expect malicious input,

487
488
00:39:21,250 --> 00:39:27,040
or potentially malicious input, and
do the appropriate input audition.

488
489
00:39:27,040 --> 00:39:30,950
Now, I want to look at the format path that Naivete uses.

489
490
00:39:30,950 --> 00:39:37,750
So we already saved this features file, and I
happen to know that this is a property list.

490
491
00:39:37,750 --> 00:39:42,920
So we can view it in the Property List Editor.

491
492
00:39:42,920 --> 00:39:48,290
This first line is a cue-- is a clue to
what format the application is using.

492
493
00:39:48,290 --> 00:39:54,600
It's says NSKeyedArchiver, and that means that
it's a Cocoa Archive using NSKeyedArchiving.

493
494
00:39:54,600 --> 00:40:04,300
Keyed archiving is a relatively complicated format
that can encode an arbitrary graph of objects.

494
495
00:40:04,300 --> 00:40:06,040
It's very easy to use.

495
496
00:40:06,040 --> 00:40:09,170
You just pass it the root object that you want to encode.

496
497
00:40:09,170 --> 00:40:18,820
But it has some curious properties that makes it
unsuitable for use as a general purpose document format.

497
498
00:40:18,820 --> 00:40:28,170
For example, here, we see the NSURL string, and you might
wonder, "What happens if I change this to some other class?"

498
499
00:40:28,170 --> 00:40:35,700
Let's use something that the application will not expect.

499
500
00:40:35,700 --> 00:40:42,630
So this means that any object that implements
initWithCoder, the NS coding protocol,

500
501
00:40:42,630 --> 00:40:48,970
will be exposed to potentially
malicious data coming from your document.

501
502
00:40:48,970 --> 00:41:03,080
And we can see what happens if we open up this document
that I prepared that replaces the URL with a button.

502
503
00:41:03,080 --> 00:41:08,190
In this case, we just got some warnings
about an unrecognized selective being sent

503
504
00:41:08,190 --> 00:41:10,720
to the object, because the code was expecting an NSURL.

504
505
00:41:10,720 --> 00:41:13,130
It found an NSButton.

505
506
00:41:13,130 --> 00:41:23,220
This can be-- get worse, and I'm just experienced
log message a document that doesn't load.

506
507
00:41:23,220 --> 00:41:29,180
And I won't show you the details on how
this works, but this document managed

507
508
00:41:29,180 --> 00:41:35,090
to start an application that could have run any code.

508
509
00:41:35,090 --> 00:41:41,930
So the fix we want to apply in this case,
is to replace the serialization format.

509
510
00:41:41,930 --> 00:41:45,220
And it started out looking pretty good.

510
511
00:41:45,220 --> 00:41:46,520
This was a Property List.

511
512
00:41:46,520 --> 00:41:49,610
And Property Lists are fine to use for untrusted input.

512
513
00:41:49,610 --> 00:41:53,760
The problem was that it was a keyed archive.

513
514
00:41:53,760 --> 00:41:59,510
So we will replace this document
serialization code and loading code with--

514
515
00:41:59,510 --> 00:42:05,070
[ Pause ]

515
516
00:42:05,070 --> 00:42:10,510
>> With some code that uses just
a plain property list instead.

516
517
00:42:10,510 --> 00:42:22,050
[ Pause ]

517
518
00:42:22,050 --> 00:42:33,540
>> So if we open this up in Property List
Editor, we'll see a much simpler hierarchy here,

518
519
00:42:33,540 --> 00:42:37,090
encoding just the information that we wanted to contain.

519
520
00:42:37,090 --> 00:42:43,210
And there are no class names to replace, for example.

520
521
00:42:44,930 --> 00:42:52,520
So for the document serialization, it was another X because
it allowed arbitrary code execution from a document.

521
522
00:42:54,400 --> 00:42:59,980
So, some of the formats that are safe to use, if
you use them correctly, are XML Property List,

522
523
00:42:59,980 --> 00:43:04,510
Binary Property Lists, and spotless serialization basically.

523
524
00:43:04,510 --> 00:43:09,900
There is NSXML which is made to deal with untrusted XML,

524
525
00:43:09,900 --> 00:43:14,250
and Core Data is also appropriate as
a general purpose document format.

525
526
00:43:14,250 --> 00:43:18,500
So you should use these for your
document formats, your natural protocols,

526
527
00:43:18,500 --> 00:43:23,190
and other cases when you share
data across privileged boundaries.

527
528
00:43:23,190 --> 00:43:29,130
There are some things you shouldn't use, and we've
already talked about the NSArchiver and NSKeyedArchiver.

528
529
00:43:29,130 --> 00:43:36,240
And if you're using this class, it's way overdue
to be replaced because it was deprecated in 10.2.

529
530
00:43:36,240 --> 00:43:42,610
These APIs, with the exception on NSSerialization, might
still be appropriate to use in your internal storage,

530
531
00:43:42,610 --> 00:43:49,130
like preference files, or if you're doing something
similar to Interface Builder with frozen code,

531
532
00:43:49,130 --> 00:43:52,700
or if you have an IPC connection where you're passing--

532
533
00:43:52,700 --> 00:44:00,440
serializing data to pass across a connection
where there's no real trust boundary.

533
534
00:44:00,440 --> 00:44:05,770
Now, let's move on to the code
part of the development cycle.

534
535
00:44:05,770 --> 00:44:11,090
And connect cleanups in here.

535
536
00:44:13,170 --> 00:44:28,220
So first, we'll use the Build and Analyze menu item to see
if the static analyzer will catch any bugs for free for us.

536
537
00:44:30,210 --> 00:44:34,720
So we got one warning and one static analyzer warning.

537
538
00:44:34,720 --> 00:44:37,420
Let's start with the warning.

538
539
00:44:37,420 --> 00:44:47,140
In this case, we're calling NSLog in
the handler for the naivete: URL format.

539
540
00:44:47,140 --> 00:44:53,420
And we're taking the URL and passing
it as the first argument to NSLog.

540
541
00:44:53,420 --> 00:44:55,710
NSLog takes a format string.

541
542
00:44:55,710 --> 00:45:04,820
And format strings are some of the oldest
and most obnoxious security bugs out there.

542
543
00:45:04,820 --> 00:45:09,870
In C, they are usually exploited using the %n specifier.

543
544
00:45:09,870 --> 00:45:12,530
Cocoa does not support %n.

544
545
00:45:12,530 --> 00:45:19,290
But what it does support is the
%at operator which sends a message.

545
546
00:45:19,290 --> 00:45:25,510
So first, I'll show an example of how this bug can trigger.

546
547
00:45:25,510 --> 00:45:36,140
[ Pause ]

547
548
00:45:36,140 --> 00:45:38,710
>> Actually, I will show you that later on a different bug.

548
549
00:45:38,710 --> 00:45:45,170
The problem with sending messages
to an object off of the stack

549
550
00:45:45,170 --> 00:45:50,250
when we are not passing any object
beyond the first parameter here,

550
551
00:45:50,250 --> 00:45:57,410
so it will just take some random value off the stacks,
send as message, and when Objective-C message send picks

551
552
00:45:57,410 --> 00:46:04,660
up that pointer, it does a series of pointer references,
and finally arrives at the IMP which is a function pointer.

552
553
00:46:04,660 --> 00:46:13,630
And if the attacker is able to control any of these pointers
along that path that Objective-C message send traverses,

553
554
00:46:13,630 --> 00:46:19,230
then he might be able to point execution
to his code, which would obviously be bad.

554
555
00:46:19,230 --> 00:46:21,750
The fix is very simple.

555
556
00:46:21,750 --> 00:46:29,180
We just use a static string as format specifier and
pass the document-- the object that we want to print.

556
557
00:46:29,180 --> 00:46:30,740
That is the second one.

557
558
00:46:30,740 --> 00:46:36,830
Or in this case, it is just debug codes so we can remove it.

558
559
00:46:36,830 --> 00:46:39,370
Remove your debug code before shipping.

559
560
00:46:39,370 --> 00:46:50,680
The other warning we need to-- run the analyzer again.

560
561
00:46:50,680 --> 00:46:54,060
Here's the analyzer warning.

561
562
00:46:54,060 --> 00:46:57,150
We get an error on the return line here.

562
563
00:46:57,150 --> 00:47:03,710
It says that an object had order release sent too
many times, and of course, this is a stupid bug.

563
564
00:47:03,710 --> 00:47:09,840
I called order release on an object
that was returned already, or released.

564
565
00:47:09,840 --> 00:47:11,630
Fix is very simple.

565
566
00:47:11,630 --> 00:47:19,290
As Matt mentioned, the static analyzer will catch a
lot, but it definitely would not catch everything.

566
567
00:47:19,290 --> 00:47:24,340
Actually, there is another format
string vulnerability on this line,

567
568
00:47:24,340 --> 00:47:28,330
and that is what I wanted to show you a minute ago.

568
569
00:47:28,330 --> 00:47:37,710
When I load this format string URL, it contains some %x
specifiers that's translated into random data off the sack

569
570
00:47:37,710 --> 00:47:41,100
in this very dialog when we are using NSAlert.

570
571
00:47:41,100 --> 00:47:50,900
And as an example, when that causes a potential security
vulnerability, if we are using this %at specifier, yep,

571
572
00:47:50,900 --> 00:47:56,400
we got a crash, and the debugger has broken.

572
573
00:47:56,400 --> 00:47:58,810
That's bad.

573
574
00:47:58,810 --> 00:48:01,310
The fix though is as simple.

574
575
00:48:01,310 --> 00:48:06,190
Just like that.

575
576
00:48:06,190 --> 00:48:12,630
The order release case was a reference counting mistake.

576
577
00:48:12,630 --> 00:48:16,620
And reference counting mistakes can become pretty hairy.

577
578
00:48:16,620 --> 00:48:28,850
And one example of that is when I'm using NSURLConnection
in this document, I set the document as the delegates.

578
579
00:48:28,850 --> 00:48:35,950
And as you will know, if you have read NSURLConnections
documentation, the connection retains its delegate.

579
580
00:48:35,950 --> 00:48:45,840
So even if the user closes the document, the object--
if the URLConnection finishes or causes an error,

580
581
00:48:45,840 --> 00:48:50,890
the object will still be around to get that message.

581
582
00:48:50,890 --> 00:48:52,670
So we should be OK.

582
583
00:48:52,670 --> 00:49:02,680
So let's see what happens if we try to connect
to a fake web server here that will just hang.

583
584
00:49:02,680 --> 00:49:05,510
We have the spinner here showing
that something is happening.

584
585
00:49:05,510 --> 00:49:14,100
The user gets impatient, closes the
window, and then this connection closes.

585
586
00:49:14,100 --> 00:49:16,170
Ah,we crashed.

586
587
00:49:16,170 --> 00:49:16,950
Why did we crash?

587
588
00:49:16,950 --> 00:49:19,500
The document is still around.

588
589
00:49:19,500 --> 00:49:25,530
And indeed, the document did get the
message about the connection failing.

589
590
00:49:25,530 --> 00:49:31,630
The problem is that when the window was closed,
the-- any IBOutlets to that window got invalid,

590
591
00:49:31,630 --> 00:49:40,120
because the IBOutlets are typically-- unless you have
retained them specifically-- they're weak references.

591
592
00:49:40,120 --> 00:49:46,460
So when we're sending a message to this
release progress indicator, we get a bug.

592
593
00:49:46,460 --> 00:49:51,930
And again, if the attacker is able to fill
the address space with malicious data,

593
594
00:49:51,930 --> 00:49:54,290
he might be able to highjack execution here.

594
595
00:49:54,290 --> 00:50:00,200
The solution in this case is too complicated
to show in a demo, but it involves making sure

595
596
00:50:00,200 --> 00:50:08,660
that the connection gets canceled before
any referenced objects get released.

596
597
00:50:08,660 --> 00:50:13,180
And as I mentioned, this code is all up
on the [inaudible] site of sample code.

597
598
00:50:13,180 --> 00:50:17,260
So, there are some vulnerabilities
that I won't be able to show you today

598
599
00:50:17,260 --> 00:50:26,880
but if you're curious, you can
look at them in the sample code.

599
600
00:50:26,880 --> 00:50:33,380
So, format strings and reference counting, another X there.

600
601
00:50:33,380 --> 00:50:36,980
Static analyzing your code is a great aid.

601
602
00:50:36,980 --> 00:50:40,120
It will find some bugs but it definitely
won't catch everything.

602
603
00:50:40,120 --> 00:50:45,250
So you need to stay vigilant and
make sure that you code correctly.

603
604
00:50:45,250 --> 00:50:48,330
Be careful with format strings.

604
605
00:50:48,330 --> 00:50:52,910
It's very easy to-- whenever you don't
pass a static string as a format string,

605
606
00:50:52,910 --> 00:50:56,460
it's likely that there might be a vulnerability there.

606
607
00:50:56,460 --> 00:51:04,980
And the complier will give you warnings in most cases but
not all format string methods and functions are annotated.

607
608
00:51:04,980 --> 00:51:08,290
And reference counting and weak references are hard.

608
609
00:51:08,290 --> 00:51:14,060
It's easy to get mixed up, especially
around the edge cases like in this case

609
610
00:51:14,060 --> 00:51:19,210
when the download hang and the user close the document.

610
611
00:51:19,210 --> 00:51:22,270
Using Garbage Collection on the Mac might help.

611
612
00:51:22,270 --> 00:51:29,300
On the other hand, it might introduce other
edge cases and it's not available on the phone.

612
613
00:51:29,300 --> 00:51:33,760
Next apply-- let's play some fuzzing
techniques that Matt talked about.

613
614
00:51:33,760 --> 00:51:41,150
It's a very simple and effective technique
and I wrote a fuzzer for a general--

614
615
00:51:41,150 --> 00:51:46,190
in generic fuzzer for binary and XML
property list in less than an hour.

615
616
00:51:46,190 --> 00:51:50,100
It's about a hundred lines of code really simple Python.

616
617
00:51:50,100 --> 00:51:56,830
It enumerates a plist and at each element, it
does the number of permutations to it to try

617
618
00:51:56,830 --> 00:52:03,990
to confuse the application that
will later be reading on the file.

618
619
00:52:03,990 --> 00:52:12,660
And I won't be doing that now but you can run it
with CrashWrangler in order to find duplicate crashes

619
620
00:52:12,660 --> 00:52:16,970
or to determine whether they are
likely to be exploitable or not.

620
621
00:52:16,970 --> 00:52:24,520
So, I'll just quickly run this fuzzer against
one of our documents that we've created.

621
622
00:52:26,810 --> 00:52:30,660
This is also available at sample code for this session.

622
623
00:52:30,660 --> 00:52:36,330
And it's easy to run.

623
624
00:52:36,330 --> 00:52:44,200
So now you'll see that it created 20 files here that
are all subtle variations of the original document.

624
625
00:52:44,200 --> 00:52:51,510
And when I open them up, you'll see some perhaps
unexpected behavior from-- we're still crashed.

625
626
00:52:51,510 --> 00:53:01,010
[ Pause ]

626
627
00:53:01,010 --> 00:53:01,730
[ Laughter ]

627
628
00:53:01,730 --> 00:53:08,070
>> Yeah, so some of these were not expected

628
629
00:53:08,070 --> 00:53:15,830
and I think there are some log messages
emitted about in other selectors being invoked.

629
630
00:53:15,830 --> 00:53:24,470
So there are other vulnerabilities in this
code and they're all listed in the sample code.

630
631
00:53:24,470 --> 00:53:31,630
Fuzzing, spending an hour fuzzing this application would
have eliminated a number of security vulnerabilities.

631
632
00:53:32,820 --> 00:53:36,990
So, fuzzing is important and should
be part of your testing strategy

632
633
00:53:36,990 --> 00:53:40,390
and use multiple fuzzers because
they excel at different things.

633
634
00:53:40,390 --> 00:53:51,650
This one just generated a lot of valid XML, valid
properties XML but you will want to try some binary fuzzers

634
635
00:53:51,650 --> 00:54:00,330
and you want to try a fuzzer that focuses on boundary
values and maybe one that just does random permutations.

635
636
00:54:00,330 --> 00:54:06,040
And if you are developing a protocol,
then you might have a fuzzer that does--

636
637
00:54:06,040 --> 00:54:14,320
that has a deep understanding of the protocol and another
one that just does dumb manipulation of the traffic.

637
638
00:54:14,320 --> 00:54:21,270
You shouldn't only rely on fuzzing, of course. You should
also be writing unit tests and focus on the edge cases.

638
639
00:54:21,270 --> 00:54:27,560
Not the ones that the user will most often hit
but the ones that an attacker will focus on.

639
640
00:54:27,560 --> 00:54:32,850
Penetration testing, which is pretty much
what we started this part of the talk doing.

640
641
00:54:32,850 --> 00:54:38,310
Trying some different attacks and seeing
how the application responds to them.

641
642
00:54:38,310 --> 00:54:42,750
Even if you think you've mitigated the
vulnerability it doesn't hurt to verify it.

642
643
00:54:42,750 --> 00:54:49,350
So, in summary you should think about security
throughout the entire development process from design

643
644
00:54:49,350 --> 00:54:53,520
to code, to testing, and then post release.

644
645
00:54:53,520 --> 00:54:58,020
Be aware of the security properties of the API CUs.

645
646
00:54:58,020 --> 00:55:07,160
Read the Secure Coding Guide with the API DOCs, talk
to others and have a deep understanding of the APIs.

646
647
00:55:07,160 --> 00:55:11,590
Understand the attacks that affect your application space.

647
648
00:55:11,590 --> 00:55:18,430
So, in this case we were dealing with a feed reader
and the bugs we were looking at had a lot to do

648
649
00:55:18,430 --> 00:55:23,440
with cross-site scripting, URLs, input validation.

649
650
00:55:23,440 --> 00:55:25,940
Your application will be different.

650
651
00:55:25,940 --> 00:55:29,290
It might be running on different devices.

651
652
00:55:29,290 --> 00:55:36,890
It might be in a completely different problem space and
it's up to you to have a deep understanding of that space.

652
653
00:55:36,890 --> 00:55:42,530
And take advantage of the hardening
techniques and security APIs like key chained

653
654
00:55:42,530 --> 00:55:47,870
and content protection on the phone because why not?

654
655
00:55:47,870 --> 00:55:52,090
It might save your users from being exploited.

655
656
00:55:52,090 --> 00:55:56,580
What are some simple steps that you can go out and do today?

656
657
00:55:56,580 --> 00:55:59,470
First of all, you can visit the Dev Forum Security sections.

657
658
00:55:59,470 --> 00:56:04,230
There's a lot of helpful people there
that will answers your questions.

658
659
00:56:04,230 --> 00:56:13,160
Read the Secure Coding Guide if you haven't already
and run the static analyzer against your application.

659
660
00:56:13,160 --> 00:56:16,300
You might find one bug, you might find 20.

660
661
00:56:16,300 --> 00:56:19,470
It's definitely worth the time investment.

661
662
00:56:19,470 --> 00:56:21,850
And finally fuzz your application.

662
663
00:56:21,850 --> 00:56:28,400
Use one of the commercially available fuzzers or
write your own, it doesn't take a lot of work.

663
664
00:56:28,400 --> 00:56:35,310
And that will put you on the path to giving
your application a clean security score card.

664
665
00:56:35,310 --> 00:56:40,660
Here are some other sessions that
might be interesting to you for launchd

665
666
00:56:40,660 --> 00:56:46,820
or if you're writing network applications
specifically for iOS.

666
667
00:56:46,820 --> 00:56:53,450
And there's the iPhone securing your application
data session which might be interesting to you.

667
668
00:56:53,450 --> 00:56:53,760
Thank you.

668
669
00:56:53,760 --> 00:57:05,730
[ Applause ]

669
