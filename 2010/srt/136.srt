1
00:00:07,040 --> 00:00:07,710
>> Ed Voas: Well, good afternoon.

1
2
00:00:07,710 --> 00:00:13,180
And welcome to Session 136, Calendar
Integration With EventKit.

2
3
00:00:13,180 --> 00:00:17,870
I'm Ed Voas, and I work on Calendar for iOS.

3
4
00:00:17,870 --> 00:00:23,700
So, in this session, you're going to learn about EventKit,
what it is, and how you can use it in your applications.

4
5
00:00:23,700 --> 00:00:26,220
So, first, what is it?

5
6
00:00:26,220 --> 00:00:33,380
Well, first and foremost, it's a high level API and allows
you to get access to the calendar data on the device.

6
7
00:00:33,380 --> 00:00:37,040
It's split into two parts, mostly as
a function of the way we built our OS.

7
8
00:00:37,040 --> 00:00:39,260
But we have a non-UI side and a UI side.

8
9
00:00:39,260 --> 00:00:45,030
So, in EventKit, we have all of the APIs that allow you
to get at the calendar data itself, you know, calendars,

9
10
00:00:45,030 --> 00:00:52,530
events, etc. And, in the UI side, we offer a couple of view
controllers which you can use to display and edit events.

10
11
00:00:52,530 --> 00:00:54,470
It's not a low-level syncing API, though.

11
12
00:00:54,470 --> 00:00:56,180
It's very high level.

12
13
00:00:56,180 --> 00:01:02,970
But for anything that you modify in one of our, you know,
calendars, if you happen to modify an event that's in, like,

13
14
00:01:02,970 --> 00:01:06,400
an Exchange calendar or CalDAV calendar,
syncing will just happen automatically.

14
15
00:01:06,400 --> 00:01:09,100
You don't need to think about it at all.

15
16
00:01:09,100 --> 00:01:12,710
One thing I want to call up is
that, you know, it isn't your data.

16
17
00:01:12,710 --> 00:01:14,620
It's really the user's data.

17
18
00:01:14,620 --> 00:01:18,920
So if you're going to modify the calendar
in some way, make it painfully obvious

18
19
00:01:18,920 --> 00:01:22,280
to the user that that's what you're doing.

19
20
00:01:22,280 --> 00:01:26,070
So I want to show a brief picture
of the way this is put together.

20
21
00:01:26,070 --> 00:01:30,910
So, ultimately, we have a calendar database; and that
lives off in a protected area of the file system.

21
22
00:01:30,910 --> 00:01:33,230
So it's sandboxed off from your application.

22
23
00:01:33,230 --> 00:01:35,800
So how do we talk to it?

23
24
00:01:35,800 --> 00:01:40,700
Well, through EventKit, what we do is we
actually talk to a daemon called iCalX SD.

24
25
00:01:40,700 --> 00:01:43,350
And that's the thing that actually talks to the database.

25
26
00:01:43,350 --> 00:01:49,100
iCalX SD and the sync daemons are pretty much the only
things that are allowed to talk to the database directly.

26
27
00:01:49,100 --> 00:01:53,530
So let's start delving into some APIs.

27
28
00:01:53,530 --> 00:01:59,830
So here's just an object diagram showing
all the major players that we have here.

28
29
00:01:59,830 --> 00:02:03,070
EKRecurrenceDayOfWeek on the bottom
there, I'm not going to talk about.

29
30
00:02:03,070 --> 00:02:05,850
But I'm just showing it here because
it's one of our classes.

30
31
00:02:05,850 --> 00:02:08,980
So the first one I want to talk about is EKEventStore.

31
32
00:02:08,980 --> 00:02:11,450
This is basically where it all starts.

32
33
00:02:11,450 --> 00:02:13,240
It's your connection to the database.

33
34
00:02:13,240 --> 00:02:17,530
When you instantiate one of these objects,
you are effectively opening the database.

34
35
00:02:17,530 --> 00:02:24,240
And, just like the slide a couple slides
ago, because we're talking to a daemon,

35
36
00:02:24,240 --> 00:02:27,460
it will actually spin the daemon up on demand, if necessary.

36
37
00:02:27,460 --> 00:02:29,450
Most of the time, it's probably running.

37
38
00:02:29,450 --> 00:02:32,840
But just be aware it's not exactly a lightweight operation.

38
39
00:02:32,840 --> 00:02:36,920
So, generally, you want to have these
objects around for as long as you can.

39
40
00:02:36,920 --> 00:02:44,560
The other factor in this is that, when you get objects
out of this EKEventStore, they're tied to this EventStore.

40
41
00:02:44,560 --> 00:02:48,240
So if you close it, if you release it
and then you try to open it back up again

41
42
00:02:48,240 --> 00:02:51,380
and save an event, for example, you won't be able to do it.

42
43
00:02:51,380 --> 00:02:55,590
They're tied to the EventStore from which they came.

43
44
00:02:55,590 --> 00:02:58,850
And to get one alloc init and you have an EventStore.

44
45
00:02:58,850 --> 00:03:02,930
Hooray. So now we'll look at Calendar.

45
46
00:03:02,930 --> 00:03:05,310
So, EKCalendar.

46
47
00:03:05,310 --> 00:03:12,120
So, obviously, we support multiple calendar
types on iOS: Exchange, CalDAV, MobileMe,

47
48
00:03:12,120 --> 00:03:16,560
etc. Again, sync is automatic for these types.

48
49
00:03:16,560 --> 00:03:19,840
We support read-only versus read/write calendars.

49
50
00:03:19,840 --> 00:03:22,140
So most calendars are read/write.

50
51
00:03:22,140 --> 00:03:25,730
You can add events to them and
change the events that are in them.

51
52
00:03:25,730 --> 00:03:30,200
But we also have read-only calendars; and those
would be such things as Subscribe calendars

52
53
00:03:30,200 --> 00:03:35,310
or the Birthday calendar, which is a new calendar in iOS 4.

53
54
00:03:35,310 --> 00:03:39,020
One thing that I want to point out is you
can't create new calendars in this release.

54
55
00:03:39,020 --> 00:03:43,590
It's definitely a limitation, but just be aware of it.

55
56
00:03:43,590 --> 00:03:45,600
We also have the notion of a default calendar.

56
57
00:03:45,600 --> 00:03:49,030
And it usually sets this in settings, as you can see here.

57
58
00:03:49,030 --> 00:03:52,020
If they have more than one calendar, they
can set which calendar is the default.

58
59
00:03:52,020 --> 00:03:55,870
And when you're in, like, the Calendar
application and you add a new event,

59
60
00:03:55,870 --> 00:03:57,640
this is the calendar that it's automatically set to.

60
61
00:03:57,640 --> 00:04:00,230
And you have access to this calendar.

61
62
00:04:00,230 --> 00:04:03,490
So, to get a calendar, it's really simple.

62
63
00:04:03,490 --> 00:04:07,750
First off, you just create an instance of
EKEventStore at some point in your application.

63
64
00:04:07,750 --> 00:04:10,370
Using that EventStore, you just call store.calendars.

64
65
00:04:10,370 --> 00:04:13,060
And now you have an array of calendars.

65
66
00:04:13,060 --> 00:04:19,370
Or, if you want the default calendar that I just
talked about, you can call defaultCalendarForNewEvents.

66
67
00:04:19,370 --> 00:04:23,880
Once you have your calendar, you can get
information from it: title, color, type.

67
68
00:04:23,880 --> 00:04:28,540
Type would be something such as Exchange or CalDAV.

68
69
00:04:28,540 --> 00:04:34,940
And, then, if you to want find out if it's read-only,
you can query the allowsContentModifications property.

69
70
00:04:34,940 --> 00:04:37,510
And if that returns yes, it's writable.

70
71
00:04:37,510 --> 00:04:42,420
[ Pause ]

71
72
00:04:42,420 --> 00:04:47,420
Okay. Now let's start talking about
EKEvent, which is the core of most of this.

72
73
00:04:47,420 --> 00:04:50,420
An instance of EKEvent represents an occurrence of an event.

73
74
00:04:50,420 --> 00:04:55,190
So if you have an event that repeats
weekly, each one of those events

74
75
00:04:55,190 --> 00:04:58,550
that would occur is represented by an individual EKEvent.

75
76
00:04:58,550 --> 00:05:00,770
And, from there, you can get and set most of the properties

76
77
00:05:00,770 --> 00:05:04,490
that you're intimately familiar
with, probably from using the device.

77
78
00:05:04,490 --> 00:05:07,560
So, obviously, you have title, location, start and end date.

78
79
00:05:07,560 --> 00:05:09,010
You can set whether it's an all-day event.

79
80
00:05:09,010 --> 00:05:14,470
You can set how it repeats, alarms, calendar, availability.

80
81
00:05:14,470 --> 00:05:15,540
We also -- obviously, notes.

81
82
00:05:15,540 --> 00:05:17,140
You can't see it because it's scrolled off screen.

82
83
00:05:17,140 --> 00:05:18,870
But we also allow things like status.

83
84
00:05:18,870 --> 00:05:20,110
You can get the status of an event.

84
85
00:05:20,110 --> 00:05:24,770
You can find out if it's canceled.

85
86
00:05:24,770 --> 00:05:27,290
So creating events is dead simple.

86
87
00:05:27,290 --> 00:05:31,390
Obviously, we start with our EventStore again.

87
88
00:05:31,390 --> 00:05:33,860
We just call EKEvent eventWithEventStore.

88
89
00:05:33,860 --> 00:05:35,520
So now we've created a new event.

89
90
00:05:35,520 --> 00:05:37,660
It's bound to that EventStore.

90
91
00:05:37,660 --> 00:05:39,500
And then we set some data.

91
92
00:05:39,500 --> 00:05:42,030
So title, start date, end date, and calendar.

92
93
00:05:42,030 --> 00:05:46,090
And here I'm setting the calendar to
be the defaultCalendarForNewEvents.

93
94
00:05:46,090 --> 00:05:51,670
Now, startDate, endDate in Calendar are required.

94
95
00:05:51,670 --> 00:05:56,350
So if you're going to try to save one of
these events, you must fill these fields in.

95
96
00:05:56,350 --> 00:06:01,340
And, if you don't, it will actually give you an error; and
it will probably tell you exactly what you didn't fill in.

96
97
00:06:01,340 --> 00:06:07,670
And, to save the event, you call
EKEventStore saveEvent span error.

97
98
00:06:07,670 --> 00:06:11,660
The span, whenever you're saving a new event,
really doesn't matter what you pass there.

98
99
00:06:11,660 --> 00:06:13,740
But it does matter when you modify and remove events.

99
100
00:06:13,740 --> 00:06:15,830
And we're going to see how it affects things later on.

100
101
00:06:15,830 --> 00:06:25,120
Every event in the database is-- has a unique identifier.

101
102
00:06:25,120 --> 00:06:26,740
So it's unique across the entire database.

102
103
00:06:26,740 --> 00:06:32,620
It's only valid if the event has
actually been saved into the EventStore.

103
104
00:06:32,620 --> 00:06:34,780
But they can change.

104
105
00:06:34,780 --> 00:06:38,970
If you happen to move an event
across calendars, specifically,

105
106
00:06:38,970 --> 00:06:42,050
it's across accounts, but we don't
expose accounts right now.

106
107
00:06:42,050 --> 00:06:48,020
But if it moves calendars, you might want to refetch the
ID to make sure that you have the latest ID for that item.

107
108
00:06:48,020 --> 00:06:51,270
Now, of course, it goes into the calendar,
anybody could have changed that, any other app.

108
109
00:06:51,270 --> 00:06:54,420
So maybe the user saw it in calendar
and did something with it.

109
110
00:06:54,420 --> 00:07:02,170
In that case, you might not have -- you might not be able
to find that event anymore, because now it's been changed.

110
111
00:07:02,170 --> 00:07:05,060
And, if that's the case, you might
want to resort to sort of a backup plan

111
112
00:07:05,060 --> 00:07:09,140
and just save off some identifying information
about the event and search for it later.

112
113
00:07:09,140 --> 00:07:15,240
And to get the eventIdentifier, it's just .eventIdentifier.

113
114
00:07:15,240 --> 00:07:17,980
We're clever that way.

114
115
00:07:17,980 --> 00:07:22,630
Deleting events, pretty much just as easy as saving events.

115
116
00:07:22,630 --> 00:07:24,090
So we have our EventStore.

116
117
00:07:24,090 --> 00:07:27,880
And, then, here we're actually going to look the
event up by its identifier that we just talked about.

117
118
00:07:27,880 --> 00:07:32,930
So EKEventStore eventWithIdentifier,
pass the identifier, get an event.

118
119
00:07:32,930 --> 00:07:34,440
Fair trade.

119
120
00:07:34,440 --> 00:07:38,510
And then you just call removeEvent span error.

120
121
00:07:38,510 --> 00:07:42,440
And, again, the span is meaningful
mostly for repeating events.

121
122
00:07:42,440 --> 00:07:46,040
But, for single events, you can just kind of pass anything.

122
123
00:07:46,040 --> 00:07:52,260
This event is usually the most common thing to pass.

123
124
00:07:52,260 --> 00:07:55,680
Okay. Every event can have an alarm.

124
125
00:07:55,680 --> 00:08:01,550
The alarms are generally relative to the start
date, and you specify them in negative seconds.

125
126
00:08:01,550 --> 00:08:04,980
They always display the standard calendar alert right now.

126
127
00:08:04,980 --> 00:08:06,600
So enjoy it.

127
128
00:08:06,600 --> 00:08:13,930
One thing to note is that different calendars can have
different limits to the number of alarms that they can have.

128
129
00:08:13,930 --> 00:08:18,570
For example, a CalDAV calendar can
have pretty much infinite alarms.

129
130
00:08:18,570 --> 00:08:21,780
And an Exchange calendar, we only have one alarm.

130
131
00:08:21,780 --> 00:08:26,830
And our UI enforces this, but we don't currently
have a way to expose that through our API right now.

131
132
00:08:26,830 --> 00:08:31,380
So it's best to assume that there's just one
that you can set, at least for the duration.

132
133
00:08:31,380 --> 00:08:37,070
Sometimes there's confusion between
alarms and UILocalNotifications.

133
134
00:08:37,070 --> 00:08:41,730
Like when EventKit was first kind of
introduced to developers, people thought, Oh,

134
135
00:08:41,730 --> 00:08:46,160
I can use that to put up an alert and, you
know, then I can call my application later.

135
136
00:08:46,160 --> 00:08:48,000
And that's not what it's used for.

136
137
00:08:48,000 --> 00:08:51,830
I mean, if you're going to -- if you're
going to make an alarm, you're going to --

137
138
00:08:51,830 --> 00:08:53,240
first off, you're going to have to make an event.

138
139
00:08:53,240 --> 00:08:54,710
That event's going to be in the calendar.

139
140
00:08:54,710 --> 00:08:56,020
You're just going to see that.

140
141
00:08:56,020 --> 00:08:57,520
They could delete that.

141
142
00:08:57,520 --> 00:09:02,500
And, then, when you press the Action button
on that alert that comes up, it's going to go

142
143
00:09:02,500 --> 00:09:06,000
and show you the event, which is probably not what you want.

143
144
00:09:06,000 --> 00:09:09,220
If you want something more general, you
should be using UILocalNotifications.

144
145
00:09:09,220 --> 00:09:12,190
And they don't involve the calendar, and
the Action button will just call your app.

145
146
00:09:12,190 --> 00:09:18,450
So, if it doesn't belong in the calendar,
you shouldn't be using EventKit for it.

146
147
00:09:18,450 --> 00:09:20,440
To add an alarm, it's pretty simple.

147
148
00:09:20,440 --> 00:09:24,400
To create one, you just say EKAlarm alarmWithRelativeOffset.

148
149
00:09:24,400 --> 00:09:29,930
-900 in this case means 15 minutes
before the start of the meeting.

149
150
00:09:29,930 --> 00:09:31,880
Call EKEvent addAlarm.

150
151
00:09:31,880 --> 00:09:37,110
And, then, again, our favorite saveEvent span error.

151
152
00:09:40,730 --> 00:09:42,640
Okay. Now we're going to touch on participants.

152
153
00:09:42,640 --> 00:09:48,430
A participant is basically either the
organizer or an invitee of an event.

153
154
00:09:48,430 --> 00:09:50,890
With these objects, you can check
to see what their status is.

154
155
00:09:50,890 --> 00:09:53,910
You can see whether they've accepted the
meeting, whether they've declined it,

155
156
00:09:53,910 --> 00:09:56,370
or maybe they've just marked it tentative.

156
157
00:09:56,370 --> 00:10:00,120
But not all servers tell us the
information, so you might get unknown.

157
158
00:10:00,120 --> 00:10:06,180
So, if you have an event that's on Exchange 2003
or 2007, you won't be able to get that data.

158
159
00:10:06,180 --> 00:10:09,520
If it's 2010 or later or if it's
on CalDAV, you will get that data.

159
160
00:10:09,520 --> 00:10:13,770
So just be aware that sometimes
you might not always get the data.

160
161
00:10:13,770 --> 00:10:16,150
Once you have the participant, you
can get an Address Book record.

161
162
00:10:16,150 --> 00:10:19,050
And we do that by email lookup.

162
163
00:10:19,050 --> 00:10:21,100
So it's kind of a loose coupling.

163
164
00:10:21,100 --> 00:10:22,300
It's not really very tight.

164
165
00:10:22,300 --> 00:10:25,740
So it does a pretty decent job, though.

165
166
00:10:25,740 --> 00:10:28,870
And they're read-only in this release.

166
167
00:10:28,870 --> 00:10:35,080
So you can't modify a participant nor
can you set participants on an event.

167
168
00:10:35,080 --> 00:10:38,040
And the implication there is it
means to, at least programmatically,

168
169
00:10:38,040 --> 00:10:41,830
you can't create invites in this 1.0 release of the API.

169
170
00:10:41,830 --> 00:10:42,770
You can through the UI.

170
171
00:10:42,770 --> 00:10:45,420
If you use our UI, it does support invite creation.

171
172
00:10:45,420 --> 00:10:50,190
But, right now, we don't have the APIs available to you.

172
173
00:10:50,190 --> 00:10:54,700
And to get at these things, it's just
event.organizer, event.attendees.

173
174
00:10:54,700 --> 00:10:56,890
Simple. All right.

174
175
00:10:56,890 --> 00:11:02,190
So now we've kind of covered the basic
-- the basic concept of everything.

175
176
00:11:02,190 --> 00:11:06,250
So, you know, now you want to see what can we do with
the APIs that we've already seen in a real application.

176
177
00:11:06,250 --> 00:11:07,840
And with me to help do that is Glen Steele.

177
178
00:11:07,840 --> 00:11:08,510
Glen.

178
179
00:11:08,510 --> 00:11:13,250
[ Applause ]

179
180
00:11:13,250 --> 00:11:14,130
>> Glen Steele: Thanks, Ed.

180
181
00:11:14,130 --> 00:11:18,750
So, so far you've seen most of the basic APIs that
are available to you as developers in EventKit.

181
182
00:11:18,750 --> 00:11:21,110
But, of course, we want to flesh
those out in some examples for you.

182
183
00:11:21,110 --> 00:11:23,320
So we're going to show you a demo.

183
184
00:11:23,320 --> 00:11:28,010
And, for the purpose of this demo, I'd like you
to imagine for a moment that you're a loan shark.

184
185
00:11:28,010 --> 00:11:31,720
And, for the parents among you,
there's no imagination necessary.

185
186
00:11:31,720 --> 00:11:35,110
But, for our purposes, just think
of yourself as a loan shark.

186
187
00:11:35,110 --> 00:11:39,790
And you're no fool, so you want to keep track of these
loans that you hand out to people pretty closely.

187
188
00:11:39,790 --> 00:11:42,880
So the good news is that there's an
app for that, and we can help you.

188
189
00:11:42,880 --> 00:11:43,930
And it's called Sharkster.

189
190
00:11:43,930 --> 00:11:46,050
So I'm going to show it to you now.

190
191
00:11:46,050 --> 00:11:47,230
Okay. So I'll just launch it.

191
192
00:11:47,230 --> 00:11:49,980
And this is a table-driven application.

192
193
00:11:49,980 --> 00:11:54,060
And it's created using -- it's backed by Core Data.

193
194
00:11:54,060 --> 00:11:55,640
And it's pretty simple.

194
195
00:11:55,640 --> 00:12:00,500
We can just tap on any one of our loans
here to see the details of the loan.

195
196
00:12:00,500 --> 00:12:02,590
We get the contact of the person, the amount.

196
197
00:12:02,590 --> 00:12:05,980
And we can drill down a little bit
further and see the payment schedule

197
198
00:12:05,980 --> 00:12:11,200
and how much each payment it is --
each payment is and when it's due.

198
199
00:12:11,200 --> 00:12:15,190
So we can back out here and hit the plus
button if we want to create a new one.

199
200
00:12:15,190 --> 00:12:17,630
And we can choose a contact if we want.

200
201
00:12:17,630 --> 00:12:22,160
And then choose the amount and, you know,
some -- whatever interest rate we want.

201
202
00:12:22,160 --> 00:12:27,920
And then we can pick the payment schedule, you know,
whether it's daily, weekly, monthly, what have you.

202
203
00:12:27,920 --> 00:12:28,950
And then save that.

203
204
00:12:28,950 --> 00:12:35,140
And, then, to delete, it's just a simple, you know, swipe --
whoops -- swipe to delete paradigm or edit or what have you.

204
205
00:12:35,140 --> 00:12:38,020
So that's the basics of the app.

205
206
00:12:38,020 --> 00:12:42,510
And so now I'd just like to show you a little
bit about the Xcode project that makes this up.

206
207
00:12:42,510 --> 00:12:47,090
[ Pause ]

207
208
00:12:47,090 --> 00:12:48,300
Okay. So here we are in Xcode.

208
209
00:12:48,300 --> 00:12:50,460
And I'll just show you a few things.

209
210
00:12:50,460 --> 00:12:53,920
The first thing is, in the resources
here, let's take a look at the data model.

210
211
00:12:53,920 --> 00:12:57,640
As I said, this is a Core Data driven application.

211
212
00:12:57,640 --> 00:12:59,800
So we just take a look.

212
213
00:12:59,800 --> 00:13:04,590
What I want you to see here is just basically
we're dealing with loans and payments.

213
214
00:13:04,590 --> 00:13:11,790
And we have NSManagedObject subclasses that
deal with these and we pass these around.

214
215
00:13:11,790 --> 00:13:14,620
So the loans have a one-to-many
relationship with the payments.

215
216
00:13:14,620 --> 00:13:18,370
And so, if you see, these are what we're moving around.

216
217
00:13:18,370 --> 00:13:24,670
And, then, in our supporting classes folder here,
this is just basically what makes up the structure

217
218
00:13:24,670 --> 00:13:32,470
of the application, the table views and the
cells and etc. And, then, in EventKit stuff,

218
219
00:13:32,470 --> 00:13:34,480
we have this thing called a Loan Event Scheduler.

219
220
00:13:34,480 --> 00:13:40,240
And so this represents the funnel point for
us for all our interactions with EventKit.

220
221
00:13:40,240 --> 00:13:43,810
And this kind of thing may or may not
make sense for you in your application.

221
222
00:13:43,810 --> 00:13:49,700
But, for us, it's a nice way to just sort of coalesce
all our EventKit interactions into one place.

222
223
00:13:49,700 --> 00:13:50,850
All right.

223
224
00:13:50,850 --> 00:13:54,750
So what are we going to do with EventKit
to make our app a little bit better?

224
225
00:13:54,750 --> 00:14:01,550
Well, the obvious thing is, in our payments, we'd like to
be able to schedule each one of those into the calendar.

225
226
00:14:01,550 --> 00:14:06,640
And so the place to do that is when the user taps Save,
that's when we go and create those payment objects.

226
227
00:14:06,640 --> 00:14:09,200
And we'd like to actually put those
into the calendar as they do that.

227
228
00:14:09,200 --> 00:14:17,320
So saving happens in our Loan View
Controller in the aptly named save method.

228
229
00:14:17,320 --> 00:14:19,190
And this thing is pretty simple right now.

229
230
00:14:19,190 --> 00:14:23,400
All it does is call this generate payments helper method.

230
231
00:14:23,400 --> 00:14:30,790
And that thing goes out and creates the individual Core Data
payment objects and calculates the date on which each one

231
232
00:14:30,790 --> 00:14:38,240
of those is going to land and then -- and puts those into
the database and relates them back to our loan object.

232
233
00:14:38,240 --> 00:14:43,140
And, then, once we finish doing that, we just
call the delegate, which basically has the effect

233
234
00:14:43,140 --> 00:14:46,310
of dismissing us and calling a save on the database.

234
235
00:14:46,310 --> 00:14:46,590
All right.

235
236
00:14:46,590 --> 00:14:49,730
So how are we going to modify this thing to add scheduling?

236
237
00:14:49,730 --> 00:14:53,660
Well, let's go ahead and implement a new save method.

237
238
00:14:53,660 --> 00:14:57,570
And this is it here, and I just
left the old one up for comparison.

238
239
00:14:57,570 --> 00:15:00,240
So we're still going to generate those payments.

239
240
00:15:00,240 --> 00:15:03,950
But, before we do that, we're going to
create one of our loan event schedulers.

240
241
00:15:03,950 --> 00:15:09,810
Once we do that, we'll call schedule all events
for payments and pass in the ordered payments.

241
242
00:15:09,810 --> 00:15:16,480
And the job of this thing is to go in and basically create
all the EKEvents for each one of those individual payments.

242
243
00:15:16,480 --> 00:15:21,820
Then it's just a matter of releasing -- releasing
that and then we still call the delegate.

243
244
00:15:21,820 --> 00:15:26,390
So I'm going to delete that old method and save this.

244
245
00:15:26,390 --> 00:15:30,880
And, then, now we're going to go ahead and
delete this new method in our event scheduler.

245
246
00:15:30,880 --> 00:15:31,990
All right.

246
247
00:15:31,990 --> 00:15:34,680
So let's declare that.

247
248
00:15:34,680 --> 00:15:38,420
And I'm going to create an instance
variable called EventStore.

248
249
00:15:38,420 --> 00:15:40,270
So this is our EKEventStore.

249
250
00:15:40,270 --> 00:15:44,740
And as Ed mentioned, this represents
our connection to the calendar database.

250
251
00:15:44,740 --> 00:15:50,840
So now that we've done that, let's
go and initialize this thing.

251
252
00:15:50,840 --> 00:15:57,220
And, then, don't forget to release it.

252
253
00:15:57,220 --> 00:16:00,950
And now we've got all our setup out
of the way, we can actually go ahead

253
254
00:16:00,950 --> 00:16:02,620
and implement this new method that we have.

254
255
00:16:02,620 --> 00:16:05,590
So, as I said, it's called schedule all events for payments.

255
256
00:16:05,590 --> 00:16:07,770
It takes an array of payments.

256
257
00:16:07,770 --> 00:16:11,510
And what we're going to do is just
iterate through each one of those.

257
258
00:16:11,510 --> 00:16:14,560
And, as we do that, we're going to create a new EKEvent.

258
259
00:16:14,560 --> 00:16:19,180
So we do that with EKEvent, eventWithEventStore.

259
260
00:16:19,180 --> 00:16:23,280
And then we set the properties on that new event.

260
261
00:16:23,280 --> 00:16:28,350
Now, as Ed mentioned, the required ones are
the calendar, the start date, and the end date.

261
262
00:16:28,350 --> 00:16:30,510
So we make sure we set those.

262
263
00:16:30,510 --> 00:16:35,610
And we're just going to use the default calendar for
new events, which is that property on the EventStore.

263
264
00:16:35,610 --> 00:16:39,390
And that's the default calendar
that the user sets in Settings

264
265
00:16:39,390 --> 00:16:43,180
or is just provided automatically
if they only have one calendar.

265
266
00:16:43,180 --> 00:16:46,360
So, once we've done that, we can set the title.

266
267
00:16:46,360 --> 00:16:50,530
And we've just got a helper method
that returns the string for the title

267
268
00:16:50,530 --> 00:16:55,180
and includes basically the contact
name and the amount for that payment.

268
269
00:16:55,180 --> 00:16:57,620
And that's it for setting those properties.

269
270
00:16:57,620 --> 00:17:02,570
But what we'd also like to do is set an alarm so
that, you know, when we wake up in the morning,

270
271
00:17:02,570 --> 00:17:08,150
we get all the alarms for the people who owe us money and
we can, you know, send a muscle to go and extract them.

271
272
00:17:08,150 --> 00:17:12,300
And we're going to do that with just a relative
offset of 0; because we want those to fire,

272
273
00:17:12,300 --> 00:17:16,850
you know, right away first thing in the morning.

273
274
00:17:16,850 --> 00:17:22,630
Okay. So now that we've set our new alarm,
we can call saveEvent and providing a span --

274
275
00:17:22,630 --> 00:17:28,030
and, as Ed said, we'll go into those a little
more later -- and a pointer to an error.

275
276
00:17:28,030 --> 00:17:31,610
And we check the return Boolean.

276
277
00:17:31,610 --> 00:17:38,280
And if it didn't save and there's an error, in our case,
we're just going to print out that error description.

277
278
00:17:38,280 --> 00:17:40,420
You may need to do more in your app.

278
279
00:17:40,420 --> 00:17:44,300
And, then, the last thing we need to
do is save aside that eventIdentifier.

279
280
00:17:44,300 --> 00:17:47,630
So now that we've created our new
event, we want to reference that later.

280
281
00:17:47,630 --> 00:17:54,280
So we're going to take the eventIdentifier that
we created and put that into our payment object.

281
282
00:17:54,280 --> 00:17:54,890
Okay, great.

282
283
00:17:54,890 --> 00:17:57,770
So now we're creating new EKEvents.

283
284
00:17:57,770 --> 00:17:59,410
We're storing them in the calendar.

284
285
00:17:59,410 --> 00:18:02,520
But there's one thing we're missing
and that's deletion, right?

285
286
00:18:02,520 --> 00:18:05,700
So deletion happens on that root view controller.

286
287
00:18:05,700 --> 00:18:13,720
And, specifically, it happens here in the commit
editing style for row and index path method.

287
288
00:18:13,720 --> 00:18:18,950
So this project was created from, you know, one
of our Xcode templates, and it's already populated

288
289
00:18:18,950 --> 00:18:25,310
with basically everything that's needed
to remove those loans from our database.

289
290
00:18:25,310 --> 00:18:28,730
But we want to add just one more thing
here and that's to delete all the payments

290
291
00:18:28,730 --> 00:18:31,730
that are associated with that loan in the calendar.

291
292
00:18:31,730 --> 00:18:35,360
So, to do that, we're going to
create a new loan event scheduler

292
293
00:18:35,360 --> 00:18:41,170
and then call a new method called delete all events
for payments and pass in those ordered payments.

293
294
00:18:41,170 --> 00:18:41,480
All right.

294
295
00:18:41,480 --> 00:18:42,800
So we're done here.

295
296
00:18:42,800 --> 00:18:46,120
Let's go and declare that new method.

296
297
00:18:47,500 --> 00:18:52,660
And let's implement it.

297
298
00:18:52,660 --> 00:18:54,670
Okay. So, again, this is pretty simple.

298
299
00:18:54,670 --> 00:18:58,510
We're going to iterate in a four loop
through each one of those payments,

299
300
00:18:58,510 --> 00:19:03,360
get our pointer to the EKEvent using
EventStore, eventWithIdentifier.

300
301
00:19:03,360 --> 00:19:07,360
Remember we saved this aside when
we created our event before.

301
302
00:19:07,360 --> 00:19:11,550
And then it's just a matter of
calling EventStore removeEvent,

302
303
00:19:11,550 --> 00:19:15,680
and we're just using that EKSpanThisEvent
span for the moment.

303
304
00:19:15,680 --> 00:19:23,180
And same thing, pass in an error, check the result,
and print out or log any issues that might come up.

304
305
00:19:23,180 --> 00:19:23,650
Okay, great.

305
306
00:19:23,650 --> 00:19:25,810
So it looks like we're done.

306
307
00:19:25,810 --> 00:19:26,280
And, phew.

307
308
00:19:26,280 --> 00:19:26,940
It builds.

308
309
00:19:26,940 --> 00:19:28,140
That's good.

309
310
00:19:28,140 --> 00:19:31,820
And we're going to build that and
send it over to the device.

310
311
00:19:31,820 --> 00:19:37,720
So what we'd expect to happen now is, when we create a
new event, we should see that pop up in our loan table.

311
312
00:19:37,720 --> 00:19:43,420
Should be able to look at that and then flip over to
the calendar and those new events should show up for us.

312
313
00:19:43,420 --> 00:19:46,240
Let's see if it works.

313
314
00:19:46,240 --> 00:19:49,910
So let's create one for Claire.

314
315
00:19:49,910 --> 00:19:56,080
We'll do 5,000 and some exorbitant interest rate.

315
316
00:19:56,080 --> 00:19:57,600
[ Laughter ]

316
317
00:19:57,600 --> 00:19:58,530
I know. Ouch, right?

317
318
00:19:58,530 --> 00:20:09,800
We're just going to choose a loan length of three days,
and we'll just do the three payments, 2,000 apiece.

318
319
00:20:09,800 --> 00:20:10,680
So we saved it.

319
320
00:20:10,680 --> 00:20:13,350
Here's our new loan.

320
321
00:20:13,350 --> 00:20:15,020
And pops up here.

321
322
00:20:15,020 --> 00:20:16,670
We can see the loan payment schedule.

322
323
00:20:16,670 --> 00:20:18,550
Looks like it's going to show up tomorrow.

323
324
00:20:18,550 --> 00:20:21,830
But, of course, the real question
is: Did it show up in the calendar?

324
325
00:20:21,830 --> 00:20:24,560
So let's flip over the calendar and, hey, presto.

325
326
00:20:24,560 --> 00:20:25,820
There it is.

326
327
00:20:25,820 --> 00:20:31,040
So our payment shows up there and it looks good to go.

327
328
00:20:31,040 --> 00:20:35,280
And we can see on each payment we created that alert,

328
329
00:20:35,280 --> 00:20:39,370
and it shows that we're going to get
an alert on the day of the event.

329
330
00:20:39,370 --> 00:20:40,720
Okay. Good stuff.

330
331
00:20:40,720 --> 00:20:42,510
So now --

331
332
00:20:42,510 --> 00:20:46,480
[ Applause ]

332
333
00:20:46,480 --> 00:20:49,130
-- Now we're going to try and delete
that, and let's see if this works.

333
334
00:20:49,130 --> 00:20:52,580
So we'll delete that and flip back to the calendar.

334
335
00:20:52,580 --> 00:20:57,890
And after that snapshot loads, we see
those events have now disappeared.

335
336
00:20:57,890 --> 00:21:00,350
Okay, great.

336
337
00:21:01,720 --> 00:21:05,650
So that's adding and deleting simple events using EventKit.

337
338
00:21:05,650 --> 00:21:11,370
And, to do that, to insert an event, we just
create a new EKEvent using EKEventStore.

338
339
00:21:11,370 --> 00:21:17,600
Set the properties on those events on the
event and then we save using EKEvent saveEvent.

339
340
00:21:17,600 --> 00:21:19,850
Now, to delete, it's pretty simple too.

340
341
00:21:19,850 --> 00:21:25,830
We can fetch the event using the eventIdentifier that we
saved aside and then just remove using EKEvent removeEvent.

341
342
00:21:25,830 --> 00:21:27,420
So that the adding and removing.

342
343
00:21:27,420 --> 00:21:28,510
Back to you, Ed.

343
344
00:21:28,510 --> 00:21:32,040
[ Applause ]

344
345
00:21:32,040 --> 00:21:34,870
>> Ed Voas: Thanks, Glen.

345
346
00:21:34,870 --> 00:21:36,850
Okay. Now we've seen easy events.

346
347
00:21:36,850 --> 00:21:37,740
Let's get a little harder.

347
348
00:21:37,740 --> 00:21:40,370
We're going to talk about recurrence rules.

348
349
00:21:40,370 --> 00:21:43,690
So recurrence rules ultimately
tell you how an event repeats.

349
350
00:21:43,690 --> 00:21:47,790
And, you know, our UI, as you can see here,
does really simple rules every day, every week,

350
351
00:21:47,790 --> 00:21:53,400
etc. But the API will allow you to do far more
complex things, such as the examples here.

351
352
00:21:53,400 --> 00:21:57,410
So we're going to just do a simple one.

352
353
00:21:57,410 --> 00:22:00,100
We actually have two init functions on recurrence rule.

353
354
00:22:00,100 --> 00:22:03,000
We have a simple one and then we
have, like, the mind-blowing one.

354
355
00:22:03,000 --> 00:22:05,850
So we're going to go with the simple one for right now.

355
356
00:22:05,850 --> 00:22:08,150
So let's -- we want to create a
weekly meeting that never ends.

356
357
00:22:08,150 --> 00:22:09,370
[ Laughter ]

357
358
00:22:09,370 --> 00:22:16,240
So we use EKRecurrenceRule initWithRecurrenceFrequency
internal end.

358
359
00:22:16,240 --> 00:22:20,820
So, in this case, we're going to pass a recurrence
frequency of weekly and an interval of 1.

359
360
00:22:20,820 --> 00:22:21,420
So that's every week.

360
361
00:22:21,420 --> 00:22:25,630
If we passed an interval of 2, that's every
other week, etc., etc. And the end is nil.

361
362
00:22:25,630 --> 00:22:28,790
So no end in sight for this meeting, sorry to say.

362
363
00:22:28,790 --> 00:22:36,770
And we just set our recurrence rule; and,
again, our favorite, saveEvent, span and error.

363
364
00:22:36,770 --> 00:22:40,590
But, you know, sometimes you want this meeting to end maybe.

364
365
00:22:40,590 --> 00:22:42,090
So there's two ways to do that.

365
366
00:22:42,090 --> 00:22:47,490
The first is by creating -- well, in every case,
you always create an EKRecurrenceEnd object.

366
367
00:22:47,490 --> 00:22:50,500
But the two ways that you can do
that is the first one is by dates.

367
368
00:22:50,500 --> 00:22:55,270
You can call EKRecurrenceEnd, recurrenceEndWithEndDate,
pass the date.

368
369
00:22:55,270 --> 00:22:58,840
And, then, the second variance is a number of times.

369
370
00:22:58,840 --> 00:23:02,550
So you can say EKRecurrenceEnd
recurrenceEndWithOccurrenceCount.

370
371
00:23:02,550 --> 00:23:08,440
So, in this case, I want the meeting
to happen five times and that's it.

371
372
00:23:08,440 --> 00:23:11,290
And just like last time, call the same init method.

372
373
00:23:11,290 --> 00:23:16,100
But this time we're passing the end
object in for the end parameter.

373
374
00:23:16,100 --> 00:23:17,910
Fancy that way.

374
375
00:23:17,910 --> 00:23:25,860
And then we just set the rule and save the event.

375
376
00:23:25,860 --> 00:23:29,140
Okay. So we've kind of discussed how to get events in.

376
377
00:23:29,140 --> 00:23:30,050
How do we get events out?

377
378
00:23:30,050 --> 00:23:33,880
Well, we've already seen one way, and that's by ID.

378
379
00:23:33,880 --> 00:23:36,700
So I mentioned every event has an identifier.

379
380
00:23:36,700 --> 00:23:41,220
And you can use that by calling EKEventStore
eventWithIdentifier and get the event back.

380
381
00:23:41,220 --> 00:23:43,720
That will give you the very first occurrence of that event.

381
382
00:23:43,720 --> 00:23:48,350
So, if it was a repeating event, it will be
the very first, you know, occurrence of that.

382
383
00:23:48,350 --> 00:23:51,120
So, if it was somebody's birthday,
it's actually the day of their birth,

383
384
00:23:51,120 --> 00:23:53,900
not the anniversary of their birth many years later.

384
385
00:23:53,900 --> 00:24:00,050
But what you're probably going to use more
often than not is search for your predicate,

385
386
00:24:00,050 --> 00:24:02,460
especially if you want to show, you
know, something across a date range.

386
387
00:24:02,460 --> 00:24:06,890
So this -- we offer one predicate right now,
predicateForEventsWithStartDate, endDate, and calendars.

387
388
00:24:06,890 --> 00:24:11,930
So you can search across a date range
and across a number of calendars.

388
389
00:24:11,930 --> 00:24:14,520
And because it's the only predicate we have right now,

389
390
00:24:14,520 --> 00:24:19,500
if you want to do a more fine-grained search,
you will have to postfilter that list.

390
391
00:24:19,500 --> 00:24:23,460
So an example here is to just create one.

391
392
00:24:23,460 --> 00:24:27,670
You go EKEventStore predicateForEventsWithStartDate,
endDate, and calendars.

392
393
00:24:27,670 --> 00:24:29,570
And I'm just, you know, whatever
the start date and end date are.

393
394
00:24:29,570 --> 00:24:31,030
And then I'm passing store.calendars.

394
395
00:24:31,030 --> 00:24:34,760
So I want to search across all calendars.

395
396
00:24:34,760 --> 00:24:36,650
You then call eventsMatchingPredicate.

396
397
00:24:36,650 --> 00:24:41,890
That will go out, find the appropriate
events, and return them as an array.

397
398
00:24:41,890 --> 00:24:44,520
But that array has no guaranteed order.

398
399
00:24:44,520 --> 00:24:46,960
So now you probably want to sort it.

399
400
00:24:46,960 --> 00:24:52,350
Well, we have a convenience method for that
on EKEvent called compareStartDateWithEvent.

400
401
00:24:52,350 --> 00:24:55,260
So all you need to do is just make
a mutable copy of the array

401
402
00:24:55,260 --> 00:24:58,890
and then just call sortUsingSelector
passing compareStartDateWithEvent.

402
403
00:24:58,890 --> 00:25:01,320
And now everything's in start order -- in start date order,

403
404
00:25:01,320 --> 00:25:07,570
which is probably the most common
way that you'd want to sort them.

404
405
00:25:07,570 --> 00:25:11,260
Now, eventsWithPredicate is synchronous.

405
406
00:25:11,260 --> 00:25:16,580
It will block your app for as long as it takes to operate,
and it could take almost no time or it could take a lot

406
407
00:25:16,580 --> 00:25:20,640
of time, depending on what you're
searching for and how big your database is.

407
408
00:25:20,640 --> 00:25:24,020
So more often than not, you're going
to want to do this asynchronously.

408
409
00:25:24,020 --> 00:25:26,470
And we don't offer any specific asynchronous function.

409
410
00:25:26,470 --> 00:25:33,440
Instead, you know, we say, if you want asynchronous
behavior, you know, use an asynchronous mechanism

410
411
00:25:33,440 --> 00:25:37,930
such as NSOperation or my favorite, dispatch_async.

411
412
00:25:37,930 --> 00:25:40,030
So, if you're familiar with Grand Central Dispatch --

412
413
00:25:40,030 --> 00:25:46,370
I think there was a session on it yesterday
-- dispatch_async is my new best friend.

413
414
00:25:46,370 --> 00:25:50,710
So when you're doing -- I'm just going to
show you an example of using dispatch_async.

414
415
00:25:50,710 --> 00:25:56,950
So, whenever you want to start some
sort of task or whatever in Dispatch,

415
416
00:25:56,950 --> 00:26:00,090
all you need to do is get your
hands on a queue to run it on.

416
417
00:26:00,090 --> 00:26:03,730
So the first thing I'm going to do is
what's called dispatch_get_global_queue.

417
418
00:26:03,730 --> 00:26:06,870
I'm using the standard priority queue.

418
419
00:26:06,870 --> 00:26:09,420
Then I call dispatch_async, passing the queue.

419
420
00:26:09,420 --> 00:26:13,410
So you want to send a block of code over to this queue.

420
421
00:26:13,410 --> 00:26:14,220
And what does it do?

421
422
00:26:14,220 --> 00:26:15,750
Exactly what you already saw.

422
423
00:26:15,750 --> 00:26:19,710
We're just going to call EventStore eventsMatchingPredicate.

423
424
00:26:19,710 --> 00:26:24,430
Now, someplace over in the system
there's this thread that has this array.

424
425
00:26:24,430 --> 00:26:26,700
Now, how do we get them back to the main thread?

425
426
00:26:26,700 --> 00:26:28,430
Dispatch_async.

426
427
00:26:28,430 --> 00:26:30,530
And here we just pass get_main_queue instead.

427
428
00:26:30,530 --> 00:26:32,210
So we want to throw it back to the main thread.

428
429
00:26:32,210 --> 00:26:36,700
And we're going to call a method on
our object called setEvents:array.

429
430
00:26:36,700 --> 00:26:39,780
It's very simple.

430
431
00:26:39,780 --> 00:26:44,530
I mean, the last three lines could actually be replaced
with something like perform selector on main thread.

431
432
00:26:44,530 --> 00:26:47,670
But dispatch_async is far more flexible,
because it doesn't restrict you to the number

432
433
00:26:47,670 --> 00:26:50,510
of parameters that you can pass to that selector.

433
434
00:26:50,510 --> 00:26:55,050
[ Pause ]

434
435
00:26:55,050 --> 00:26:56,470
Okay. Modifying events.

435
436
00:26:56,470 --> 00:27:02,180
I mean, modifying events is basically you get an event; you
set the properties; you save it; and, well, you're done.

436
437
00:27:02,180 --> 00:27:04,390
Okay. And that's fine for simple events.

437
438
00:27:04,390 --> 00:27:09,710
But repeating events get a little complicated.

438
439
00:27:09,710 --> 00:27:13,470
When you -- this is where we talked
about the span parameter.

439
440
00:27:13,470 --> 00:27:16,810
When you modify a repeating event, the
span parameter then really matters.

440
441
00:27:16,810 --> 00:27:20,900
And you -- and we offer two of them:
SpanThisEvent, SpanFutureEvents.

441
442
00:27:20,900 --> 00:27:25,550
And they correspond to the two buttons that you
see there on that standard alert sheet that we put

442
443
00:27:25,550 --> 00:27:30,350
up whenever you do modify a repeating
event in the Calendar application.

443
444
00:27:30,350 --> 00:27:31,480
They behave very differently.

444
445
00:27:31,480 --> 00:27:35,390
And we're going to see an example of how they behave.

445
446
00:27:35,390 --> 00:27:36,440
They're very valid.

446
447
00:27:36,440 --> 00:27:38,770
I mean, both are equally valid
whenever you change something.

447
448
00:27:38,770 --> 00:27:45,030
However, if you change the recurrence information on an
event, then only the EKSpanFutureEvents span is valid

448
449
00:27:45,030 --> 00:27:50,090
because SpanThisEvent actually doesn't
make any sense in that context.

449
450
00:27:50,090 --> 00:27:52,890
So let's take the case of simple detachment.

450
451
00:27:52,890 --> 00:27:59,650
So if I -- if I save an event and I say SpanThisEvent,
that creates what's called a detached event.

451
452
00:27:59,650 --> 00:28:04,590
So let's say I want to take the event on August 5th
and move it from 11 a.m. to 2 p.m. So I do that.

452
453
00:28:04,590 --> 00:28:07,350
So what happens is we actually
go out and create a new event,

453
454
00:28:07,350 --> 00:28:11,970
but we tie it to the original series;
and it's considered part of the series.

454
455
00:28:11,970 --> 00:28:15,370
It's effectively a child of the original series.

455
456
00:28:15,370 --> 00:28:19,690
So now if I go back to July 1st
and I say DeleteFutureEvents,

456
457
00:28:19,690 --> 00:28:22,360
that event will actually go away, as well.

457
458
00:28:22,360 --> 00:28:28,000
In contrast, if you pass EKSpanFutureEvents
and I say, from August 5th on,

458
459
00:28:28,000 --> 00:28:33,010
meeting's at 2 p.m. What happens
is we actually get a new event.

459
460
00:28:33,010 --> 00:28:36,140
It's a completely separate entity
and has no relation to the original.

460
461
00:28:36,140 --> 00:28:42,680
So now if I go back to July 1st and say DeleteFuture,
only the events up through July 29th will get deleted.

461
462
00:28:42,680 --> 00:28:47,680
Everything from August 5th will stay.

462
463
00:28:47,680 --> 00:28:53,890
If I delete passing EKSpanThisEvent,
all we do is set an exception date.

463
464
00:28:53,890 --> 00:28:55,550
So August 5th, we're not having that meeting.

464
465
00:28:55,550 --> 00:28:56,570
Forget it.

465
466
00:28:56,570 --> 00:29:03,480
And now we just set an exception date and now we
know not to generate a recurrence on that date.

466
467
00:29:03,480 --> 00:29:05,470
DeleteFuture, it's very similar.

467
468
00:29:05,470 --> 00:29:09,980
So everything, you know, after
July 29th, we don't want; gone.

468
469
00:29:09,980 --> 00:29:13,750
And so we just modify the recurrence
rules to end on that date.

469
470
00:29:13,750 --> 00:29:19,020
So it's kind of important to kind of get a feel
for, like, what happens when you modify events.

470
471
00:29:19,020 --> 00:29:23,820
Because it does change things in
certain ways, especially since, like,

471
472
00:29:23,820 --> 00:29:29,090
the deletion behavior is a little
different, it's important to know.

472
473
00:29:29,090 --> 00:29:30,600
Okay. So we've talked about recurrences.

473
474
00:29:30,600 --> 00:29:33,890
So let's see if we can actually take advantage
of recurrences in our demo application.

474
475
00:29:33,890 --> 00:29:34,560
Glen.

475
476
00:29:34,560 --> 00:29:37,970
>> Glen Steele: So, so far we've been creating and
deleting simple events in our Sharkster application.

476
477
00:29:37,970 --> 00:29:41,820
It would be great if we could leverage some
of this recurrence stuff since, you know,

477
478
00:29:41,820 --> 00:29:45,450
loan payments typically happen,
you know, on a repeating basis.

478
479
00:29:45,450 --> 00:29:49,410
So this is where you want to think kind of
carefully about how you architect your application.

479
480
00:29:49,410 --> 00:29:54,950
And whether using recurrences makes sense
or whether it's better to use simple events,

480
481
00:29:54,950 --> 00:30:01,080
it's important to remember that, for single events, you
get an eventIdentifier for each one of those, right?

481
482
00:30:01,080 --> 00:30:06,580
So it's easy to reference those later if you need
to because you have an eventIdentifier that points

482
483
00:30:06,580 --> 00:30:10,290
to that specific occurrence; whereas, with recurrences,

483
484
00:30:10,290 --> 00:30:14,340
each recurrence of the original event
inherits the same eventIdentifier.

484
485
00:30:14,340 --> 00:30:18,420
So if you want to locate that later, it's a
little bit more difficult because you may have

485
486
00:30:18,420 --> 00:30:22,100
to perform a search using the eventIdentifier
around the specific date.

486
487
00:30:22,100 --> 00:30:24,640
And you've got to know where that
occurrence is going to land.

487
488
00:30:24,640 --> 00:30:26,780
So it's something you really want to think about,

488
489
00:30:26,780 --> 00:30:31,430
whether using recurrences makes sense
or using single events makes sense.

489
490
00:30:31,430 --> 00:30:33,080
We're going to try and use recurrences now, though.

490
491
00:30:33,080 --> 00:30:36,270
So I'll switch back to the Xcode project.

491
492
00:30:36,270 --> 00:30:40,530
And the first thing we're going
to do is update our save method.

492
493
00:30:40,530 --> 00:30:44,700
So here's the old one, and I'm
just going to start a new one here.

493
494
00:30:44,700 --> 00:30:50,600
So, in the prior version, we created our loan event
scheduler and then we called generate payments

494
495
00:30:50,600 --> 00:30:54,870
and then we went and scheduled the
events based on those payments.

495
496
00:30:54,870 --> 00:30:59,050
Well, we're going to change our thinking a little
bit, because we actually want EventKit to do the work

496
497
00:30:59,050 --> 00:31:03,280
of scheduling the dates for us so that we don't have to.

497
498
00:31:03,280 --> 00:31:08,460
In generate payments, we were using NSCalendar to go
and figure out what dates each event needed to fall on.

498
499
00:31:08,460 --> 00:31:10,540
Well, now we're going to have EventKit do the work for us.

499
500
00:31:10,540 --> 00:31:15,430
So, instead of generating the payments
first and then calling schedule events,

500
501
00:31:15,430 --> 00:31:20,170
we're going to call a new method called schedule
payment events using recurrence for loan.

501
502
00:31:20,170 --> 00:31:25,750
And we're going to expect that that returns
to us an array of scheduled EKEvents.

502
503
00:31:25,750 --> 00:31:35,480
And once we have that in hand, we can go ahead and
generate our payments based on each one of those.

503
504
00:31:35,480 --> 00:31:39,320
So the next thing we do is call generate
payments for events and pass in that array.

504
505
00:31:39,320 --> 00:31:43,810
And once we've done that, we have
to deal with a special case.

505
506
00:31:43,810 --> 00:31:47,720
And it's the case of that last loan
payment being slightly different.

506
507
00:31:47,720 --> 00:31:54,280
So if the loan amount doesn't divide evenly into
the number of payments, we may be in a situation

507
508
00:31:54,280 --> 00:31:58,750
where the very last payment is a slightly
different amount, right, to make up the difference.

508
509
00:31:58,750 --> 00:32:02,530
And so we have a convenience method
on our loan object that tells us

509
510
00:32:02,530 --> 00:32:05,500
if that last payment is going to
be slightly different amount.

510
511
00:32:05,500 --> 00:32:12,880
And, based on that, if that turns out to be true, we're
going to call a method called update event with payment.

511
512
00:32:12,880 --> 00:32:14,040
And this is very simple.

512
513
00:32:14,040 --> 00:32:16,310
All it does is take in one of our EKEvents.

513
514
00:32:16,310 --> 00:32:21,310
And it takes in a payment object, and it
basically puts in the new properties based on --

514
515
00:32:21,310 --> 00:32:24,670
or the new amount based on that payment, right?

515
516
00:32:24,670 --> 00:32:27,550
So it's essentially just going
to update the title of that event

516
517
00:32:27,550 --> 00:32:30,690
to reflect that, hey, this one's got a different amount.

517
518
00:32:30,690 --> 00:32:37,490
Well, let's get rid of that old save
method and go ahead and implement these.

518
519
00:32:37,490 --> 00:32:42,580
So first we need to declare the scheduled
payment events using recurrence for loan.

519
520
00:32:42,580 --> 00:32:44,230
That's a bit of a tongue twister.

520
521
00:32:44,230 --> 00:32:47,510
And then update event with payment.

521
522
00:32:47,510 --> 00:32:55,140
[ Pause ]

522
523
00:32:55,140 --> 00:32:59,420
Okay. So, as I said before, we're expecting
scheduled payment events using recurrence

523
524
00:32:59,420 --> 00:33:01,830
for loan to return an NSArray.

524
525
00:33:01,830 --> 00:33:04,920
So we're just going to declare that.

525
526
00:33:04,920 --> 00:33:08,260
Whoops. Okay.

526
527
00:33:08,260 --> 00:33:15,030
And once we do that, we're going to create our
first EKEvent using EKEvent, event with store.

527
528
00:33:15,030 --> 00:33:21,560
Set the properties, just as we did before;
set up that alarm, just as we did before.

528
529
00:33:21,560 --> 00:33:23,770
And here's where it starts to diverge a little bit.

529
530
00:33:23,770 --> 00:33:26,190
We're going to create a recurrence rule.

530
531
00:33:26,190 --> 00:33:30,090
And the way we do that is using EKRecurrenceRule.

531
532
00:33:30,090 --> 00:33:34,750
And EventKit defines recurrences using two parameters.

532
533
00:33:34,750 --> 00:33:37,600
It takes a frequency and an interval.

533
534
00:33:37,600 --> 00:33:41,740
And so, for instance if you had a
payment that was due on a biweekly basis,

534
535
00:33:41,740 --> 00:33:45,000
you'd have a frequency of weekly and an interval of two.

535
536
00:33:45,000 --> 00:33:48,040
But we don't present the UI to the user in that way, right?

536
537
00:33:48,040 --> 00:33:52,900
They can just choose, well, I want it every three days
or I want it every week or biweekly or what have you.

537
538
00:33:52,900 --> 00:33:59,720
So we just need some helper functions to translate our
concept of that in the UI to what EventKit expects.

538
539
00:33:59,720 --> 00:34:05,730
So, to do that, we've got these two helper methods,
EventKit frequency for loan and EventKit interval for loan.

539
540
00:34:05,730 --> 00:34:12,590
And I'll just show you really quickly, if the
user chooses a biweekly frequency for their loan,

540
541
00:34:12,590 --> 00:34:18,700
we return a frequency of weekly and an interval of two.

541
542
00:34:18,700 --> 00:34:21,590
And so these are just basically translation functions here.

542
543
00:34:21,590 --> 00:34:23,570
All right.

543
544
00:34:23,570 --> 00:34:28,410
So we've actually done all we need
to do to create a recurrence rule.

544
545
00:34:28,410 --> 00:34:31,240
But there's one thing that we need
to define, and that's the end.

545
546
00:34:31,240 --> 00:34:34,110
And we could have done that right
here in this last parameter.

546
547
00:34:34,110 --> 00:34:36,230
But I just broke it out just for clarity.

547
548
00:34:36,230 --> 00:34:39,220
So all we do is create an EKRecurrenceEnd.

548
549
00:34:39,220 --> 00:34:46,620
And our loan objects are able to calculate
what the end date is, so we just pass that in.

549
550
00:34:46,620 --> 00:34:50,180
Once we've done that, we set that on the recurrence rule.

550
551
00:34:50,180 --> 00:34:54,280
And then we've got a complete recurrence
rule that we can set on the EKEvent.

551
552
00:34:54,280 --> 00:34:57,110
Okay. So we're done setting up our EKEvent.

552
553
00:34:57,110 --> 00:35:01,270
And the next thing we need to do is just save it.

553
554
00:35:01,270 --> 00:35:07,760
So, just as before, we're going to save
our event using EventStore saveEvent.

554
555
00:35:07,760 --> 00:35:09,200
Check for any errors.

555
556
00:35:09,200 --> 00:35:17,800
And assuming that all goes well, now we just need
to -- let's just lay that out a little nicer --

556
557
00:35:17,800 --> 00:35:22,440
we're not quite done yet, because we've
got to return that array of events, right?

557
558
00:35:22,440 --> 00:35:29,220
So we've now scheduled this in the calendar, but we --
our caller is expecting an array of scheduled events back.

558
559
00:35:29,220 --> 00:35:30,230
And so how do we do that?

559
560
00:35:30,230 --> 00:35:31,870
Well, we've got to find them.

560
561
00:35:31,870 --> 00:35:35,440
So, to do that, we create an NSPredicate.

561
562
00:35:35,440 --> 00:35:40,920
And, as Ed mentioned, EventStore
has a prebaked predicate for us.

562
563
00:35:40,920 --> 00:35:47,790
So we just call predicate for events with start date, and
we provide the start date of the loan and the end date

563
564
00:35:47,790 --> 00:35:51,180
of the loan and the calendar that we want to search.

564
565
00:35:51,180 --> 00:35:57,400
So once we call EventStore eventsMatchingPredicate,
basically, what we're going to get is every event

565
566
00:35:57,400 --> 00:36:01,440
between the start date of the loan and the end
date of the loan, which is not what we want.

566
567
00:36:01,440 --> 00:36:02,310
So what do we need to do?

567
568
00:36:02,310 --> 00:36:04,490
We need to postfilter this array.

568
569
00:36:04,490 --> 00:36:09,850
So we created a mutable copy of it immediately
so we can just filter that in place.

569
570
00:36:09,850 --> 00:36:13,710
And, to do that, we create another predicate.

570
571
00:36:13,710 --> 00:36:20,050
And we're going to search based on the eventIdentifier
that we got given when we created that first event.

571
572
00:36:20,050 --> 00:36:24,390
So, remember, each recurrence of the event
has the same eventIdentifier as the first one.

572
573
00:36:24,390 --> 00:36:30,340
So if we can say, hey, our recurrence lands on this date and
it's got this identifier, we'll get the one that we want.

573
574
00:36:30,340 --> 00:36:33,120
That gives us an unsorted list.

574
575
00:36:33,120 --> 00:36:39,900
So now we need to call sortUsingSelector, and we have
that prebaked selector called compareStartDateWithEvent.

575
576
00:36:39,900 --> 00:36:43,430
And that will give us an ordered
list of our scheduled payments,

576
577
00:36:43,430 --> 00:36:47,190
which we can then use to generate
our payment objects in our database.

577
578
00:36:47,190 --> 00:36:55,680
Okay. So we're finished with that method, and now we
just have to implement this update event with payment.

578
579
00:36:55,680 --> 00:36:56,790
So this is very simple.

579
580
00:36:56,790 --> 00:36:59,510
I just pasted the whole thing in right away.

580
581
00:36:59,510 --> 00:37:05,190
Essentially, we're taking an EKEvent; we're taking in a
payment; we're figuring out what the new title needs to be;

581
582
00:37:05,190 --> 00:37:07,950
and we're setting the properties on the event.

582
583
00:37:07,950 --> 00:37:12,890
Once that's done, we just call EventStore
saveEvent and check for success.

583
584
00:37:12,890 --> 00:37:18,910
And now that we've detached this from our series, we're
going to get a slightly different eventIdentifier.

584
585
00:37:18,910 --> 00:37:22,690
So we're going to save that aside,
too, in our payment object.

585
586
00:37:22,690 --> 00:37:24,880
Okay. So this looks all good.

586
587
00:37:24,880 --> 00:37:31,940
So we're creating events with recurrences; we're
handling the case of that different last payment amount.

587
588
00:37:31,940 --> 00:37:35,250
But there's one thing left, and we've
got to handle deletion correctly.

588
589
00:37:35,250 --> 00:37:38,010
So we need to update our delete method a little bit.

589
590
00:37:38,010 --> 00:37:42,430
I'll leave the old one up there and paste in the new one.

590
591
00:37:42,430 --> 00:37:44,890
And this looks just a little bit different now.

591
592
00:37:44,890 --> 00:37:50,930
So, previously, we were iterating through each one
of our payment objects, grabbing the eventIdentifier

592
593
00:37:50,930 --> 00:37:54,970
and then removing each one of those
EKEvents based on that eventIdentifier.

593
594
00:37:54,970 --> 00:37:56,420
We don't need to do that anymore, right?

594
595
00:37:56,420 --> 00:37:59,570
We've got a single event that's
recurring, maybe another event --

595
596
00:37:59,570 --> 00:38:03,040
that's that last one -- so we just
need to take care of those.

596
597
00:38:03,040 --> 00:38:09,360
So, to do that, we're going to call
value for key on the payments array.

597
598
00:38:09,360 --> 00:38:15,150
So this has the effect of calling the event
ID method on every object in that array,

598
599
00:38:15,150 --> 00:38:18,800
and that will give us an array of all the event IDs, right?

599
600
00:38:18,800 --> 00:38:24,060
But the problem there is that we basically got
a list of the same event identifiers, right?

600
601
00:38:24,060 --> 00:38:26,350
So we need to unique those.

601
602
00:38:26,350 --> 00:38:29,080
And an easy way to do that is to make a set with the array,

602
603
00:38:29,080 --> 00:38:33,960
and that will have the effect of
uniquing all the event identifiers.

603
604
00:38:33,960 --> 00:38:39,850
Now, once we have that, we can loop through those
event identifiers, get the EKEvent using event

604
605
00:38:39,850 --> 00:38:43,650
with eventIdentifier, and then call remove.

605
606
00:38:43,650 --> 00:38:50,810
This time, we're using the EKSpanFutureEvents parameter
for the span argument so that we blow away all

606
607
00:38:50,810 --> 00:38:53,270
of the recurrences for future events, right?

607
608
00:38:53,270 --> 00:38:58,640
Now, it's worth noting here, actually,
there's a little caveat to this.

608
609
00:38:58,640 --> 00:39:03,440
And because, when we created this recurrence we used --

609
610
00:39:03,440 --> 00:39:08,600
when we updated that last event, we
used the EKSpanThisEvent parameter.

610
611
00:39:08,600 --> 00:39:13,830
When we detached that from our series,
it still remained a child of that series;

611
612
00:39:13,830 --> 00:39:16,740
because we didn't use the EKSpanFutureEvent parameter.

612
613
00:39:16,740 --> 00:39:22,980
So, actually, the first time through this loop,
we are effectively deleting the entire thing.

613
614
00:39:22,980 --> 00:39:28,930
So it's just worth noting that I'm leaving
the loop in place because, you know,

614
615
00:39:28,930 --> 00:39:36,140
in case we did decide to detach using EKSpanFutureEvents or
something, we want to just take care of blowing it all away.

615
616
00:39:36,140 --> 00:39:36,880
All right.

616
617
00:39:36,880 --> 00:39:42,160
So let's delete this old version, save this, builds.

617
618
00:39:42,160 --> 00:39:45,270
And let's build and send that over to the device.

618
619
00:39:45,270 --> 00:39:49,120
Okay. So now what we should expect to
happen is we can create new events.

619
620
00:39:49,120 --> 00:39:50,980
We should see them pop up in the calendar.

620
621
00:39:50,980 --> 00:39:55,700
And, if we examine each one of those, we'll be able
to see that they're actually a recurring event.

621
622
00:39:55,700 --> 00:39:58,410
And, then, hopefully, when we delete
them, they'll get taken away too.

622
623
00:39:58,410 --> 00:40:01,920
So I'll create a new loan here.

623
624
00:40:03,230 --> 00:40:03,900
All right.

624
625
00:40:03,900 --> 00:40:06,040
Let's choose Claire.

625
626
00:40:06,040 --> 00:40:11,810
And I'll just choose some random amount.

626
627
00:40:11,810 --> 00:40:18,730
And hopefully this will give us a payment schedule that
will give us a slightly different last payment, right?

627
628
00:40:18,730 --> 00:40:20,620
Because we just want to test that functionality.

628
629
00:40:20,620 --> 00:40:24,970
So this gives us two payments of 440.13 and one of 440.12.

629
630
00:40:24,970 --> 00:40:28,220
So that will go through that code
that updates that last payment for us.

630
631
00:40:28,220 --> 00:40:31,100
And, then, let's hit Save.

631
632
00:40:31,100 --> 00:40:32,220
All right.

632
633
00:40:32,220 --> 00:40:33,090
Take a look.

633
634
00:40:33,090 --> 00:40:35,620
And everything looks good here.

634
635
00:40:35,620 --> 00:40:40,930
Let's jump over to the calendar and see if they show up.

635
636
00:40:40,930 --> 00:40:42,520
And, indeed, they do.

636
637
00:40:42,520 --> 00:40:46,700
And if I hit the Edit button here, I'll
actually see that there's a repeat rule

637
638
00:40:46,700 --> 00:40:49,060
which shows us that the recurrence worked.

638
639
00:40:49,060 --> 00:40:54,200
And let's look at that very last payment.

639
640
00:40:54,200 --> 00:40:55,210
And we can see, yes.

640
641
00:40:55,210 --> 00:40:56,690
That is a slightly different amount.

641
642
00:40:56,690 --> 00:40:58,690
So that worked too.

642
643
00:40:58,690 --> 00:41:04,080
Now, let's jump back to Sharkster and try and delete this.

643
644
00:41:04,080 --> 00:41:07,360
So we hit Delete, move back to the calendar.

644
645
00:41:07,360 --> 00:41:08,160
And, hey, look at that.

645
646
00:41:08,160 --> 00:41:09,510
They all disappeared.

646
647
00:41:09,510 --> 00:41:16,050
[ Applause ]

647
648
00:41:16,050 --> 00:41:20,330
Okay. So that's creating and deleting
events using recurrences in EventKit.

648
649
00:41:20,330 --> 00:41:25,100
And so, to do that, you create the initial
event, set the properties on that event,

649
650
00:41:25,100 --> 00:41:29,000
set the recurrence rule, and then
save using EKEvent saveEvent.

650
651
00:41:29,000 --> 00:41:34,450
And, then, to delete, you want to get the event
using the eventIdentifier or a search predicate

651
652
00:41:34,450 --> 00:41:38,460
so you can do searching, and remove
using EKEvent removeEvent.

652
653
00:41:38,460 --> 00:41:42,900
But you've got to use that EKSpanFutureEvents
argument to blow the whole series away.

653
654
00:41:42,900 --> 00:41:44,270
All right, that's it.

654
655
00:41:44,270 --> 00:41:45,510
Thank, Ed.

655
656
00:41:45,510 --> 00:41:51,040
[ Applause ]

656
657
00:41:51,040 --> 00:41:52,890
>> Ed Voas: Thanks, Glen.

657
658
00:41:52,890 --> 00:41:57,170
So right now we've been operating in a vacuum
as if you're the only person on, you know,

658
659
00:41:57,170 --> 00:41:59,670
on the device who's modifying the calendar database.

659
660
00:41:59,670 --> 00:42:01,010
And you're not.

660
661
00:42:01,010 --> 00:42:04,880
So, when other people modify the
database, you need to be told.

661
662
00:42:04,880 --> 00:42:06,120
And you need to react.

662
663
00:42:06,120 --> 00:42:11,300
And we do that by sending you a notification
called EKEventStoreChangedNotification.

663
664
00:42:11,300 --> 00:42:14,930
Again, we're very original with our naming.

664
665
00:42:14,930 --> 00:42:16,580
It can happen at any time.

665
666
00:42:16,580 --> 00:42:21,230
And even though, like, calendar
might be suspended, sync is not.

666
667
00:42:21,230 --> 00:42:23,930
So if something happens and sync
decides that it needs to bring something

667
668
00:42:23,930 --> 00:42:26,140
down into the database, you need to be informed.

668
669
00:42:26,140 --> 00:42:27,870
You need to react to that.

669
670
00:42:27,870 --> 00:42:29,080
They're very coarse-grained, though.

670
671
00:42:29,080 --> 00:42:32,910
It barely tells you that something
happened but you have no idea what.

671
672
00:42:32,910 --> 00:42:34,650
Welcome to my world.

672
673
00:42:34,650 --> 00:42:36,680
And they're coalesced.

673
674
00:42:36,680 --> 00:42:42,710
So if you happen to be suspended and stuff changes out
behind your back, when you resume, you'll get the event.

674
675
00:42:42,710 --> 00:42:48,830
So when you receive it, what you should do is effectively
treat your EKEvent and EKCalendar things as invalid.

675
676
00:42:48,830 --> 00:42:51,580
So all the food in the fridge is
bad; throw it out and go shopping.

676
677
00:42:51,580 --> 00:42:53,810
So that's what you want to do.

677
678
00:42:53,810 --> 00:42:58,160
So -- but we also have a method called
EKEvent refresh which you can use.

678
679
00:42:58,160 --> 00:43:01,280
It returns a Boolean and tells you
whether the event is still valid or not.

679
680
00:43:01,280 --> 00:43:06,110
And, after the database is changed, if that
event had happened to have its data updated,

680
681
00:43:06,110 --> 00:43:12,460
it will repopulate the properties of that event with
the latest values, unless you've modified something.

681
682
00:43:12,460 --> 00:43:15,850
So, if you've modified title and
location, those will stay intact.

682
683
00:43:15,850 --> 00:43:18,530
But everything that you haven't modified will get reloaded.

683
684
00:43:18,530 --> 00:43:19,670
But it's kind of a pricey call.

684
685
00:43:19,670 --> 00:43:21,780
And you don't want to call it on
hundreds or thousands of event.

685
686
00:43:21,780 --> 00:43:23,150
It's just not worth it.

686
687
00:43:23,150 --> 00:43:27,160
So the rule of thumb that we use is,
generally, if you are actively viewing

687
688
00:43:27,160 --> 00:43:30,010
or editing an event, you call EKEvent refresh.

688
689
00:43:30,010 --> 00:43:34,280
And if you're not, just refetch your events.

689
690
00:43:34,280 --> 00:43:36,730
Okay. So that's all of the non-UI side of things.

690
691
00:43:36,730 --> 00:43:40,680
So let's look at the two view controllers
that we provide for you.

691
692
00:43:40,680 --> 00:43:41,740
The first is Detail View.

692
693
00:43:41,740 --> 00:43:44,120
You've seen it before.

693
694
00:43:44,120 --> 00:43:47,550
EKEventViewControllers, how it's exposed to you.

694
695
00:43:47,550 --> 00:43:49,470
It's the same view you've ever seen.

695
696
00:43:49,470 --> 00:43:54,220
It does everything that you've seen it do in Calendar.

696
697
00:43:54,220 --> 00:43:56,070
So you can respond to invites, the whole thing.

697
698
00:43:56,070 --> 00:43:59,160
It can allow editing, optionally.

698
699
00:43:59,160 --> 00:44:01,460
You have the Edit button up here.

699
700
00:44:01,460 --> 00:44:04,780
And it listens to those notifications
we just talked about for you.

700
701
00:44:04,780 --> 00:44:08,280
So, if the event changes, it will just refresh itself.

701
702
00:44:08,280 --> 00:44:12,220
If the event is deleted, it will pop
itself off of the navigation stack.

702
703
00:44:12,220 --> 00:44:15,990
To put one up, really easy.

703
704
00:44:15,990 --> 00:44:24,770
Just alloc and init, set the event, tell it whether you want
editing or not, and then call pushViewController animated.

704
705
00:44:24,770 --> 00:44:29,010
And now you have Detail View.

705
706
00:44:29,010 --> 00:44:31,580
Likewise, we supply you with the standard editor.

706
707
00:44:31,580 --> 00:44:34,460
And this, again, the exact same editor
that we use in the Calendar application.

707
708
00:44:34,460 --> 00:44:38,910
It's exposed through EKEventEditViewController.

708
709
00:44:38,910 --> 00:44:42,430
So you can edit existing events or it
can use this to create brand new events.

709
710
00:44:42,430 --> 00:44:48,330
To do that, you could just not pass us an event and we will
make one, or you can pass in a partially constructed event.

710
711
00:44:48,330 --> 00:44:49,880
So consider the case of data detectors.

711
712
00:44:49,880 --> 00:44:55,190
So you tap on a date in Mail, and it has some certain
fields that it wants to prepopulate the event with.

712
713
00:44:55,190 --> 00:45:01,190
It just fills that in and just invokes
this view controller with that information.

713
714
00:45:01,190 --> 00:45:04,590
If you don't pass us anything, we
will fill in defaults as needed.

714
715
00:45:04,590 --> 00:45:10,670
So we'll fill in a default date, start and end
time; and we'll also always use the default calendar

715
716
00:45:10,670 --> 00:45:14,530
for new events that we keep talking about.

716
717
00:45:14,530 --> 00:45:15,690
It also relies on a delegate.

717
718
00:45:15,690 --> 00:45:20,910
It will tell you when the user has canceled or
saved the event or whether the event was deleted.

718
719
00:45:20,910 --> 00:45:24,830
And deleted can come from two sources:
either the user actually deleted it,

719
720
00:45:24,830 --> 00:45:29,720
or we picked up one of those notifications we talked
about, determined that the event had been deleted,

720
721
00:45:29,720 --> 00:45:33,750
and we want to tell you it's gone now, please close me.

721
722
00:45:33,750 --> 00:45:36,530
We also allow you to override the
default calendar that we'll use.

722
723
00:45:36,530 --> 00:45:42,530
So you might just supply a calendar before you,
you know, pass it into this view controller.

723
724
00:45:42,530 --> 00:45:47,370
But let's say you did that and now sync
came along and decided, You know what?

724
725
00:45:47,370 --> 00:45:50,250
You went and deleted that calendar on
a different device, and it's gone now.

725
726
00:45:50,250 --> 00:45:50,760
So what do you do?

726
727
00:45:50,760 --> 00:45:53,950
Well, we'll call the delegate and say,
well, we need a new default calendar.

727
728
00:45:53,950 --> 00:45:55,240
What should we use?

728
729
00:45:55,240 --> 00:45:59,240
And if you don't fill -- if you don't actually override
this method, we'll just use default calendar for new events.

729
730
00:45:59,240 --> 00:46:02,430
But it's there if you want to hook it in.

730
731
00:46:02,430 --> 00:46:04,920
Explain the editors, it's just as easy.

731
732
00:46:04,920 --> 00:46:08,750
Create it and just set the event
in the EventStore this time.

732
733
00:46:08,750 --> 00:46:13,370
And then you set edit view delegate to
whatever is appropriate for your application.

733
734
00:46:13,370 --> 00:46:18,980
And then it's packaged as a UI navigation
controller, and it's meant to be presented modally.

734
735
00:46:18,980 --> 00:46:23,640
So you want to call presentModalViewController animated.

735
736
00:46:23,640 --> 00:46:28,450
And, likewise, when you want to dismiss
it, you just dismiss modal view controller.

736
737
00:46:28,450 --> 00:46:35,070
Okay. Let's just see a quick sample of
actually using Detail View in our application.

737
738
00:46:35,070 --> 00:46:36,510
Glen.

738
739
00:46:36,510 --> 00:46:40,040
[ Pause ]

739
740
00:46:40,040 --> 00:46:40,270
>> Glen Steele: Okay.

740
741
00:46:40,270 --> 00:46:44,840
So, really quickly, we're just going to add
the EKEventViewController to our application.

741
742
00:46:44,840 --> 00:46:48,200
And so we want to do this in the
list of payments that we have.

742
743
00:46:48,200 --> 00:46:53,370
We'd like to be able to tap on one of those
and get shown, basically, the Calendar UI.

743
744
00:46:53,370 --> 00:46:57,850
So that view controller is actually
the payment schedule view controller.

744
745
00:46:57,850 --> 00:47:02,110
And the first thing we want to do is
just update our configure cell method.

745
746
00:47:02,110 --> 00:47:06,140
We want to make sure that we show
that little disclosure chevron.

746
747
00:47:06,140 --> 00:47:13,540
So, to do that, we just set the cell accessory type
to UI table view cell accessory disclosure indicator.

747
748
00:47:13,540 --> 00:47:19,850
And the next thing we need to do is update
our did select row at index path method.

748
749
00:47:19,850 --> 00:47:21,260
All right.

749
750
00:47:22,930 --> 00:47:29,480
So what we're going to do here is grab our payment object
that's associated with the payment that we just tapped.

750
751
00:47:29,480 --> 00:47:33,950
And we do that using our core data
magic and our fetch results controller.

751
752
00:47:33,950 --> 00:47:38,080
And then we need to create a loan event scheduler

752
753
00:47:38,080 --> 00:47:43,420
so that we can actually find the EKEvent
that's associated would this payment.

753
754
00:47:43,420 --> 00:47:47,580
So we're going to define a new method
called event recurrence for payment.

754
755
00:47:47,580 --> 00:47:50,970
And that's going to return our EKEvent.

755
756
00:47:50,970 --> 00:47:56,450
Once we've got that, we can create our new event
view controller and then set the properties

756
757
00:47:56,450 --> 00:48:00,230
on it, the most important one being the event.

757
758
00:48:00,230 --> 00:48:02,780
And set the allows editing property.

758
759
00:48:02,780 --> 00:48:04,900
Now, you know, I had this set as no.

759
760
00:48:04,900 --> 00:48:09,620
But I'm going to set it to yes just so that you
can see how easy it is to put the Edit button

760
761
00:48:09,620 --> 00:48:12,480
up there and get the edit view controller.

761
762
00:48:12,480 --> 00:48:16,310
And once that's done, it's just a matter of
pushing it onto our navigation controller.

762
763
00:48:16,310 --> 00:48:18,490
So we're done here.

763
764
00:48:18,490 --> 00:48:21,510
Let's just go and implement this
event recurrence for payment method.

764
765
00:48:21,510 --> 00:48:28,270
[ Pause ]

765
766
00:48:28,270 --> 00:48:30,210
Okay. So this is very simple.

766
767
00:48:30,210 --> 00:48:32,450
Actually, you've seen this code before.

767
768
00:48:32,450 --> 00:48:37,580
This is the code that we use to search for
events once we had created the recurring event,

768
769
00:48:37,580 --> 00:48:39,430
and it's pretty much the same thing.

769
770
00:48:39,430 --> 00:48:41,870
All we're doing is creating a search predicate,

770
771
00:48:41,870 --> 00:48:48,470
calling eventsMatchingPredicate using
a mutable copy to postfilter in place.

771
772
00:48:48,470 --> 00:48:54,430
And, then, we know that we're going
to get basically one event, right?

772
773
00:48:54,430 --> 00:48:59,780
So we're just going to take the first event and return that.

773
774
00:49:01,990 --> 00:49:02,730
All right.

774
775
00:49:02,730 --> 00:49:03,660
So let's build.

775
776
00:49:03,660 --> 00:49:05,350
Everything went okay.

776
777
00:49:05,350 --> 00:49:06,390
Send that over to the device.

777
778
00:49:06,390 --> 00:49:16,090
And now what we should expect to see is we should be able
to create a loan and look at our payment schedule controller

778
779
00:49:16,090 --> 00:49:20,660
and tap on any one of those payments and we
should see EventKitUI for each one of those.

779
780
00:49:20,660 --> 00:49:27,090
So let's go ahead and do that, create
a new loan for Charlie this time.

780
781
00:49:27,090 --> 00:49:31,580
We'll be a bit more ambitious.

781
782
00:49:31,580 --> 00:49:42,190
And let's do it over a month and do
payments every -- let's say every three days.

782
783
00:49:42,190 --> 00:49:49,590
Hit Save. And now, if we tap on this and look at the
payment schedule, it looks like our chevrons showed up.

783
784
00:49:49,590 --> 00:49:54,220
And we should be able to tap on any one of
these and, hey look, we get the event UI for it.

784
785
00:49:54,220 --> 00:50:02,620
And we can tap on the Edit button and that
gives us the event UI edit controller.

785
786
00:50:02,620 --> 00:50:04,510
Okay.

786
787
00:50:04,510 --> 00:50:09,060
[ Applause ]

787
788
00:50:09,060 --> 00:50:09,220
All right.

788
789
00:50:09,220 --> 00:50:13,830
So that's using EventKitUI to show
EventKitUI in your application.

789
790
00:50:13,830 --> 00:50:14,940
And it's pretty easy.

790
791
00:50:14,940 --> 00:50:20,200
You just need to find the event using the eventIdentifier
or search for it using the predicate methods;

791
792
00:50:20,200 --> 00:50:27,390
create a new EKEventViewController; and then set the
controller properties, mainly your event property;

792
793
00:50:27,390 --> 00:50:31,640
and push that onto your navigation stack.

793
794
00:50:31,640 --> 00:50:33,850
All right, thanks.

794
795
00:50:33,850 --> 00:50:36,500
>> Ed Voas: Thanks, Glen.

795
796
00:50:36,500 --> 00:50:40,070
Okay. So that's pretty much the bulk of the API.

796
797
00:50:40,070 --> 00:50:43,180
It doesn't really take a lot and you
can still get a bunch of stuff done.

797
798
00:50:43,180 --> 00:50:45,700
I just want to mention some facts
about working with the simulator.

798
799
00:50:45,700 --> 00:50:51,870
So, in the simulator, the SDK, we don't
have the Calendar application there.

799
800
00:50:51,870 --> 00:50:54,270
So it's a little difficult to manufacture events.

800
801
00:50:54,270 --> 00:51:00,430
So one way that you could do that is just write --
you know, we saw how easy it is to generate events.

801
802
00:51:00,430 --> 00:51:04,230
You can just write some code and
just populate the database that way.

802
803
00:51:04,230 --> 00:51:08,610
Or you can actually use the birthday calendar
which I believe does work in the simulator.

803
804
00:51:08,610 --> 00:51:14,120
So you can just add some contacts, give them birthdays,
and the birthday calendar will just autopopulate.

804
805
00:51:14,120 --> 00:51:21,520
And that would be an example of a read-only
calendar that you could poke around with.

805
806
00:51:21,520 --> 00:51:24,880
So the bottom line here is we have,
like, really easy to use,

806
807
00:51:24,880 --> 00:51:29,530
very high-level APIs that allow you
to get at calendar data on a device.

807
808
00:51:29,530 --> 00:51:31,620
We have a couple of view controllers.

808
809
00:51:31,620 --> 00:51:34,700
They do everything that you can
do in the Calendar application.

809
810
00:51:34,700 --> 00:51:38,920
And one of the things that we don't demonstrate
is that they're fully rotatable now in iOS 4.

810
811
00:51:38,920 --> 00:51:44,950
And, obviously, this is just the first release of this API.

811
812
00:51:44,950 --> 00:51:48,410
We want to do more stuff as time progresses.

812
813
00:51:48,410 --> 00:51:53,160
But it's up to you to help us to figure
out what we should do first, all right?

813
814
00:51:53,160 --> 00:51:57,100
So the best way to do that is to file bugs.

814
815
00:51:57,100 --> 00:52:00,820
Now, many people file a bug and
say, I need an API that gives me X.

815
816
00:52:00,820 --> 00:52:01,820
It's like, Okay.

816
817
00:52:01,820 --> 00:52:03,370
But what are you really trying to do?

817
818
00:52:03,370 --> 00:52:07,460
So if you could tell us, you know, exactly what you're
trying to get at, you know, what you're trying to do

818
819
00:52:07,460 --> 00:52:13,800
with the API, we can then see how we
can best fit that into the public API.

819
820
00:52:13,800 --> 00:52:19,740
And we take all of those requests; and, obviously, the most
popular features, the most oft-requested things are the ones

820
821
00:52:19,740 --> 00:52:25,220
that we prioritize first rather than last.

821
822
00:52:25,220 --> 00:52:31,980
So tomorrow there's a lab at 9 a.m. -- God help me -- Lab B.

822
823
00:52:31,980 --> 00:52:37,160
Yesterday, there was a talk on GCD.

823
824
00:52:37,160 --> 00:52:41,830
So, if you missed that, you can catch it
later on in the -- on the web, I guess.

824
825
00:52:41,830 --> 00:52:50,130
There was also a session which I neglected to put here on
UILocalNotifications which you might also be interested in.

825
826
00:52:50,130 --> 00:52:56,850
If you need to contact someone,
I pick Mark Malone.

826
827
00:52:56,850 --> 00:52:59,440
So if you have questions on Calendar, you can contact him.

827
828
00:52:59,440 --> 00:53:04,350
We also have documentation on developer.Apple.com.

828
829
00:53:04,350 --> 00:53:11,020
And the -- on the Dev Forums, I'm patrolling that,
too, and trying to answer questions as best as I can.

829
830
00:53:11,020 --> 00:53:13,650
So you can always use that as a way to talk to us.

830
