1
00:00:06,620 --> 00:00:09,160
>> Josh Shaffer: Alright, good morning guys.

1
2
00:00:09,160 --> 00:00:12,720
My name's Josh and I'll be joined
in just a little bit by Eliza,

2
3
00:00:12,720 --> 00:00:17,320
who once again has some more incredible
demos to share with you guys this year.

3
4
00:00:17,320 --> 00:00:22,910
If you came to see the mastering iPhone-- the
Mastering iPhone Scroll Views last year at WWDC,

4
5
00:00:22,910 --> 00:00:29,080
then you know we started out that by talk by getting into
a lot of the basics of how to configure a scroll view

5
6
00:00:29,080 --> 00:00:35,480
for just a bit of scrolling and zooming, the really
simple parts that, you know, that everyone has to do

6
7
00:00:35,480 --> 00:00:37,490
when they start out to configure a scroll view.

7
8
00:00:37,490 --> 00:00:41,700
So this year we're actually going to skip
over all of that introductory basic stuff.

8
9
00:00:41,700 --> 00:00:46,150
So if you weren't here last year or you're kind
of new to this, don't worry, it's no problem.

9
10
00:00:46,150 --> 00:00:47,960
There's plenty of sample code available,

10
11
00:00:47,960 --> 00:00:51,340
and the documentation is excellent
and it's actually really easy anyway.

11
12
00:00:51,340 --> 00:00:53,730
There're only a couple of things to do to configure it.

12
13
00:00:53,730 --> 00:00:59,500
But what we really want to do this year is jump right in to
some of the more advanced, exciting things that you can do

13
14
00:00:59,500 --> 00:01:03,600
with UIScrollView, when you really start
to use them in your applications the way

14
15
00:01:03,600 --> 00:01:06,990
that Apple uses the UIScrollView in our applications.

15
16
00:01:06,990 --> 00:01:15,120
So we're going to frame the rest of the talk around building
a photo browser that behaves exactly like the photo browser

16
17
00:01:15,120 --> 00:01:18,560
that you'll find in the Photos application in iPhone OS.

17
18
00:01:18,560 --> 00:01:22,670
Now, I see some of you kind of looking at me
thinking, "I don't have any photo browsers in my app.

18
19
00:01:22,670 --> 00:01:24,800
So maybe I just kind of get out here."

19
20
00:01:24,800 --> 00:01:27,010
But don't worry about it, it's not a problem.

20
21
00:01:27,010 --> 00:01:32,530
All the techniques we're going to talk about are perfectly
applicable to plenty of other types of applications.

21
22
00:01:32,530 --> 00:01:39,350
In fact, the things we're going to discuss
are used in Safari, in Maps, in Stocks,

22
23
00:01:39,350 --> 00:01:44,280
in Weather and all of these different
applications on iPhone.

23
24
00:01:44,280 --> 00:01:49,730
So we'll take a look at how we can use them, and we'll build
a photo browser and then you guys can go back and figure

24
25
00:01:49,730 --> 00:01:52,360
out how you can use them in your own applications.

25
26
00:01:52,360 --> 00:01:57,180
So let's get started by talking about
how we'll configure our UIScrollViews

26
27
00:01:57,180 --> 00:01:59,870
in order to behave like the photos application.

27
28
00:01:59,870 --> 00:02:02,120
So what is it that we want to get?

28
29
00:02:02,120 --> 00:02:04,040
Well hopefully, you've all already seen this.

29
30
00:02:04,040 --> 00:02:09,700
The basic idea is going to be, that you can
scroll around on photos and zoom in on them

30
31
00:02:09,700 --> 00:02:13,620
and view just these large great full screen photos.

31
32
00:02:13,620 --> 00:02:18,260
So of course, we've got the full screen
photo is the most important part of that.

32
33
00:02:18,260 --> 00:02:24,130
And you know that your users expect to be able to
swipe left and right to go between multiple photos.

33
34
00:02:24,130 --> 00:02:27,290
So let's add one to the left and one to the right there.

34
35
00:02:27,290 --> 00:02:34,010
Then they expect to be able to just swipe and have it move
over and swipe back to navigate around between their photos.

35
36
00:02:34,010 --> 00:02:38,910
When they're at a photo, they want to be
able to zoom in on that photo by pinching

36
37
00:02:38,910 --> 00:02:41,400
or by double tapping or two finger tapping.

37
38
00:02:41,400 --> 00:02:43,910
Now, you'll notice something interesting happened here.

38
39
00:02:43,910 --> 00:02:49,730
When I zoomed in on that photo, the two photos to the
left and to the right didn't actually move to make room

39
40
00:02:49,730 --> 00:02:53,610
for the thing that I just zoomed in,
they're off screen and not visible anyway.

40
41
00:02:53,610 --> 00:02:55,370
So it doesn't really matter where they are.

41
42
00:02:55,370 --> 00:02:57,370
Now this isn't just for the slide.

42
43
00:02:57,370 --> 00:03:03,190
This is kind of a setup to give you an idea of what to
expect for how we're going to end up implementing this.

43
44
00:03:03,190 --> 00:03:10,660
A lot of people start out by thinking that they really
need to move this entire set of photos as one large plane

44
45
00:03:10,660 --> 00:03:14,720
and it's not entirely obvious how
you might do that with UIScrollView.

45
46
00:03:14,720 --> 00:03:20,420
So a lot of people end up going back to UIView and
starting from scratch and just subclassing UIView

46
47
00:03:20,420 --> 00:03:24,420
and implementing raw touch handling
and doing everything from the ground

47
48
00:03:24,420 --> 00:03:27,630
up implementing an entire scrolling subclass.

48
49
00:03:27,630 --> 00:03:32,780
Even if you didn't do that, a lot of people we find
end up going out and looking for third party frameworks

49
50
00:03:32,780 --> 00:03:35,900
that provide this kind of functionality,
because it seems really hard

50
51
00:03:35,900 --> 00:03:38,600
and it's not something you'd want to take on, on your own.

51
52
00:03:38,600 --> 00:03:42,290
Well the important thing that we really want to
get across while we're talking about this today,

52
53
00:03:42,290 --> 00:03:43,780
is that you really don't have to do this.

53
54
00:03:43,780 --> 00:03:47,230
You don't have to start from scratch you
don't have to go to third party frameworks.

54
55
00:03:47,230 --> 00:03:50,820
You can use UIScrollView to get all this
behaviors that we're going to talk about here.

55
56
00:03:50,820 --> 00:03:56,640
Alright, so your users zoomed in on the photo, once they're
viewing it large, they can then swipe around on that photo

56
57
00:03:56,640 --> 00:03:59,470
to scroll around and view different parts of it, right?

57
58
00:03:59,470 --> 00:04:04,310
And when they get to the edge, they'll continue to
pull the photo and it will swipe back to next one

58
59
00:04:04,310 --> 00:04:09,010
and shrink the one they zoomed in
back down to its original size.

59
60
00:04:09,010 --> 00:04:14,480
OK, so that's the type of behavior
we're trying to end up with.

60
61
00:04:14,480 --> 00:04:17,950
What kind of view hierarchy to we
have to build in order to get to that?

61
62
00:04:17,950 --> 00:04:23,630
Well, we're actually going to take the two parts that
we're trying to accomplish and separate them out.

62
63
00:04:23,630 --> 00:04:28,790
We're going to look at paging independent from
zooming and consider them to be two different things.

63
64
00:04:28,790 --> 00:04:31,390
So we'll start out with implementing the paging.

64
65
00:04:31,390 --> 00:04:35,770
And to do that we'll use a paging UIScrollView
and if you use UIScrollView you know

65
66
00:04:35,770 --> 00:04:40,290
that that's just a normal UIScrollView
where you set the paging enabled bit to yes.

66
67
00:04:40,290 --> 00:04:44,000
And we'll create one that covers the entire iPhone screen.

67
68
00:04:44,000 --> 00:04:50,260
So in this case it's going to be 320 by
480 points, so it fills the entire display.

68
69
00:04:50,260 --> 00:04:54,460
Now we'll configure this for the sample we're
looking at here to display three photos.

69
70
00:04:54,460 --> 00:04:56,770
So if you've used paging scroll views before,

70
71
00:04:56,770 --> 00:05:01,700
you know that the page width is determined
simply by the bounds width of the scroll view.

71
72
00:05:01,700 --> 00:05:07,950
So in our case since our bounds width is 320 points,
we're going to have page width of 320 points.

72
73
00:05:07,950 --> 00:05:15,620
So we'll multiply by that 3 and set our content size
to 960 by 480, so we can swipe between three pages.

73
74
00:05:15,620 --> 00:05:19,280
Now that's all we actually have to do, to get
the paging behavior that we're trying to add.

74
75
00:05:19,280 --> 00:05:21,780
So on to zooming.

75
76
00:05:21,780 --> 00:05:29,520
For zooming, we're going to add separate UIScrollViews that
handle just that zooming and panning on the zoomed images.

76
77
00:05:29,520 --> 00:05:32,300
So we're going to add a new UIScrollView subview

77
78
00:05:32,300 --> 00:05:36,760
of our outer paging Scroll View
that again covers the entire screen.

78
79
00:05:36,760 --> 00:05:42,850
So it's going to be 320 by 480, and it will be a subview
of that paging ScrollView filling the entire screen.

79
80
00:05:42,850 --> 00:05:47,170
And since we've got two other photos that we're trying
to display as well, we'll add two more to the left--

80
81
00:05:47,170 --> 00:05:52,290
to the right rather, so that you can see a zooming--

81
82
00:05:52,290 --> 00:05:56,240
allowing the user to zoom in on
each one of these different photos.

82
83
00:05:56,240 --> 00:05:59,080
And finally, we need to actually display the photos.

83
84
00:05:59,080 --> 00:06:04,950
And if you've used UIScrollView to add zooming support
before, you'll be familiar with the delegate method view

84
85
00:06:04,950 --> 00:06:10,220
for zooming in Scroll View which is how you implement
zooming in a Scroll View, you basically return some subview

85
86
00:06:10,220 --> 00:06:13,830
of your UIScrollView that you want the user to be able zoom.

86
87
00:06:13,830 --> 00:06:19,950
So we're going to need to add a subview, so we'll just
add one UIImageView to each of these zooming scroll views,

87
88
00:06:19,950 --> 00:06:23,290
and we'll return those from the view for
zooming and scroll view delegate method

88
89
00:06:23,290 --> 00:06:24,530
so that they're the things that get zoomed.

89
90
00:06:24,530 --> 00:06:28,470
So we've kind of a built a bit of
a layer-- a set of layers up here.

90
91
00:06:28,470 --> 00:06:31,210
It's gotten a little bit complicated
and you can't see it all anymore.

91
92
00:06:31,210 --> 00:06:33,990
So let's step back and take a look
at everything we just did.

92
93
00:06:33,990 --> 00:06:37,600
We've got our outer paging scroll view at the bottom.

93
94
00:06:37,600 --> 00:06:39,800
That handles just the paging.

94
95
00:06:39,800 --> 00:06:44,290
We've got subviews to handle the zooming
and those are also UIScrollViews.

95
96
00:06:44,290 --> 00:06:46,840
And then finally, we've got the UIImageViews subviews

96
97
00:06:46,840 --> 00:06:50,450
of the zooming scroll views that
are actually displaying the photos.

97
98
00:06:50,450 --> 00:06:55,260
The combination of these three things just like
this is all you actually have to do in order

98
99
00:06:55,260 --> 00:07:01,140
to get the exact same paging, zooming, scrolling
behavior that you see in the photos app in iPhone OS.

99
100
00:07:01,140 --> 00:07:05,060
Just adding them as subviews takes care of everything.

100
101
00:07:05,060 --> 00:07:09,780
So the one thing that's missing before we go and
take a look at how you'll actually implement it is

101
102
00:07:09,780 --> 00:07:16,090
that the photos application, you'll notice actually
separates the photos a bit, there's a bit of black padding

102
103
00:07:16,090 --> 00:07:19,030
between each one of the photos to make
it very clear that there's a border

103
104
00:07:19,030 --> 00:07:21,580
where one photo ends and where the next begins.

104
105
00:07:21,580 --> 00:07:27,150
In our pictures of frogs here, they're all pretty green
and as you're scrolling between it's not entirely obvious

105
106
00:07:27,150 --> 00:07:30,390
where one ends and the next begins,
because they kind of bleed together.

106
107
00:07:30,390 --> 00:07:35,560
So in order to make them stand apart a bit,
we actually have to increase the page width

107
108
00:07:35,560 --> 00:07:38,400
so that there's more space between each page.

108
109
00:07:38,400 --> 00:07:40,100
But as I just said a minute ago, the page width

109
110
00:07:40,100 --> 00:07:44,430
of a scroll a scroll view is determined
by that scroll view's bounds width.

110
111
00:07:44,430 --> 00:07:49,860
So in order to get the page width bigger, we actually have
to increase the size of that outer paging scroll view.

111
112
00:07:49,860 --> 00:07:57,320
So I'm just going to change the bounds from 320
points up to 340 points and keep it centered on screen

112
113
00:07:57,320 --> 00:08:01,220
so there'll be 10 points hanging off on the left and
10 on the right but they're off the side of the screen

113
114
00:08:01,220 --> 00:08:03,050
and there's not going to be displayed there anyway.

114
115
00:08:03,050 --> 00:08:05,560
So it's really just to increase the page width.

115
116
00:08:05,560 --> 00:08:08,550
The zooming scroll views will stay the same size.

116
117
00:08:08,550 --> 00:08:11,770
So once we do that, you'll see they'll kind
of spread apart and we'll get a bit of padding

117
118
00:08:11,770 --> 00:08:14,660
between each photo, to frame the photo against black.

118
119
00:08:14,660 --> 00:08:18,020
Now it's a little hard to see so
we collapse it back down again.

119
120
00:08:18,020 --> 00:08:21,260
You can start to see that we now we can view a bit

120
121
00:08:21,260 --> 00:08:25,190
of that outer paging scroll view from
behind of the zooming scroll view.

121
122
00:08:25,190 --> 00:08:30,780
Zooming scroll view is still 320 points,
paging scroll view is now 340 points.

122
123
00:08:30,780 --> 00:08:32,760
And each of those zooming scroll views are just centered

123
124
00:08:32,760 --> 00:08:36,120
within their respective 340 points
of the paging scroll view.

124
125
00:08:36,120 --> 00:08:38,660
So that's the configuration.

125
126
00:08:38,660 --> 00:08:40,030
There's really not much else to it.

126
127
00:08:40,030 --> 00:08:47,350
With that, let's have Eliza come up and
show us how to actually build this in code.

127
128
00:08:47,350 --> 00:08:47,800
>>Eliza Block: Hi.

128
129
00:08:47,800 --> 00:08:51,150
I'm Eliza and I'm an Engineer on the Spring Board team.

129
130
00:08:51,150 --> 00:08:55,870
I'm going to show you how you can set this up
in code to do exactly what Josh just described.

130
131
00:08:55,870 --> 00:09:01,580
So we're going to start with a simple view base
application and we're going to do almost all of the work

131
132
00:09:01,580 --> 00:09:08,920
to configure the zooming and paging in the view
controller subclass that's our root view controller.

132
133
00:09:08,920 --> 00:09:11,910
So I'm going to switch here to the demo machine.

133
134
00:09:11,910 --> 00:09:18,830
Alright, so this is the header file for our view controller
and I'm going to add one instance variable to start us off,

134
135
00:09:18,830 --> 00:09:23,050
which is the paging scroll view
that we're going to be using.

135
136
00:09:23,050 --> 00:09:28,340
I'm now going to switch to the implementation,
and we can actually do all of the setup

136
137
00:09:28,340 --> 00:09:32,330
in the Load view method of our view controller.

137
138
00:09:32,330 --> 00:09:36,560
So we'll start by creating the Paging
Scroll View that we just declared.

138
139
00:09:36,560 --> 00:09:39,970
We need to figure out what its frame is going to be.

139
140
00:09:39,970 --> 00:09:43,080
So let's start with the screen bounds.

140
141
00:09:43,080 --> 00:09:49,080
But as Josh explained, we're going to want to have that
paging scroll view hang off the sides of the screen

141
142
00:09:49,080 --> 00:09:52,180
by 10 pixels so that we'll leave some space on either side.

142
143
00:09:52,180 --> 00:09:59,650
So I'm going to subtract 10 from its X
origin and I'm going to add 20 to its width.

143
144
00:09:59,650 --> 00:10:04,480
And the effect of that is it will now hang off
10 pixels on the left and 10 pixels on the right.

144
145
00:10:04,480 --> 00:10:12,100
So let's create the paging scroll view with that frame.

145
146
00:10:12,100 --> 00:10:14,090
We're going to set a few properties now.

146
147
00:10:14,090 --> 00:10:17,780
We need to set paging enabled as Josh explained.

147
148
00:10:17,780 --> 00:10:22,120
We need to set the background color to black.

148
149
00:10:22,120 --> 00:10:26,120
And finally, we need to set the content
size of this paging scroll view now.

149
150
00:10:26,120 --> 00:10:30,420
The content size is the property
that determines the scrollable area.

150
151
00:10:30,420 --> 00:10:37,250
So we want to make it wide enough to accommodate all of
the pages that we're going to insert in a minute here.

151
152
00:10:37,250 --> 00:10:45,850
So the width of this content size is going to be the size of
the width of a page times the number of images that we have

152
153
00:10:45,850 --> 00:10:47,980
and I've got a convenient method here, image count,

153
154
00:10:47,980 --> 00:10:50,260
which just returns the number of
images that we're going to display.

154
155
00:10:50,260 --> 00:10:54,450
And the height will just be the size-- the
height of the frame because we're not going

155
156
00:10:54,450 --> 00:10:57,320
to allow for scrolling in the vertical direction.

156
157
00:10:57,320 --> 00:11:00,790
Alright, we're in the load view method.

157
158
00:11:00,790 --> 00:11:02,340
We need to produce a view.

158
159
00:11:02,340 --> 00:11:05,380
So we can actually use this paging scroll view as our view.

159
160
00:11:05,380 --> 00:11:08,360
So I'll just set our view to the paging scroll view.

160
161
00:11:08,360 --> 00:11:10,790
So now the paging part is totally finished.

161
162
00:11:10,790 --> 00:11:13,730
This is going to work just fine but
it doesn't have any content yet.

162
163
00:11:13,730 --> 00:11:20,110
So the next thing we need to do is add some pages.

163
164
00:11:20,110 --> 00:11:27,350
Alright, now as a first pass, let's just go through
all the images we have and for each image we're going

164
165
00:11:27,350 --> 00:11:30,530
to make a page and insert it into the scroll view.

165
166
00:11:30,530 --> 00:11:34,570
So I'm going to just iterate through my images.

166
167
00:11:34,570 --> 00:11:38,780
And for each image, I'm going to
create a zooming scroll view.

167
168
00:11:38,780 --> 00:11:44,960
And now, I've made a custom subclass of UIScrollView
called imageScrollView and I'm going to use it.

168
169
00:11:44,960 --> 00:11:52,430
What this does is it sets up the zooming for you and--
but-- so I'm not going to show you the details of that now.

169
170
00:11:52,430 --> 00:11:55,170
But if you want to take look at it
in the sample code you can go ahead.

170
171
00:11:55,170 --> 00:12:01,100
Basically, it creates a zooming scroll view exactly as you
would if you weren't embedding it into a paging scroll view.

171
172
00:12:01,100 --> 00:12:03,490
It's just a straightforward zooming scroll view.

172
173
00:12:03,490 --> 00:12:08,550
And it sets itself up with the right minimum
and maximum zoom scale and everything.

173
174
00:12:08,550 --> 00:12:13,190
Alright, we're going to configure this page
for the particular index that we're at.

174
175
00:12:13,190 --> 00:12:17,530
And that's just going to set the
frame of the page appropriately.

175
176
00:12:17,530 --> 00:12:24,050
So the first page is going to go at the beginning of the
content of the paging scroll view and then as we go forward

176
177
00:12:24,050 --> 00:12:27,890
and index this we'll position them in a row.

177
178
00:12:27,890 --> 00:12:34,710
It's also going to find the image for that index and
tell the zooming scroll view to display that image.

178
179
00:12:34,710 --> 00:12:41,790
Finally, we need to add that page as a subview of
our paging scroll view and that's pretty much it.

179
180
00:12:41,790 --> 00:12:44,510
We can just go ahead and build this.

180
181
00:12:44,510 --> 00:12:51,620
[ Pause ]

181
182
00:12:51,620 --> 00:12:54,000
OK. So, we have a page here.

182
183
00:12:54,000 --> 00:12:57,570
We can zoom in and out on it.

183
184
00:12:57,570 --> 00:12:58,800
So the zooming part is working.

184
185
00:12:58,800 --> 00:13:04,500
As we get to the edge, we can page over and
you can see that the paging works as planned.

185
186
00:13:04,500 --> 00:13:13,140
There's one drawback here which is that the-- our
image when it gets to the landscape dimension is

186
187
00:13:13,140 --> 00:13:14,950
up at the top which isn't really what you'd want.

187
188
00:13:14,950 --> 00:13:20,000
So you'd actually kind of want as the image gets zoomed
out to be smaller than the screen you kind of want it

188
189
00:13:20,000 --> 00:13:23,470
to be centered in the screen rather
than hugging the upper left corner.

189
190
00:13:23,470 --> 00:13:28,630
So that some of you might be aware the default behavior
of UIScrollView is that as the image gets smaller

190
191
00:13:28,630 --> 00:13:31,530
than the bounds of the Scroll View it hugs the upper left.

191
192
00:13:31,530 --> 00:13:36,960
Actually a lot of people asked us last year after
our session whether there was a good way to fix that

192
193
00:13:36,960 --> 00:13:39,870
and what I'm going to do right
now is show you how to do that.

193
194
00:13:39,870 --> 00:13:45,660
So we're going to modify this so that the image
stays centered as you scroll out, zoom out on it.

194
195
00:13:45,660 --> 00:13:50,050
Alright so to do that, we're going to switch
over to this imageScrollView subclass.

195
196
00:13:50,050 --> 00:13:53,990
So I'm going to go grab the implementation file for that.

196
197
00:13:53,990 --> 00:13:58,400
And we can do that by overriding the layout subviews method.

197
198
00:13:58,400 --> 00:14:06,670
Now, the advantage of the layout subviews method is that
it's called at every frame of both zooming and scrolling.

198
199
00:14:06,670 --> 00:14:13,880
So if we want to keep a view centered,
this is the perfect place to do it.

199
200
00:14:15,230 --> 00:14:17,800
So the first thing to do when you're
overriding layout subviews

200
201
00:14:17,800 --> 00:14:21,150
in a UIScrollView subclass is to remember to call super.

201
202
00:14:21,150 --> 00:14:26,530
UIScrollView does a lot of important configuration in
its layout subview methods so don't forget to do that.

202
203
00:14:26,530 --> 00:14:32,160
And then we're going to need to figure out what is the size
of the bounds that I want to keep this thing centered in

203
204
00:14:32,160 --> 00:14:39,190
and that's going to be the bounds, my own bound
size, since I'm in this case, the UIScrollView.

204
205
00:14:39,190 --> 00:14:46,010
And then we need to grab the frame that we're going
to want to center which is the image view frame.

205
206
00:14:46,010 --> 00:14:50,950
So now we're just going to go ahead and center
this frame both horizontally and vertically.

206
207
00:14:50,950 --> 00:14:53,430
So here's the horizontal direction.

207
208
00:14:53,430 --> 00:15:02,400
Alright, as you're zooming out so
that your image is getting smaller,

208
209
00:15:02,400 --> 00:15:10,090
you only want to start centering it once it has
started to be smaller than the width of your bounds,

209
210
00:15:10,090 --> 00:15:12,000
otherwise you want to kind of leave it alone.

210
211
00:15:12,000 --> 00:15:16,140
So what we want to do is check.

211
212
00:15:16,140 --> 00:15:19,830
Is the frame smaller in width than the bounds?

212
213
00:15:19,830 --> 00:15:26,040
If so, we're going to adjust the origin of
our frame to keep it centered in the bounds.

213
214
00:15:26,040 --> 00:15:29,670
If it's not smaller, we're just going to put it back at zero where it started

214
215
00:15:29,670 --> 00:15:34,150
so that we don't leave it centered as we zoom back in again.

215
216
00:15:34,150 --> 00:15:38,590
Do the exact same thing for the vertical.

216
217
00:15:38,590 --> 00:15:43,340
And finally, we just need to use
the new frame that we calculated.

217
218
00:15:43,340 --> 00:15:45,510
So I'm going to build this again.

218
219
00:15:45,510 --> 00:15:54,160
[ Pause ]

219
220
00:15:54,160 --> 00:16:01,170
And now, as I scroll over, you can see that the
landscape images are centered as we'd hoped.

220
221
00:16:01,170 --> 00:16:07,870
And in fact if I zoom out on one of these, you can see
that it hugs the center rather than the upper left.

221
222
00:16:07,870 --> 00:16:12,070
Alright, so before I turn it back to Josh,
I want to just signal one big problem

222
223
00:16:12,070 --> 00:16:13,810
with the application as we've run it so far.

223
224
00:16:13,810 --> 00:16:20,040
So I'm just going to open the activity monitor
and take a look at our memory consumption here.

224
225
00:16:20,040 --> 00:16:27,920
So, alright, let me see whether I can zoom in
on this to show you the real memory here is--

225
226
00:16:27,920 --> 00:16:32,210
we're using 400, almost 450 megabytes, the real memory.

226
227
00:16:32,210 --> 00:16:36,200
Now the reason for that is that
these images are pretty large.

227
228
00:16:36,200 --> 00:16:42,170
They're 6 or 7 megabytes compressed which translates
to somewhere between 20 and 40 megabytes uncompressed

228
229
00:16:42,170 --> 00:16:45,940
and what we did was we loaded every
single one of them upfront.

229
230
00:16:45,940 --> 00:16:52,070
We added every single one of them to our paging scroll
view so we have them all open in memory at once.

230
231
00:16:52,070 --> 00:16:55,610
And an iPhone doesn't have this much memory at all.

231
232
00:16:55,610 --> 00:17:01,680
So you would crash before you even started if
you were to do it this way on the actual device.

232
233
00:17:01,680 --> 00:17:03,510
So I'm going to turn it back to Josh.

233
234
00:17:03,510 --> 00:17:09,510
He's going to talk a little bit
about how we can avoid this problem.

234
235
00:17:09,510 --> 00:17:16,130
[ Applause ]

235
236
00:17:16,130 --> 00:17:17,740
>> Josh Shaffer: Alright, thanks Eliza.

236
237
00:17:17,740 --> 00:17:22,070
So, now we've got all of our behaviors
exactly as we want them except for the part

237
238
00:17:22,070 --> 00:17:26,200
where our users can't really see them because the
app crashes before they can actually launch it.

238
239
00:17:26,200 --> 00:17:30,330
So, let's try and fix that problem so
that somebody could actually use our app.

239
240
00:17:30,330 --> 00:17:35,950
Now we talked a bit about one of these approaches
last year in the Mastering iPhone Scroll View session.

240
241
00:17:35,950 --> 00:17:41,660
And what we talked about was tiling
your content using subview tiling.

241
242
00:17:41,660 --> 00:17:44,720
So we're going to talk about two
different approaches to tiling this year.

242
243
00:17:44,720 --> 00:17:50,250
The first will be subview tiling again although we're
going to talk about it in a different context and use it

243
244
00:17:50,250 --> 00:17:52,330
for a different purpose than what we used it for last year.

244
245
00:17:52,330 --> 00:17:58,000
And then we're going to talk about
CATiledLayer and drawn tiling.

245
246
00:17:58,000 --> 00:18:00,190
So why do you want to tile first of all?

246
247
00:18:00,190 --> 00:18:02,080
Well, the first reason is what we just talked about.

247
248
00:18:02,080 --> 00:18:06,060
You may want to display more content
than you can actually fit in the memory.

248
249
00:18:06,060 --> 00:18:10,320
But you may also want to download additional
pieces of content as you need them.

249
250
00:18:10,320 --> 00:18:17,110
The Maps Application on iPhone OS for example downloads just
individual tiles of whole world map at multiple zoom scales

250
251
00:18:17,110 --> 00:18:21,210
and different resolutions, more data than
would probably even fit on the phone.

251
252
00:18:21,210 --> 00:18:24,110
So you may want to tile if you
have to do something like that.

252
253
00:18:24,110 --> 00:18:25,650
But it also improves load time.

253
254
00:18:25,650 --> 00:18:29,550
I'm not sure if you noticed when
Eliza was building and running there.

254
255
00:18:29,550 --> 00:18:32,860
But it actually took quite a while
for that app to launch the first time

255
256
00:18:32,860 --> 00:18:36,550
because it was uncompressing all those
images and that was on a really fast Mac Pro.

256
257
00:18:36,550 --> 00:18:39,230
On your device, it would take so long that you would--

257
258
00:18:39,230 --> 00:18:43,670
your app would get killed before it even launched
anyway, even if it didn't run out of memory.

258
259
00:18:43,670 --> 00:18:46,100
So we really don't want to do that.

259
260
00:18:46,100 --> 00:18:48,370
Alright, so two approaches.

260
261
00:18:48,370 --> 00:18:49,910
First, we've got subview tiling.

261
262
00:18:49,910 --> 00:18:53,680
So we'll leave our little frog for
later and we'll come back to him.

262
263
00:18:53,680 --> 00:18:59,470
Now if you've used UITableView before, you've
already seen subview tiling in one way.

263
264
00:18:59,470 --> 00:19:04,680
Table view, you know, when you implement your cell for
rowAtIndexPath method, the first thing that you try

264
265
00:19:04,680 --> 00:19:08,080
and do is dequeue a reusable cell with an identifier.

265
266
00:19:08,080 --> 00:19:12,810
And what's that doing is basically implementing
subview tiling for you on your behalf.

266
267
00:19:12,810 --> 00:19:18,410
So, as your user scrolls through their table
view, cells move off the top, you dequeue them

267
268
00:19:18,410 --> 00:19:20,970
and put new content in and they scroll in on the bottom.

268
269
00:19:20,970 --> 00:19:23,800
And this happens repeatedly.

269
270
00:19:23,800 --> 00:19:27,710
So we'd really like to do basically
the exact same thing for our photos app

270
271
00:19:27,710 --> 00:19:31,420
as the user is paging horizontally
one photo moves off screen.

271
272
00:19:31,420 --> 00:19:34,270
We no longer need that scroll view
to display it when it's not visible.

272
273
00:19:34,270 --> 00:19:37,520
We can reuse it and move it in to
display another photo on the right.

273
274
00:19:37,520 --> 00:19:41,650
So that's exactly what we're going to do.

274
275
00:19:41,650 --> 00:19:44,620
We've got this set up that we just looked at.

275
276
00:19:44,620 --> 00:19:51,110
Let's expand it again but now see only the
parts that we actually need at any given time.

276
277
00:19:51,110 --> 00:19:56,370
So the shaded version of our paging scroll view
is the frame that's actually visible on the phone.

277
278
00:19:56,370 --> 00:20:01,480
And so we only have one zooming scroll view
that's visible in that frame right now.

278
279
00:20:01,480 --> 00:20:04,050
And so we only have to load one photo.

279
280
00:20:04,050 --> 00:20:07,340
Now if we make it a little bigger so
that we can see this happen over time,

280
281
00:20:07,340 --> 00:20:11,960
as the user pages through our photos, at
any point there's only going to be a maximum

281
282
00:20:11,960 --> 00:20:15,350
of two different photos visible at any given time.

282
283
00:20:15,350 --> 00:20:20,000
So we can page through and as we do it you
can see we only ever have two photos visible

283
284
00:20:20,000 --> 00:20:23,350
and there is only ever two scroll
views created to show those photos.

284
285
00:20:23,350 --> 00:20:26,860
So it's going to be much less memory and
much less set up cost initially in order

285
286
00:20:26,860 --> 00:20:31,850
to even begin launching and displaying these things.

286
287
00:20:31,850 --> 00:20:32,940
So where do we want to do this?

287
288
00:20:32,940 --> 00:20:34,770
That's what we're trying to accomplish.

288
289
00:20:34,770 --> 00:20:38,130
Well, we could do it in the layout
subviews method that Eliza just showed us.

289
290
00:20:38,130 --> 00:20:43,360
But maybe we don't actually want to have to subclass
UIScrollView because it's really not even necessary

290
291
00:20:43,360 --> 00:20:44,790
for the zooming case that we just looked at.

291
292
00:20:44,790 --> 00:20:48,810
You could do that all without a subclass.

292
293
00:20:48,810 --> 00:20:52,860
So if we didn't want to subclass, we
could instead implement the view--

293
294
00:20:52,860 --> 00:20:58,280
scrollViewDidScroll delegate method which is called
under the same conditions as layout subviews.

294
295
00:20:58,280 --> 00:21:03,270
Basically, every time that the user scrolls any amount
through the scroll view, either by dragging their finger

295
296
00:21:03,270 --> 00:21:07,040
or by flicking or having it decelerate,
scrollViewDidScroll will be called

296
297
00:21:07,040 --> 00:21:10,720
for every frame before that frame
is actually drawn on screen.

297
298
00:21:10,720 --> 00:21:13,030
So you have a chance to add subviews if you're going to need

298
299
00:21:13,030 --> 00:21:17,870
to display more content before that
empty spot even becomes visible.

299
300
00:21:17,870 --> 00:21:19,230
So that's exactly what we'll do.

300
301
00:21:19,230 --> 00:21:21,610
And Eliza is going to come back
up to show us how to do that.

301
302
00:21:21,610 --> 00:21:26,060
>> Eliza Block: Alright, so we're going to just start
right where we left off with the same application.

302
303
00:21:26,060 --> 00:21:30,340
I've moved back to the view controller header
file because we're going to need to add a couple

303
304
00:21:30,340 --> 00:21:33,270
of new ibars in order to accomplish the tiling.

304
305
00:21:33,270 --> 00:21:38,110
So our strategy is going to be-- we're going to
keep track of what tiles are currently visible.

305
306
00:21:38,110 --> 00:21:41,840
So we're going to need a set to keep track of
the visible tiles and we're also going to--

306
307
00:21:41,840 --> 00:21:46,790
as we pull out tiles that are already used because
they've gone off screen, we're going to keep track

307
308
00:21:46,790 --> 00:21:50,150
of them in another set of recyclable tiles.

308
309
00:21:50,150 --> 00:21:56,050
So I'm going to add two ibars here.

309
310
00:21:56,050 --> 00:22:01,160
A recycled pages set and a visible pages set.

310
311
00:22:01,160 --> 00:22:03,730
I'm also going to declare two new methods.

311
312
00:22:03,730 --> 00:22:09,610
We are going to need a method will get us a
recycled page if there is one available so this is--

312
313
00:22:09,610 --> 00:22:15,110
I've named this by analogy with the
UITableView dequeue reusable cell method.

313
314
00:22:15,110 --> 00:22:22,660
So we'll get us a recycled page and we're also going
to need a method that actually accomplishes the tiling.

314
315
00:22:22,660 --> 00:22:26,420
So let me switch over back to the implementation.

315
316
00:22:26,420 --> 00:22:33,700
Alright, here's our load view method and at the bottom,
we have these lines of code that add all the pages in.

316
317
00:22:33,700 --> 00:22:36,110
We don't want to do that because that's
what was using up all of our memory.

317
318
00:22:36,110 --> 00:22:37,950
So I'm just going to delete that.

318
319
00:22:37,950 --> 00:22:44,750
And instead what we'll do here is first we'll actually
create our recycled pages and visible pages sets

319
320
00:22:44,750 --> 00:22:51,710
and then we'll just call tile pages once to get
the tiling started and that will have the effect

320
321
00:22:51,710 --> 00:22:56,840
of showing the first page since that's the page
that you start on when this view is loaded.

321
322
00:22:56,840 --> 00:23:02,070
Now as Josh has pointed out it's
not enough to tile the pages once.

322
323
00:23:02,070 --> 00:23:04,600
We need to tile them every time
that the scroll view scrolls.

323
324
00:23:04,600 --> 00:23:09,190
So for that purpose, I'm going to implement
this scrollViewDidScroll delegate method.

324
325
00:23:09,190 --> 00:23:14,560
So we need to set our view controller as
the delegate of the paging scroll view.

325
326
00:23:14,560 --> 00:23:17,480
And then we'll implement scrollViewDidScroll

326
327
00:23:17,480 --> 00:23:21,510
and all we'll do is call tile pages
again every time the scroll view scrolls.

327
328
00:23:21,510 --> 00:23:25,720
OK, so what does it look like to tile the pages?

328
329
00:23:25,720 --> 00:23:30,350
I'm going to scroll down here to give us some space.

329
330
00:23:30,350 --> 00:23:37,710
So the first thing that we need to do when
we're tiling the pages is to calculate how--

330
331
00:23:37,710 --> 00:23:42,450
which pages should be visible given the
current content offset of our scroll view.

331
332
00:23:42,450 --> 00:23:47,460
So for that purpose, what we're going to do
is grab the visible bounds of the scroll view.

332
333
00:23:47,460 --> 00:23:53,000
And once we have the visible bounds, you can think of that
as a rectangle of the content and we're going to take a look

333
334
00:23:53,000 --> 00:23:58,350
at that rectangle and you can think
of it as a bunch of columns of pixels.

334
335
00:23:58,350 --> 00:24:04,420
So we'll look at the first column of pixels and we'll
see which page is that column of pixels associated with.

335
336
00:24:04,420 --> 00:24:05,880
Which page is that column of pixels in?

336
337
00:24:05,880 --> 00:24:11,100
And that's going to be the first page that we need to
display and then we'll look at the last column of pixels

337
338
00:24:11,100 --> 00:24:14,630
and we'll find the page that that column is on.

338
339
00:24:14,630 --> 00:24:16,730
And so that's going to be our range of pages.

339
340
00:24:16,730 --> 00:24:17,880
That's the strategy.

340
341
00:24:17,880 --> 00:24:19,420
So I'm going to paste some math here.

341
342
00:24:19,420 --> 00:24:20,770
I don't want you to worry about it.

342
343
00:24:20,770 --> 00:24:23,550
You can take a look at the sample code
and go through it and see how it works.

343
344
00:24:23,550 --> 00:24:26,520
But what it's doing is, what I just described,

344
345
00:24:26,520 --> 00:24:31,750
it's calculating the first needed page
index and the last needed page index.

345
346
00:24:31,750 --> 00:24:37,760
Alright, so now that we know which pages
we need, let's first recycle the ones

346
347
00:24:37,760 --> 00:24:41,060
that we don't need but that we already have in our view.

347
348
00:24:41,060 --> 00:24:45,470
So for that, we're going to use
this visible pages set that we have.

348
349
00:24:45,470 --> 00:24:47,520
And we're going to look at each
of the pages that's currently

349
350
00:24:47,520 --> 00:24:51,830
in the visible pages set and find out is it needed or not.

350
351
00:24:51,830 --> 00:24:55,350
Now, I've taken advantage of the
fact that I have a custom subclass

351
352
00:24:55,350 --> 00:24:58,080
of UIScrollView that my pages are image scroll views.

352
353
00:24:58,080 --> 00:25:00,530
And I've taught them to know what index they are.

353
354
00:25:00,530 --> 00:25:02,450
So what page index they represent.

354
355
00:25:02,450 --> 00:25:04,310
So what we're going to do is use that here.

355
356
00:25:04,310 --> 00:25:08,890
We'll just ask the page that we're on, is
your index outside of our needed range?

356
357
00:25:08,890 --> 00:25:11,960
Is it less than the first or greater
than the last needed page?

357
358
00:25:11,960 --> 00:25:16,840
So if it is outside of the needed range, we're going
to recycle it by adding it to our recycled pages.

358
359
00:25:16,840 --> 00:25:25,290
We're going to remove it from the Super View and we also
want to now take note of the fact that it's no longer

359
360
00:25:25,290 --> 00:25:30,040
in our visible pages set so we want to
remove it from the visible pages set.

360
361
00:25:30,040 --> 00:25:34,070
But don't do that in that way because adding this line

361
362
00:25:34,070 --> 00:25:39,150
of code here would be mutating a
set while we're enumerating it.

362
363
00:25:39,150 --> 00:25:45,750
And that's a really bad idea once you've checked that bug
into Springboard you never make the same mistake again.

363
364
00:25:45,750 --> 00:25:50,480
[Laughter] So let's take that out and after the
four loops safely, when we're finished enumerating,

364
365
00:25:50,480 --> 00:25:55,060
we can take advantage of the fact that these
are sets and we can do a set subtraction

365
366
00:25:55,060 --> 00:26:01,180
and just remove all those recycled pages from the visible
pages and that's a safer way to handle that problem.

366
367
00:26:01,180 --> 00:26:08,280
So now that we've recycled our pages, we need to add the
ones that are needed, that aren't already in the view.

367
368
00:26:08,280 --> 00:26:17,390
So for that, we're going to iterate through from the
first to the last needed page and we'll ask is this--

368
369
00:26:17,390 --> 00:26:20,280
do we actually have a page that's indexed already?

369
370
00:26:20,280 --> 00:26:22,750
And I've made a convenience method here,

370
371
00:26:22,750 --> 00:26:24,420
isDisplayingPageForIndex.

371
372
00:26:24,420 --> 00:26:29,010
What that does is it actually just looks through the
visible pages and sees whether there is one at that index.

372
373
00:26:29,010 --> 00:26:36,710
So if there's not, so if we're missing this
page that we need, we're going to make the page,

373
374
00:26:36,710 --> 00:26:43,720
configure it for the right index, add it as a
subview of our scroll view just like we did before.

374
375
00:26:43,720 --> 00:26:48,300
And finally, we'll note that this
page is now in our visible set.

375
376
00:26:48,300 --> 00:26:49,900
OK, we're almost ready to go.

376
377
00:26:49,900 --> 00:26:52,850
This would work at least at first.

377
378
00:26:52,850 --> 00:26:57,710
But you'll notice that I'm actually not using my
recycled pages at all for every time that we discover

378
379
00:26:57,710 --> 00:27:00,750
that we need a new page, I'm creating one from scratch.

379
380
00:27:00,750 --> 00:27:05,920
So eventually, we would hit our same memory problem as
we had in the first version once we filled up-- had--

380
381
00:27:05,920 --> 00:27:08,200
you know, scrolled all the way over to the last page.

381
382
00:27:08,200 --> 00:27:11,870
So let's actually use the recycled pages here.

382
383
00:27:11,870 --> 00:27:17,690
We need to implement this dequeue
recycled page method that I declared.

383
384
00:27:17,690 --> 00:27:18,950
So here it is.

384
385
00:27:18,950 --> 00:27:27,220
I grab any object out of my recycled pages set
and I do a little memory management stuff here,

385
386
00:27:27,220 --> 00:27:31,830
because presumably the recycled pages
set owns the last retain on this page.

386
387
00:27:31,830 --> 00:27:35,490
So if I were to remove it from the
recycled pages set and then return it,

387
388
00:27:35,490 --> 00:27:38,500
it would actually go away before
it had a chance to be returned.

388
389
00:27:38,500 --> 00:27:44,850
So first, I retain and auto release it to guarantee
that that page is still there when we go try to use it.

389
390
00:27:44,850 --> 00:27:52,630
Alright, so scrolling back up to here, instead of creating a
page at this point, we're going to try to get a recycled one

390
391
00:27:52,630 --> 00:27:56,660
by calling that method and only if we fail to get one.

391
392
00:27:56,660 --> 00:28:00,470
So if there wasn't one available,
will we actually create a new one.

392
393
00:28:00,470 --> 00:28:11,000
Oops. Alright, so let me go ahead and build
this version and we'll see what happens.

393
394
00:28:11,000 --> 00:28:15,020
Alright, so I've got my same app.

394
395
00:28:15,020 --> 00:28:16,570
It looks the same.

395
396
00:28:16,570 --> 00:28:18,400
I can zoom in just as I could before.

396
397
00:28:18,400 --> 00:28:22,130
I can scroll to the next page.

397
398
00:28:23,150 --> 00:28:25,700
So, things seem OK.

398
399
00:28:25,700 --> 00:28:35,020
Let's take a look at the activity monitor and
see how much memory we're using this time.

399
400
00:28:35,020 --> 00:28:36,490
There it is.

400
401
00:28:36,490 --> 00:28:38,070
Just a little over a 100 megabytes.

401
402
00:28:38,070 --> 00:28:40,910
So we've cut our memory consumption
down by a significant amount.

402
403
00:28:40,910 --> 00:28:45,350
Enough that you could probably actually run
this version of this application on the device.

403
404
00:28:45,350 --> 00:28:47,220
But let me just signal a problem.

404
405
00:28:47,220 --> 00:28:50,970
I don't know if it was very apparent
when I was scrolling through here.

405
406
00:28:50,970 --> 00:28:57,120
But if you take a look at the arrow, as I scroll
there's a perceptible lag before the next page appears.

406
407
00:28:57,120 --> 00:29:00,920
And the experience of it, you really feel
like this thing isn't responding very well.

407
408
00:29:00,920 --> 00:29:09,300
The reason is that, I'm actually having to load
and decompress that huge image at the beginning

408
409
00:29:09,300 --> 00:29:12,050
of the scroll, as I'm getting to my next page.

409
410
00:29:12,050 --> 00:29:17,940
And so, you actually get a bad performance problem
on this really powerful Mac, it's perceptible.

410
411
00:29:17,940 --> 00:29:19,900
On the device it would be really unacceptable.

411
412
00:29:19,900 --> 00:29:25,090
So let's-- I'm going to turn you back over to
Josh who will tell us how we can fix that problem.

412
413
00:29:25,090 --> 00:29:25,670
[ Applause ]

413
414
00:29:25,670 --> 00:29:29,850
>> Josh Shaffer: Alright, thanks again Eliza.

414
415
00:29:29,850 --> 00:29:31,480
So, we're getting much closer.

415
416
00:29:31,480 --> 00:29:34,650
We're actually almost there.

416
417
00:29:34,650 --> 00:29:36,060
Now I'm sure this is familiar.

417
418
00:29:36,060 --> 00:29:39,400
You've got the maps application from
iPhone OS here and it shows you exactly

418
419
00:29:39,400 --> 00:29:42,420
where you are at, you know, any given time.

419
420
00:29:42,420 --> 00:29:47,210
And at some point later, it shows
you what else is where you are.

420
421
00:29:47,210 --> 00:29:54,260
The way that works is by using CATiled layer to
lazily load all of the different tiles that make

421
422
00:29:54,260 --> 00:29:56,480
up the map that you're currently viewing.

422
423
00:29:56,480 --> 00:30:01,460
And these tiles are loaded off the network on a background
thread and then get drawn when they are finally available.

423
424
00:30:01,460 --> 00:30:07,170
And see, a tiled layer is available for
use as public API in your own applications.

424
425
00:30:07,170 --> 00:30:09,740
So you can do the exact same thing.

425
426
00:30:09,740 --> 00:30:12,860
So we already looked at this first subview tiling example.

426
427
00:30:12,860 --> 00:30:18,790
And that's a great way to do tiling if you
need to tile more complicated view hierarchies.

427
428
00:30:18,790 --> 00:30:22,290
Things like whole table view cells that
are composed of multiple subviews and,

428
429
00:30:22,290 --> 00:30:24,400
you know, UILabels, and all these other things.

429
430
00:30:24,400 --> 00:30:28,600
Or in the case of our paging, we
needed to tile entire UIScrollViews.

430
431
00:30:28,600 --> 00:30:33,720
So if you need complicated view hierarchies, you
really want to do your own subview tiling like that.

431
432
00:30:33,720 --> 00:30:39,410
But if you can do your drawing in drawRect, then
CATiledLayer can make this significantly easier.

432
433
00:30:39,410 --> 00:30:45,260
It can remove almost all of the management code that we just
looked at and, basically, just leave you do draw your content

433
434
00:30:45,260 --> 00:30:50,230
when you're asked and handles things like caching
to make sure that it's only using the amount

434
435
00:30:50,230 --> 00:30:53,770
of memory that's reasonable given
what the user has looked at.

435
436
00:30:53,770 --> 00:30:57,170
It only asks you to draw things that are currently visible.

436
437
00:30:57,170 --> 00:30:58,930
It supports multiple zoom scales.

437
438
00:30:58,930 --> 00:31:04,160
So as your user pinches to zoom in and out, it will
ask you for new tiles at a different zoom scale based

438
439
00:31:04,160 --> 00:31:10,500
on how many different levels of detail you'd like to
be able to display. And it manages all these for you.

439
440
00:31:10,500 --> 00:31:15,150
It's very easy to configure and you don't
have to write any code to implement all that.

440
441
00:31:15,150 --> 00:31:17,990
So let's take a look at that guy.

441
442
00:31:17,990 --> 00:31:21,630
The idea here is that we're going to
start out at a 100 percent zoom scale

442
443
00:31:21,630 --> 00:31:25,020
and will assume that our tiles are 100 by 100.

443
444
00:31:25,020 --> 00:31:28,640
So obviously, that means that in this case for
this portion of this frog we're looking at,

444
445
00:31:28,640 --> 00:31:32,210
we've got 16 tiles to make up this
entire portion of the frog.

445
446
00:31:32,210 --> 00:31:35,250
And that total size is 400 by 400.

446
447
00:31:35,250 --> 00:31:41,940
So assuming this was all we were looking at, we would
have created a CATiledLayer with bounds of 400 by 400

447
448
00:31:41,940 --> 00:31:45,180
and we'd add that as a subview of our zooming scroll view.

448
449
00:31:45,180 --> 00:31:50,040
Now as the user pinches in, we're going to drop
down to the 50 percent zoom scale at some point

449
450
00:31:50,040 --> 00:31:53,420
because the user will have pinched enough
that we're now only viewing half as much

450
451
00:31:53,420 --> 00:31:56,470
or we're viewing the image at half the original size.

451
452
00:31:56,470 --> 00:32:00,940
Once that's happened, assuming you've configured
your tiled layer to support a second level of detail,

452
453
00:32:00,940 --> 00:32:03,060
you'll be asked to draw the content again.

453
454
00:32:03,060 --> 00:32:07,650
But now, you'll be asked to draw it
at 50 percent of its original size.

454
455
00:32:07,650 --> 00:32:11,050
When that happens, the tiles will still be 100 by 100.

455
456
00:32:11,050 --> 00:32:17,170
So that's going to remain the same for the entire
duration of our example here and we're going to try

456
457
00:32:17,170 --> 00:32:20,220
and draw the exact same portion of our original image.

457
458
00:32:20,220 --> 00:32:25,810
So in that same frog we just saw before, we're
drawing again, but now, using tiles that are only as--

458
459
00:32:25,810 --> 00:32:28,810
a quarter as big, half an inch dimension.

459
460
00:32:30,430 --> 00:32:38,110
What this is going to end up doing though is asking us
to draw it into a bounds that is still the original size

460
461
00:32:38,110 --> 00:32:43,900
because if you looked at CALayer's geometry or UIView
geometry, you know that when a transform is applied

461
462
00:32:43,900 --> 00:32:48,520
to a view, that modifies the view's
frame which is the view size

462
463
00:32:48,520 --> 00:32:52,080
and the view super view, but it
doesn't modify the view's bounds.

463
464
00:32:52,080 --> 00:32:57,340
Frame is computed from bounds and
transform among a couple other properties.

464
465
00:32:57,340 --> 00:33:03,110
So the bounds of that CATiledLayer is still 400 by 400 and
we're going to be asked to draw under those same bounds.

465
466
00:33:03,110 --> 00:33:10,240
So effectively, we're going to be asked to draw
this, 100 by 100 tiles into a 400 by 400 bounds.

466
467
00:33:10,240 --> 00:33:14,420
Now, it may seem like-- when you start thinking about this,
you're going to have to multiply by your scale and so,

467
468
00:33:14,420 --> 00:33:19,640
you'll draw your 100 by 100 tile and stretch
it to be 200 by 200, and that's true.

468
469
00:33:19,640 --> 00:33:27,100
But that won't actually end up causing any actual stretching
in the drawing because the context you'll be asked to draw

469
470
00:33:27,100 --> 00:33:31,710
in actually has the inverse scale on it that
will scale it back down by half the amount.

470
471
00:33:31,710 --> 00:33:37,790
So you'll stretch it out to 200 by 200 and CG when it goes
to draw it will then scale it back down to 100 by 100.

471
472
00:33:37,790 --> 00:33:41,820
And the final draw of that image
will just be a 1 to 1 pixel bit.

472
473
00:33:41,820 --> 00:33:45,290
So the backing store for this is actually 200 by 200.

473
474
00:33:45,290 --> 00:33:49,220
So you saved the memory and you don't
actually lose image quality by scaling.

474
475
00:33:49,220 --> 00:33:55,560
Now similarly, if we had another level of
detail below this, we could have 25 percent.

475
476
00:33:55,560 --> 00:34:01,290
Once we got there, we'd be asked to draw the entire image
that we the just looked at into a single 100 by 100 tile

476
477
00:34:01,290 --> 00:34:07,770
because we now have 1/16 the amount of pixels, 1/16
the amount of memory being used, we've saved a lot

477
478
00:34:07,770 --> 00:34:11,450
and the user has pinched down so far that it doesn't
matter that we don't have all those original pixels

478
479
00:34:11,450 --> 00:34:14,320
because they're not able to be drawn on screen anyway.

479
480
00:34:14,320 --> 00:34:19,110
Again, 100 by 100, we're going to stretch
it when we draw it to fill that 400 by 400.

480
481
00:34:19,110 --> 00:34:25,260
Now as I said, CA or Core Graphics rather, when
it actually does this drawing is really going

481
482
00:34:25,260 --> 00:34:28,320
to be drawing it into that 100 by 100 backing store.

482
483
00:34:28,320 --> 00:34:32,030
So that really is what you have
in memory, just a smaller amount.

483
484
00:34:32,030 --> 00:34:35,240
So at that point, assuming the user has
actually zoomed through all these things,

484
485
00:34:35,240 --> 00:34:38,650
Core Animation now has three different
sets of tiles to work with.

485
486
00:34:38,650 --> 00:34:43,350
And as the user pinches to zoom in and out or
double taps if you've got programmatic zooming,

486
487
00:34:43,350 --> 00:34:46,710
Core Animation will correctly swap
between which tile is necessary

487
488
00:34:46,710 --> 00:34:50,500
to optimally display whatever zoom
scale the user's currently looking at.

488
489
00:34:50,500 --> 00:34:54,960
And it's even cooler because if you do some
programmatic animations for the zoom scale changes,

489
490
00:34:54,960 --> 00:35:00,130
Core Animation does trilinear filtering to blend these
as they're animating between them and it's really,

490
491
00:35:00,130 --> 00:35:04,640
really cool and it's stuff that we'd take a long
time to actually implement on your own from scratch

491
492
00:35:04,640 --> 00:35:08,110
and you get it all for free just by using CATiledLayer.

492
493
00:35:08,110 --> 00:35:11,240
Alright, so hopefully that, you know,
kind of makes you want to use it.

493
494
00:35:11,240 --> 00:35:13,780
What is it that we actually have to do to use it?

494
495
00:35:13,780 --> 00:35:15,890
Well, turns out it's actually really easy.

495
496
00:35:15,890 --> 00:35:20,740
There are just two methods on UIView that you
have to implement to begin using a CATiledLayer.

496
497
00:35:20,740 --> 00:35:25,520
First off, you actually have to tell UIKit that
you want to use CATiledLayer, because by default,

497
498
00:35:25,520 --> 00:35:31,150
when a UIView is created, that UIView is
backed by a plain CALayer, not a subclass.

498
499
00:35:31,150 --> 00:35:37,460
So in order to change to a CATiledLayer, you implement a
class method in your UIView subclass called "layer class."

499
500
00:35:37,460 --> 00:35:41,370
And you just return CATiledLayer class from that method.

500
501
00:35:41,370 --> 00:35:42,480
Once you've done that, that's it.

501
502
00:35:42,480 --> 00:35:46,570
UIKit is creating a CATiledLayer
for you to back your UIView.

502
503
00:35:46,570 --> 00:35:50,430
So all that's left to do is actually draw
your content and you do that in drawRect,

503
504
00:35:50,430 --> 00:35:53,080
the same as you would with any other
layer that you were trying to draw.

504
505
00:35:53,080 --> 00:35:58,790
Now you need two pieces of information in order
to accurately draw what you're being asked.

505
506
00:35:58,790 --> 00:36:04,020
The first is the rect that comprises the tiles
you actually are being asked to draw right now.

506
507
00:36:04,020 --> 00:36:08,270
And the second is the zoom scale
that you're being asked to draw at.

507
508
00:36:08,270 --> 00:36:09,590
So the rect is easy.

508
509
00:36:09,590 --> 00:36:10,830
We've got it right there, right?

509
510
00:36:10,830 --> 00:36:16,110
And as we already said, keep in mind, this rect
is in the original bounds of that CATiledLayer

510
511
00:36:16,110 --> 00:36:18,500
because the bounds don't change while you're zooming.

511
512
00:36:18,500 --> 00:36:24,270
So how do we get the zoom scale though, there's no
property or no perimeter telling us what that is?

512
513
00:36:24,270 --> 00:36:25,980
Well, this is a little tricky.

513
514
00:36:25,980 --> 00:36:29,030
You actually have to pull the zoom
scale out of the current graphics--

514
515
00:36:29,030 --> 00:36:33,510
no, the current transform matrix of the current
graphics context associated with this drawRect.

515
516
00:36:33,510 --> 00:36:35,490
So what does that mean?

516
517
00:36:35,490 --> 00:36:41,620
Well, you can call UIGraphicsGetCurrentContext to
find out which context you're being asked to draw into

517
518
00:36:41,620 --> 00:36:46,220
and that'll be a CGContextRef that you're actually
going to draw into using core graphics calls.

518
519
00:36:46,220 --> 00:36:54,700
Then from that, you can get the current transform matrix
by calling CGContextGetCTM on the context we just got.

519
520
00:36:54,700 --> 00:36:57,980
And that's going to return the
CGAffineTransform which is the transform

520
521
00:36:57,980 --> 00:37:00,640
that is applied to all drawings done in that context.

521
522
00:37:00,640 --> 00:37:03,360
This is the bit I talked about where even
though you stretch out by multiplying

522
523
00:37:03,360 --> 00:37:07,100
by 2 this affine transform is going to scale back down by 2.

523
524
00:37:07,100 --> 00:37:09,620
So you'll end up actually not stretching.

524
525
00:37:09,620 --> 00:37:15,330
And in fact, that's exactly what we're looking for to
figure out which level of detail we're being asked to draw.

525
526
00:37:15,330 --> 00:37:19,440
We need to figure out what that scale
is that's on the CGAffineTransform.

526
527
00:37:19,440 --> 00:37:25,610
Now, I already know because we're using a
UIScrollView that were being scaled uniformly

527
528
00:37:25,610 --> 00:37:27,780
in the horizontal and vertical dimension.

528
529
00:37:27,780 --> 00:37:32,490
So we can greatly simplify the act of figuring out what
our scale is because we know that we can only zoom in--

529
530
00:37:32,490 --> 00:37:35,540
or that-- we can look at either because they're the same.

530
531
00:37:35,540 --> 00:37:37,410
And we know that there's no rotation on this transform.

531
532
00:37:37,410 --> 00:37:39,600
If there was, you'd have to do a bit more math.

532
533
00:37:39,600 --> 00:37:45,350
So this transform will assume just as the
scale that's applied by the UIScrollView.

533
534
00:37:45,350 --> 00:37:49,440
Given that, we can pull the scale out of the .a component--

534
535
00:37:49,440 --> 00:37:57,820
or .a field of this CGAffineTransform .a and .d are the two
scale fields, not too very important what that is right now.

535
536
00:37:57,820 --> 00:37:58,990
But we'll just get it out.

536
537
00:37:58,990 --> 00:38:02,830
So transform.a is the CGFloat that represents
the scale we're being asked to draw it.

537
538
00:38:02,830 --> 00:38:04,040
And that's it.

538
539
00:38:04,040 --> 00:38:05,940
We now have the rect we're being asked to draw.

539
540
00:38:05,940 --> 00:38:09,060
Make sure that you only draw that rect or
else you've negated the entire, you know,

540
541
00:38:09,060 --> 00:38:11,950
benefit of doing this because it's
only asking you to draw what's visible

541
542
00:38:11,950 --> 00:38:16,400
on screen and we also know what scale to draw in.

542
543
00:38:16,400 --> 00:38:18,840
So we can now draw our tiles.

543
544
00:38:18,840 --> 00:38:23,190
Now, I see some of you guys staring at me
and saying, "I tried this, didn't work."

544
545
00:38:23,190 --> 00:38:25,700
Well, that was actually true in iPhone OS 3.0.

545
546
00:38:25,700 --> 00:38:28,700
There was a little bit more that you
had to do in order to make that work.

546
547
00:38:28,700 --> 00:38:30,320
I've got a link to the tech note up here.

547
548
00:38:30,320 --> 00:38:36,510
If you want to deploy on iPhone OS 3.0, you can
check out this tech note at developer.apple.com.

548
549
00:38:36,510 --> 00:38:40,900
If you can't write it all down right now, you can
just search developer.apple.com for CATiledLayer.

549
550
00:38:40,900 --> 00:38:44,210
There're not a lot of references
so you can find it pretty quickly.

550
551
00:38:44,210 --> 00:38:45,780
But we'll ignore that for now.

551
552
00:38:45,780 --> 00:38:53,900
In iPhone OS or iOS 4, UIGraphicsGetCurrentContext as you
heard in the session earlier today is now thread safe.

552
553
00:38:53,900 --> 00:39:00,290
So even though CATiledLayer is going to call drawRect on
the background thread, that's now thread safe and you--

553
554
00:39:00,290 --> 00:39:03,500
you're UIGraphicsGetCurrentContext call will not be trampled

554
555
00:39:03,500 --> 00:39:06,490
by another drawRect happening on
your main thread simultaneously.

555
556
00:39:06,490 --> 00:39:09,790
Each one will have correctly their own current context.

556
557
00:39:09,790 --> 00:39:17,680
Also, UI image, UIColor, UIFont and the NSString
drawing additions in UIKit, they're also threadsafe now.

557
558
00:39:17,680 --> 00:39:21,410
So there's actually a lot of UIKit based
drawing that you can do in this drawRect even

558
559
00:39:21,410 --> 00:39:26,620
on your background thread that
CATiledLayer will call you on.

559
560
00:39:26,620 --> 00:39:31,510
So with that, let's have Eliza come back up and
want-- and make one final modification to her demo.

560
561
00:39:31,510 --> 00:39:39,180
[ Applause ]

561
562
00:39:39,180 --> 00:39:39,520
>> Eliza Block: Alright.

562
563
00:39:39,520 --> 00:39:41,680
So once again, we're going to start where we left off.

563
564
00:39:41,680 --> 00:39:48,260
We're going to modify this so that our zooming
scroll views instead of using image views as--

564
565
00:39:48,260 --> 00:39:51,890
in order to display an image, are going to use
a subclass of UIView that we're going to write

565
566
00:39:51,890 --> 00:39:55,190
in a moment and I called it a tiling view.

566
567
00:39:55,190 --> 00:40:00,740
Alright so before we get to the implementation of the
tiling view, there's one modification that we need to make

567
568
00:40:00,740 --> 00:40:03,440
to prepare to use tiles instead of full images.

568
569
00:40:03,440 --> 00:40:09,240
And that is-- this was a piece of
the demo that I didn't show you.

569
570
00:40:09,240 --> 00:40:15,810
But a part of configuring the zooming scroll view was
setting its content size for the zooming scroll view

570
571
00:40:15,810 --> 00:40:18,860
which we were setting to be the size
of the image that we were displaying.

571
572
00:40:18,860 --> 00:40:24,520
And conveniently, since we were displaying an entire
image, we could just grab the size right out of that image

572
573
00:40:24,520 --> 00:40:28,390
and use that to be the content
size of our zooming scroll view.

573
574
00:40:28,390 --> 00:40:33,640
Now, we don't want to open an entire image because
that was what was taking so long and making it--

574
575
00:40:33,640 --> 00:40:37,250
or delay when we were trying to page from page to page.

575
576
00:40:37,250 --> 00:40:42,760
So instead, we're going to not open the entire image
which means that in your own app, you would need some way

576
577
00:40:42,760 --> 00:40:46,870
to have access up front to the sizes of
the content that you're going to display.

577
578
00:40:46,870 --> 00:40:51,010
So I'm going to show you where
this change needs to take place.

578
579
00:40:51,010 --> 00:40:55,820
It's in this configurePage-forIndex method
that I keep calling, but I haven't shown you yet.

579
580
00:40:55,820 --> 00:40:58,200
So, let's scroll down to that method now.

580
581
00:40:58,200 --> 00:40:59,030
Here it is.

581
582
00:40:59,030 --> 00:41:00,010
It doesn't do much.

582
583
00:41:00,010 --> 00:41:05,750
It sets the index of the page which we used
if you remember for the subview tiling.

583
584
00:41:05,750 --> 00:41:10,870
It sets the frame for the page and it tells
the page to display an image which it looks

584
585
00:41:10,870 --> 00:41:13,610
up with this convenience imageAtIndex method.

585
586
00:41:13,610 --> 00:41:18,350
So this is the line we need to get rid of because we
don't want to be opening that whole image anymore instead,

586
587
00:41:18,350 --> 00:41:26,010
we're going to tell our page to display a tiled image
named something and it's going to use this name to figure

587
588
00:41:26,010 --> 00:41:32,120
out which tiles to load and we're also going to tell it
the size which I've added as metadata in this project

588
589
00:41:32,120 --> 00:41:36,670
because it's going to need to set the content size
on the scroll view and it's also going to need

589
590
00:41:36,670 --> 00:41:41,220
to correctly size our tiling view using that size.

590
591
00:41:41,220 --> 00:41:50,210
OK, so now with that done, we can switch over to
this tiling view implementation and we're going

591
592
00:41:50,210 --> 00:41:52,890
to do the steps that Josh already told you about.

592
593
00:41:52,890 --> 00:41:58,790
So first, we need to override the layer class method
to return a CATiledLayer so that this view is now going

593
594
00:41:58,790 --> 00:42:04,090
to be backed by a special CATiledLayer
rather than a regular CALayer.

594
595
00:42:04,090 --> 00:42:10,630
We also need to tell our view-- rather, tell the
TiledLayer in question how many levels of detail to display.

595
596
00:42:10,630 --> 00:42:14,330
So for that, I'm going to override initWithFrame.

596
597
00:42:14,330 --> 00:42:21,250
And in initWithFrame, I'm now going to grab the tiled layer
by asking for my own views layer property and I'm going

597
598
00:42:21,250 --> 00:42:23,820
to set the levels of-- the levels of detail to 4.

598
599
00:42:23,820 --> 00:42:29,510
Now what that means, is we're going to be asked in our
drawRect to draw at potentially four different scales.

599
600
00:42:29,510 --> 00:42:31,590
Each one is half the previous ones.

600
601
00:42:31,590 --> 00:42:35,700
So that the maximum scale is going to be
100 percent then we're going to get asked

601
602
00:42:35,700 --> 00:42:39,480
for 50 percent, 25 percent, and 12-1/2 percent tiles.

602
603
00:42:39,480 --> 00:42:43,240
And in fact, these images are so large
that you'll see that we only are going

603
604
00:42:43,240 --> 00:42:48,490
to need the 12-1/2 percent tiles for
quite a while as we first view them.

604
605
00:42:48,490 --> 00:42:53,120
So what is the drawRect look like?

605
606
00:42:53,120 --> 00:43:01,970
Alright so the first thing we're going to do is figure out
what is the scale that were currently being asked to draw at

606
607
00:43:01,970 --> 00:43:03,700
and I'm going to do that the way that Josh explained.

607
608
00:43:03,700 --> 00:43:10,310
We're going to get our current graphics context and
we're going to grab the scale out of that current context

608
609
00:43:10,310 --> 00:43:18,130
by getting the current transform matrix and
asking that transform for its A component.

609
610
00:43:18,130 --> 00:43:20,160
Alright, so now, we have our scale.

610
611
00:43:20,160 --> 00:43:24,100
We're also going to need-- in order to
figure out which tiles we need to draw

611
612
00:43:24,100 --> 00:43:26,320
in order to fill the rect that we've been passed.

612
613
00:43:26,320 --> 00:43:28,780
We're going to need to know how big the tiles are.

613
614
00:43:28,780 --> 00:43:31,400
And that's a property on CATiledLayer.

614
615
00:43:31,400 --> 00:43:37,000
So I will get my CATiledLayer and
I'll ask it for its tile size.

615
616
00:43:37,000 --> 00:43:40,550
Alright, so now comes the part that's perhaps the weirdest.

616
617
00:43:40,550 --> 00:43:47,990
It's not going to be good enough to use this tile size
as is because if we we're being asked to draw a scaled

617
618
00:43:47,990 --> 00:43:54,770
down version of our tiles, we need to adjust for the--
for the scale when we think about how big our tiles are.

618
619
00:43:54,770 --> 00:43:59,290
And the reason for that is what Josh explained
but I'll just talk about it briefly again.

619
620
00:43:59,290 --> 00:44:04,230
If we're being asked to draw at, say, the 50
percent scale, we still need to stretch those tiles

620
621
00:44:04,230 --> 00:44:07,820
out to fill the entire region of the original image.

621
622
00:44:07,820 --> 00:44:13,040
So although our tiles have less information in
them, we're going to stretch them out to be bigger

622
623
00:44:13,040 --> 00:44:15,510
than they really are to fill that full region.

623
624
00:44:15,510 --> 00:44:20,500
So we need to compensate for our
scale by adjusting our tile size.

624
625
00:44:20,500 --> 00:44:25,070
And we're going to do that by dividing
both the width and the height by the scale.

625
626
00:44:25,070 --> 00:44:31,410
So we're going to pretend that our tile size is
bigger as we get to smaller and smaller scales.

626
627
00:44:31,410 --> 00:44:39,640
So, alright, now that we've got our adjusted tile size, we
need to first figure out which of these tiles do we need

627
628
00:44:39,640 --> 00:44:42,100
in order to fill this rectangle that we've been passed.

628
629
00:44:42,100 --> 00:44:44,750
So this is again the same math that I did before.

629
630
00:44:44,750 --> 00:44:50,200
We're going to look at the rectangle that we need and we're
going to look at the top and bottom and left and right rows

630
631
00:44:50,200 --> 00:44:54,900
and columns of pixels and we're going to figure out which
tiles those are associated with and then we're going

631
632
00:44:54,900 --> 00:44:59,310
to iterate through the rows that we need
and draw all of the tiles that we need.

632
633
00:44:59,310 --> 00:45:04,060
So block of math calculating the
first column that we need of tiles

633
634
00:45:04,060 --> 00:45:09,370
and the last column and the first row and the last row.

634
635
00:45:09,370 --> 00:45:15,400
And now, we're just going to-- for each tile that
we need-- so for each row and within each row,

635
636
00:45:15,400 --> 00:45:19,780
for each column, we're going to draw that tile.

636
637
00:45:19,780 --> 00:45:22,950
OK, so I've got a convenience method
which will grab us the tile.

637
638
00:45:22,950 --> 00:45:27,900
What it does is it just looks at the scale, the row, and
the column and I've got a naming convention for my tiles

638
639
00:45:27,900 --> 00:45:36,050
that are saved as images here that will
grab us the right one for that purpose.

639
640
00:45:36,050 --> 00:45:41,140
Next, we need to calculate the rectangle that
we're going to use to draw this tile into.

640
641
00:45:41,140 --> 00:45:53,220
So the origin of the rectangle is just going to be the
column times the width of our adjusted tile size by the row

641
642
00:45:53,220 --> 00:45:55,380
that we're on times the height of the tile size.

642
643
00:45:55,380 --> 00:46:00,690
So we're going to move over and down by the appropriate
amount given what column and row that we're on.

643
644
00:46:00,690 --> 00:46:05,620
And the size of our rectangle is going
to just be the size of our tiles,

644
645
00:46:05,620 --> 00:46:12,010
but adjusted once again for the scale that we're drawing at.

645
646
00:46:12,010 --> 00:46:15,120
Alright, there's one caveat.

646
647
00:46:15,120 --> 00:46:17,230
This is going to cause some problems.

647
648
00:46:17,230 --> 00:46:19,650
Let me just show you a couple of these tiles.

648
649
00:46:19,650 --> 00:46:23,390
So, most of the tiles-- here's a
good example of our 12-1/2 percent.

649
650
00:46:23,390 --> 00:46:27,470
Here's a piece of a frog taking up a full tile.

650
651
00:46:27,470 --> 00:46:32,940
But the tile underneath this is actually only
a partial tile and the reason for that is just

651
652
00:46:32,940 --> 00:46:37,460
that my image is very unlikely to be
an exact multiple of my tile size.

652
653
00:46:37,460 --> 00:46:39,820
So you're always going to have at the bottom

653
654
00:46:39,820 --> 00:46:44,410
and at the right edge some partial tiles
that you don't want to stretch out.

654
655
00:46:44,410 --> 00:46:48,170
So if I were to draw going back to the code here.

655
656
00:46:48,170 --> 00:46:52,110
If I were to draw that partial tile
into the rectangle that I just computed,

656
657
00:46:52,110 --> 00:46:56,260
it would be stretched to fill the
entire square and it would look weird.

657
658
00:46:56,260 --> 00:46:59,190
It would look like your image was
kind of bleeding off at the edges.

658
659
00:46:59,190 --> 00:47:01,190
So we need to compensate for that.

659
660
00:47:01,190 --> 00:47:04,590
And we're going to do this by checking--
we kind of want to check,

660
661
00:47:04,590 --> 00:47:08,250
is the rectangle that we just computed,
is it going off of our bounds?

661
662
00:47:08,250 --> 00:47:09,520
Is it outside of our bounds?

662
663
00:47:09,520 --> 00:47:13,850
And if it is, then we need to truncate
it so that it stays within our bounds.

663
664
00:47:13,850 --> 00:47:19,330
And we can actually do that with one line of code just
by taking the rectangle intersection of our bounds

664
665
00:47:19,330 --> 00:47:21,670
and the tile rect that we're about to draw.

665
666
00:47:21,670 --> 00:47:24,750
So then we can just go ahead.

666
667
00:47:24,750 --> 00:47:28,800
Draw our tile and this is all you would really need to do.

667
668
00:47:28,800 --> 00:47:33,820
For demonstration purposes I'm going to add some
white lines over the tiles so that when I build this,

668
669
00:47:33,820 --> 00:47:37,520
you'll be able to see when we change
from one tile size to the next.

669
670
00:47:37,520 --> 00:47:42,360
So there are just a couple of lines that draw
white border around the tile that we just drew.

670
671
00:47:42,360 --> 00:47:49,850
OK, so let me just go ahead and run this.

671
672
00:47:49,850 --> 00:47:54,890
Alright, so we've got-- what we're
seeing here is the 12-1/2 percent scale.

672
673
00:47:54,890 --> 00:48:02,590
And you can see that you only need a total of actually four
tiles in order to draw the entire 12-1/2 percent image.

673
674
00:48:02,590 --> 00:48:11,560
As I zoom in, it razzed up to 25 percent and then as
I continue to zoom in, we get the 50 percent tiles,

674
675
00:48:11,560 --> 00:48:15,290
and finally we-- the 100 percent
tiles, look how big these images are.

675
676
00:48:15,290 --> 00:48:17,810
So here's the level of detail that we've got.

676
677
00:48:17,810 --> 00:48:23,270
You can see that at a 100 percent, this image
is huge and if you can imagine the entire image,

677
678
00:48:23,270 --> 00:48:27,360
how many of these 100 percent tiles are needed
to make-- to construct the entire image?

678
679
00:48:27,360 --> 00:48:31,090
That was what we were loading in the
previous version before we started tiling.

679
680
00:48:31,090 --> 00:48:34,990
We were loading all of the 100 percent
tiles in the form of one image.

680
681
00:48:34,990 --> 00:48:39,940
And then we were scaling that down to fit
the screen which was extraordinarily wasteful

681
682
00:48:39,940 --> 00:48:42,810
and that's why we were using so much memory.

682
683
00:48:42,810 --> 00:48:47,190
So let me just test this by scrolling around.

683
684
00:48:47,190 --> 00:48:48,700
I can scroll really fast.

684
685
00:48:48,700 --> 00:48:54,610
I can zoom in again and my center
ring still works even if I zoom out.

685
686
00:48:54,610 --> 00:48:57,770
So how much memory are we using now?

686
687
00:48:57,770 --> 00:49:04,650
Switch back to the activity monitor
and I'll just zoom in on that.

687
688
00:49:04,650 --> 00:49:14,060
A total of 16 megabytes of real memory [background
applause] even though I've zoomed in and out a ton.

688
689
00:49:14,060 --> 00:49:17,290
[Applause] Great. And that's all there is to it, so back to Josh.

689
690
00:49:17,290 --> 00:49:23,490
[ Applause ]

690
691
00:49:23,490 --> 00:49:24,520
>> Josh Shaffer: I got it.

691
692
00:49:24,520 --> 00:49:26,510
Alright, thanks Eliza.

692
693
00:49:26,510 --> 00:49:28,980
So that's pretty much there is to it, right?

693
694
00:49:28,980 --> 00:49:33,080
[Laughter] Simple, it's five lines of code.

694
695
00:49:33,080 --> 00:49:38,210
>> Josh Shaffer: Sample code is
available either now or soon after.

695
696
00:49:38,210 --> 00:49:43,380
It's already been gone through and will be up on the web,
available for download and also associated with the session

696
697
00:49:43,380 --> 00:49:45,420
through the developer-- WWDC, attendee site.

697
698
00:49:45,420 --> 00:49:51,140
If you have any other questions, Bill Dudney
is the Application Frameworks Evangelist.

698
699
00:49:51,140 --> 00:49:56,790
It's a long URL but UIScrollView has a whole class
reference that has all kinds of additional information

699
700
00:49:56,790 --> 00:50:01,030
about scroll view, and of course,
the Apple Developer Forums.

700
701
00:50:01,030 --> 00:50:04,540
There are a couple of related sessions later this week.

701
702
00:50:04,540 --> 00:50:10,700
If you're interested in how the photos
application does detection of taps and double taps

702
703
00:50:10,700 --> 00:50:13,870
and two-finger taps to do zooming in and out on images.

703
704
00:50:13,870 --> 00:50:18,900
There's a whole new framework for
doing it in iPhone OS 3.2 and 4.0.

704
705
00:50:18,900 --> 00:50:23,970
And that's the-- We're going to talk about in a Simplifying
Touch Event Handling with Gesture Recognizer session.

705
706
00:50:23,970 --> 00:50:26,530
And also, if you want more information about table views

706
707
00:50:26,530 --> 00:50:29,470
and how you can display just those
vertically scrolling bits of content.

707
708
00:50:29,470 --> 00:50:33,580
The Mastering Table View session is on Thursday at 11:30.

708
709
00:50:33,580 --> 00:50:34,930
Both of those are here.

709
710
00:50:34,930 --> 00:50:38,650
The Gesture Recognizer is tomorrow at 3:15.

710
711
00:50:38,650 --> 00:50:39,750
So that's about it.

711
712
00:50:39,750 --> 00:50:43,670
The only thing I'd like to say is, you
really don't have to write your own.

712
713
00:50:43,670 --> 00:50:45,400
You don't have to go looking for third party frameworks.

713
714
00:50:45,400 --> 00:50:48,900
You don't have to start from scratch with UIView.

714
715
00:50:48,900 --> 00:50:50,040
That's all.

715
716
00:50:50,040 --> 00:50:51,540
So, thanks a lot.

716
