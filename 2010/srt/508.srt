1
00:00:07,270 --> 00:00:08,120
>> Hi everyone.

1
2
00:00:08,120 --> 00:00:09,140
My name is Paul.

2
3
00:00:09,140 --> 00:00:13,770
And this is Adding Touch and Gesture
Detection to Web Pages on iPhone OS.

3
4
00:00:13,770 --> 00:00:16,570
I'm an engineer on Safari for iOS.

4
5
00:00:16,570 --> 00:00:18,810
Why are you here today?

5
6
00:00:18,810 --> 00:00:24,130
You're here because you have a website for
iPad, iPhone or you're thinking of building one.

6
7
00:00:24,130 --> 00:00:26,670
And you want it to feel great.

7
8
00:00:26,670 --> 00:00:28,330
iPad, iPhone, they're amazing.

8
9
00:00:28,330 --> 00:00:30,810
They let you hold the web in your hands.

9
10
00:00:30,810 --> 00:00:34,180
But maybe what's missing is you
can't touch your web content.

10
11
00:00:34,180 --> 00:00:39,390
Your users, your customers, and you want to be able to
build web content for fingers, things that you can move

11
12
00:00:39,390 --> 00:00:44,010
around the screen just by dragging them,
pinch to zoom or rotate with two fingers.

12
13
00:00:44,010 --> 00:00:48,480
We can do these things using just web
technologies, HTML, CSS, JavaScript.

13
14
00:00:48,480 --> 00:00:51,430
You don't need Objective-C, you don't a native application.

14
15
00:00:51,430 --> 00:00:52,800
We'll talk about how you can do that today.

15
16
00:00:52,800 --> 00:01:01,880
And we can build really amazing, rich web applications
for these platforms for iPhone, iPad, iPod touch.

16
17
00:01:01,880 --> 00:01:05,630
Things that when they're sitting on the
home screen of your customer's phones

17
18
00:01:05,630 --> 00:01:08,690
and devices, they feel just like native applications.

18
19
00:01:08,690 --> 00:01:12,500
We'll talk about some tips, techniques
and ways we can do that.

19
20
00:01:12,500 --> 00:01:14,420
So, we're going to cover three main things today.

20
21
00:01:14,420 --> 00:01:18,150
We're going to talk about the touch
event API and the touch event model.

21
22
00:01:18,150 --> 00:01:22,350
What touch events are, how they get delivered
to your application, how you use them.

22
23
00:01:22,350 --> 00:01:27,800
We're going to talk about building controls, reusable
interface widgets, a few really rich controllers

23
24
00:01:27,800 --> 00:01:31,660
that aren't part of the standard HTML5 repertoire.

24
25
00:01:31,660 --> 00:01:35,900
And along the way we're going to be using the
Document Object Model and some CSS transforms

25
26
00:01:35,900 --> 00:01:40,010
to build some really nice, complex, rich interfaces.

26
27
00:01:40,010 --> 00:01:44,520
So, hopefully everyone here is already
familiar with HTML, JavaScript, and CSS.

27
28
00:01:44,520 --> 00:01:48,890
This is going to be a very code heavy
presentation, but don't worry about trying

28
29
00:01:48,890 --> 00:01:51,420
to copy everything down in your notes, in your laptops.

29
30
00:01:51,420 --> 00:01:55,270
All the sample code that's presented here on
the slides today is attached to the session.

30
31
00:01:55,270 --> 00:01:57,610
You can get it from the WWDC Attendee site later.

31
32
00:01:57,610 --> 00:02:02,400
And hopefully you're familiar with the
basics of the Document Object Model.

32
33
00:02:02,400 --> 00:02:07,560
Now, you don't need to know the 15 parameters you need
to use in order to create a mouse event programmatically.

33
34
00:02:07,560 --> 00:02:16,190
Hopefully though you're able to use a document.get
ElementById to pull a DOM node out of a HTML document.

34
35
00:02:16,190 --> 00:02:18,620
So let's talk about touch events.

35
36
00:02:18,620 --> 00:02:20,250
The touch event API.

36
37
00:02:20,250 --> 00:02:22,170
Why do we even have these touch events?

37
38
00:02:22,170 --> 00:02:23,870
We already have mouse events.

38
39
00:02:23,870 --> 00:02:27,900
Why do we need a separate set of
events to describe your fingers?

39
40
00:02:27,900 --> 00:02:31,400
And the answer is your fingers are different from mice.

40
41
00:02:31,400 --> 00:02:33,220
There's a couple really big differences.

41
42
00:02:33,220 --> 00:02:35,900
First, you have more than one finger.

42
43
00:02:35,900 --> 00:02:38,240
Most computers only have one mouse.

43
44
00:02:38,240 --> 00:02:41,640
Second, you can remove your fingers
entirely from the equation.

44
45
00:02:41,640 --> 00:02:46,180
You can lift your fingers off the screen and put
them down in a completely different location.

45
46
00:02:46,180 --> 00:02:47,330
I'm talking too much.

46
47
00:02:47,330 --> 00:02:48,880
Let me show you what I'm talking about.

47
48
00:02:48,880 --> 00:02:50,680
And I have this really simple demo.

48
49
00:02:50,680 --> 00:02:53,920
It's got these three bubbles, mouse
down, mouse move, mouse up.

49
50
00:02:53,920 --> 00:02:58,290
And every time this page receives one of those
events from the browser, they're going to light up.

50
51
00:02:58,290 --> 00:03:02,960
So if I move the mouse around the screen,
we'll get a series of mouse-move events.

51
52
00:03:02,960 --> 00:03:08,530
And if I click, we'll get a mouse-down
event, followed by a mouse-up event.

52
53
00:03:08,530 --> 00:03:13,050
Now, on an iPad, iPhone or iPod touch
it works a little bit differently.

53
54
00:03:13,050 --> 00:03:17,600
Ok, I've got the exact same page loaded here on my iPad.

54
55
00:03:17,600 --> 00:03:18,610
Thank you.

55
56
00:03:18,610 --> 00:03:23,240
And I'm going to tap on the screen to click.

56
57
00:03:23,240 --> 00:03:26,360
And what happens is we get all
three of those events at once.

57
58
00:03:26,360 --> 00:03:31,410
We get a mouse move and a mouse down and
a mouse up all delivered at the same time.

58
59
00:03:31,410 --> 00:03:36,950
And in fact, if you notice, if I
tap there's a little bit of a delay.

59
60
00:03:36,950 --> 00:03:41,620
Safari for iOS needs just a brief second
to figure out what the user's trying to do.

60
61
00:03:41,620 --> 00:03:44,790
Is the user going to double tap to zoom in to an element?

61
62
00:03:44,790 --> 00:03:46,930
Is the user going to pan the page?

62
63
00:03:46,930 --> 00:03:51,070
It needs just that really brief delay to figure
out if we're trying to click on something

63
64
00:03:51,070 --> 00:03:54,650
or if we're using some other sort of gesture.

64
65
00:03:54,650 --> 00:03:57,870
So mouse events are different than touch events.

65
66
00:03:57,870 --> 00:04:01,610
Now I have another page right here with the touch events.

66
67
00:04:01,610 --> 00:04:03,750
Touch events are different than mouse events.

67
68
00:04:03,750 --> 00:04:07,570
Safari doesn't take any time to look at
the touches and figure out what's going on.

68
69
00:04:07,570 --> 00:04:09,350
It delivers them immediately.

69
70
00:04:09,350 --> 00:04:14,450
So if I place my finger down on the screen,
we'll immediately receive a touch startevent.

70
71
00:04:14,450 --> 00:04:19,480
And as I move my finger around the screen,
we'll receive a series of touchmove events.

71
72
00:04:19,480 --> 00:04:23,640
And when I lift my finger off the
screen, we'll receive a touchend event.

72
73
00:04:23,640 --> 00:04:26,400
These are dispatched to your web content first.

73
74
00:04:26,400 --> 00:04:29,220
You get a first crack at all of these input events.

74
75
00:04:29,220 --> 00:04:32,010
Now we have more than one finger,
I've mentioned this already.

75
76
00:04:32,010 --> 00:04:35,810
And we'll receive these events for each
finger and they might be interleaved.

76
77
00:04:35,810 --> 00:04:39,660
So if I put one finger down, I receive
a touchstart for that first finger.

77
78
00:04:39,660 --> 00:04:43,810
I put another finger down, I'll receive
a touchstart for that second finger.

78
79
00:04:43,810 --> 00:04:46,860
Then I'll receive touchmoves as
my fingers move on the screen.

79
80
00:04:46,860 --> 00:04:49,220
And touchend when I lift them.

80
81
00:04:49,220 --> 00:04:52,720
Now there's a fourth event on this
screen and it's called touchcancel.

81
82
00:04:52,720 --> 00:04:54,950
Touchcancel means something unusual kind of happened.

82
83
00:04:54,950 --> 00:04:56,620
Touches were interrupted.

83
84
00:04:56,620 --> 00:05:02,850
Maybe you got a phone call or you
hit the screen with your whole hand.

84
85
00:05:02,850 --> 00:05:04,990
Normally that works.

85
86
00:05:04,990 --> 00:05:07,520
Apparently I can't be unusual enough today.

86
87
00:05:07,520 --> 00:05:09,650
Touchcancel means something unusual happened.

87
88
00:05:09,650 --> 00:05:11,370
Your touches were interrupted.

88
89
00:05:11,370 --> 00:05:14,080
Basically all the touches are being reset.

89
90
00:05:14,080 --> 00:05:17,390
So if you're keeping track of any
state, you need to reset that.

90
91
00:05:17,390 --> 00:05:22,920
So I talked about four basic events in the touch event
model, four events that are delivered to your page.

91
92
00:05:22,920 --> 00:05:27,580
There's touchstart, that gets sent every time
a finger is placed on the screen; touchmove,

92
93
00:05:27,580 --> 00:05:34,650
gets sent every time a finger moves on the screen; touchend
when a finger is removed from the screen; and touchcancel,

93
94
00:05:34,650 --> 00:05:38,900
touches have been interrupted,
reset all of your state, start over.

94
95
00:05:40,690 --> 00:05:44,080
Using all of these things, we can build a button.

95
96
00:05:44,080 --> 00:05:48,940
"But wait," all of you are saying, "We have buttons.

96
97
00:05:48,940 --> 00:05:49,790
We have lots of buttons.

97
98
00:05:49,790 --> 00:05:55,030
We have input buttons and the button in element, why,
why do we need to build a button with touch events?"

98
99
00:05:55,030 --> 00:05:59,450
I can think of two reasons we might want to
build our own custom button with touch events.

99
100
00:05:59,450 --> 00:06:03,420
First, remember how there is that really
short delay while Safari is trying to figure

100
101
00:06:03,420 --> 00:06:06,970
out if you're trying to click on an element or pan around?

101
102
00:06:06,970 --> 00:06:09,610
If we use touch events, we get first crack at those events

102
103
00:06:09,610 --> 00:06:13,410
and we can build something that
responds immediately to user input.

103
104
00:06:13,410 --> 00:06:16,760
Second, all those mouse events come at once.

104
105
00:06:16,760 --> 00:06:20,240
If we want to build a button that say
looks depressed when you're pressing

105
106
00:06:20,240 --> 00:06:23,080
down on it, we'll need to use touch events for that.

106
107
00:06:23,080 --> 00:06:27,400
So, the markup for this is going to be really simple.

107
108
00:06:27,400 --> 00:06:29,270
We're going to build a button out of a div.

108
109
00:06:29,270 --> 00:06:33,030
You can use a button or an input element
if you'd like to be a little more semantic,

109
110
00:06:33,030 --> 00:06:35,470
but that brings with it some default browser style.

110
111
00:06:35,470 --> 00:06:39,280
For this example, we're just going to use a div element.

111
112
00:06:39,280 --> 00:06:43,720
And in the JavaScript side, we need a callback,
something that happens when that button is tapped.

112
113
00:06:43,720 --> 00:06:49,170
We could show or hide another part of the user
interface or take the user to a different page.

113
114
00:06:49,170 --> 00:06:53,910
Whatever happens when we tap that
button, that's our callback method.

114
115
00:06:53,910 --> 00:06:59,950
Then we'll use document.getElementById to find that
button on the DOM, hold onto a reference for the element

115
116
00:06:59,950 --> 00:07:04,500
and we'll add an event listener, touchstart
seems like a natural place to start.

116
117
00:07:04,500 --> 00:07:08,690
We'll pass in the callback so that when
we tap that button, we do something.

117
118
00:07:08,690 --> 00:07:10,460
Let's take a look at how this works.

118
119
00:07:10,460 --> 00:07:14,120
So this is a button, very simple,
it's a div with a touch start handler.

119
120
00:07:14,120 --> 00:07:18,460
And I'm going to place my finger
on it and the button was tapped.

120
121
00:07:18,460 --> 00:07:20,040
But that doesn't really feel right.

121
122
00:07:20,040 --> 00:07:23,040
The button is tapped as soon as I
put my finger down on the screen.

122
123
00:07:23,040 --> 00:07:27,100
Normally we want to put our finger down,
wait and then when we lift our finger,

123
124
00:07:27,100 --> 00:07:29,300
that's when we want the event to be dispatched.

124
125
00:07:29,300 --> 00:07:32,540
So we'll make a really quick modification to the code.

125
126
00:07:32,540 --> 00:07:39,020
Instead of registering on touchstart, let's listen
for a touchend event and see how that works instead.

126
127
00:07:39,020 --> 00:07:42,430
Modified button, I can place my finger down on the button

127
128
00:07:42,430 --> 00:07:46,020
and then when I lift my finger, we
get our callback function called.

128
129
00:07:46,020 --> 00:07:49,000
That feels a lot more natural.

129
130
00:07:49,000 --> 00:07:52,720
So far, there's nothing that complicated about this button.

130
131
00:07:52,720 --> 00:07:56,120
It doesn't really do much, it doesn't do any of
the really cool things that I said we could do,

131
132
00:07:56,120 --> 00:07:59,300
like make it look depressed when we're pressing down on it.

132
133
00:07:59,300 --> 00:08:01,930
And our code is already starting to get a little messy.

133
134
00:08:01,930 --> 00:08:06,670
We're pulling out elements individually, we're
registering these sort of floating methods.

134
135
00:08:06,670 --> 00:08:08,130
We want to keep our code clean.

135
136
00:08:08,130 --> 00:08:13,990
We want to keep it reusable, especially with touch
events where we have to keep track of a lot of details.

136
137
00:08:13,990 --> 00:08:16,000
So let's wrap it all up into a JavaScript class.

137
138
00:08:16,000 --> 00:08:22,700
I have a constructor, capital B button it takes
in 2 parameters, an elementID and a callback.

138
139
00:08:22,700 --> 00:08:28,650
We'll use the exact same getelementbyID to pull
the element out of the DOM, store it for later use.

139
140
00:08:28,650 --> 00:08:30,330
We'll keep the callback around for later use.

140
141
00:08:30,330 --> 00:08:35,070
And then we'll add our event listener
near a touchstart and touchend.

141
142
00:08:35,070 --> 00:08:38,770
There is something kind of unusual
about this form of addEventListener.

142
143
00:08:38,770 --> 00:08:41,170
Normally addEventListener takes three properties.

143
144
00:08:41,170 --> 00:08:45,850
It takes the name of the event, it takes
the callback method and then it takes

144
145
00:08:45,850 --> 00:08:49,160
in this false Boolean that we always pass in.

145
146
00:08:49,160 --> 00:08:50,910
But here I'm passing in an object.

146
147
00:08:50,910 --> 00:08:52,590
I'm passing in this.

147
148
00:08:52,590 --> 00:08:55,150
This is a somewhat unusual form of addEventListener.

148
149
00:08:55,150 --> 00:09:01,930
But what happens is if you register events
passing in an object, when that event occurs,

149
150
00:09:01,930 --> 00:09:05,980
the handleEvent method, it's a special name, handleEvent.

150
151
00:09:05,980 --> 00:09:08,920
That gets called on the object in question.

151
152
00:09:08,920 --> 00:09:13,740
So instead of having to keep around the
closure and store this and put it into self

152
153
00:09:13,740 --> 00:09:21,770
and create anonymous inline function so we can call on the
right object later, this is one way we can get around that.

153
154
00:09:21,770 --> 00:09:24,940
I want to do something kind of tricky
to keep our code a little simple.

154
155
00:09:24,940 --> 00:09:31,360
Event.type on a DOM event is the name of the
event, touchstart or touchend, something like that.

155
156
00:09:31,360 --> 00:09:39,060
I'm using subscript notation to look on this on our button
instance to find a property named touchstart or touchend.

156
157
00:09:39,060 --> 00:09:41,830
And then I'm going to make sure it's a function.

157
158
00:09:41,830 --> 00:09:45,090
And if it is, I'm going to call it.

158
159
00:09:45,090 --> 00:09:50,610
This is a bit unusual but what this means is we don't
have to sit around and register touchstart handler

159
160
00:09:50,610 --> 00:09:57,510
for touchstart events and touchend handler for touchend
events on our, on our button class, on our prototype,

160
161
00:09:57,510 --> 00:09:59,990
we just create methods called touchstart and touchend.

161
162
00:09:59,990 --> 00:10:03,410
And those get called when we get our events.

162
163
00:10:03,410 --> 00:10:07,120
In order to do our highlighted state,
I'm just going to set a classing,

163
164
00:10:07,120 --> 00:10:09,770
add a new class highlighted on the actual element.

164
165
00:10:09,770 --> 00:10:12,080
Then in CSS we can do whatever we need to do.

165
166
00:10:12,080 --> 00:10:18,650
We can change the background image or make it a
different color or make it explode into 1000 tiny pieces.

166
167
00:10:18,650 --> 00:10:21,660
And on touchend we also want to call our callback function.

167
168
00:10:21,660 --> 00:10:29,480
In the CSS, I'm using something kind
of neat to create this lozenge shape.

168
169
00:10:29,480 --> 00:10:35,160
If you set a height and then use a -border-radius to
round off those edges, you can get a lozenge shape

169
170
00:10:35,160 --> 00:10:37,430
without having to use any sort of images.

170
171
00:10:37,430 --> 00:10:43,840
And then the background I'm using webkit-gradient to
create that sort of really nice, light to dark effect.

171
172
00:10:43,840 --> 00:10:48,630
When the button is highlighted, you just reverse
the gradient so it looks depressed instead.

172
173
00:10:48,630 --> 00:10:54,670
It's really simple way to create a button that looks
really nice, looks very visual without using any images.

173
174
00:10:54,670 --> 00:10:59,730
So let's take a look at how this button works now.

174
175
00:10:59,730 --> 00:11:09,050
With our new event handlers and that extra CSS styling,
when I tap down on the button, it looks depressed.

175
176
00:11:09,050 --> 00:11:14,460
It responds immediately and when I remove my
finger, it pops back out, the callback gets called.

176
177
00:11:14,460 --> 00:11:18,380
It's a really nice way of keeping your code simple.

177
178
00:11:18,380 --> 00:11:23,710
Now, we've handled touchstart and touchend, but
there's that fourth mysterious touchcancel event.

178
179
00:11:23,710 --> 00:11:25,850
We need to make sure we handle this.

179
180
00:11:25,850 --> 00:11:28,500
Touchcancel can happen for a variety of reasons.

180
181
00:11:28,500 --> 00:11:32,240
A JavaScript alert pops up, you get a phone
call while you're using your web page.

181
182
00:11:32,240 --> 00:11:36,620
And it's important that you reset any state,
anything that you're doing with touch events.

182
183
00:11:36,620 --> 00:11:40,740
So in this case, on touchcancel,
we'll simply remove that extra class.

183
184
00:11:40,740 --> 00:11:44,790
Otherwise you might come back from a phone
call and your button is stuck depressed.

184
185
00:11:44,790 --> 00:11:51,410
And that's one way that we can build a button
that responds immediately to touch events.

185
186
00:11:51,410 --> 00:11:54,300
So we've talked about the four basic touch events.

186
187
00:11:54,300 --> 00:11:56,990
Touchstart, fingers placed on the screen.

187
188
00:11:56,990 --> 00:11:59,580
Touchmove, a finger on the screen moves.

188
189
00:11:59,580 --> 00:12:02,570
Touchend, a finger has been removed from the screen.

189
190
00:12:02,570 --> 00:12:07,140
And touchcancel, touches have been
interrupted, don't forget to handle this.

190
191
00:12:07,140 --> 00:12:11,510
For the rest of the examples I'm not going to
walk through explicitly what I do on touchcancel.

191
192
00:12:11,510 --> 00:12:14,860
But look at the sample code and
make sure you handle touchcancel.

192
193
00:12:14,860 --> 00:12:17,990
But that's just the start.

193
194
00:12:17,990 --> 00:12:20,810
It tells us when fingers on the screen, what they're doing,

194
195
00:12:20,810 --> 00:12:23,960
but it doesn't really give us information
about the fingers themselves.

195
196
00:12:23,960 --> 00:12:27,040
What if we need to know where a finger is on the screen?

196
197
00:12:27,040 --> 00:12:33,790
If we think back to mouse events and we look at
a mouse event object, it looks pretty familiar.

197
198
00:12:33,790 --> 00:12:39,080
We can immediately look at that object and figure out
what button is down, the left or the right mouse button,

198
199
00:12:39,080 --> 00:12:43,590
where on the screen the cursor is, whether
or not any modifier keys are being held down.

199
200
00:12:43,590 --> 00:12:47,640
But if we look at a touch event, it looks really small.

200
201
00:12:47,640 --> 00:12:48,680
There's not much there.

201
202
00:12:48,680 --> 00:12:50,580
What is this changedTtouches?

202
203
00:12:50,580 --> 00:12:52,570
Where are my screen coordinates?

203
204
00:12:52,570 --> 00:12:58,790
The important thing to remember is that a touch event,
because we have multiple fingers, is a list of touches.

204
205
00:12:58,790 --> 00:13:01,890
What you're given is actually a list of touches.

205
206
00:13:01,890 --> 00:13:04,100
There are three lists actually.

206
207
00:13:04,100 --> 00:13:05,790
There's the touches list.

207
208
00:13:05,790 --> 00:13:10,090
That's all the touches that are
currently active or down on the screen.

208
209
00:13:10,090 --> 00:13:15,140
So if I have five fingers on the screen, those
five finger will be in the touches array.

209
210
00:13:15,140 --> 00:13:16,980
There's changedTouches.

210
211
00:13:16,980 --> 00:13:21,190
These are the fingers that have
changed since the last event.

211
212
00:13:21,190 --> 00:13:26,090
If I have two fingers on the screen and I'm
moving one, and the other is staying still,

212
213
00:13:26,090 --> 00:13:29,170
changedTouches will contain only the finger that's moving.

213
214
00:13:29,170 --> 00:13:31,970
And touches will contain both of them.

214
215
00:13:31,970 --> 00:13:34,440
And lastly there's targetTouches.

215
216
00:13:34,440 --> 00:13:36,950
These are touches that are inside the target element.

216
217
00:13:36,950 --> 00:13:43,170
So if I'm tapping on an image for example,
then the fingers that are inside the bounds

217
218
00:13:43,170 --> 00:13:45,410
of that image are inside of targetTouches.

218
219
00:13:45,410 --> 00:13:50,640
Now these lists are more or less array
like, so they have a length property.

219
220
00:13:50,640 --> 00:13:57,120
So you could look at e.touches.length, event.touches.length
and that's the number of fingers currently on the screen.

220
221
00:13:57,120 --> 00:14:00,800
Or if we wanted to get the first
finger inside the target element,

221
222
00:14:00,800 --> 00:14:03,870
we can use subscript notation, loop over them with arrays.

222
223
00:14:03,870 --> 00:14:09,330
All those sorts of things we're familiar with,
with arrays, will work on these touch lists.

223
224
00:14:09,330 --> 00:14:14,440
So a touch event is a list of objects, is a list of touches.

224
225
00:14:14,440 --> 00:14:17,450
Let's look at the individual touch.

225
226
00:14:17,450 --> 00:14:20,630
The first property on a touch is an identifier.

226
227
00:14:20,630 --> 00:14:25,670
This is a unique number that you can use to keep
track of a single finger across multiple events.

227
228
00:14:25,670 --> 00:14:29,700
Don't hold onto a touch object itself, you'll
prevent it from being garbage collected.

228
229
00:14:29,700 --> 00:14:34,440
Hold on to this number instead if you need
to keep track of an individual finger.

229
230
00:14:34,440 --> 00:14:35,620
Then there's target.

230
231
00:14:35,620 --> 00:14:37,690
This is the DOM node that is the target.

231
232
00:14:37,690 --> 00:14:41,460
So if we're tapping on that image,
then this will be the image.

232
233
00:14:41,460 --> 00:14:46,530
And then there's two sets of coordinates,
screen coordinates and page coordinates.

233
234
00:14:46,530 --> 00:14:54,510
If we tap here on this iPhone 4, screen
coordinates are the position of the tap

234
235
00:14:54,510 --> 00:14:57,470
from the top right hand corner of the screen.

235
236
00:14:57,470 --> 00:15:03,890
And if we double tap to zoom in say and we tap in
the same location, page coordinates are the location

236
237
00:15:03,890 --> 00:15:07,840
of that tap relative from the top
right hand corner of the page.

237
238
00:15:07,840 --> 00:15:09,670
This is in CSS pixels.

238
239
00:15:09,670 --> 00:15:13,150
So if you're going to be moving an
element around to respond to a tap,

239
240
00:15:13,150 --> 00:15:15,730
this is probably the set of coordinates you want to use.

240
241
00:15:15,730 --> 00:15:20,060
If you're simply interested in whether or not the
user is tapping in the top half or the bottom half

241
242
00:15:20,060 --> 00:15:22,590
of the screen, that's what screen coordinates are for.

242
243
00:15:22,590 --> 00:15:27,040
With all this information we can go on and
build another really cool control, a slider.

243
244
00:15:27,040 --> 00:15:32,020
Something that has a track and a
knob and we can move it around.

244
245
00:15:32,020 --> 00:15:33,980
Mark up is going to be really simple.

245
246
00:15:33,980 --> 00:15:39,570
We're going to use a container div and then inside of
that two divs, one for our track, one for our knob.

246
247
00:15:39,570 --> 00:15:41,670
We'll have classes so we can get to those.

247
248
00:15:41,670 --> 00:15:44,300
And then there's the constructor.

248
249
00:15:44,300 --> 00:15:49,910
We're going to bundle this up to an object just
like we did on the button so we can reuse it.

249
250
00:15:49,910 --> 00:15:56,400
We'll pull the main parent, the container div
out of the documents tree with getElementById.

250
251
00:15:56,400 --> 00:16:00,760
Then we'll pull the knob out by getting
getElementsByClassname, because we want to have more

251
252
00:16:00,760 --> 00:16:05,330
than one slider on the page, we need to use class
names and not IDs in order to pull these out.

252
253
00:16:05,330 --> 00:16:11,610
Let's also look at the width of that knob, offsetWidth
is the actual width of that inside the rendered tree.

253
254
00:16:11,610 --> 00:16:17,270
We'll use this to do a little bit of math so we
don't drag the knob off the end of the track.

254
255
00:16:17,270 --> 00:16:23,610
And then we'll also grab the bar out with
getElementsByClassname and look at its width too.

255
256
00:16:23,610 --> 00:16:27,360
The touchstart handler is going to be really simple.

256
257
00:16:27,360 --> 00:16:31,380
At the start, we're going to look at the
event and look into that targetTouches array.

257
258
00:16:31,380 --> 00:16:36,090
Remember targetTouches is the list of
fingers that is inside the target element.

258
259
00:16:36,090 --> 00:16:44,740
We'll grab the first finger and grab its page X
coordinate, location in CSS pixels on the page.

259
260
00:16:44,740 --> 00:16:49,930
And we'll store that and then we'll
call this method, this.moveKnobTo.

260
261
00:16:49,930 --> 00:16:53,750
We'll get to this, but this is where
we're actually going to do all the work.

261
262
00:16:53,750 --> 00:17:01,170
Then on touchmove, we're just going to call moveKnobTo
and again we're going to look at the targetTouches array,

262
263
00:17:01,170 --> 00:17:04,950
pull the first finger out, get its page location.

263
264
00:17:04,950 --> 00:17:10,270
The moveKnobTo method is where
all the work is going to be done.

264
265
00:17:10,270 --> 00:17:13,240
First, we need to figure out how far the finger is moved.

265
266
00:17:13,240 --> 00:17:19,510
So we stored that start X at the beginning
when we, we got our first touchstart.

266
267
00:17:19,510 --> 00:17:23,380
And we're just going to figure out how
far the finger is from where it started.

267
268
00:17:23,380 --> 00:17:26,760
Then we're going to do a little bit of math to make sure

268
269
00:17:26,760 --> 00:17:29,680
that we clamp the position of the
knob to the ends of the track.

269
270
00:17:29,680 --> 00:17:33,030
We don't want to be able to drag the
knob all the way off to the right.

270
271
00:17:33,030 --> 00:17:37,940
And then we'll just set the left
style property inline of the knob.

271
272
00:17:37,940 --> 00:17:41,410
And that's going to position it along the track.

272
273
00:17:41,410 --> 00:17:46,500
We'll hold onto the starting position for the next time we
call it through this loop and then we'll notify our callback

273
274
00:17:46,500 --> 00:17:52,110
and say now that the slider has been moved,
here's where it is, do whatever you need to do.

274
275
00:17:52,110 --> 00:17:58,040
Now, for performance reasons, instead of
setting the left property on that, on that knob,

275
276
00:17:58,040 --> 00:18:01,560
we might want to use this instead, a webkitTransform.

276
277
00:18:01,560 --> 00:18:05,260
Left will work, but if we want
the best possible performance,

277
278
00:18:05,260 --> 00:18:08,730
this is really important for building
user interface widgets.

278
279
00:18:08,730 --> 00:18:13,070
Use webkitTransform instead with a translate3d property.

279
280
00:18:13,070 --> 00:18:19,850
We'll construct a string, set the X transform
to the X offset and then Y and Z offsets to 0.

280
281
00:18:19,850 --> 00:18:26,030
Under certain conditions this will actually
trigger hardware compositing, so we'll reload,

281
282
00:18:26,030 --> 00:18:29,100
we'll offload the positioning of this knob to the GPU.

282
283
00:18:29,100 --> 00:18:30,980
It'll work super fast.

283
284
00:18:30,980 --> 00:18:37,010
And that's the basics of building
something that will track your finger.

284
285
00:18:37,010 --> 00:18:38,390
I've been talking too much.

285
286
00:18:38,390 --> 00:18:42,500
So, instead of showing you this myself, I'd
like to invite up Greg Bolsinga, my coworker.

286
287
00:18:42,500 --> 00:18:46,270
And he's going to show you these controls and
a few others in a demo we've been working on.

287
288
00:18:46,270 --> 00:18:47,510
Greg?

288
289
00:18:47,510 --> 00:18:51,050
[ Applause ]

289
290
00:18:51,050 --> 00:19:00,180
>> Hello, I'm Greg Bolsinga, I work
on iPhone or iOS, WebKit, and Safari.

290
291
00:19:00,180 --> 00:19:07,790
So with all those parts that Paul put together
for us, I built this little scrapbook application.

291
292
00:19:07,790 --> 00:19:11,040
It's just a web page, we have an image here.

292
293
00:19:11,040 --> 00:19:20,720
And what you can do to this is play with your
image and move it around with single touches.

293
294
00:19:20,720 --> 00:19:27,660
And I created this only using HTML, JavaScript, and CSS.

294
295
00:19:27,660 --> 00:19:32,660
The only non-text, non-code portions are these images.

295
296
00:19:32,660 --> 00:19:38,960
So the first thing that I set up was
playing with some of the CSS properties.

296
297
00:19:38,960 --> 00:19:43,440
And what I can do is set the border width of the picture.

297
298
00:19:43,440 --> 00:19:45,850
These are all regular CSS properties.

298
299
00:19:45,850 --> 00:19:50,300
I can set the border radius, if
you can see that curving down here.

299
300
00:19:50,300 --> 00:19:56,170
Another thing you can do is I played with the box shadow.

300
301
00:19:56,170 --> 00:20:01,670
I have this little scroller here where we could
see more properties that I could set on here.

301
302
00:20:01,670 --> 00:20:07,250
And with the box shadow we could
pop it out either direction.

302
303
00:20:07,250 --> 00:20:09,300
We'll move it down here.

303
304
00:20:09,300 --> 00:20:14,620
Put a little blur on it so it looks
pretty, looks blurry up there.

304
305
00:20:14,620 --> 00:20:17,030
And so we have our image.

305
306
00:20:17,030 --> 00:20:22,980
The other thing that I did with this is with
the multitouch I could move these things around

306
307
00:20:22,980 --> 00:20:27,270
and I'm setting the CSS transforms that Paul mentioned.

307
308
00:20:27,270 --> 00:20:31,060
And I'm just translating it here,
but we also support gesture events.

308
309
00:20:31,060 --> 00:20:39,460
So as soon as you put more than one finger down, I could
start rotating this image as well as scaling it in.

309
310
00:20:39,460 --> 00:20:44,550
And what I'll play with now is I have these masks.

310
311
00:20:44,550 --> 00:20:50,160
These masks are all HTML canvases.

311
312
00:20:50,160 --> 00:20:51,680
So I drew all these masks.

312
313
00:20:51,680 --> 00:20:57,990
I'm going to be using the same canvas that
drew these buttons as I'll have on here.

313
314
00:20:57,990 --> 00:21:04,210
So for example, I can mask the image with just a circle.

314
315
00:21:04,210 --> 00:21:15,180
Or I can pick other fun shapes like the star
and I could still interact with the image here.

315
316
00:21:15,180 --> 00:21:21,480
Zoom in and rotate it, even through the mask.

316
317
00:21:21,480 --> 00:21:28,930
And I'm going to take the mask off so
we can see the other images that I have.

317
318
00:21:28,930 --> 00:21:29,150
[ Silence ]

318
319
00:21:29,150 --> 00:21:30,660
Re-translate this.

319
320
00:21:30,660 --> 00:21:40,900
And what I have here is another little scroller
inside of a scroller and you could pick new images.

320
321
00:21:40,900 --> 00:21:44,160
And do the same fun effects with it.

321
322
00:21:44,160 --> 00:21:49,290
This will all, the code and the pictures
for this will all be up on our website.

322
323
00:21:49,290 --> 00:21:59,510
So again, that's all HTML, JavaScript, and CSS using touch
events, gesture events and CSS effects and transforms.

323
324
00:21:59,510 --> 00:22:06,160
[ Applause ]

324
325
00:22:06,160 --> 00:22:07,000
>> Thanks Greg.

325
326
00:22:07,000 --> 00:22:11,980
Greg mentioned this, but the only images in
that demo are the four photos on the thumbnails.

326
327
00:22:11,980 --> 00:22:17,840
Everything else was canvas, CSS,
really cool tricks like that.

327
328
00:22:17,840 --> 00:22:24,070
So Greg introduced something that I've been kind of
talking about a lot and these are multitouch devices.

328
329
00:22:24,070 --> 00:22:27,330
You can have more than one finger,
but we haven't talked about that yet.

329
330
00:22:27,330 --> 00:22:31,360
We haven't talked about dealing with a second finger.

330
331
00:22:31,360 --> 00:22:35,860
There's a separate set of events that you receive
once a second finger comes into the picture.

331
332
00:22:35,860 --> 00:22:40,500
And this is very much like the earlier event
demos, the button, the bubbles just highlight

332
333
00:22:40,500 --> 00:22:42,240
when we receive one of these events on the page.

333
334
00:22:42,240 --> 00:22:44,900
And there's three gesture events.

334
335
00:22:44,900 --> 00:22:48,910
Gesture events start once a second
finger is placed on the screen.

335
336
00:22:48,910 --> 00:22:50,630
So I'll place one finger on the screen.

336
337
00:22:50,630 --> 00:22:55,680
And when I place the second finger on the
screen, we receive a gesturestart event.

337
338
00:22:55,680 --> 00:23:01,340
And so then I have two fingers on the screen and I move
them around and receive a series of gesturechange events.

338
339
00:23:01,340 --> 00:23:05,850
And then when I remove a second
finger, we get a gestureend event.

339
340
00:23:05,850 --> 00:23:08,590
Now these events are not exclusive from touch events.

340
341
00:23:08,590 --> 00:23:11,550
We'll receive both at the same time.

341
342
00:23:11,550 --> 00:23:19,000
So here both touch events and gesture event bubbles
first finger on the screen will send a touchstart.

342
343
00:23:19,000 --> 00:23:25,110
Second finger on the screen will send a
gesturestart and a touchstart for the second finger.

343
344
00:23:25,110 --> 00:23:30,470
We'll receive both touchmoves and
gesturechanges as I move my fingers.

344
345
00:23:30,470 --> 00:23:35,290
And we'll receive touchends and gestureends
for all of those as I remove them.

345
346
00:23:35,290 --> 00:23:40,530
One more time, touchstart, second finger
sends both touchstart and gesturestart.

346
347
00:23:40,530 --> 00:23:42,340
These events are all interleaved.

347
348
00:23:42,340 --> 00:23:47,720
And gestureend and touchends when I remove those fingers.

348
349
00:23:47,720 --> 00:23:51,280
So there are three events in the gesture event model.

349
350
00:23:51,280 --> 00:23:54,670
Gesturestart, second finger on the screen.

350
351
00:23:54,670 --> 00:23:58,080
Gesturechange, something is going
on with those multiple fingers.

351
352
00:23:58,080 --> 00:24:01,260
Gestureend, second finger removed from the screen.

352
353
00:24:01,260 --> 00:24:05,930
There's one thing missing here you might notice,
gesturecancel, there is no gesturecancel.

353
354
00:24:05,930 --> 00:24:11,930
But because you receive both touch events and gesture
events at the same time, you still need to handle it,

354
355
00:24:11,930 --> 00:24:17,400
listen for touchcancel even if all
you're doing is gesture handling events.

355
356
00:24:17,400 --> 00:24:22,490
The gesture event object is actually really
simple and looks a lot more familiar.

356
357
00:24:22,490 --> 00:24:24,660
First, there's scale.

357
358
00:24:24,660 --> 00:24:27,430
Scale is multiplier, it's a float.

358
359
00:24:27,430 --> 00:24:32,390
If I put two fingers on the screen and they're 100
pixels apart, and I move those two fingers apart

359
360
00:24:32,390 --> 00:24:37,570
so they're now 200 pixels apart, then
that scale property is going to be 2.0.

360
361
00:24:37,570 --> 00:24:41,350
My fingers are twice as far as
when I put them on the screen.

361
362
00:24:41,350 --> 00:24:44,770
If I put my fingers down at 100
pixels apart and bring them together

362
363
00:24:44,770 --> 00:24:49,170
so they're only 50 pixels apart,
that scale is going to be 0.5.

363
364
00:24:49,170 --> 00:24:52,860
My fingers are half as far apart as they used to be.

364
365
00:24:52,860 --> 00:24:54,800
Then there's rotation.

365
366
00:24:54,800 --> 00:24:57,350
Rotation is, are you ready for this?

366
367
00:24:57,350 --> 00:25:01,230
Degrees clockwise relative to the starting position.

367
368
00:25:01,230 --> 00:25:07,780
So if I have 2 fingers and I rotate my fingers
like this, that rotation is going to be 90,

368
369
00:25:07,780 --> 00:25:12,010
90 degrees clockwise relative from the starting position.

369
370
00:25:12,010 --> 00:25:14,400
And then there's page coordinates.

370
371
00:25:14,400 --> 00:25:21,190
Again these are coordinates from the top right hand corner
of the page, they're in CSS pixels and this is the center

371
372
00:25:21,190 --> 00:25:24,990
of the gesture or the center of where all your fingers are.

372
373
00:25:24,990 --> 00:25:30,970
So with all of that, we now have the information
we need to build the rest of the picture frame.

373
374
00:25:30,970 --> 00:25:34,950
We've already basically built the
translation, the panning of the picture.

374
375
00:25:34,950 --> 00:25:40,750
That's just tracking fingers in their X and Y
coordinates, but the multitouch part which is new.

375
376
00:25:40,750 --> 00:25:44,080
The picture frame is actually deceptively easy to build.

376
377
00:25:44,080 --> 00:25:46,520
It contains only two parts.

377
378
00:25:48,630 --> 00:25:51,490
The image is actually larger than the frame.

378
379
00:25:51,490 --> 00:25:55,930
We can use something like overflow: none
on the frame to crop the image down.

379
380
00:25:55,930 --> 00:26:00,530
But the frame is a separate element that contains the image.

380
381
00:26:00,530 --> 00:26:01,670
It's just a div.

381
382
00:26:01,670 --> 00:26:05,870
We give it a class pictureFrame and
then underneath it is the image.

382
383
00:26:05,870 --> 00:26:09,530
That's it, they're the only two parts
to building this frame, two elements.

383
384
00:26:09,530 --> 00:26:12,620
When we set overflow: none on that frame, we crop the image.

384
385
00:26:12,620 --> 00:26:16,630
And when we do all these panning
effects and these rotation effects,

385
386
00:26:16,630 --> 00:26:19,630
all we're doing is we're moving the image behind the frame.

386
387
00:26:19,630 --> 00:26:21,620
The frame stays in the same place.

387
388
00:26:21,620 --> 00:26:26,560
We're scaling the image, applying these webkitTransforms.

388
389
00:26:26,560 --> 00:26:34,950
And when overflow: none is in effect, we get
this really nice sort of in frame editing effect.

389
390
00:26:34,950 --> 00:26:42,370
So the mark up is super simple, container
div, image on the inside of that.

390
391
00:26:42,370 --> 00:26:47,720
Our constructor is going to take just one parameter
element, we don't really have a callback for this.

391
392
00:26:47,720 --> 00:26:50,900
And we're going to hold on to a little more state.

392
393
00:26:50,900 --> 00:26:57,390
Gesture events, the information they report, the scale and
the rotation, they're relative to the start of the gesture.

393
394
00:26:57,390 --> 00:27:02,270
So we'll hold on both to the current scale
and rotation of the picture and the scale

394
395
00:27:02,270 --> 00:27:05,510
and the rotation when the gesture starts.

395
396
00:27:05,510 --> 00:27:08,330
And then we pull the image out with getElementsByTagName.

396
397
00:27:08,330 --> 00:27:11,500
And then we listen for gesturechange events.

397
398
00:27:11,500 --> 00:27:14,500
Again this is just for the rotation and the scaling.

398
399
00:27:14,500 --> 00:27:18,130
The panning we want to use touch events.

399
400
00:27:18,130 --> 00:27:21,480
Gesturechange is going to be really straight forward.

400
401
00:27:21,480 --> 00:27:24,070
We look at the scale of when we started the gesture.

401
402
00:27:24,070 --> 00:27:27,420
And we multiply it by the gesture scale.

402
403
00:27:27,420 --> 00:27:35,590
So if the image starts out at 200% and we bring our fingers
together so that the scale on the gesture event is 0.5,

403
404
00:27:35,590 --> 00:27:40,360
we multiply them and we shrink our
image back down to original size.

404
405
00:27:40,360 --> 00:27:46,100
Then rotation, there are degrees relative from
the starting location, so we just add that.

405
406
00:27:46,100 --> 00:27:49,240
And then we call this mysterious transformImage method.

406
407
00:27:49,240 --> 00:27:53,460
TransformImage is where we're actually going
to apply the properties and do the work.

407
408
00:27:53,460 --> 00:27:55,250
It's a single line.

408
409
00:27:55,250 --> 00:28:00,300
We're going to set an inline webkitTransform
style and build up this string.

409
410
00:28:00,300 --> 00:28:01,960
First we're going to translate the image.

410
411
00:28:01,960 --> 00:28:09,850
If we're positioning it 100 pixels left, 100 pixels
up, we're going to set both X and Y transforms there.

411
412
00:28:09,850 --> 00:28:12,030
Then we're going to scale the image.

412
413
00:28:12,030 --> 00:28:16,390
WebkitTransform takes in the same sort of
units that the gesture event will report.

413
414
00:28:16,390 --> 00:28:18,970
So it's easy just to translate this over into CSS.

414
415
00:28:18,970 --> 00:28:24,490
And then the rotation, the unit
for rotation is degrees, deg.

415
416
00:28:24,490 --> 00:28:28,780
And we're going to build up this string, that
concatenation is really kind of ugly in code.

416
417
00:28:28,780 --> 00:28:31,170
But what we're building is a string that looks like this.

417
418
00:28:31,170 --> 00:28:36,700
Translate3d, X and Y coordinate, scale, and rotate.

418
419
00:28:36,700 --> 00:28:37,580
And that's it.

419
420
00:28:37,580 --> 00:28:40,370
That's all we need to do to build our picture.

420
421
00:28:40,370 --> 00:28:45,270
All we need to do to handle scaling and rotation.

421
422
00:28:45,270 --> 00:28:48,390
I want to step back and talk about the DOM Event Model.

422
423
00:28:48,390 --> 00:28:54,790
All of these events, mouse events, touch events, gesture
events, these all fall under the system called DOM events.

423
424
00:28:54,790 --> 00:28:56,400
Here we have a DOM tree.

424
425
00:28:56,400 --> 00:29:01,030
There's two of these picture frame
controllers in the same document.

425
426
00:29:01,030 --> 00:29:07,430
And we're going to send an event down to say
we tap on the second picture frame control.

426
427
00:29:07,430 --> 00:29:14,420
So we have an event and using hit testing or something
like that, we figure out where this event is going.

427
428
00:29:14,420 --> 00:29:17,050
It's going to that second image in the document.

428
429
00:29:17,050 --> 00:29:19,000
The event is going to start at the top.

429
430
00:29:19,000 --> 00:29:22,720
It's going to start at your Window object,
from the browser and it's going to work its way

430
431
00:29:22,720 --> 00:29:24,860
down to the specific event it's trying to get to.

431
432
00:29:24,860 --> 00:29:26,710
It's going to work its way down to the <img>.

432
433
00:29:26,710 --> 00:29:29,360
This is called the capture phase.

433
434
00:29:29,360 --> 00:29:35,260
This event is going to be dispatched to every one of these
elements all the way from Window to Document, <html>,

434
435
00:29:35,260 --> 00:29:40,290
<body>, then eventually our picture frame
control, the containing <div>, and then the <img>.

435
436
00:29:40,290 --> 00:29:47,320
And any one of these elements that have a capture
phase event listener we'll get to handle this event.

436
437
00:29:47,320 --> 00:29:52,880
The event will reach our target element, the image, and
then it's going to start working its way back the other way.

437
438
00:29:52,880 --> 00:29:54,620
This is called the bubbling phase.

438
439
00:29:54,620 --> 00:29:59,920
The event starts at the most specific element
and starts working its way back up to the top.

439
440
00:29:59,920 --> 00:30:04,370
Once it reaches the top, returns
to the browser from whence it came.

440
441
00:30:04,370 --> 00:30:08,200
Normally we only work in the bubbling phase.

441
442
00:30:08,200 --> 00:30:10,520
Remember how addEventListener has three properties.

442
443
00:30:10,520 --> 00:30:15,170
It takes in the name of the event,
the callback or object and then false.

443
444
00:30:15,170 --> 00:30:17,180
We always just put false in there.

444
445
00:30:17,180 --> 00:30:23,560
That third Boolean is whether or not we're adding our
event listener to the capture phase or the bubble phase.

445
446
00:30:23,560 --> 00:30:29,280
If it's false, it's in the bubble phase and if
it's true, we're listening in the capture phase.

446
447
00:30:29,280 --> 00:30:30,310
We normally don't want that.

447
448
00:30:30,310 --> 00:30:36,600
We normally want to start from the most specific element
and then let event bubble up to less specific elements.

448
449
00:30:36,600 --> 00:30:39,220
But occasionally capture events are a really useful thing.

449
450
00:30:39,220 --> 00:30:42,410
If you're having a problem with a web
page and you're trying to debug it,

450
451
00:30:42,410 --> 00:30:45,480
you might want to add a capture event listener on document.

451
452
00:30:45,480 --> 00:30:51,120
It'll see basically every event
that goes down into your page.

452
453
00:30:51,120 --> 00:30:54,250
So with this in mind, let's go back to
these really cool controls we're building

453
454
00:30:54,250 --> 00:30:57,550
and we'll talk about this single finger scrolling pane.

454
455
00:30:57,550 --> 00:31:03,570
Now on desktop, if we want this area where we
have content and we can scroll it and it stays

455
456
00:31:03,570 --> 00:31:09,470
within this nice little frame, one way we might do
that is by using a div with overflow set to auto.

456
457
00:31:09,470 --> 00:31:14,220
The child contents larger than the,
than the div, we'll get scroll bars,

457
458
00:31:14,220 --> 00:31:17,420
we can use scroll wheels, all that sort of stuff.

458
459
00:31:17,420 --> 00:31:21,090
This actually works on iPhone and iOS.

459
460
00:31:21,090 --> 00:31:24,820
But you have to use two fingers
at once to scroll that content.

460
461
00:31:24,820 --> 00:31:26,240
It's not really discoverable.

461
462
00:31:26,240 --> 00:31:28,300
A lot of people have trouble finding that.

462
463
00:31:28,300 --> 00:31:33,270
So instead we're going to build an area that we can
scroll using just one finger, using touch events.

463
464
00:31:33,270 --> 00:31:37,620
So the mark up or the actual implementation
for this is extremely simple.

464
465
00:31:37,620 --> 00:31:39,810
In fact we've basically already built it.

465
466
00:31:39,810 --> 00:31:41,100
It's got two parts.

466
467
00:31:41,100 --> 00:31:43,970
It has the content underneath.

467
468
00:31:43,970 --> 00:31:47,560
The child layer, the content layer I suppose we can call it.

468
469
00:31:47,560 --> 00:31:49,730
This contains whatever we need it to contain.

469
470
00:31:49,730 --> 00:31:56,340
It could be lists, it could be images, it could be other
scrolling panes because we're programs, we like recursion,

470
471
00:31:56,340 --> 00:31:59,190
we like putting things into things because we can.

471
472
00:31:59,190 --> 00:32:01,670
And then outside of that there's the panel container.

472
473
00:32:01,670 --> 00:32:07,240
This'll have overflow: none set, it'll stay fixed
on the page and when we receive touch events,

473
474
00:32:07,240 --> 00:32:13,170
we'll simply translate that content layer, we'll
move that content layer around using webkitTransform.

474
475
00:32:13,170 --> 00:32:17,130
And we'll get a really nice single finger scrolling area.

475
476
00:32:17,130 --> 00:32:19,430
The mark up we're going to use for this is really simple.

476
477
00:32:19,430 --> 00:32:22,910
There's an outer scrollable class,
this is the, this is the frame.

477
478
00:32:22,910 --> 00:32:25,740
And then inside of that is our content layer.

478
479
00:32:25,740 --> 00:32:29,240
It can contain whatever we want it to contain.

479
480
00:32:29,240 --> 00:32:30,620
So let's take a look at this.

480
481
00:32:30,620 --> 00:32:35,810
I have here one of these scrolling views,
these scroll panels, scroll containers.

481
482
00:32:35,810 --> 00:32:39,190
And inside of it, it's a list, it just counts from 1 to 8.

482
483
00:32:39,190 --> 00:32:48,520
And I'm going to use a single finger and start
scrolling and that doesn't work very well.

483
484
00:32:48,520 --> 00:32:54,550
As I'm scrolling, as I'm trying to scroll
this container, the page is panning too.

484
485
00:32:54,550 --> 00:32:55,700
What's going on here?

485
486
00:32:55,700 --> 00:33:00,420
It really helps if we go back to the DOM Event
Model, the DOM tree to understand what's going on.

486
487
00:33:00,420 --> 00:33:05,820
This is a DOM tree where we have two of these scrolling
containers and we're receiving a touchmove event.

487
488
00:33:05,820 --> 00:33:08,730
Touchmove is how we're panning that content.

488
489
00:33:08,730 --> 00:33:15,120
So the touchmove starts the Content, it moves to the
Container, we actually do something like scroll our content.

489
490
00:33:15,120 --> 00:33:16,520
And then the event keeps going.

490
491
00:33:16,520 --> 00:33:17,810
It keeps bubbling.

491
492
00:33:17,810 --> 00:33:21,780
It goes all the way back up to the
browser and the browser gets to handle it.

492
493
00:33:21,780 --> 00:33:23,690
Safari gets a crack at that event.

493
494
00:33:23,690 --> 00:33:29,390
Now Safari's default action, what Safari usually
does on a touchmove event is it pans the page.

494
495
00:33:29,390 --> 00:33:36,840
This isn't necessarily the case with say a desktop browser
where a mouse move pans, pans the page or scrolls the page.

495
496
00:33:36,840 --> 00:33:43,790
But these default actions always bubble up to the
browser and the browser does its default thing.

496
497
00:33:43,790 --> 00:33:49,000
Instead of letting that happen, what we really
want to do is after we handle the touchmove event,

497
498
00:33:49,000 --> 00:33:55,000
after we scroll out content, we want to let
Safari know that we've handled the event.

498
499
00:33:55,000 --> 00:33:56,150
We've taken care of it.

499
500
00:33:56,150 --> 00:33:58,270
Safari shouldn't do its default thing.

500
501
00:33:58,270 --> 00:33:59,960
And there's a method for that.

501
502
00:33:59,960 --> 00:34:01,790
It's called preventDefault.

502
503
00:34:01,790 --> 00:34:05,450
We call this on the event, the event gets canceled.

503
504
00:34:05,450 --> 00:34:08,050
It's marked as already having been handled.

504
505
00:34:08,050 --> 00:34:13,430
The event will still continue to propagate, it'll go all
the way back up to Safari, but once it reaches there,

505
506
00:34:13,430 --> 00:34:17,890
Safari will see the event has been handled
and it won't do its default action.

506
507
00:34:17,890 --> 00:34:26,330
So if we go back to our scroller and we add that
preventDefault call and we try sending touchmoves to scroll.

507
508
00:34:26,330 --> 00:34:28,010
Now it works great.

508
509
00:34:28,010 --> 00:34:30,680
We have this pane that we can scroll
with just a single finger.

509
510
00:34:30,680 --> 00:34:35,150
Now I said we can put anything we want in here.

510
511
00:34:35,150 --> 00:34:37,500
We can put another scroller perhaps.

511
512
00:34:37,500 --> 00:34:39,560
So let's try that.

512
513
00:34:39,560 --> 00:34:42,750
Here's another scroller, the individual
items are a little bit larger,

513
514
00:34:42,750 --> 00:34:45,780
but we still have these same numbers and we're counting up.

514
515
00:34:45,780 --> 00:34:52,500
And then I have this imbedded lists that counts
letters instead, you can count letters I suppose.

515
516
00:34:52,500 --> 00:34:56,120
And let's try scrolling, we're going to see that it works.

516
517
00:34:56,120 --> 00:35:00,220
Terribly. They're both scrolling.

517
518
00:35:00,220 --> 00:35:02,770
They're both scrolling at the same time.

518
519
00:35:02,770 --> 00:35:04,920
If I scroll on the outer one, it's fine.

519
520
00:35:04,920 --> 00:35:13,370
But as I'm trying to scroll this internal, this interior
letter list, both scrollers are trying to scroll.

520
521
00:35:13,370 --> 00:35:15,790
What's going on here?

521
522
00:35:15,790 --> 00:35:20,950
Again, it really helps if we go back to the DOM
Event Model, see what's going on with these events.

522
523
00:35:20,950 --> 00:35:26,320
Touchmove starts at the interior scroller, it
moves up to the Container and we cancel it.

523
524
00:35:26,320 --> 00:35:27,930
We mark it as handled.

524
525
00:35:27,930 --> 00:35:29,960
But then the event keeps propagating.

525
526
00:35:29,960 --> 00:35:35,480
It goes to the exterior container, the
exterior scroller and that also scrolls.

526
527
00:35:35,480 --> 00:35:37,130
Now we could do a couple of things here.

527
528
00:35:37,130 --> 00:35:42,710
We could say check to see if the event has been
canceled and not scroll our outer container,

528
529
00:35:42,710 --> 00:35:45,840
or we could do something a little bit different.

529
530
00:35:45,840 --> 00:35:49,520
Once we've handled the touchmove event,
we're done with that touchmove event.

530
531
00:35:49,520 --> 00:35:52,700
We really don't want anything else
to get that touchmove event.

531
532
00:35:52,700 --> 00:35:54,430
So we call this other method.

532
533
00:35:54,430 --> 00:35:56,110
StopPropagation.

533
534
00:35:56,110 --> 00:35:57,820
It does what it says on the box.

534
535
00:35:57,820 --> 00:35:59,480
It destroys the event.

535
536
00:35:59,480 --> 00:36:03,460
No other event handler will receive that touchmove event.

536
537
00:36:03,460 --> 00:36:06,550
We'll be the last bit of code to see that event.

537
538
00:36:06,550 --> 00:36:08,780
So the outer container never sees it.

538
539
00:36:08,780 --> 00:36:12,500
It never acknowledges that exists.

539
540
00:36:12,500 --> 00:36:15,290
We can give this a try.

540
541
00:36:15,290 --> 00:36:21,310
Instead of calling just preventDefault, let's call
stopPropagation on that interior scroller first.

541
542
00:36:21,310 --> 00:36:25,390
The outer one works and the inner one works too.

542
543
00:36:25,390 --> 00:36:28,540
So we can scroll our two lists independently of each other.

543
544
00:36:28,540 --> 00:36:34,050
[ Applause ]

544
545
00:36:34,050 --> 00:36:35,990
This is one of those things that you actually have to try.

545
546
00:36:35,990 --> 00:36:37,940
You actually have to feel.

546
547
00:36:37,940 --> 00:36:44,660
It's amazing how with CSS transforms and touch
events you can get this really responsive.

547
548
00:36:44,660 --> 00:36:46,550
And we've built our scrolling pane.

548
549
00:36:46,550 --> 00:36:52,920
We now have these areas that we can scroll
with just one finger in our web content.

549
550
00:36:54,050 --> 00:36:57,330
So we've talked about a ton of things today.

550
551
00:36:57,330 --> 00:36:59,800
And since I've got you all looking at
me and paying attention still, I hope,

551
552
00:36:59,800 --> 00:37:07,290
while I've got your attention I want to talk, just share
a couple of last minute totally super awesome tips.

552
553
00:37:07,290 --> 00:37:10,310
First, go try this.

553
554
00:37:10,310 --> 00:37:14,520
There's a lot of details that are always
inherent when you're building any kind

554
555
00:37:14,520 --> 00:37:16,900
of UI, especially any kind of really rich UI.

555
556
00:37:16,900 --> 00:37:17,880
Give it a try.

556
557
00:37:17,880 --> 00:37:19,200
Download the sample code.

557
558
00:37:19,200 --> 00:37:26,180
All of those event bubbles and that scrapbook demo,
they're both available from the WWDC attendee site.

558
559
00:37:26,180 --> 00:37:32,290
If you log in, find this session number 508 and
then click the More Info inside that grid view,

559
560
00:37:32,290 --> 00:37:36,050
you can download the sample code, check it out.

560
561
00:37:36,050 --> 00:37:40,500
We're doing a few other things, a few that
we kind of glossed over in this presentation.

561
562
00:37:40,500 --> 00:37:42,340
So give it a try.

562
563
00:37:42,340 --> 00:37:46,470
As you're experimenting, remember, multitouch.

563
564
00:37:46,470 --> 00:37:48,550
So the touch event that you get, the touch event

564
565
00:37:48,550 --> 00:37:54,450
that your event handler has delivered is a
list of touches and there's three of them.

565
566
00:37:54,450 --> 00:37:58,460
Second, I stopped doing this, I got
lazy part way through the presentation.

566
567
00:37:58,460 --> 00:37:59,970
Don't get lazy yourselves.

567
568
00:37:59,970 --> 00:38:01,350
Handle touchcancel.

568
569
00:38:01,350 --> 00:38:03,270
They're going to come when you least expect it.

569
570
00:38:03,270 --> 00:38:05,180
It means you have to reset state.

570
571
00:38:05,180 --> 00:38:11,040
So if you need to reset any variables that you're
holding onto or maybe reset some CSS styles,

571
572
00:38:11,040 --> 00:38:14,120
make sure you do that handle touchcancel.

572
573
00:38:14,120 --> 00:38:18,300
And lastly, actually test on your iPhone on your iPad.

573
574
00:38:18,300 --> 00:38:20,240
The simulator is an awesome tool.

574
575
00:38:20,240 --> 00:38:26,160
I love using it for development work, but nothing
really beats actually trying this stuff on hardware.

575
576
00:38:26,160 --> 00:38:28,950
You're going to find things that you didn't
realize when you're using the simulator

576
577
00:38:28,950 --> 00:38:32,180
like maybe your buttons are too small for your fingers.

577
578
00:38:32,180 --> 00:38:34,070
Or maybe your text needs to be bigger.

578
579
00:38:34,070 --> 00:38:37,720
Or maybe your hand obscures more of
the screen than you think it did.

579
580
00:38:37,720 --> 00:38:42,480
When we're building sites for desktop, we might
build a menu that pops underneath the mouse cursor.

580
581
00:38:42,480 --> 00:38:49,260
But if you think about how your hands work, if you tap
that menu, it's going to pop underneath your hands.

581
582
00:38:49,260 --> 00:38:50,980
That's not so good.

582
583
00:38:50,980 --> 00:38:54,590
Instead you might want to build a menu
that pops above where you're touching.

583
584
00:38:54,590 --> 00:38:57,120
So test on hardware.

584
585
00:38:57,120 --> 00:38:59,880
We've talked about a bunch of things today.

585
586
00:38:59,880 --> 00:39:03,070
We've talked about touch events and gesture events.

586
587
00:39:03,070 --> 00:39:10,660
The APIs, how they're delivered, what they look like, four
touch events, three gesture events, they come interleaved.

587
588
00:39:10,660 --> 00:39:14,130
We've talked about strategies for
building reusable interface components,

588
589
00:39:14,130 --> 00:39:17,860
how to keep your code organized with this sort of code.

589
590
00:39:17,860 --> 00:39:21,830
You try using an object as that
second parameter to addEventListener.

590
591
00:39:21,830 --> 00:39:25,770
You'd be surprised how much it can
really clean up your event handling code.

591
592
00:39:25,770 --> 00:39:31,870
And lastly, there is a ton of built in power
to CSS transforms and the DOM Event Model.

592
593
00:39:31,870 --> 00:39:37,350
Instead of reinventing the wheel and building
additional state handling information tracking events

593
594
00:39:37,350 --> 00:39:39,610
by hand, use what's already there.

594
595
00:39:39,610 --> 00:39:41,260
Use the power that's already there.

595
596
00:39:41,260 --> 00:39:42,810
Try this out.

596
597
00:39:42,810 --> 00:39:48,540
Really, there's, for touch events especially,
nothing beats actually writing code yourself.

597
598
00:39:48,540 --> 00:39:53,800
If you have additional questions, you can always contact
Vicky Murley, our Safari Technologies Evangelist.

598
599
00:39:53,800 --> 00:39:58,880
There's documentation on developer.apple.com/safari,
information about touch events

599
600
00:39:58,880 --> 00:40:02,470
and the touch event model and how they're delivered.

600
601
00:40:02,470 --> 00:40:06,140
If you're really interested in learning
more about DOM events and how they work,

601
602
00:40:06,140 --> 00:40:12,440
the DOM Level 3 Events Specification spells all of
this and all of it is regular specification gory.

602
603
00:40:12,440 --> 00:40:17,580
If you're really interested, try starting
with the DOM Level 2 Event Specification.

603
604
00:40:17,580 --> 00:40:20,880
It contains all the stuff we talked
about today like stopPropagation,

604
605
00:40:20,880 --> 00:40:24,030
preventDefault, but it's a bit easier to read.

605
606
00:40:24,030 --> 00:40:25,740
And there's the Developer Forums.

606
607
00:40:25,740 --> 00:40:26,710
You can ask questions in there.

607
608
00:40:26,710 --> 00:40:29,870
There's a forum specifically for
building web applications for iPhone.

608
