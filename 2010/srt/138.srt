1
00:00:06,900 --> 00:00:08,170
>> Ali Ozer: Good afternoon, everyone.

1
2
00:00:08,170 --> 00:00:11,600
Welcome to API Design for Cocoa and Cocoa Touch.

2
3
00:00:11,600 --> 00:00:12,530
My name is Ali Ozer.

3
4
00:00:12,530 --> 00:00:17,120
I'm the Manager of the Cocoa Frameworks team at Apple.

4
5
00:00:17,120 --> 00:00:25,750
OK. So first, there's lot of you here, let's just make sure
we're on the same page with regards to what we mean by API.

5
6
00:00:25,750 --> 00:00:26,950
Now, I looked it up.

6
7
00:00:26,950 --> 00:00:29,020
API turns out to have many meanings.

7
8
00:00:29,020 --> 00:00:32,680
But we're not here talking about
Active Pharmaceutical Ingredients.

8
9
00:00:32,680 --> 00:00:36,650
We're not talking about Armor-Piercing Incendiaries.

9
10
00:00:36,650 --> 00:00:39,940
Definitely not the American Pirate Industries.

10
11
00:00:39,940 --> 00:00:42,070
And it's not the American Pain Institute.

11
12
00:00:42,070 --> 00:00:45,830
Now, these all sound like fun topics for
talks, but this is not what we're covering.

12
13
00:00:45,830 --> 00:00:49,970
Instead, we're talking about Application
Programming Interfaces.

13
14
00:00:49,970 --> 00:00:56,420
Now, APIs, Application Programming Interfaces, are very
important because they allow your code to interface

14
15
00:00:56,420 --> 00:01:02,380
with the system, you know, let you use
the facilities of the operating system.

15
16
00:01:02,380 --> 00:01:05,410
But well-designed APIs go much further.

16
17
00:01:05,410 --> 00:01:07,170
They make you more productive.

17
18
00:01:07,170 --> 00:01:11,980
When you're using well-designed APIs, you don't
have to look at documentation for every single API.

18
19
00:01:11,980 --> 00:01:14,020
You've learned how the APIs work in general.

19
20
00:01:14,020 --> 00:01:16,530
You can predict how they're going to behave.

20
21
00:01:16,530 --> 00:01:19,330
Well-designed APIs allow you to leverage existing code.

21
22
00:01:19,330 --> 00:01:24,880
Not only can you reuse something, you can
go ahead and extend it to your own needs.

22
23
00:01:24,880 --> 00:01:29,700
Well-designed APIs also let your write
code that works as the user expects.

23
24
00:01:29,700 --> 00:01:32,330
That's because well-designed APIs set policy.

24
25
00:01:32,330 --> 00:01:39,320
And by using these APIs, you make apps that,
for instance, do the HI guidelines correctly,

25
26
00:01:39,320 --> 00:01:42,800
so the user is happy because your
code works like other code.

26
27
00:01:42,800 --> 00:01:47,980
Now, APIs live for a long time so that's
why we consider API design very important.

27
28
00:01:47,980 --> 00:01:51,870
Once we've put an API out here and it's
adopted, it's very hard for us to get rid of it.

28
29
00:01:51,870 --> 00:01:55,740
So, if we made some mistake, it takes
a while to correct that mistake.

29
30
00:01:55,740 --> 00:02:01,710
And one final factor is that API
design is UI design for developers.

30
31
00:02:01,710 --> 00:02:05,740
So, just like Apple takes UI design of its software

31
32
00:02:05,740 --> 00:02:10,380
and its hardware very seriously, we
also take API design very seriously.

32
33
00:02:10,380 --> 00:02:18,900
Here are the five factors we consider important when we're
designing APIs, and the talk is going to cover, it's going--

33
34
00:02:18,900 --> 00:02:23,060
the talk is going to have these
five sections covering these areas.

34
35
00:02:23,060 --> 00:02:27,820
Each section is going to start with why
these areas are, these factors are important,

35
36
00:02:27,820 --> 00:02:34,150
and now I'm going to give examples of how
these factors are reflected in our APIs,

36
37
00:02:34,150 --> 00:02:39,860
and how you yourself can also use these--
use these factors in your own APIs as well.

37
38
00:02:39,860 --> 00:02:46,610
Now, this talk assumes knowledge of Objective-C, and
you've hopefully programmed a bit in Cocoa or Cocoa Touch.

38
39
00:02:46,610 --> 00:02:52,060
A lot of the examples I'm going to use are from Foundation,
since it's a common substrate to AppKit and UIKit.

39
40
00:02:52,060 --> 00:02:56,870
However, in some cases, we'll also use
examples from AppKit or UIKit as well.

40
41
00:02:56,870 --> 00:03:02,430
OK. So with that, let's begin to our
first section which is consistency.

41
42
00:03:02,430 --> 00:03:07,830
And the main topic in this section is naming conventions.

42
43
00:03:07,830 --> 00:03:10,480
Now, I'll just cover some of the
naming conventions we use in our APIs.

43
44
00:03:10,480 --> 00:03:15,090
Now, why is consistency important?

44
45
00:03:15,090 --> 00:03:20,530
Well, as I said earlier, it eliminates the need
to refer to documentation for every single API.

45
46
00:03:20,530 --> 00:03:24,120
You can read about the general guidelines,
the general rules, the general philosophy,

46
47
00:03:24,120 --> 00:03:28,050
and now you don't have to look up every
single API to understand what it does

47
48
00:03:28,050 --> 00:03:32,200
or what other APIs there might be with it.

48
49
00:03:32,200 --> 00:03:36,180
Consistency also allows different subsystems
to plug-in to each other more easily.

49
50
00:03:36,180 --> 00:03:40,660
You know if you get one Objective-C API from
someone and another one from someone else,

50
51
00:03:40,660 --> 00:03:43,550
with this consistency, it should work well together.

51
52
00:03:43,550 --> 00:03:48,140
And finally as, well not finally because there
are many, many reasons why it's important,

52
53
00:03:48,140 --> 00:03:50,650
but one other way it's important is that being--

53
54
00:03:50,650 --> 00:03:56,320
having consistent APIs actually can
improve performance as we'll see later.

54
55
00:03:56,320 --> 00:03:59,180
OK. So let's dive into naming conventions.

55
56
00:03:59,180 --> 00:04:01,940
And the first thing I want to talk
about is naming of classes.

56
57
00:04:01,940 --> 00:04:09,610
I'm sure many of you have seen some of the classes we
have in our APIs: NSString, UIView, CLLocation, et cetera.

57
58
00:04:09,610 --> 00:04:12,010
And typically, class names are nouns.

58
59
00:04:12,010 --> 00:04:15,170
And one thing you'll notice is that we use prefixes.

59
60
00:04:15,170 --> 00:04:20,560
Now, prefixes protect against collisions,
and they also differentiate functional areas.

60
61
00:04:20,560 --> 00:04:24,230
A name like view or location is highly generic.

61
62
00:04:24,230 --> 00:04:29,260
It's possible that two different
developers might use the same name.

62
63
00:04:29,260 --> 00:04:33,050
But in addition, using the prefix like
CL allows you to immediately recognize

63
64
00:04:33,050 --> 00:04:36,500
that this class comes from Core Location.

64
65
00:04:36,500 --> 00:04:43,220
So in your own designs, in your application, you don't have
to use prefixes since you're managing the whole namespace,

65
66
00:04:43,220 --> 00:04:48,390
but it might be a good idea for you to use prefixes as well
in which case I recommend either using three-letter prefixes

66
67
00:04:48,390 --> 00:04:56,340
or maybe even more complete longer prefixes for your class
names, where it may be it's the name of your company.

67
68
00:04:56,340 --> 00:05:00,910
Method names, you've undoubtedly seen many
methods if not before during this week.

68
69
00:05:00,910 --> 00:05:02,440
Here are some examples.

69
70
00:05:02,440 --> 00:05:05,090
With method names, we focus on readability.

70
71
00:05:05,090 --> 00:05:07,050
For instance, the name "is Editable" there.

71
72
00:05:07,050 --> 00:05:13,010
We put the "is" in there as a general rule because
it makes it easier to read, myTextField.isEditable.

72
73
00:05:13,010 --> 00:05:14,900
That reads very naturally.

73
74
00:05:14,900 --> 00:05:16,760
Now, some other things you'll notice here.

74
75
00:05:16,760 --> 00:05:18,830
We use camel case.

75
76
00:05:18,830 --> 00:05:25,170
What camel case means is the subwords
inside our names are actually capitalized.

76
77
00:05:25,170 --> 00:05:27,150
We don't use underbars or anything like that.

77
78
00:05:27,150 --> 00:05:29,470
We actually use uppercase letters.

78
79
00:05:29,470 --> 00:05:33,860
And one other thing you might notice
is we choose clarity over brevity.

79
80
00:05:33,860 --> 00:05:40,280
In some cases, our names are not short
and we also name all the arguments.

80
81
00:05:40,280 --> 00:05:43,210
Now, I'll talk about these last two now.

81
82
00:05:43,210 --> 00:05:48,090
So, here's an example method from
NSMutableArray removeObjectAtIndex.

82
83
00:05:48,090 --> 00:05:51,070
You might be wondering why all those words.

83
84
00:05:51,070 --> 00:05:56,360
Well, this method is trying to communicate to you that
removes an object at an index, so the argument is an index.

84
85
00:05:56,360 --> 00:06:00,190
In fact, we have another method called
removeObject which removes an object.

85
86
00:06:00,190 --> 00:06:06,190
So you can immediately see that these two are distinguished
by those words, and it's really clear what each one does.

86
87
00:06:06,190 --> 00:06:10,600
So, those of you wondering why isn't there just a
method called remove, well you can now understand why

87
88
00:06:10,600 --> 00:06:14,380
that the method remove would be ambiguous
in the presence of these other two methods.

88
89
00:06:14,380 --> 00:06:18,260
Remove by itself just does not
communicate either one of these.

89
90
00:06:18,260 --> 00:06:24,090
And for that reason, we often try to name, you
know, with a noun what the argument is about.

90
91
00:06:24,090 --> 00:06:25,540
Naming all the arguments.

91
92
00:06:25,540 --> 00:06:28,920
Here's a method that's not the longer
method names in our frameworks.

92
93
00:06:28,920 --> 00:06:32,740
It comes from NSBitmapImageRep, in AppKit.

93
94
00:06:32,740 --> 00:06:37,010
You can see all the keywords I'm talking about,
you know, the pixelsWide, pixelsHigh and so on.

94
95
00:06:37,010 --> 00:06:39,520
Now, here's a secret, but I don't
want you to take it out of this room.

95
96
00:06:39,520 --> 00:06:43,370
In fact, you should forget about it
after the beer bash wil help with that.

96
97
00:06:43,370 --> 00:06:46,030
I want you to forget about it after you see it.

97
98
00:06:46,030 --> 00:06:50,930
But you can create a method name like this
where you actually removed all those keywords.

98
99
00:06:50,930 --> 00:06:52,320
But we don't want you to do that.

99
100
00:06:52,320 --> 00:06:58,330
As you can see, you immediately start losing, you
know, some of the what-- you're trying to communicate.

100
101
00:06:58,330 --> 00:07:00,910
When you're using this method in
code, here's what this looks like.

101
102
00:07:00,910 --> 00:07:04,740
You know, you have all these numbers like 32 YES, NO, 0.

102
103
00:07:04,740 --> 00:07:09,570
Without those names, you know,
really this will be lot less clear.

103
104
00:07:09,570 --> 00:07:12,010
In fact, let me give you a concrete example.

104
105
00:07:12,010 --> 00:07:19,510
Back about year 2000, we're experimenting with Java and,
you know, a lot of other people were a lot of crazy kids.

105
106
00:07:19,510 --> 00:07:21,180
But we didn't inhale.

106
107
00:07:21,180 --> 00:07:24,300
[ Laughter ]

107
108
00:07:24,300 --> 00:07:27,420
[ Applause ]

108
109
00:07:27,420 --> 00:07:32,290
Anyway, so here's what this-- and we have this
class method actually existed in Java as well.

109
110
00:07:32,290 --> 00:07:33,120
Here is what it look like.

110
111
00:07:33,120 --> 00:07:40,140
New NSBitmapImageRep, and as you can see, you immediately
lose all what all those arguments mean - 32, true, false --

111
112
00:07:40,140 --> 00:07:42,100
you know, you have to go and look up what this means.

112
113
00:07:42,100 --> 00:07:46,040
So, this is the reason why those arguments are important.

113
114
00:07:46,040 --> 00:07:49,260
OK. Naming accessors, getters, and setters.

114
115
00:07:49,260 --> 00:07:55,100
Here are some examples:- color,
setColor, isEditable, setEditable, so on.

115
116
00:07:55,100 --> 00:08:00,190
Now, one thing to note, as I mentioned earlier, for boolean
properties that are adjectives, we use "is" on the getter.

116
117
00:08:00,190 --> 00:08:03,420
So, it's "setEditable", but the getter is "isEditable".

117
118
00:08:03,420 --> 00:08:08,900
Another thing you might notice is that we do not
embellish the getter with "get" or other verbs.

118
119
00:08:08,900 --> 00:08:14,560
So, for instance, the color method is not called "getColor".

119
120
00:08:14,560 --> 00:08:16,770
It just reads better to have it be "color".

120
121
00:08:16,770 --> 00:08:20,980
Another example is we don't put words
like "compute" on the accessors.

121
122
00:08:20,980 --> 00:08:25,430
For instance, the last one here, even if
the thumbnail image is computed, you know,

122
123
00:08:25,430 --> 00:08:29,980
when you ask an object for its thumbnail image,
even if that object computes the thumbnail image,

123
124
00:08:29,980 --> 00:08:33,760
it's usually not interesting to communicate
the fact that it's being computed.

124
125
00:08:33,760 --> 00:08:37,190
Just have the property, call it
ThumbnailImage and that's good enough.

125
126
00:08:37,190 --> 00:08:43,290
Only in the cases where it is important to communicate that
or distinguish it would you want to put those words in.

126
127
00:08:43,290 --> 00:08:49,510
Now, there are some acceptable uses of
"get", and that's one case is when we use,

127
128
00:08:49,510 --> 00:08:52,740
we use get on accessors that return values by reference.

128
129
00:08:52,740 --> 00:08:59,220
For instance, the NSData method getBytes: which returns
an arbitrary number of bytes given the range argument,

129
130
00:08:59,220 --> 00:09:01,680
it really needs a buffer so to get method.

130
131
00:09:01,680 --> 00:09:03,810
Another example is this method from UIBezierPath

131
132
00:09:03,810 --> 00:09:08,610
which returns three related arguments,
three related properties at once.

132
133
00:09:08,610 --> 00:09:12,810
In this case, we actually have a get
method that returns three different values.

133
134
00:09:12,810 --> 00:09:14,820
They are all by reference.

134
135
00:09:14,820 --> 00:09:22,050
You'll note that the caller can pass NULL in
for the arguments they don't want in such cases.

135
136
00:09:22,050 --> 00:09:25,860
For accessors, the simple accessors, you
can certainly go ahead and use @property

136
137
00:09:25,860 --> 00:09:28,140
and we encourage that whenever it's possible.

137
138
00:09:28,140 --> 00:09:33,420
You know, our accessors in this case would
look like this, property (copy) UIColor *color.

138
139
00:09:33,420 --> 00:09:38,930
For the editable one, we have a special getter because
@property does not know about our rule about putting "is",

139
140
00:09:38,930 --> 00:09:42,510
so you might have seen this in our
APIs where we specify a special getter.

140
141
00:09:42,510 --> 00:09:44,370
Now, let me talk a bit about functions.

141
142
00:09:44,370 --> 00:09:46,740
Function names you probably seen a few.

142
143
00:09:46,740 --> 00:09:48,730
Here's what they look like.

143
144
00:09:48,730 --> 00:09:54,140
Typically, for functions, the rule is to use a framework
prefix followed by the type or functionality area,

144
145
00:09:54,140 --> 00:09:56,040
and then followed by whatever is happening.

145
146
00:09:56,040 --> 00:10:01,110
For instance, CFRangeMake, CGPathAddLines.

146
147
00:10:01,110 --> 00:10:07,010
And the common prefix allows easier
searching, sorting, et cetera.

147
148
00:10:07,010 --> 00:10:09,210
Enum values and constants are very similar.

148
149
00:10:09,210 --> 00:10:11,160
Here are some examples.

149
150
00:10:11,160 --> 00:10:14,710
Now, we also have sometimes common suffixes.

150
151
00:10:14,710 --> 00:10:16,210
Notification is one of them.

151
152
00:10:16,210 --> 00:10:18,420
We use that for NSNotification contants.

152
153
00:10:18,420 --> 00:10:21,070
Key is another one.

153
154
00:10:21,070 --> 00:10:25,360
That's for symbols that are dictionary keys.

154
155
00:10:25,360 --> 00:10:30,380
Now, one thing to note about functions, enum values and
constants, and it's actually true for some other APIs,

155
156
00:10:30,380 --> 00:10:33,890
our naming conventions have evolved over time.

156
157
00:10:33,890 --> 00:10:39,820
So, although we have some examples of, you know,
great naming, which follow our conventions,

157
158
00:10:39,820 --> 00:10:43,110
you will also occasionally run
across names that are not that great.

158
159
00:10:43,110 --> 00:10:47,710
These are mostly some of the older names that
we haven't either had a chance to deprecate

159
160
00:10:47,710 --> 00:10:49,640
or we're just leaving it in there for old time sake.

160
161
00:10:49,640 --> 00:10:51,700
You can see some examples here.

161
162
00:10:51,700 --> 00:10:58,390
So, not everything you run across especially in some of
the older APIs may be correct but, you know, in general,

162
163
00:10:58,390 --> 00:11:00,960
for new APIs, we definitely follow the latest conventions.

163
164
00:11:00,960 --> 00:11:04,750
Do not abbreviate arbitrarily.

164
165
00:11:04,750 --> 00:11:07,820
Here is a fine-looking method,
which is maybe a little too wordy,

165
166
00:11:07,820 --> 00:11:10,440
but you know, as I said again, there is value in that.

166
167
00:11:10,440 --> 00:11:15,380
You might make it just a little bad
by arbitrarily abbreviating point

167
168
00:11:15,380 --> 00:11:18,500
to pnt, you know, setFloatingPntFormat, OK.

168
169
00:11:18,500 --> 00:11:22,130
I mean this generally help you because
Xcode usually helps you at typing.

169
170
00:11:22,130 --> 00:11:27,070
Or you can make it really ugly by removing all
the vowels out of it, if you're a vowel hater.

170
171
00:11:27,070 --> 00:11:30,090
But you know, we don't recommend this.

171
172
00:11:30,090 --> 00:11:32,890
So, the first one is really the best one here.

172
173
00:11:32,890 --> 00:11:36,750
Now, there are some acceptable abbreviations
though, and it's good to be consistent.

173
174
00:11:36,750 --> 00:11:42,160
Our documentation lists some of these acceptable
abbreviations: alloc, dealloc, et cetera.

174
175
00:11:42,160 --> 00:11:47,280
There are also commonly used acronyms such
PDF and USB, and we recommend you use these.

175
176
00:11:47,280 --> 00:11:50,250
Because if you went ahead and spelled
out portable document formats,

176
177
00:11:50,250 --> 00:11:52,140
some people might not even know what you're referring to.

177
178
00:11:52,140 --> 00:11:56,340
You know, people are so used to terms like
USB and PDF, so it's best to stick to them.

178
179
00:11:56,340 --> 00:11:58,920
It's also good to stick to consistent terminology.

179
180
00:11:58,920 --> 00:12:04,710
Earlier, I gave you the example of remove, you know,
maybe one possibility is, hey, instead of remove objects,

180
181
00:12:04,710 --> 00:12:07,970
let's use delete, and instead of remove
this way, let's use some other term.

181
182
00:12:07,970 --> 00:12:11,930
So, you know, there might be a tendency to
look in the source and come up with synonyms.

182
183
00:12:11,930 --> 00:12:13,310
There are a lot of great synonyms.

183
184
00:12:13,310 --> 00:12:15,700
You know, vaporizeObjectsAtIndex, sounds great.

184
185
00:12:15,700 --> 00:12:16,520
[ Laughter ]

185
186
00:12:16,520 --> 00:12:22,990
However, it really does make APIs less predictable,
so it's, you know, good to stick to consistent words

186
187
00:12:22,990 --> 00:12:26,800
and use more descriptive words
to describe your functionality.

187
188
00:12:26,800 --> 00:12:30,600
And avoid names that are ambiguous.

188
189
00:12:30,600 --> 00:12:36,090
You know, at first glance, these
names don't look so bad, but sendPort,

189
190
00:12:36,090 --> 00:12:41,840
is that a method that sends a port
or is that a port used for sending?

190
191
00:12:41,840 --> 00:12:46,840
displayName, is this a directive to display
a name or is it name used for display?

191
192
00:12:46,840 --> 00:12:49,650
Center, is that a verb or is it a noun?

192
193
00:12:49,650 --> 00:12:56,600
It turns out center is a verb in AppKit and a noun
in UIKit, so there's one we missed out of the gate.

193
194
00:12:56,600 --> 00:13:00,610
So, it's good to try to disambiguate these
names and choose a little more clear names.

194
195
00:13:00,610 --> 00:13:02,440
Here are some suggestions here.

195
196
00:13:02,440 --> 00:13:04,540
One is this portForSending.

196
197
00:13:04,540 --> 00:13:07,780
localizedNames is actually one we do use whenever we can.

197
198
00:13:07,780 --> 00:13:13,190
And a middle, maybe center as a noun, middle might be a
better term, we don't use it, but maybe we should consider.

198
199
00:13:13,190 --> 00:13:17,630
And let me talk a bit about Block naming.

199
200
00:13:17,630 --> 00:13:22,120
Blocks, as you know, are new in Snow Leopard and iOS 4.

200
201
00:13:22,120 --> 00:13:27,630
Block itself can be ambiguous because Block as a
verb is like block, you know stop, block processing.

201
202
00:13:27,630 --> 00:13:29,410
So, we try to be careful with that.

202
203
00:13:29,410 --> 00:13:34,920
So, we use the term Block only in generic
cases such as enumerateObjectsusingBlock.

203
204
00:13:34,920 --> 00:13:41,590
But in other cases where we can have more descriptive
names, we have come up with a list of names that we use.

204
205
00:13:41,590 --> 00:13:49,250
For instance, indexOfObjectsPassingTest, a Block that
returns a boolean that cites or testing is a test.

205
206
00:13:49,250 --> 00:13:54,790
We also have Comparator, handler,
completionHandler, ExpirationHandler, et cetera.

206
207
00:13:54,790 --> 00:13:58,160
So, these are some of the terms
we are using to describe blocks.

207
208
00:13:58,160 --> 00:14:04,100
OK. So, the last item I want to discuss
in this section is object ownership.

208
209
00:14:04,100 --> 00:14:09,350
Now, most of you are probably familiar with object
ownership rules in Cocoa and the memory management rules.

209
210
00:14:09,350 --> 00:14:15,720
Object ownership is not transferred across calls,
and the only methods that actually do are exemptions

210
211
00:14:15,720 --> 00:14:24,340
to this rule are methods whose names begin with
alloc, new, copy.mutableCopy or the retain method.

211
212
00:14:24,340 --> 00:14:28,740
So, what this means is whenever you're looking
an API, you never have to ask the question,

212
213
00:14:28,740 --> 00:14:31,600
do I have to release the results from calling this method.

213
214
00:14:31,600 --> 00:14:37,280
And similarly, if you're designing your
own API, you have a good guideline.

214
215
00:14:37,280 --> 00:14:42,610
Now, there might be mistakes in APIs especially if a
subsystem was designed without API guidelines in mind,

215
216
00:14:42,610 --> 00:14:46,210
maybe it's an internal subsystem of your application.

216
217
00:14:46,210 --> 00:14:53,610
And if you're on the Clang Static Analyzer, it will
mark these erroneous names and give you warnings

217
218
00:14:53,610 --> 00:14:56,820
that you're over-releasing an object
or you're not releasing it enough.

218
219
00:14:56,820 --> 00:15:01,590
We do have some attribute, a decorator
you can add to methods for this purpose.

219
220
00:15:01,590 --> 00:15:07,110
For instance, if you had a method name, full name
that erroneously returned and retained object,

220
221
00:15:07,110 --> 00:15:10,070
you could put NS_RETURNS_RETAINED
on there to sort of describe

221
222
00:15:10,070 --> 00:15:13,200
to the analyzer, hey, this returns your retained object.

222
223
00:15:13,200 --> 00:15:17,730
However, please use this only for
Static Analyzer's purposes.

223
224
00:15:17,730 --> 00:15:21,800
You know, do not use it to define
bad APIs or just iffy APIs.

224
225
00:15:21,800 --> 00:15:26,100
We intend not to have any APIs, you know,
in this system that use this, for instance.

225
226
00:15:26,100 --> 00:15:30,180
If we did, that would be an error and we'd want to fix it.

226
227
00:15:30,180 --> 00:15:33,720
OK. With that, let's get to the performance section.

227
228
00:15:33,720 --> 00:15:44,210
In here, we're going to talk about Impedance matching, I'll
describe what I mean by that, mutability, and concurrency.

228
229
00:15:44,210 --> 00:15:48,780
So, first of all, why is performance important?

229
230
00:15:48,780 --> 00:15:51,110
Well, you know, it seems like that's an obvious question.

230
231
00:15:51,110 --> 00:15:55,970
Users love it, you know, when the applications are
fast in response, so that seems like a clear one.

231
232
00:15:55,970 --> 00:16:04,760
But another reason performance is important is that even
though an application might seem responsive and fast,

232
233
00:16:04,760 --> 00:16:10,320
maybe it's not fast enough or maybe it's not doing things
fast enough where it's using more power than needed.

233
234
00:16:10,320 --> 00:16:16,550
So, being especially focused on performance, you
know, making sure you're getting everything as fast

234
235
00:16:16,550 --> 00:16:19,630
as possible can improve battery life and make users happier.

235
236
00:16:19,630 --> 00:16:24,360
So, let me talk about impedance matching.

236
237
00:16:24,360 --> 00:16:29,780
Impedance matching, to describe what it means, it's a term,
I think, from electrical engineering where it's talking

237
238
00:16:29,780 --> 00:16:35,270
about input and output connections,
and it's done in such a way

238
239
00:16:35,270 --> 00:16:40,110
that the power is maximized, the throughput is maximized.

239
240
00:16:40,110 --> 00:16:45,100
So, it's basically a term that, you know, where you
can connect things together with highest efficiency.

240
241
00:16:45,100 --> 00:16:52,050
You might think of it as plug and
play, really, easy plug and play.

241
242
00:16:52,050 --> 00:16:59,650
Now, what I mean here is this concept of using small number
of basic data types in APIs, and not having redundancy.

242
243
00:16:59,650 --> 00:17:03,030
That improves consistency.

243
244
00:17:03,030 --> 00:17:06,370
You can plug things together more easily.

244
245
00:17:06,370 --> 00:17:08,220
Code fits together more easily.

245
246
00:17:08,220 --> 00:17:10,980
In addition, it eliminates the need to do conversions.

246
247
00:17:10,980 --> 00:17:15,900
If you have two different representations for the
same concept, every time you cross an API boundary,

247
248
00:17:15,900 --> 00:17:19,660
you have to do conversions on those,
and that just reduces performance.

248
249
00:17:19,660 --> 00:17:24,010
So, for to this end, we have a small
number of basic data types for strings.

249
250
00:17:24,010 --> 00:17:27,850
You know, we use NSStrings everywhere,
in all API for strings.

250
251
00:17:27,850 --> 00:17:30,040
NSDates for dates.

251
252
00:17:30,040 --> 00:17:33,110
NSURLs to represent file paths.

252
253
00:17:33,110 --> 00:17:39,970
For ordered collections or association tables
or map tables, we use NSArray, NSDictionary.

253
254
00:17:39,970 --> 00:17:44,220
There's also NSSet, but it is used less commonly in APIs.

254
255
00:17:44,220 --> 00:17:48,930
In addition, we have this other
higher level types, UIColor and UIKit,

255
256
00:17:48,930 --> 00:17:53,390
NSColor in AppKit, and types for font and image as well.

256
257
00:17:53,390 --> 00:17:59,360
So, I recommend that anytime you want to represent an image
in your application or in you API, you use either UIImage

257
258
00:17:59,360 --> 00:18:06,230
or NSImage with regard to UIKit or AppKit,
and there are few other types that fit here.

258
259
00:18:08,440 --> 00:18:11,080
Now, not all basic data types are objects.

259
260
00:18:11,080 --> 00:18:14,260
You might know that we have some
C types in our APIs as well.

260
261
00:18:14,260 --> 00:18:17,210
For instance, NSInteger and NSUInteger.

261
262
00:18:17,210 --> 00:18:21,470
These are actually simple typedefs on top of int or long.

262
263
00:18:21,470 --> 00:18:23,320
CGFloat is another type like that.

263
264
00:18:23,320 --> 00:18:25,500
It's either a float or a double.

264
265
00:18:25,500 --> 00:18:27,450
Now, we do have an NSNumber type.

265
266
00:18:27,450 --> 00:18:29,360
It's an object to represent numbers.

266
267
00:18:29,360 --> 00:18:35,690
But you've probably have noticed that we do not use
NSNumbers in our APIs to represent numerical quantities,

267
268
00:18:35,690 --> 00:18:40,250
we only use NSNumbers to wrap these
basic types when necessary, for instance,

268
269
00:18:40,250 --> 00:18:43,750
when you're putting them in dictionaries or arrays.

269
270
00:18:43,750 --> 00:18:47,470
Now, we also have some struct types.

270
271
00:18:47,470 --> 00:18:54,410
And for widely use types, you know, things they are using
all over the place where abstraction is not important,

271
272
00:18:54,410 --> 00:18:57,140
it's not valuable, it's OK to use structs.

272
273
00:18:57,140 --> 00:19:02,430
We have four widely use structs,
points, ranges, sizes, and rects.

273
274
00:19:02,430 --> 00:19:06,060
Consider this point, you know, CGPoint, it's got X and a Y.

274
275
00:19:06,060 --> 00:19:10,920
We have, you know, we do not pretend
that anybody will want to extend CGPoint,

275
276
00:19:10,920 --> 00:19:13,360
nobody is going to want to subclass CGPoint.

276
277
00:19:13,360 --> 00:19:15,320
We have a bunch of utility functions and that's good enough.

277
278
00:19:15,320 --> 00:19:19,600
It's OK for you to go in there and group
the X and the Y values, you know, it's OK.

278
279
00:19:19,600 --> 00:19:23,670
It's a public struct, we all understand it,
it works well, points aren't going to change.

279
280
00:19:23,670 --> 00:19:25,950
With that in mind, structs are OK.

280
281
00:19:25,950 --> 00:19:32,780
Structs are good because you can, you know, stack allocate
them, and you can use them, you know, pretty flexibly.

281
282
00:19:32,780 --> 00:19:36,360
Now, once upon a time when we were
designing some of the basic types,

282
283
00:19:36,360 --> 00:19:39,620
we made the mistake of designing
the color type to be a struct.

283
284
00:19:39,620 --> 00:19:44,440
So, it was basically a struct with RGBA,
and we quickly realized our mistake,

284
285
00:19:44,440 --> 00:19:48,170
you know, and color is much richer type than that.

285
286
00:19:48,170 --> 00:19:50,610
You know, you have different color representation, CMYK.

286
287
00:19:50,610 --> 00:19:52,160
You have color matching information.

287
288
00:19:52,160 --> 00:19:55,050
So, we could quickly dump that
idea and switch to a color object.

288
289
00:19:55,050 --> 00:20:00,050
So that was an example where our struct is not OK.

289
290
00:20:00,050 --> 00:20:05,710
Now, so far, I've been start talking about reducing a number
of types, you know, et cetera, but then I'm also talking

290
291
00:20:05,710 --> 00:20:11,060
about sometimes multiple types that seem equivalent
and that seems to violate what I'm saying.

291
292
00:20:11,060 --> 00:20:14,220
So, you know, what's up with CGPoint and NSPoint?

292
293
00:20:14,220 --> 00:20:16,760
Why do I have two types to represent points?

293
294
00:20:16,760 --> 00:20:22,550
Well, those of you working on UIKit probably have never
even come across NSPoint because that's an Appkit concept.

294
295
00:20:22,550 --> 00:20:26,410
NSPoint was the original type for NSPoint in Appkit.

295
296
00:20:26,410 --> 00:20:27,870
CGPoint was added later.

296
297
00:20:27,870 --> 00:20:34,500
In fact, we have made the two equivalent in our
64-bit by making them the exact same typedef.

297
298
00:20:34,500 --> 00:20:38,930
So, for all purposes, these two should be
considered equal when you're working in Appkit.

298
299
00:20:38,930 --> 00:20:41,070
And in UIKit, you only have CGPoint.

299
300
00:20:41,070 --> 00:20:44,890
How about NSInteger and NSUInteger?

300
301
00:20:44,890 --> 00:20:48,570
These represent signed and unsigned integer value.

301
302
00:20:48,570 --> 00:20:49,490
Why do you we have these?

302
303
00:20:49,490 --> 00:20:52,010
Why don't we just use int?

303
304
00:20:52,010 --> 00:20:58,290
Well, our API is used to all the in terms of ints
or unsigned ints, but then when we moved to 64-bit

304
305
00:20:58,290 --> 00:21:03,730
on the desktop, we decided to add these
typedefs to sort of abstract that away.

305
306
00:21:03,730 --> 00:21:07,670
So, all our APIs are not in terms
of NSInteger or NSUInteger,

306
307
00:21:07,670 --> 00:21:13,370
and these are defined to be int
or long as needed by the platform.

307
308
00:21:13,370 --> 00:21:17,770
So again, these are just basic types on
those and they are just simple covers.

308
309
00:21:17,770 --> 00:21:21,190
And finally, the CFStringRef versus NSString.

309
310
00:21:21,190 --> 00:21:26,710
Some of you might have played with Core
Foundation, used the CFStringRef type for instance,

310
311
00:21:26,710 --> 00:21:30,190
and you might be wondering why
do we have two types for strings.

311
312
00:21:30,190 --> 00:21:34,600
Well, it turns out these two types
are actually totally equivalent.

312
313
00:21:34,600 --> 00:21:37,940
You can just typecast between them,
no conversion is necessary.

313
314
00:21:37,940 --> 00:21:43,020
The reason we have CFStringRef is to satisfy
the needs of very low level implementations

314
315
00:21:43,020 --> 00:21:45,150
that do not use object-oriented programming.

315
316
00:21:45,150 --> 00:21:50,750
For all object-oriented implementations
based on foundation or above, use NSString.

316
317
00:21:50,750 --> 00:21:54,260
It plays much better with the object-oriented environment.

317
318
00:21:54,260 --> 00:21:56,700
And it's also on the desktop, especially.

318
319
00:21:56,700 --> 00:21:57,470
This is important.

319
320
00:21:57,470 --> 00:22:01,040
It's garbage collection ready out of the box.

320
321
00:22:01,040 --> 00:22:06,000
So, we refer to this relationship between
these two types as toll-free bridging.

321
322
00:22:06,000 --> 00:22:15,490
And this relationship also exists for CFArray and NSArray
or CFDictionary, NSDictionary and also a few other types.

322
323
00:22:15,490 --> 00:22:19,170
OK. So with that, let me talk about mutability.

323
324
00:22:19,170 --> 00:22:24,550
Now, mutable means changeable,
sort of like the term "mutate."

324
325
00:22:24,550 --> 00:22:29,730
Many objects are by nature mutable-- only
mutable, for instance, NSWindow or UIScrollView.

325
326
00:22:29,730 --> 00:22:34,400
It's got many properties that can
change, and it's a changeable object,

326
327
00:22:34,400 --> 00:22:38,040
you can't even think of it as an
unchangeable, immutable object.

327
328
00:22:38,040 --> 00:22:41,820
But then there are other types such as
strings or colors that can be considered

328
329
00:22:41,820 --> 00:22:45,620
in immutable forms and these are usually value objects.

329
330
00:22:45,620 --> 00:22:53,350
And what I mean by a value object is object whose important
characteristic is its value not its object identity.

330
331
00:22:53,350 --> 00:23:01,110
If you have two strings and their contents are both "hello",
you would consider those two strings to be equal, right?

331
332
00:23:01,110 --> 00:23:02,340
So, those are value objects.

332
333
00:23:02,340 --> 00:23:06,760
And in those cases, the immutable approach makes sense.

333
334
00:23:06,760 --> 00:23:13,260
And in some cases, having both a mutable
and an immutable variant also make sense.

334
335
00:23:13,260 --> 00:23:15,680
An example is NSString.

335
336
00:23:15,680 --> 00:23:21,280
If you have an immutable NSString, here is how
you would append to it, you have your string,

336
337
00:23:21,280 --> 00:23:26,860
you call stringByAppendingString and you
get back a new string that has a result.

337
338
00:23:26,860 --> 00:23:31,270
If you have an NSMutableString and you want to
append to it, you would just call appendString

338
339
00:23:31,270 --> 00:23:34,840
and it just modifies that sting in place.

339
340
00:23:34,840 --> 00:23:36,620
So, looking at that, you're like, "Hm.

340
341
00:23:36,620 --> 00:23:39,480
Mutable string seems more efficient here.

341
342
00:23:39,480 --> 00:23:42,040
We don't have to create an intermediate object.

342
343
00:23:42,040 --> 00:23:45,430
Why do we even have the immutable version?"

343
344
00:23:45,430 --> 00:23:52,020
Well, there are some reasons and
actually performance is one of them.

344
345
00:23:52,020 --> 00:23:57,860
If you have a string which has five characters in it
like hello and you know it's never going to change,

345
346
00:23:57,860 --> 00:24:00,060
the storage for that string can be very optimized.

346
347
00:24:00,060 --> 00:24:03,090
It can store those five characters in its base object.

347
348
00:24:03,090 --> 00:24:06,840
In fact it doesn't even have to create
another malloc block for instance.

348
349
00:24:06,840 --> 00:24:10,300
This also yields to simpler implementation.

349
350
00:24:10,300 --> 00:24:11,510
No mutation is needed.

350
351
00:24:11,510 --> 00:24:15,240
You don't have to keep track of all sorts of editing state.

351
352
00:24:15,240 --> 00:24:17,130
This yields to thread safety.

352
353
00:24:17,130 --> 00:24:21,040
You know, if you're not changing,
you can be a lot more thread safe.

353
354
00:24:21,040 --> 00:24:24,680
And this also allows for easier analysis of program logic.

354
355
00:24:24,680 --> 00:24:29,460
If you have an object at point A whose value is hello
and it's immutable, you know that later at point B,

355
356
00:24:29,460 --> 00:24:38,130
it's going to have the same value, so that makes
some things about your program easier to understand.

356
357
00:24:38,130 --> 00:24:40,640
OK. Now, which one to use in APIs?

357
358
00:24:40,640 --> 00:24:45,110
For instance, let's say you're a window or a button and
you have a title, here's what your API could look like.

358
359
00:24:45,110 --> 00:24:51,840
NSString title to give you a new title, you
know, the callers exactly give you a new title.

359
360
00:24:51,840 --> 00:24:57,160
Or you can have an API like this, NSMutableString
title where the expectation is that if somebody wants

360
361
00:24:57,160 --> 00:25:01,110
to change your title, they basically
reach in there and mutate that string.

361
362
00:25:01,110 --> 00:25:04,900
As you probably realize, this latter is not what we'd like.

362
363
00:25:04,900 --> 00:25:11,730
We almost always recommend the immutable version; that's
because sort of having immutable title and reaching in there

363
364
00:25:11,730 --> 00:25:17,380
to change it feels like you're totally breaking
the encapsulation of a window or a button object.

364
365
00:25:17,380 --> 00:25:23,520
However, oh, and by the way, this is-- if you're using
properties, which as I said is usually, you know, good idea,

365
366
00:25:23,520 --> 00:25:28,010
this adheres to the way how you would declare
this property, property (copy) NSString*(title).

366
367
00:25:28,010 --> 00:25:31,450
Now, there are few exceptions to this.

367
368
00:25:31,450 --> 00:25:34,670
For instance, there's an NSAttributedString class.

368
369
00:25:34,670 --> 00:25:42,120
It has a string method, however, its subclass
NSMutableAttributedString has a mutableString method.

369
370
00:25:42,120 --> 00:25:48,710
And this method, just because it's so special, it
returns NSMutableString value and has the word "mutable"

370
371
00:25:48,710 --> 00:25:51,720
in the name actually expects you to mutate that.

371
372
00:25:51,720 --> 00:25:53,820
It's ready for you to mutate that.

372
373
00:25:53,820 --> 00:25:58,780
So, this is, and in this case, when you mutate that
string, the containing mutable attributed string,

373
374
00:25:58,780 --> 00:26:01,440
it sees the changes and takes appropriate action.

374
375
00:26:01,440 --> 00:26:05,950
So, these exceptions are almost always going to be
named with the word "mutable" in them one way or another

375
376
00:26:05,950 --> 00:26:11,340
to make it clear to you that yes, this is OK to mutate.

376
377
00:26:11,340 --> 00:26:13,950
OK. Let me now talk about concurrency.

377
378
00:26:13,950 --> 00:26:19,780
Now, concurrency is a way to achieve
higher performance on multi-core machines.

378
379
00:26:19,780 --> 00:26:25,420
As you know, on the desktop, we're adding more
and more cores instead of cranking up CPU speeds.

379
380
00:26:25,420 --> 00:26:31,380
So, being able to run things concurrently
means you can achieve higher performance.

380
381
00:26:31,380 --> 00:26:35,540
Now, we've-- you know, all along we
have various ways to do concurrency --

381
382
00:26:35,540 --> 00:26:40,670
we had thread objects, we had runloop objects,
we had notification queues, and so on.

382
383
00:26:40,670 --> 00:26:50,470
But now we have a way to represent even more granular,
smaller grained work, and blocks are of course that tool.

383
384
00:26:50,470 --> 00:26:53,400
Blocks are a good fit for presenting concurrent work.

384
385
00:26:53,400 --> 00:26:55,810
They can be processed by Grand Central Dispatch.

385
386
00:26:55,810 --> 00:26:58,900
They can be executed by NSOperationQueue.

386
387
00:26:58,900 --> 00:27:01,610
But even more importantly, they can capture state.

387
388
00:27:01,610 --> 00:27:07,550
Now, if you're going to have some concurrent work
happening, it's great to be able to encapsulate that work,

388
389
00:27:07,550 --> 00:27:11,360
throw it out there, and have that
block capture all the state it needs

389
390
00:27:11,360 --> 00:27:13,990
so it doesn't rely on you staying around anymore.

390
391
00:27:13,990 --> 00:27:18,000
So, from that point of view, blocks
are also good hit for concurrent work,

391
392
00:27:18,000 --> 00:27:23,190
but note that not all block usage is necessarily
concurrent, and we'll see examples of this later.

392
393
00:27:23,190 --> 00:27:31,700
Now, in our-- in the APIs we're adding, when we want to
enable concurrency, there's often an explicit option,

393
394
00:27:31,700 --> 00:27:34,550
for instance, enumeration, sorting, searching.

394
395
00:27:34,550 --> 00:27:39,890
Here's an NSArray method
enumerateObjectsWithOptions:usingBlock.

395
396
00:27:39,890 --> 00:27:43,060
Here's a usage case for it.

396
397
00:27:43,060 --> 00:27:49,800
If you provide the option NSEnumerationConcurrent, the
block is executed concurrently with elements in that array,

397
398
00:27:49,800 --> 00:27:55,850
so that's an explicit way to get
concurrency out of enumeration.

398
399
00:27:55,850 --> 00:28:01,950
If you're at the What's New In Foundation talk, Tuesday,
you probably saw this in a lot of the other related APIs

399
400
00:28:01,950 --> 00:28:04,600
that we introduced in iOS 4 and Snow Leopard.

400
401
00:28:04,600 --> 00:28:08,580
Here's another example, NSNotifications.

401
402
00:28:08,580 --> 00:28:12,930
Observers can now indicate that they want
to receive notifications concurrently.

402
403
00:28:12,930 --> 00:28:17,810
For that, we have a new method,
addObserverForName object queue usingBlock.

403
404
00:28:17,810 --> 00:28:26,960
If the observer indicates a non-nil queue, the block
will be executed concurrently for that observer.

404
405
00:28:26,960 --> 00:28:31,020
So, this is again, an explicit way to
indicate your find for concurrency.

405
406
00:28:31,020 --> 00:28:36,920
And here's one more example out of
the spell, NSSpellChecker class.

406
407
00:28:36,920 --> 00:28:40,110
NSSpellChecker can do the spell checking.

407
408
00:28:40,110 --> 00:28:42,870
This class does the spell checking,
grammar checking, et cetera.

408
409
00:28:42,870 --> 00:28:51,940
It can do the checking either in a synchronous fashion with
this method where this method simply returns the result

409
410
00:28:51,940 --> 00:28:58,060
as its return value, which makes sense for a synchronous
approach, and then returns additional results here

410
411
00:28:58,060 --> 00:29:04,290
in these two argument, or it can do it asynchronously
with this method where the results are communicated

411
412
00:29:04,290 --> 00:29:07,690
in the completion handler block at a later time,

412
413
00:29:07,690 --> 00:29:11,980
and the results are returned in
these arguments, passed to the block.

413
414
00:29:11,980 --> 00:29:17,880
And also note one more thing, the sequence number passed to
the block is actually the integer value that was returned

414
415
00:29:17,880 --> 00:29:23,840
by this method so that you can associate the request
and the reply at a later time when the reply comes in.

415
416
00:29:23,840 --> 00:29:26,800
OK. So, with that, we get to our safety section.

416
417
00:29:26,800 --> 00:29:34,330
And here, I'm going to talk about runtime
errors, programming errors, and also atomicity.

417
418
00:29:34,330 --> 00:29:41,980
So, safety is important because, you know, you can
reduce the chance of crashes with safer programming.

418
419
00:29:41,980 --> 00:29:49,260
You can make debugger, debugging more easy, and also
writing more robust apps, which even if errors occur,

419
420
00:29:49,260 --> 00:29:54,650
it can indicate to the user why errors occur
then allow the user to recover is a good idea.

420
421
00:29:54,650 --> 00:30:03,140
Now, there are two types of errors that we're going to talk
about, expected errors which we also call runtime errors

421
422
00:30:03,140 --> 00:30:09,740
and programming errors which are sort of these unexpected
errors that are caused by often bugs in the program.

422
423
00:30:09,740 --> 00:30:13,670
Now runtime errors are errors that are expected to occur.

423
424
00:30:13,670 --> 00:30:18,540
For instance unreadable file, a file gets corrupt,
the user tries to open it, they get an error --

424
425
00:30:18,540 --> 00:30:26,050
out of disc space, user is trying to save a file but the
disk was full, lost network connection, invalid user input,

425
426
00:30:26,050 --> 00:30:31,250
you're trying to make a trade and you indicate
billions instead of millions you know it might happen.

426
427
00:30:31,250 --> 00:30:35,330
So these are the kind of errors that
your program should guard against.

427
428
00:30:35,330 --> 00:30:40,160
Now these are typically handled with
return values in an optional NSerror.

428
429
00:30:40,160 --> 00:30:46,200
The return value is often a boolean or an object
that returns an initialized object or nil.

429
430
00:30:46,200 --> 00:30:52,170
And in cases where you want to report an error
you would use NSError argument, here's an example.

430
431
00:30:52,170 --> 00:30:58,620
Here the ID returns, you know, returns in your
object, if it returns nil then the error argument,

431
432
00:30:58,620 --> 00:31:03,690
NSError** that's a by reference
argument indicates what the error is.

432
433
00:31:03,690 --> 00:31:12,640
And of course as before you can pass NULL here
if you don't want to hear about that error.

433
434
00:31:12,640 --> 00:31:17,830
Now sometimes NSErrors can be passed by other means
for instance here is a UIWebView delegate method,

434
435
00:31:17,830 --> 00:31:24,120
if an error occurs during loading, this delegate method
is called and the error is simply passed to the delegate.

435
436
00:31:24,120 --> 00:31:26,680
And here's another example: NSWorkspace.

436
437
00:31:26,680 --> 00:31:34,000
This is a method to NSWorkspace to make copies of
files just like the finder does on the desktop.

437
438
00:31:34,000 --> 00:31:41,540
This is an asynchronous call in a way to you pass
the URLs to copy and the completion handler is called

438
439
00:31:41,540 --> 00:31:49,300
with the NSDictionary indicating to you what the new
names of the copied files are and in addition NSError

439
440
00:31:49,300 --> 00:31:54,490
which could be nil if no error occurred or maybe
an error that indicates a partial error like 3

440
441
00:31:54,490 --> 00:31:56,770
of the files could not be copied but the rest were.

441
442
00:31:56,770 --> 00:32:01,730
So this is actually a pretty novel way
of using and indicating a partial error.

442
443
00:32:01,730 --> 00:32:07,230
Now not all APIs need NSError in fact if you look

443
444
00:32:07,230 --> 00:32:11,240
at our APIs you probably see only a
few percent of them have NSErrors.

444
445
00:32:11,240 --> 00:32:18,200
That's because NSError usage is really best confined
to API's you know where you really want the caller

445
446
00:32:18,200 --> 00:32:22,670
to either look at the error and make
decision based on the error type.

446
447
00:32:22,670 --> 00:32:27,670
But even that's a chore you know having to look through the
NSError, figure out the code, have a big switch statement

447
448
00:32:27,670 --> 00:32:31,830
and then in the future new codes
are added you know that's not fun.

448
449
00:32:31,830 --> 00:32:37,930
So the other, the more compelling reason to add
NSError is that the error may be reported to the user.

449
450
00:32:37,930 --> 00:32:40,830
What I mean by that is you get an error from an API.

450
451
00:32:40,830 --> 00:32:46,450
You know, you can just put it up to the user and
in fact have the error automatically provide ways

451
452
00:32:46,450 --> 00:32:50,380
of recovery from that error and NSError has that.

452
453
00:32:50,380 --> 00:32:54,700
It has the failure reason which is
localized and it's got recovery suggestion

453
454
00:32:54,700 --> 00:32:58,480
and even a way to provide recovery options.

454
455
00:32:58,480 --> 00:33:05,840
And the errors we provide out of our frameworks
usually have well localized error messages

455
456
00:33:05,840 --> 00:33:08,040
and sometimes recovery suggestions as well.

456
457
00:33:08,040 --> 00:33:11,040
And if you're using the App Kit there's this responder API

457
458
00:33:11,040 --> 00:33:14,760
that will let you present an error
either modally or as a sheet.

458
459
00:33:14,760 --> 00:33:17,560
But on UIKit as well you can actually take an NSError

459
460
00:33:17,560 --> 00:33:22,120
and show the various localized
pieces in whatever fashion you want.

460
461
00:33:22,120 --> 00:33:25,710
OK. So let's talk about programming errors.

461
462
00:33:25,710 --> 00:33:29,190
And these are errors often caused by misuse of APIs.

462
463
00:33:29,190 --> 00:33:30,190
Here's an example.

463
464
00:33:30,190 --> 00:33:33,320
This is out of bounds access into an array.

464
465
00:33:33,320 --> 00:33:38,040
Here's another example where you're calling a method which
expects a caller but you're calling it with a string,

465
466
00:33:38,040 --> 00:33:41,220
you know sort of maybe looks like a caller.

466
467
00:33:41,220 --> 00:33:47,860
And an invalid parameter value, we often consider
nil not to be a valid string when passed to APIs

467
468
00:33:47,860 --> 00:33:50,410
and you know this is a bad call here setStringValue of nil.

468
469
00:33:50,410 --> 00:33:58,270
Now we do not indicate programming errors by return values
because programming errors are really errors in programming

469
470
00:33:58,270 --> 00:34:04,580
in program logic and these should be fixed and
dealt with before you ship the application.

470
471
00:34:04,580 --> 00:34:08,710
It's not something that you'd expect to
deal with on the user's machine at runtime.

471
472
00:34:08,710 --> 00:34:13,080
You want to deal with it before you ship so you, you
know, you test, you find these bugs, you fix them.

472
473
00:34:13,080 --> 00:34:15,730
So there's no need to deal with them at runtime.

473
474
00:34:15,730 --> 00:34:21,090
So therefore you will never see an API like this,
setBackgroundColor, which returns an error code.

474
475
00:34:21,090 --> 00:34:26,180
And if you happen to pass in a string instead, it
will return an error indicating a string passed in.

475
476
00:34:26,180 --> 00:34:29,940
I mean how do you deal with the set runtime is just
like why would you do that, you just fix this bug.

476
477
00:34:29,940 --> 00:34:31,810
In fact, the compiler will probably tell you

477
478
00:34:31,810 --> 00:34:36,850
that you're passing a wrong argument
if you have a type checking happening.

478
479
00:34:36,850 --> 00:34:38,710
So, not a good idea.

479
480
00:34:38,710 --> 00:34:45,330
We indicate these errors via exceptions using NSException
and it's important to note that in this fashion,

480
481
00:34:45,330 --> 00:34:51,200
Cocoa uses exceptions in somewhat different ways than
some other frameworks than some other platforms do,

481
482
00:34:51,200 --> 00:34:55,050
so that is the difference in the way
exceptions are used on our system.

482
483
00:34:55,050 --> 00:34:58,680
And you know, we do not expect you to handle exceptions.

483
484
00:34:58,680 --> 00:35:02,990
For instance, you shouldn't have to write code where you
set a background color and then put that tri-cache block

484
485
00:35:02,990 --> 00:35:06,530
around it just in case a string was passed
and so you can cache it or run deal with it.

485
486
00:35:06,530 --> 00:35:08,590
Again. don't write this kind of code.

486
487
00:35:08,590 --> 00:35:14,090
Just listen to the compiler and try to fix these bugs--
discover and fix this bug before you ship your application.

487
488
00:35:14,090 --> 00:35:19,890
Now, it might still be a good idea to have a
top-level exception handling in your application.

488
489
00:35:19,890 --> 00:35:26,460
So if these kinds of exceptions do occur for the
user, you know, you should be aware, hopefully.

489
490
00:35:26,460 --> 00:35:31,230
You can alert the user something bad happened
or you can try to recover and let them say--

490
491
00:35:31,230 --> 00:35:37,740
now, if you write the Cocoa chips-- Tips and Tricks
Talk on Tuesday at 2 p.m., you saw a technique a way

491
492
00:35:37,740 --> 00:35:40,870
of doing this on the-- in the context AppKit.

492
493
00:35:40,870 --> 00:35:45,010
So, the last safety topic I want to talk about is atomicity.

493
494
00:35:45,010 --> 00:35:53,400
Objective-C 2.0 properties are by default atomic but they
can be made non-atomic by putting non-atomic keywords.

494
495
00:35:53,400 --> 00:36:02,040
And many APIs in iOS, in iPhone OS are
actually have non-atomic properties.

495
496
00:36:02,040 --> 00:36:04,360
Now, here's what atomic does.

496
497
00:36:04,360 --> 00:36:08,180
It guarantees that when one thread is setting or another--

497
498
00:36:08,180 --> 00:36:13,680
and another thread is getting a value,
you're guaranteed to get a good value.

498
499
00:36:13,680 --> 00:36:21,330
And the good value is either the previous value or the next
value, but you're guaranteed not to get some corrupt value

499
500
00:36:21,330 --> 00:36:27,720
that will make you crash or some half-set value,
for instance a rectangle whose origin comes

500
501
00:36:27,720 --> 00:36:30,320
from some place and size comes from some place else.

501
502
00:36:30,320 --> 00:36:32,710
So that's what atomic guarantee is.

502
503
00:36:32,710 --> 00:36:33,960
It's not very much.

503
504
00:36:33,960 --> 00:36:40,350
So it gives you a basic low-level of thread safety for
single property but it can actually prevent crashes

504
505
00:36:40,350 --> 00:36:43,700
in the presence of threading in your application.

505
506
00:36:43,700 --> 00:36:45,450
So it's a good idea.

506
507
00:36:45,450 --> 00:36:49,280
Now, it's important to note, this does not
provide consistency between properties.

507
508
00:36:49,280 --> 00:36:51,780
It does not give you high level of thread safety.

508
509
00:36:51,780 --> 00:36:57,170
For instance, let's say you have one part of your program
setting the first name and last name on an object,

509
510
00:36:57,170 --> 00:37:02,000
on a person object and some other part of your
program reading the first name and last name.

510
511
00:37:02,000 --> 00:37:06,270
If this guy sets the first name while-- and then
this guy comes in and then fetches the first name

511
512
00:37:06,270 --> 00:37:09,470
and last name, it will get back an invalid name.

512
513
00:37:09,470 --> 00:37:11,790
That's what I mean by how to look consistency.

513
514
00:37:11,790 --> 00:37:17,410
You know, it might get back a name like Bill Jobs
or Steve Gates, you know, that would be good.

514
515
00:37:17,410 --> 00:37:18,700
An abomination.

515
516
00:37:18,700 --> 00:37:24,230
[Laughter] So you want to-- you know, that's
that high-level consistency I'm taking about.

516
517
00:37:24,230 --> 00:37:27,770
Now, atomicity is still often a good idea to use.

517
518
00:37:27,770 --> 00:37:29,760
Leave properties atomic.

518
519
00:37:29,760 --> 00:37:31,500
It is safer.

519
520
00:37:31,500 --> 00:37:37,060
When you might concern an atomic is, if you
notice when you do use instruments for instance,

520
521
00:37:37,060 --> 00:37:44,340
if you know this calls to objc_getProperty or setProperty
keep appearing in your back traces and taking some CPU time.

521
522
00:37:44,340 --> 00:37:47,500
That's when you might want to concern using anatomic.

522
523
00:37:47,500 --> 00:37:53,520
Another case you might want to drop atomic is if
you already have higher level synchronization.

523
524
00:37:53,520 --> 00:37:57,230
You know, I just mentioned an example of where
you might use higher level synchronization.

524
525
00:37:57,230 --> 00:38:02,520
So if you already have locks or if you're already using
cues or if you already have single-threaded access

525
526
00:38:02,520 --> 00:38:05,950
to your objects, you know, as long
as those objects are confined

526
527
00:38:05,950 --> 00:38:09,920
to those contexts, you might want to non-atomic properties.

527
528
00:38:09,920 --> 00:38:15,020
The Cocoa Performance Techniques talk, from
two years ago, if you can find the video

528
529
00:38:15,020 --> 00:38:20,470
in our developer's site, has some more about this topic.

529
530
00:38:20,470 --> 00:38:25,370
OK. So with that, I want to move to the
next major section which is Reusability.

530
531
00:38:25,370 --> 00:38:28,140
And by Reusability, I also mean Extensibility.

531
532
00:38:28,140 --> 00:38:35,610
In this section, we'll talk about subclassing
categories on patterns for communicating changes.

532
533
00:38:35,610 --> 00:38:37,650
So why is Reusability important?

533
534
00:38:37,650 --> 00:38:41,600
Well, clearly, there's no need
reinvent the wheel over and over.

534
535
00:38:41,600 --> 00:38:44,390
If you can reuse something that
somebody else did, that's good.

535
536
00:38:44,390 --> 00:38:51,880
And from our point of view, we want to give you API's
that allow you to do what every application does,

536
537
00:38:51,880 --> 00:38:56,370
so that you can go ahead write the code on
top of it that distinguishes your application.

537
538
00:38:56,370 --> 00:38:59,260
So we want you to be able to reuse
our code as much as possible

538
539
00:38:59,260 --> 00:39:03,530
so you can do the creative things
that make your application shine.

539
540
00:39:03,530 --> 00:39:06,730
And also, you, yourself, can write
code which can be reused elsewhere.

540
541
00:39:06,730 --> 00:39:09,700
Maybe you can write some objects in
this application and then use them

541
542
00:39:09,700 --> 00:39:13,700
in another project you're doing by writing reusable code.

542
543
00:39:13,700 --> 00:39:19,630
So subclassing is the fundamental object-oriented
programming feature, of course, for your Reusability.

543
544
00:39:19,630 --> 00:39:21,780
You know, we all know about it.

544
545
00:39:21,780 --> 00:39:26,300
But it's not very commonly used in
Cocoa and Cocoa Touch for customization.

545
546
00:39:26,300 --> 00:39:31,550
Most of our classes are concrete, meaning they're
usable as is and they're fairly customizable.

546
547
00:39:31,550 --> 00:39:34,840
So often, rather than using subclassing
to customize objects,

547
548
00:39:34,840 --> 00:39:38,940
you just set various properties to
make them behave in different ways.

548
549
00:39:38,940 --> 00:39:42,320
However, we do have some classes
which are meant for subclassing.

549
550
00:39:42,320 --> 00:39:46,050
Sometimes, they're abstract, meaning
you have to subclass them.

550
551
00:39:46,050 --> 00:39:52,170
And other times, they're semi-abstract, meaning their
functional as is, but they probably want to be subclassed.

551
552
00:39:52,170 --> 00:39:56,970
Examples are NSObject, UIView, et cetera, NSDocument.

552
553
00:39:56,970 --> 00:39:59,240
These are classes that often subclassed.

553
554
00:39:59,240 --> 00:40:04,430
In these cases you want to identify
which methods are there for overwriting.

554
555
00:40:04,430 --> 00:40:07,130
NSObject init for instance, if you
don't have a custom initialization.

555
556
00:40:07,130 --> 00:40:12,960
If you don't have custom drawing in
your UI view, drawRect, and so on.

556
557
00:40:12,960 --> 00:40:18,500
But then there's this other subtle scenario that we have
in our frameworks, and I wanted to talk about that now.

557
558
00:40:18,500 --> 00:40:25,500
Some foundation classes such as NSString, NSData, et
cetera, are absesetract, but they're also fully usable,

558
559
00:40:25,500 --> 00:40:30,860
which means you can alloc init these and you
will get back a fully functional instance.

559
560
00:40:30,860 --> 00:40:34,360
You know, you've done this many
times in your code, I'm sure.

560
561
00:40:34,360 --> 00:40:39,060
However, if you try to subclass these, you find
that subclasses do not work unless you've gone ahead

561
562
00:40:39,060 --> 00:40:46,260
and implemented a few methods, overridden a few methods,
and these are Primitive-- what we call Primitive methods.

562
563
00:40:46,260 --> 00:40:50,870
Primitive methods are the minimal
API to implement a new subclass.

563
564
00:40:50,870 --> 00:40:55,050
In the case of NSString, there is just two methods.

564
565
00:40:55,050 --> 00:40:59,670
Just by overriding these two methods in your subclass
of NSString, you have a fully functional NSString

565
566
00:40:59,670 --> 00:41:04,770
that does everything any NSString can do.

566
567
00:41:04,770 --> 00:41:06,430
So why do we have this approach?

567
568
00:41:06,430 --> 00:41:09,130
Why are these classes abstract?

568
569
00:41:09,130 --> 00:41:10,430
Well, for one reason.

569
570
00:41:10,430 --> 00:41:18,460
We have a bunch private implementation classes that are
hidden behind a facade, like NSString, an abstract class,

570
571
00:41:18,460 --> 00:41:22,760
and we don't want to expose those private classes.

571
572
00:41:22,760 --> 00:41:26,560
So we have this behavior where subclassing
is actually giving you the abstract class.

572
573
00:41:26,560 --> 00:41:31,860
But another important reason is that we do not want to
encourage subclassing these classes for the wrong reason,

573
574
00:41:31,860 --> 00:41:36,690
and the wrong reason being to add additional properties.

574
575
00:41:36,690 --> 00:41:42,440
And that's because it changes fundamental
meaning of this object, what this object stores.

575
576
00:41:42,440 --> 00:41:44,900
And let me explain that to you.

576
577
00:41:44,900 --> 00:41:49,120
Here's NSString, it's got two fundamental
methods, length and characterAtIndex.

577
578
00:41:49,120 --> 00:41:51,610
This is how an NSString is defined.

578
579
00:41:51,610 --> 00:41:56,770
Let's say you subclass NSString with a RichString
because you-- RichString is just like a string.

579
580
00:41:56,770 --> 00:42:00,910
It's got length, characterAtIndex, but it also has a font.

580
581
00:42:00,910 --> 00:42:02,980
Now, let's try to use these two classes in a program.

581
582
00:42:02,980 --> 00:42:07,110
You create a string, its value is hello.

582
583
00:42:07,110 --> 00:42:12,120
You create a RichString, its value is
hello, but it also has the font, Helvetica.

583
584
00:42:12,120 --> 00:42:15,620
Now you ask the string, is it equal to the RichString?

584
585
00:42:15,620 --> 00:42:18,810
So the string says, "Hey, my contests are hello.

585
586
00:42:18,810 --> 00:42:20,780
That other strings contents are hello."

586
587
00:42:20,780 --> 00:42:24,680
because it only knows how to look at the
character values, and it says, "Yeah, sure.

587
588
00:42:24,680 --> 00:42:25,260
We're equal."

588
589
00:42:25,260 --> 00:42:31,110
Of course, if you ask the RichString, "Are you equal
to this poor string, the RichString puts on a monocle,

589
590
00:42:31,110 --> 00:42:34,570
takes a look and says, "No, that string is not Helvetica.

590
591
00:42:34,570 --> 00:42:35,870
We're not equal."

591
592
00:42:35,870 --> 00:42:41,180
So suddenly, you're violating some law, law of physics
or math, I don't know, but you have A is equal to B--

592
593
00:42:41,180 --> 00:42:42,000
[ Laughter ]

593
594
00:42:42,000 --> 00:42:45,540
But B is not equal to A, and that's
just a very bad thing in programming.

594
595
00:42:45,540 --> 00:42:47,630
So therefore, this is a bad idea.

595
596
00:42:47,630 --> 00:42:55,130
Let's take a look at NSString versus NSAttributedSring
and how we designed those just to solve this problem.

596
597
00:42:55,130 --> 00:42:57,400
So NSString has length and characterAtIndex.

597
598
00:42:57,400 --> 00:43:00,260
We have this other class NSAttributedString,
I already mentioned.

598
599
00:43:00,260 --> 00:43:05,190
It has a string and it has attributesAtIndex
to represent the attributes.

599
600
00:43:05,190 --> 00:43:11,080
So rather than NSAttributedString being
a subclass of NSString, it has a string.

600
601
00:43:11,080 --> 00:43:16,330
And both of these are subclasses of NSObject,
and that solves this problem I'm talking about.

601
602
00:43:16,330 --> 00:43:19,910
So this is a good design here.

602
603
00:43:19,910 --> 00:43:24,430
OK. So then, the question is, why would
you subclass NSString, NSData, et cetera,

603
604
00:43:24,430 --> 00:43:26,480
if you know, we're making it hard to subclass?

604
605
00:43:26,480 --> 00:43:32,080
Well, there're still reasons to subclass it, and the biggest
one is that you want to provide your own implementation.

605
606
00:43:32,080 --> 00:43:33,970
For instance, you could override the Primitives

606
607
00:43:33,970 --> 00:43:38,420
and have your own storage your data,
for instance, goes to a file lazily.

607
608
00:43:38,420 --> 00:43:43,790
You know, I often get the question, how can you make
NSString read a four gigabyte file and efficiently?

608
609
00:43:43,790 --> 00:43:48,660
Well, you know, you could subclass it to do that, or
various other ways of approaching large data storage.

609
610
00:43:48,660 --> 00:43:51,080
You can have NSString with a tree
backing storage if you want.

610
611
00:43:51,080 --> 00:43:54,560
Just by overriding those two methods,
you get that behaviors.

611
612
00:43:54,560 --> 00:44:00,720
The Class Clusters documentation from the Cocoa Fundamentals
Guide goes into more details on this Class Cluster approach.

612
613
00:44:00,720 --> 00:44:04,580
So we were talking about subclassing so far,
and that's one way we can extend our classes.

613
614
00:44:04,580 --> 00:44:07,760
But another way we extend our classes is via Categories.

614
615
00:44:07,760 --> 00:44:11,480
Categories is a language feature,
and it allows adding methods

615
616
00:44:11,480 --> 00:44:14,780
on existing classes where all instances are affected.

616
617
00:44:14,780 --> 00:44:16,960
This enables several things.

617
618
00:44:16,960 --> 00:44:22,700
One of them is that you can actually distribute your
methods across multiple header files, which is nice.

618
619
00:44:22,700 --> 00:44:27,450
But the other more interesting behavior is that
you can extend a class without subclassing,

619
620
00:44:27,450 --> 00:44:32,120
so that all instances of that class are affected.

620
621
00:44:32,120 --> 00:44:34,420
For instance, NSString isn't Foundation.

621
622
00:44:34,420 --> 00:44:38,550
Foundation knows nothing about
drawing, so NSString cannot draw.

622
623
00:44:38,550 --> 00:44:44,240
However, both UIKit and AppKit add new
functionality, add joint functionality to NSString.

623
624
00:44:44,240 --> 00:44:50,200
For instance, UIKit adds methods,
drawInRect withFont, drawAtPoint withFont.

624
625
00:44:50,200 --> 00:44:53,560
So let me show you how this works.

625
626
00:44:53,560 --> 00:44:56,690
Let's say we have a drawable string subclass.

626
627
00:44:56,690 --> 00:45:01,270
So here's NSString, its got length,
characterAtIndex, and bunch of other methods.

627
628
00:45:01,270 --> 00:45:06,010
We go ahead and give you a drawable string subclass
which knows how to drink-- how-- not to drink.

628
629
00:45:06,010 --> 00:45:06,780
How to--

629
630
00:45:06,780 --> 00:45:07,000
[ Laughter ]

630
631
00:45:07,000 --> 00:45:09,990
How to draw.

631
632
00:45:09,990 --> 00:45:12,530
[ Laughter ]

632
633
00:45:12,530 --> 00:45:15,070
[ Applause ]

633
634
00:45:15,070 --> 00:45:20,670
OK. And then if you create, if you have other
subclasses, some subclass and another subclass,

634
635
00:45:20,670 --> 00:45:26,940
you can see that these subclasses do not know how to draw,
so to draw a string you'd have to take these other instances

635
636
00:45:26,940 --> 00:45:30,530
and convert them to drawable strings before they can draw.

636
637
00:45:30,530 --> 00:45:33,300
So this sort of violates that all
impedance matching thing, you know,

637
638
00:45:33,300 --> 00:45:36,010
where you have to convert types just to make them draw.

638
639
00:45:36,010 --> 00:45:43,620
So, this is not a very good design, but by using categories,
you have NSString, the category is added into the string

639
640
00:45:43,620 --> 00:45:48,030
at runtime so some of the NSString knows how to draw.

640
641
00:45:48,030 --> 00:45:50,970
It replies to drawInRect, drawAtPoint, et cetera.

641
642
00:45:50,970 --> 00:45:56,760
And then your subclasses are now magically also able
to draw although, you know they have nothing to do it

642
643
00:45:56,760 --> 00:46:00,010
because these methods are part of the super implementation.

643
644
00:46:00,010 --> 00:46:01,840
So that's what categories enable.

644
645
00:46:01,840 --> 00:46:07,030
Now, in addition to subclassing and
categories, one other way to, of course--

645
646
00:46:07,030 --> 00:46:12,840
another way to extend behaviors of classes
is to have helper classes, helper objects.

646
647
00:46:12,840 --> 00:46:16,610
And so, we have several patterns for communicating changes.

647
648
00:46:16,610 --> 00:46:21,600
You're probably familiar with these: delegation,
notification, key-value observing, target-action.

648
649
00:46:21,600 --> 00:46:24,070
If not, we do have some good documentation on this

649
650
00:46:24,070 --> 00:46:28,320
in the Cocoa Design Patterns documentation
in the Cocoa Fundamentals Guide.

650
651
00:46:28,320 --> 00:46:33,210
But let me just go over how these
are used to extend behaviors.

651
652
00:46:33,210 --> 00:46:36,800
Delegation allows an object to act on behalf of another.

652
653
00:46:36,800 --> 00:46:39,430
It's not a language feature unlike categories.

653
654
00:46:39,430 --> 00:46:41,620
Classes explicitly support delegates.

654
655
00:46:41,620 --> 00:46:47,650
UITextView for instance declares that it has a
delegate as you can see here with this @property

655
656
00:46:47,650 --> 00:46:52,250
and the delegate responds to a protocol
and this protocol lists the methods

656
657
00:46:52,250 --> 00:46:55,830
that the delegate is expected to implement.

657
658
00:46:55,830 --> 00:46:59,900
In this case, they're all optional so delegate
might choose to implement only some of them.

658
659
00:46:59,900 --> 00:47:02,350
For instance, textViewShouldBeginEditing, et cetera.

659
660
00:47:02,350 --> 00:47:06,460
Now, delegation allows an object to help another object.

660
661
00:47:06,460 --> 00:47:09,530
It even allows one object to help many other objects.

661
662
00:47:09,530 --> 00:47:15,100
For instance, you might have one text
view and you might have a delegate.

662
663
00:47:15,100 --> 00:47:18,440
You might have another text view and
it might share the same delegate.

663
664
00:47:18,440 --> 00:47:23,150
In fact, you might have a table view and
it also might share the same delegate.

664
665
00:47:23,150 --> 00:47:28,490
If you do this, of course, that delegate should
respond to the UITableView delegate protocol as well.

665
666
00:47:28,490 --> 00:47:30,750
As you can see I just added, they are in that bubble.

666
667
00:47:30,750 --> 00:47:33,110
Now, delegates are also flexible.

667
668
00:47:33,110 --> 00:47:39,410
There are other object that are also sort of like
delegates, for instance UITableView also has a data source

668
669
00:47:39,410 --> 00:47:43,810
and that could be another object, even
a distinct object then its delegate.

669
670
00:47:43,810 --> 00:47:50,130
So delegation allows proper subdivision of
responsibility and it's fairly flexible.

670
671
00:47:50,130 --> 00:47:51,990
You can make it flexible.

671
672
00:47:51,990 --> 00:47:54,180
So delegation, you know, if I were to give you an analogy,

672
673
00:47:54,180 --> 00:47:58,870
a delegate is like almost your doctor
or your lawyer or maybe your spouse.

673
674
00:47:58,870 --> 00:48:04,900
You know somebody who you trust in and somebody who makes
some of the decisions for you or maybe gives you some advice

674
675
00:48:04,900 --> 00:48:09,520
on how to do things, so that's sort of
an appropriate analogy for delegation.

675
676
00:48:09,520 --> 00:48:13,510
You know, for instance, if you have an
NSWindow and the NSWindow is being closed,

676
677
00:48:13,510 --> 00:48:18,280
decision whether that window should be closed or
not, it's not really the window's place to decide.

677
678
00:48:18,280 --> 00:48:23,990
It's really the place of whoever has content being displayed
in that window to decide whether it's OK to close that.

678
679
00:48:23,990 --> 00:48:28,360
So that's why the window asks its
delegate should the window close.

679
680
00:48:28,360 --> 00:48:30,660
Notification is another pattern.

680
681
00:48:30,660 --> 00:48:36,310
Notification allows-- I was going to use the word
"event" here but "event" is so overloaded I said

681
682
00:48:36,310 --> 00:48:38,470
"happenings," which is an interesting word.

682
683
00:48:38,470 --> 00:48:42,010
It allows happenings to be broadcast
to a set of unrelated observers.

683
684
00:48:42,010 --> 00:48:44,530
These observers observe but they don't interfere.

684
685
00:48:44,530 --> 00:48:48,860
This is unlike delegation where the
delegates do have the ability to interfere.

685
686
00:48:48,860 --> 00:48:50,570
This also is in a language feature.

686
687
00:48:50,570 --> 00:48:56,630
There is a class NSNotification center and classes
have to explicitly declare notifications they post.

687
688
00:48:56,630 --> 00:49:01,410
For instance, we have many notifications
both in UIKit and AppKit,

688
689
00:49:01,410 --> 00:49:05,960
UIPasteboardChangedNotification,
NSWindowWillCloseNotification and so on.

689
690
00:49:05,960 --> 00:49:14,110
Now, note that sometimes delegate methods, you know they
might also be delegate methods that correspond to this

690
691
00:49:14,110 --> 00:49:18,490
and so the delegate might also
act as an observer in some cases.

691
692
00:49:18,490 --> 00:49:21,620
Now notifications is pretty flexible.

692
693
00:49:21,620 --> 00:49:23,160
You know you can have multiple observers.

693
694
00:49:23,160 --> 00:49:29,290
There is an indirection between the objects so that
observers can actually choose to observe any notification

694
695
00:49:29,290 --> 00:49:34,490
from a particular object or a notification from any object.

695
696
00:49:34,490 --> 00:49:36,410
That's because, you know, here are the objects we have.

696
697
00:49:36,410 --> 00:49:37,460
Here are observers.

697
698
00:49:37,460 --> 00:49:39,680
There is intermediate notification center.

698
699
00:49:39,680 --> 00:49:45,580
All the notifications are posted there and the
notification center sends the notifications

699
700
00:49:45,580 --> 00:49:48,530
to appropriate interested objects.

700
701
00:49:48,530 --> 00:49:53,750
So, if I were to give an analogy here, this is
almost like, you know, somebody whose twittering

701
702
00:49:53,750 --> 00:49:57,970
or I know you're doing it now, but it's
almost like twittering or blogging.

702
703
00:49:57,970 --> 00:50:01,880
Let's say your blogging away telling the world
about interesting things that happen to you.

703
704
00:50:01,880 --> 00:50:06,790
That might turn out nobody is reading your blog
or maybe some people signed up for your RSS feeds.

704
705
00:50:06,790 --> 00:50:10,260
So those are the observers, and you actually
don't even know how many observers you have.

705
706
00:50:10,260 --> 00:50:15,050
You know, they are just independently signing up
for your blog and you're just telling the world

706
707
00:50:15,050 --> 00:50:17,410
of what you think is important,
so that's like notifications.

707
708
00:50:17,410 --> 00:50:22,640
You choose to tell the world what's important
and they choose to listen if they want to.

708
709
00:50:22,640 --> 00:50:26,730
Key-value observing is another pattern,
I'll just quickly go over this one.

709
710
00:50:26,730 --> 00:50:30,770
This one allows objects to broadcast
updates to individual properties.

710
711
00:50:30,770 --> 00:50:33,640
You know, like a window can say, my title changed.

711
712
00:50:33,640 --> 00:50:36,790
An employee can say, my salary changed, and so on.

712
713
00:50:36,790 --> 00:50:39,010
This also is on a language feature.

713
714
00:50:39,010 --> 00:50:41,780
Classes decide which properties
they want to implement this for.

714
715
00:50:41,780 --> 00:50:44,730
However, unlike delegation notification,

715
716
00:50:44,730 --> 00:50:49,950
this doesn't require defining any new APIs,
any new symbols, and any new protocols.

716
717
00:50:49,950 --> 00:50:55,140
You know, a class just says, hey, you
know, my salary property is observable.

717
718
00:50:55,140 --> 00:51:01,650
In fact, if those properties are key-value coding compliant,
which is pretty much automatic if you use that property

718
719
00:51:01,650 --> 00:51:08,380
for instance, the key-value observing is
also automatically available in most cases.

719
720
00:51:08,380 --> 00:51:15,260
Now, key-value observing is most appropriate when
you have UIElements showing various properties.

720
721
00:51:15,260 --> 00:51:17,980
For instance, you have a text field showing the salary.

721
722
00:51:17,980 --> 00:51:22,740
That text field is interested in hearing a lot
of changes to that salary field and, you know,

722
723
00:51:22,740 --> 00:51:25,620
not necessarily any other notifications
coming from that object,

723
724
00:51:25,620 --> 00:51:30,910
so you would use key-value observing for cases like that.

724
725
00:51:30,910 --> 00:51:35,880
And finally, target action, this is
a fairly specialized simple approach.

725
726
00:51:35,880 --> 00:51:38,370
It allows UIControl syndicate user interaction.

726
727
00:51:38,370 --> 00:51:41,210
It's simple and it works well in Interface Builder.

727
728
00:51:41,210 --> 00:51:46,950
You know, control simply sends a
customizable action to a customizable target.

728
729
00:51:46,950 --> 00:51:53,950
This becomes more flexible when you have your target
specified as nil because then the responder chain is used

729
730
00:51:53,950 --> 00:51:57,100
to find the appropriate target at runtime.

730
731
00:51:57,100 --> 00:52:03,010
That's why for instance when you hit command
C, an application to copy, the appropriate,

731
732
00:52:03,010 --> 00:52:06,620
whatever the current text field
is active, gets to command C.

732
733
00:52:06,620 --> 00:52:10,260
We don't have to specify that target
ahead of time and continuously change it.

733
734
00:52:10,260 --> 00:52:15,930
The responder chain is a fairly powerful concept that
you can also use for your own purposes if you need to.

734
735
00:52:15,930 --> 00:52:18,570
For instance, we use a responder
chain also in error presentation.

735
736
00:52:18,570 --> 00:52:23,460
We just throw the error down the responder chain in
the appropriate window, and if there's no window,

736
737
00:52:23,460 --> 00:52:25,740
maybe the application will be shown there.

737
738
00:52:25,740 --> 00:52:30,680
The one final thing I'm going to talk about in this
section is Model View Controller and this is a huge topic.

738
739
00:52:30,680 --> 00:52:32,340
In fact, I talked about it earlier.

739
740
00:52:32,340 --> 00:52:33,890
I just want to have one slide.

740
741
00:52:33,890 --> 00:52:40,390
Model-View-Controller is a pattern that defines three clear
functional roles for objects, the model which owns the data,

741
742
00:52:40,390 --> 00:52:45,990
view which displays and lets the user edit the
data, and the controller which coordinates things.

742
743
00:52:45,990 --> 00:52:50,150
Each piece is separately replaceable, customizable,
and that's why this pattern is so powerful.

743
744
00:52:50,150 --> 00:52:53,550
You can choose to replace the model or the view.

744
745
00:52:53,550 --> 00:52:59,210
For instance if you're going to write a cross platform
app that works well on the iPad, the iPhone, and the Mac,

745
746
00:52:59,210 --> 00:53:05,190
you would use the ModelViewController paradigm to split
your pieces so you can reuse your model, for instance.

746
747
00:53:05,190 --> 00:53:10,640
This is used for overall app design, but also
various subsystems through our APIs use this pattern.

747
748
00:53:10,640 --> 00:53:16,570
The Cocoa text system, the bindings architecture,
UITableView, so individual classes even like UITableView,

748
749
00:53:16,570 --> 00:53:19,770
NSTableView, UIViewController use this pattern.

749
750
00:53:19,770 --> 00:53:25,940
So two talks during the week touched upon
this pattern, the model-view controller talk

750
751
00:53:25,940 --> 00:53:33,930
and Advanced Cocoa Text Tips & Tricks talks both
showed examples of how we use MVC in our APIs.

751
752
00:53:33,930 --> 00:53:40,570
OK, so with that, now we're in the convenience section,
we're going to talk about convenience APIs and blocks.

752
753
00:53:40,570 --> 00:53:43,600
So, why is convenience important?

753
754
00:53:43,600 --> 00:53:45,960
Well, there are three reasons.

754
755
00:53:45,960 --> 00:53:47,740
One is that it allows you to be more productive.

755
756
00:53:47,740 --> 00:53:51,610
Convenience APIs allow you to do more with even less code.

756
757
00:53:51,610 --> 00:53:53,850
It also makes coding fun, you know, effortless.

757
758
00:53:53,850 --> 00:53:57,420
You know, it seems more easy to do things.

758
759
00:53:57,420 --> 00:54:02,570
Now, the third reason is that I found out when I was looking
at a definition of convenience, I don't know why I did that.

759
760
00:54:02,570 --> 00:54:05,540
Apparently convenience means public
toilet in British English.

760
761
00:54:05,540 --> 00:54:05,890
[ Laughter ]

761
762
00:54:05,890 --> 00:54:07,450
And that's important.

762
763
00:54:07,450 --> 00:54:08,710
[ Laughter ]

763
764
00:54:08,710 --> 00:54:11,870
And let me use it in a sentence.

764
765
00:54:11,870 --> 00:54:17,720
At the bash tonight, you will probably need
a convenience if you drink too much beer.

765
766
00:54:17,720 --> 00:54:28,020
Anyway, so with that-- so, convenience APIs are APIs that
simplify or combine a number of other calls into one.

766
767
00:54:28,020 --> 00:54:32,370
For instance, here's an NSString method that
does comparisons and it's got four arguments.

767
768
00:54:32,370 --> 00:54:36,990
We have a convenience method on it,
compare: that just has one argument

768
769
00:54:36,990 --> 00:54:39,880
and basically fills in the other three arguments.

769
770
00:54:42,860 --> 00:54:47,320
Now, we clearly don't have convenience
APIs everywhere we could.

770
771
00:54:47,320 --> 00:54:51,140
You know, otherwise, sometimes, you look for a
convenience API and you don't see it and you have

771
772
00:54:51,140 --> 00:54:53,800
to call a bigger method and you're like,
I wish there was a convenience API.

772
773
00:54:53,800 --> 00:54:58,510
You know if you had convenience APIs
everywhere possible, that'd be a lot of APIs,

773
774
00:54:58,510 --> 00:55:06,450
so we usually consider these APIs only in cases
where the implementation is more than two lines

774
775
00:55:06,450 --> 00:55:12,130
or there are some additional value in the convenience
or there's some valuable abstraction in the convenience,

775
776
00:55:12,130 --> 00:55:16,500
and let me explain what I mean by those last two.

776
777
00:55:16,500 --> 00:55:18,860
Here are the two methods I showed you earlier.

777
778
00:55:18,860 --> 00:55:22,630
Here's the way the compare method, the
single argument one is implemented.

778
779
00:55:22,630 --> 00:55:27,980
It simply calls the four argument method
with a bunch of default arguments.

779
780
00:55:27,980 --> 00:55:30,990
I mean, if you look at it, it's really
a one line implementation, right?

780
781
00:55:30,990 --> 00:55:33,340
I mean I graphed it so it looks
good, but it's really one line.

781
782
00:55:33,340 --> 00:55:35,890
You know, you're thinking why is
there a convenience method here?

782
783
00:55:35,890 --> 00:55:39,100
Well, that's because there is additional
value in this method.

783
784
00:55:39,100 --> 00:55:45,430
The compare method allows you-- allows--
you know it can be used in sorting methods.

784
785
00:55:45,430 --> 00:55:47,950
For instance, NSArray has sort using selector.

785
786
00:55:47,950 --> 00:55:51,230
It takes a selector with one argument.

786
787
00:55:51,230 --> 00:55:55,490
So, you can just pass the compare method right in there.

787
788
00:55:55,490 --> 00:56:00,580
In fact, we have more NSString comparison
conveniences such as case insensitive compare,

788
789
00:56:00,580 --> 00:56:02,780
localized compare and so on just for this purpose.

789
790
00:56:02,780 --> 00:56:08,100
So the-- there's additional value in
these methods, in these conveniences.

790
791
00:56:08,100 --> 00:56:11,170
Another reason is valuable abstraction.

791
792
00:56:11,170 --> 00:56:14,800
Here's a method we recently added in Snow Leopard and iOS 4.

792
793
00:56:14,800 --> 00:56:22,410
This does a comparison just like the system does and we
described that this method's behavior may change over time.

793
794
00:56:22,410 --> 00:56:23,820
Here's the implementation we tell you.

794
795
00:56:23,820 --> 00:56:27,330
This is-- if you look in the release nodes,
this is the exact implementation today.

795
796
00:56:27,330 --> 00:56:30,910
However, as I said, we may change
this implementation over time.

796
797
00:56:30,910 --> 00:56:37,100
So here, this method is valuable because of its
abstraction that the implementation may change,

797
798
00:56:37,100 --> 00:56:41,330
so it's more than in fact the convenience in this case.

798
799
00:56:41,330 --> 00:56:46,900
By using it, you will get this abstraction
of comparing just like the system does.

799
800
00:56:46,900 --> 00:56:50,790
OK, so the next topic here is blocks.

800
801
00:56:50,790 --> 00:56:54,840
Now, when you think about it, blocks
are mostly for convenience.

801
802
00:56:54,840 --> 00:56:58,640
Blocks do not really enable anything
that was impossible before.

802
803
00:56:58,640 --> 00:57:00,740
You know, they bring a lot of convenience.

803
804
00:57:00,740 --> 00:57:02,450
You can specify a piece of code in line.

804
805
00:57:02,450 --> 00:57:10,310
You don't have to create an extra function, and they have
this ability to capture state, which you can also emulate.

805
806
00:57:10,310 --> 00:57:11,650
Now, I don't want to sell blocks short.

806
807
00:57:11,650 --> 00:57:12,980
Blocks are an amazing feature.

807
808
00:57:12,980 --> 00:57:15,560
In fact they are so amazing we added them to the language.

808
809
00:57:15,560 --> 00:57:19,900
In fact, we added them to C, you know, for which the
bar is pretty high, so they are an amazing feature.

809
810
00:57:19,900 --> 00:57:23,090
But in the end, they really bring a lot of convenience.

810
811
00:57:23,090 --> 00:57:29,860
For instance, we use blocks as callbacks and we're
replacing the places where they appear as callbacks.

811
812
00:57:29,860 --> 00:57:34,780
In fact, all those compare variants
are really not that necessary anymore.

812
813
00:57:34,780 --> 00:57:39,770
For instance before, if you did not have a compare
method you might have wanted like a numeric search,

813
814
00:57:39,770 --> 00:57:45,900
you would have had to go and define your
own custom function and then pass it

814
815
00:57:45,900 --> 00:57:49,370
to myArray, you know, NSArray sort using function.

815
816
00:57:49,370 --> 00:57:55,220
While before with blocks, you can just do
sortUsingComparator and pass the block right in there

816
817
00:57:55,220 --> 00:57:58,340
and the code you want to do is right
in there, so this is pretty convenient.

817
818
00:57:58,340 --> 00:58:01,180
You don't need all those compare variants anymore.

818
819
00:58:02,700 --> 00:58:05,410
Another thing we use blocks for is completions,

819
820
00:58:05,410 --> 00:58:11,190
for instance new APIs for presenting
sheets in AppKit and in the same panel.

820
821
00:58:11,190 --> 00:58:16,280
Here's what the Leopard API looks like and
here's what the Snow Leopard API looks like.

821
822
00:58:16,280 --> 00:58:17,880
It's considerably simpler.

822
823
00:58:17,880 --> 00:58:24,920
Note that we replace these last three arguments to delegate
the selector and the context in full with just the block.

823
824
00:58:24,920 --> 00:58:29,510
Also note that one thing we've done here is
get rid of this pesky void star argument.

824
825
00:58:29,510 --> 00:58:34,650
Refining that, void star arguments are really more trouble
than they're worth and we're looking at getting rid of them

825
826
00:58:34,650 --> 00:58:41,660
from our APIs as much as possible, and for one thing they
really do not behave very well under GC for instance.

826
827
00:58:41,660 --> 00:58:48,020
Here, one final example of blocks as
conveniences, the new APIs we've added in UIView,

827
828
00:58:48,020 --> 00:58:52,810
for instance animateWithDuration
animation looks fairly convenient.

828
829
00:58:52,810 --> 00:58:59,470
In fact, it replaces three lines of boilerplate code
like here, that this is the code you would have had to use

829
830
00:58:59,470 --> 00:59:05,450
on iPhone OS 3 with just one line where you're
specifying the animations you want right there in the body

830
831
00:59:05,450 --> 00:59:09,070
of the block, so again, super convenient.

831
832
00:59:09,070 --> 00:59:16,020
Hopefully, here you've heard about how good API is
very important part of Cocoa and Cocoa Touch design.

832
833
00:59:16,020 --> 00:59:20,750
We take a good API design very seriously and I
hope I've been able to communicate how we do that

833
834
00:59:20,750 --> 00:59:25,110
and how you can also do it yourself in your
own applications and in your own designs.

834
835
00:59:25,110 --> 00:59:30,420
Now modeling your APIs as ours will
allow your APIs to be more predictable

835
836
00:59:30,420 --> 00:59:36,660
so you can actually know almost all the new method names, just
roll off your tongue, you don't have to worry about them.

836
837
00:59:36,660 --> 00:59:40,270
Widely reusable, you can use it in
other projects, give it to other people,

837
838
00:59:40,270 --> 00:59:44,630
and they will also be better performing
as you hopefully saw.

838
839
00:59:44,630 --> 00:59:48,860
And one final warning, you know,
API design is an evolving art.

839
840
00:59:48,860 --> 00:59:52,550
We have examples of some APIs that are not perfectly named.

840
841
00:59:52,550 --> 00:59:56,390
So, if you ever run across something
that looks a bit fishy, maybe it is.

841
842
00:59:56,390 --> 01:00:02,730
So don't take, you know, everything strictly, but again
most of our APIs are going in the right direction.

842
843
01:00:02,730 --> 01:00:08,300
For more information, you know, you can contact
our evangelist and we have lot of great documentation,

843
844
01:00:08,300 --> 01:00:10,460
just the starting point, developer.apple.com.

844
845
01:00:10,460 --> 01:00:17,150
You can do searches for the various keywords I gave you, and
there is a lot of great background stuff on this.

845
