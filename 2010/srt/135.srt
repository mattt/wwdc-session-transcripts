1
00:00:06,370 --> 00:00:07,500
>>David Chan: Good afternoon.

1
2
00:00:07,500 --> 00:00:08,860
My name is David Chan.

2
3
00:00:08,860 --> 00:00:16,080
I'm on the iOS Performance Team and I'll be joined by
colleague later Peter Handel whose on the iOS Power Team.

3
4
00:00:16,080 --> 00:00:22,930
So today, we're going to talk about Advanced
Performance Optimization on iPhone OS.

4
5
00:00:22,930 --> 00:00:25,260
And in particular this is Part 1 of two.

5
6
00:00:25,260 --> 00:00:31,670
We're going to be talking about animations,
scrolling, responsiveness, and battery life today.

6
7
00:00:32,730 --> 00:00:38,160
"The iPad is a far slower machine that a modern
MacBook in terms of raw hardware performance,

7
8
00:00:38,160 --> 00:00:41,440
but feels faster in many ways, because
you never have to wait for it."

8
9
00:00:41,440 --> 00:00:43,090
This is a great quote.

9
10
00:00:43,090 --> 00:00:46,900
Basically, what this is saying
is this is why you're here today.

10
11
00:00:46,900 --> 00:00:51,210
People love using the iPad, the iPhone and
iPod Touch because it's a magical experience.

11
12
00:00:51,210 --> 00:00:56,670
And a large part of that experience
is you never have to wait for it.

12
13
00:00:56,670 --> 00:01:02,460
So, great performance is all about
creating an outstanding user experience.

13
14
00:01:02,460 --> 00:01:08,660
So today, we're going to be covering the most
advanced topics, for our most advanced developers.

14
15
00:01:08,660 --> 00:01:11,490
We assumed that you've already
written an iPhone application,

15
16
00:01:11,490 --> 00:01:15,750
you've played with all the different aspects
of it, and you've seen the challenges.

16
17
00:01:15,750 --> 00:01:22,460
Today, we're going to be covering animation and
scrolling, responsiveness, and battery life.

17
18
00:01:22,460 --> 00:01:27,370
Tomorrow, we're going to be covering
memory, databases, and I/O.

18
19
00:01:27,370 --> 00:01:30,420
Be sure to show up for that one as well.

19
20
00:01:30,420 --> 00:01:35,350
So, across both of these talks, we're
going to be trying to give you a framework

20
21
00:01:35,350 --> 00:01:37,720
to solve your application performance challenges.

21
22
00:01:37,720 --> 00:01:39,030
Now what do we mean by that?

22
23
00:01:39,030 --> 00:01:42,060
First, we want you to learn as
much about the system as possible.

23
24
00:01:42,060 --> 00:01:45,990
You're going to use that knowledge as
a mental model so that when you come

24
25
00:01:45,990 --> 00:01:50,550
up with performance issues you can
think creatively about solving them.

25
26
00:01:51,710 --> 00:01:55,200
And finally, we want you to really measure progress.

26
27
00:01:55,200 --> 00:02:03,590
We built great tools into the iPhone SDK and we want you
to use them to see exactly what's happening on your system.

27
28
00:02:03,590 --> 00:02:09,460
Don't guess and be able to see that the changes
that you're making are making real progress.

28
29
00:02:09,460 --> 00:02:11,760
So let's jump in.

29
30
00:02:11,760 --> 00:02:14,660
Animation and scrolling is first up, so let's begin.

30
31
00:02:14,660 --> 00:02:22,620
So what we're going to be covering today is we're
going to go behind the scenes of the animation.

31
32
00:02:22,620 --> 00:02:25,160
Now you're all familiar on how to create an animation.

32
33
00:02:25,160 --> 00:02:28,150
We're going to see what happens
after you commit that animation.

33
34
00:02:28,150 --> 00:02:32,460
We're going to go into how to keep your
animations responsive, how to keep them smooth

34
35
00:02:32,460 --> 00:02:39,050
and how to keep all these nice scroll views
in your system very, very nice and smooth.

35
36
00:02:39,050 --> 00:02:42,970
So, here's a timeline diagram of a typical animation.

36
37
00:02:42,970 --> 00:02:47,190
Now it has three stages and we'll
walk through them one by one.

37
38
00:02:47,190 --> 00:02:49,660
First, you create your animation.

38
39
00:02:49,660 --> 00:02:51,170
Now this is pretty simple.

39
40
00:02:51,170 --> 00:02:52,630
You've probably seen this before.

40
41
00:02:52,630 --> 00:02:54,770
Use UIView, create animations.

41
42
00:02:54,770 --> 00:02:56,430
You changed some part of your view hierarchy.

42
43
00:02:56,430 --> 00:02:58,650
You maybe changed some properties.

43
44
00:02:58,650 --> 00:03:01,590
And then you commit it.

44
45
00:03:01,590 --> 00:03:03,880
So that's step two.

45
46
00:03:03,880 --> 00:03:09,660
Now this is where the system calls your
layoutSubviews, and drawRect calls.

46
47
00:03:09,660 --> 00:03:15,430
Now this is when the system is ready to take
your animation, ship it over the render server,

47
48
00:03:15,430 --> 00:03:17,860
and have that animation show up for the user.

48
49
00:03:17,860 --> 00:03:21,030
And that's the third process.

49
50
00:03:21,030 --> 00:03:25,940
Every single frame is rendered by the render
server for the length of your animation.

50
51
00:03:25,940 --> 00:03:28,760
So let's start with step one.

51
52
00:03:28,760 --> 00:03:33,810
So, this should be pretty simple code
for you guys, pretty familiar stuff.

52
53
00:03:33,810 --> 00:03:38,380
We're creating a view hierarchy
starting with that inside view.

53
54
00:03:38,380 --> 00:03:41,350
We're putting a little scale on to that.

54
55
00:03:41,350 --> 00:03:42,590
So that starts up very small.

55
56
00:03:42,590 --> 00:03:49,940
We're going to begin the animation and add that
new view hierarchy to our existing view hierarchy

56
57
00:03:49,940 --> 00:03:53,430
and then bring the transform up so it will become full size.

57
58
00:03:53,430 --> 00:03:58,040
So let's see what that looks like, great.

58
59
00:03:58,040 --> 00:04:01,280
So, this is what we just saw.

59
60
00:04:01,280 --> 00:04:06,830
We saw the existing view hierarchy there
and then we add a new part to that.

60
61
00:04:06,830 --> 00:04:09,630
So that's the card with image and that great label.

61
62
00:04:09,630 --> 00:04:12,980
So as you can see, they're not quite filled in yet.

62
63
00:04:12,980 --> 00:04:17,400
The next thing that happens in stage two is
that the animation is prepared for commit

63
64
00:04:17,400 --> 00:04:20,830
by calling layoutSubviews and drawRect
on each of those new views.

64
65
00:04:20,830 --> 00:04:26,230
So they just got filled in and now they're ready for commit.

65
66
00:04:26,230 --> 00:04:34,330
So, we have the new view hierarchy on the left here and what
render server thinks is going to be displayed on screen.

66
67
00:04:34,330 --> 00:04:38,350
And major part of commit is that this gets sent over.

67
68
00:04:38,350 --> 00:04:44,780
So now this towards syncs up and the transaction
of the animation is committed to the render server

68
69
00:04:44,780 --> 00:04:49,280
like you would commit a transaction to a database.

69
70
00:04:49,280 --> 00:04:51,490
So now we're on to stage three.

70
71
00:04:51,490 --> 00:04:53,670
Now for every single frame of your animation--

71
72
00:04:53,670 --> 00:04:59,210
the length of the animation, the render
server goes through these four steps.

72
73
00:04:59,210 --> 00:05:05,170
It takes the current time and looks over
the tree that it has for your application

73
74
00:05:05,170 --> 00:05:09,590
and sees what animations it needs
to update for the current time.

74
75
00:05:09,590 --> 00:05:15,970
So in our example, we have that scale starting
very, very small and coming up to full size.

75
76
00:05:15,970 --> 00:05:22,500
Now, every 160th of a second, that
scale gets interpolated to a new value

76
77
00:05:22,500 --> 00:05:26,220
so it gets just a little bit bigger,
a little bigger on every frame.

77
78
00:05:26,220 --> 00:05:34,840
So the second part is we calculate the
screen region that needs to be updated.

78
79
00:05:34,840 --> 00:05:40,040
This is important because our render server is
really, really great at figuring out, "Well,

79
80
00:05:40,040 --> 00:05:44,480
we don't need to update the whole screen, we
just need to update that things have changed.

80
81
00:05:44,480 --> 00:05:48,700
So it can walk over the tree and figure
this out in a very, very nice way.

81
82
00:05:48,700 --> 00:05:56,810
The third thing it does is it takes the whole view hierarchy
and constructs a scene using Quads and using the images

82
83
00:05:56,810 --> 00:06:03,400
that you draw-- that you drew into in your
image assets as textures and creates a series

83
84
00:06:03,400 --> 00:06:08,080
of graphic commands for the GPU to render this scene.

84
85
00:06:08,080 --> 00:06:14,770
Once it's handed off the GPU, it tells it to present the
rendered update to the display and this is a lot of stuff.

85
86
00:06:14,770 --> 00:06:18,050
And again, it happens on every single frame.

86
87
00:06:18,050 --> 00:06:20,830
Every 160th of a second, that's 16 milliseconds.

87
88
00:06:20,830 --> 00:06:23,060
Not a long time right?

88
89
00:06:23,060 --> 00:06:27,530
So that's behind the scenes of animations.

89
90
00:06:27,530 --> 00:06:31,860
Let's talk about what can go wrong in stage two.

90
91
00:06:31,860 --> 00:06:39,240
So, like I said before we create,
commit and render an animation.

91
92
00:06:39,240 --> 00:06:43,620
And when you create the animation,
you can often set a delay--

92
93
00:06:43,620 --> 00:06:48,910
or, I'm sorry, a duration, and when you
create that duration, you're basically saying,

93
94
00:06:48,910 --> 00:06:54,390
"I want the animation to start and
end within this amount of time."

94
95
00:06:54,390 --> 00:06:59,260
So as you can see, the start of that duration
starts as soon as you create the animation.

95
96
00:06:59,260 --> 00:07:05,830
Now if you spend too much time preparing and committing that
animation, you know, maybe you spent too many time drawing,

96
97
00:07:05,830 --> 00:07:13,640
you spent too much time laying out subviews, creating
views, that can end up with a pretty serious delay.

97
98
00:07:13,640 --> 00:07:16,050
So what can you do?

98
99
00:07:16,050 --> 00:07:22,570
Well, the first thing that we use-- that we'd say
you should do is to draw less when you're preparing.

99
100
00:07:22,570 --> 00:07:28,150
So it only invalidates views that need to be
updated, only call setNeedsDisplay on visible views,

100
101
00:07:28,150 --> 00:07:35,530
if you call on hidden views, they'll still get drawn,
and only implement drawRect when absolutely needed.

101
102
00:07:35,530 --> 00:07:37,480
Now if you're going to have an empty drawRect,

102
103
00:07:37,480 --> 00:07:42,720
this still matter because the system has
to allocate a backing store for this.

103
104
00:07:42,720 --> 00:07:46,120
Second, you should invalidate smaller
regions of large views.

104
105
00:07:46,120 --> 00:07:51,950
If you have large views and let's say you
implement something like a painting program,

105
106
00:07:51,950 --> 00:07:59,460
we have a great mechanism built into systems that you can
implement a smart drawRect and use setNeedsDisplayInRect

106
107
00:07:59,460 --> 00:08:06,170
so that you can, for example like in the painting
program, only invalidate the regions around touches.

107
108
00:08:06,170 --> 00:08:11,730
And finally, if that isn't your kind of program,
you know, you should think about taking large views

108
109
00:08:11,730 --> 00:08:16,260
and decomposing them into the parts that
stay the same and the parts that change.

109
110
00:08:16,260 --> 00:08:22,020
So the other part of preparing an
animation is if you use image assets.

110
111
00:08:22,020 --> 00:08:26,130
Your image assets are going to
get decompressed in stage two.

111
112
00:08:26,130 --> 00:08:33,600
So we often see big delays because people are
using, you know, very, very large images or formats

112
113
00:08:33,600 --> 00:08:35,390
that just aren't appropriate for the device.

113
114
00:08:35,390 --> 00:08:39,150
So try to decompress and rescale big images sparingly.

114
115
00:08:39,150 --> 00:08:43,300
This will, you know, keep your animations quite responsive.

115
116
00:08:43,300 --> 00:08:47,030
And try to use the, you know, formats
that are optimized for iPhone.

116
117
00:08:47,030 --> 00:08:52,040
Or iPhone-optimized PNGs, those that are
added, your Xcode projects are great,

117
118
00:08:52,040 --> 00:08:54,770
and JPEG and TIFFs have different tradeoffs.

118
119
00:08:54,770 --> 00:09:02,410
JPEGs are small in disk but have, you know,
perhaps lost equality, whereas TIFFs are very large

119
120
00:09:02,410 --> 00:09:07,720
and so they make a little bit more
time to read off of storage.

120
121
00:09:07,720 --> 00:09:16,890
Finally, if you create any custom CGImages, we highly
encourage you to use to UIGraphics convenience functions.

121
122
00:09:16,890 --> 00:09:20,120
This will take care of the all the nitty-gritty details.

122
123
00:09:20,120 --> 00:09:25,640
And the problem-- the reason I'm mentioning is that if
you get those details a little bit wrong it's possible

123
124
00:09:25,640 --> 00:09:29,700
that the system will have to copy those
images for you into the right format.

124
125
00:09:29,700 --> 00:09:32,230
So try to avoid those.

125
126
00:09:32,230 --> 00:09:39,900
And you can use the Color Copied Images debug
option in the Core Animation Instrument to see them.

126
127
00:09:39,900 --> 00:09:43,260
So this is a big topic.

127
128
00:09:43,260 --> 00:09:45,990
People want to know how to make their animation smoother.

128
129
00:09:45,990 --> 00:09:51,380
So we're going to go through and talk about
exactly what happens behind the scenes.

129
130
00:09:51,380 --> 00:09:58,180
We're going to talk about some specific examples of how
you can improve your animations and we're going to look

130
131
00:09:58,180 --> 00:10:07,860
at a new feature in iPad and iOS 4 that I called dynamic
flattening that can help you create smoother animations.

131
132
00:10:07,860 --> 00:10:09,280
So let's begin.

132
133
00:10:09,280 --> 00:10:15,870
So, your server tries to render each frame
your animation at 60 times per second.

133
134
00:10:15,870 --> 00:10:21,490
This again is not very, very much
time to do any form of rendering.

134
135
00:10:21,490 --> 00:10:25,500
So, fewer pixels to render, means smoother animations.

135
136
00:10:25,500 --> 00:10:27,540
That means fewer input pixels.

136
137
00:10:27,540 --> 00:10:34,070
So, if you have very, very large images for
small view, that's not going to be great.

137
138
00:10:34,070 --> 00:10:42,880
If you have a lot of blended views, you're
going to end up with a lot more output pixels.

138
139
00:10:42,880 --> 00:10:47,260
And finally, few rendering passes
also means better animation.

139
140
00:10:47,260 --> 00:10:55,760
So like I said in the beginning, we want to
get you guys to measure what's going on here.

140
141
00:10:55,760 --> 00:11:00,690
So we're going to be using the Core Animation
Instrument and this is really simple to use.

141
142
00:11:00,690 --> 00:11:02,940
I hope every one of you has tried using this.

142
143
00:11:02,940 --> 00:11:10,340
You just plug in your device, launch instruments,
and select your application and hit record

143
144
00:11:10,340 --> 00:11:15,820
and it'll show you the number of frames
that were rendered in the last second.

144
145
00:11:15,820 --> 00:11:20,680
It gives you on a second by second basis that count.

145
146
00:11:20,680 --> 00:11:25,420
Now, when you're measuring, you want to make sure
that you measure the base line as in what it looks

146
147
00:11:25,420 --> 00:11:28,120
like right now and any changes that you make.

147
148
00:11:28,120 --> 00:11:31,460
So you make sure that you're actually making improvements.

148
149
00:11:31,460 --> 00:11:34,200
So I said before that this is a count.

149
150
00:11:34,200 --> 00:11:40,650
Now, one thing to keep on mind is our animation
from before was only about 300 milliseconds or so.

150
151
00:11:40,650 --> 00:11:44,200
And when I mentioned this the first
time, I only saw that I got 18 frames

151
152
00:11:44,200 --> 00:11:46,860
and I was really disappointed I thought that was quite slow.

152
153
00:11:46,860 --> 00:11:51,480
But it turns out that's actually the max that
we're hitting-- that we're shooting for right?

153
154
00:11:51,480 --> 00:12:00,950
So, at 60 frames per second is our target rate and although
I only rendered 18 frames, that was the correct number.

154
155
00:12:00,950 --> 00:12:06,760
So you have to do that division if you're going
to be measuring stuff at subsecond levels.

155
156
00:12:06,760 --> 00:12:11,130
But one thing that you can do and it's really
neat trick that I actually really like a lot.

156
157
00:12:11,130 --> 00:12:14,890
You can link in the animation over a few
seconds for much, much better measurements.

157
158
00:12:14,890 --> 00:12:17,880
And this helps reduce measurement jitter.

158
159
00:12:17,880 --> 00:12:20,860
This allows you to get the timing just right.

159
160
00:12:20,860 --> 00:12:26,960
And here we actually see that when I do
that, I was really happy and surprised

160
161
00:12:26,960 --> 00:12:30,520
that I got 60 frames a second over
the course of that animation.

161
162
00:12:30,520 --> 00:12:35,140
So, fewer pixels to render mean smoother animation.

162
163
00:12:35,140 --> 00:12:40,530
Now I've mentioned that the render server actually
looks over the whole view hierarchy and tries to figure

163
164
00:12:40,530 --> 00:12:43,110
out exactly which screen regions need to be rendered.

164
165
00:12:43,110 --> 00:12:49,670
Now you can actually see, one, it figured out that I
needed a render using the Core Animation Instrument again.

165
166
00:12:49,670 --> 00:12:53,670
And we're going to be using the
flash updated regions check box.

166
167
00:12:53,670 --> 00:12:57,490
Now, what this will do is it will
cause parts of your application

167
168
00:12:57,490 --> 00:13:02,800
that are being updated by the renderer to flash yellow.

168
169
00:13:02,800 --> 00:13:06,280
Let's take a look of what that looks like.

169
170
00:13:06,280 --> 00:13:11,430
So, we're bringing in the card, it flashed
yellow, that's exactly what we want to see.

170
171
00:13:11,430 --> 00:13:17,930
So that gives you kind of a baseline to figure what
parts of the application I actually need to fiddle

171
172
00:13:17,930 --> 00:13:21,540
with for this animation that I care about.

172
173
00:13:21,540 --> 00:13:29,990
So, let's jump in to one specific way that you
can improve the smoothness of your animation.

173
174
00:13:29,990 --> 00:13:32,540
We said this before.

174
175
00:13:32,540 --> 00:13:38,530
You want to reduce the amount of you blending
in your animation and in your view hierarchy.

175
176
00:13:38,530 --> 00:13:42,760
So again, let's take a look at how you can see that.

176
177
00:13:42,760 --> 00:13:47,200
So Core Animation Instrument, we're going
to be checking color blended layers.

177
178
00:13:47,200 --> 00:13:50,470
And let's take a look at what that looks like.

178
179
00:13:50,470 --> 00:13:53,830
So, we have the same view from before except

179
180
00:13:53,830 --> 00:13:58,340
that now the opaque regions are shaded green
and the blended regions are shaded red.

180
181
00:13:58,340 --> 00:14:08,190
And as you can see towards the top, the regions
that are even deeper blended are darkened red.

181
182
00:14:08,190 --> 00:14:10,070
So, why does this matter?

182
183
00:14:10,070 --> 00:14:16,420
Well, the graphic system can form a certain number of
pixel operations per frame to maintain a smooth frame rate.

183
184
00:14:16,420 --> 00:14:20,140
And blending requires more operations per on-screen pixel.

184
185
00:14:20,140 --> 00:14:29,300
So if you're just putting down an opaque view onto screen,
you can just write each of those pixels out, right?

185
186
00:14:29,300 --> 00:14:38,050
If you have to blend, the graphic system has to read the
value there and then write the ending pixel because it needs

186
187
00:14:38,050 --> 00:14:41,830
to figure out what is actually blending to, right?

187
188
00:14:41,830 --> 00:14:48,290
So the second reason is, the graphic system
supports efficient hidden surface removal.

188
189
00:14:48,290 --> 00:14:52,140
That is if something is fully occluded
then we can get rid of it.

189
190
00:14:52,140 --> 00:14:54,060
And it doesn't even have to touch that surface.

190
191
00:14:54,060 --> 00:14:56,050
Never even gets rendered.

191
192
00:14:56,050 --> 00:15:01,830
So-- But it can only avoid views that
are completely occluded by opaque views.

192
193
00:15:01,830 --> 00:15:09,480
So by having all the views that should be opaque,
be opaque and you can help out the graphic system

193
194
00:15:09,480 --> 00:15:13,280
and it can render your animation very smoothly.

194
195
00:15:13,280 --> 00:15:20,780
So, I mentioned that the graphic system can perform
certain number of operations per frame and we're going

195
196
00:15:20,780 --> 00:15:25,060
to take a look at what that means for
opaque views and for blended views.

196
197
00:15:25,060 --> 00:15:32,860
So here on the left, we have that view of
my animation with color blended layers on

197
198
00:15:32,860 --> 00:15:36,500
and you can see the opaque ones
are green and the blended ones red.

198
199
00:15:36,500 --> 00:15:44,750
And on the right, we have a rectangle that represents the
approximate number of pixel operations per frame at 60 bits.

199
200
00:15:44,750 --> 00:15:51,420
So let's see what happens when we bring over the
opaque pixel, the opaque views when they get drawn.

200
201
00:15:51,420 --> 00:15:53,130
I'm sorry, when they get rendered.

201
202
00:15:53,130 --> 00:16:00,600
So as you can see they're overlapping over on the
actual view and they're overlapping here as well.

202
203
00:16:00,600 --> 00:16:02,380
Now why is that?

203
204
00:16:02,380 --> 00:16:07,120
That's because our graphic system supports
something called differed rendering.

204
205
00:16:07,120 --> 00:16:13,190
Basically, what allow us to do is figure out
what's overlapping what and we don't need

205
206
00:16:13,190 --> 00:16:20,700
to spend anymore time drawing things-- I'm sorry, rendering
things that are just going to be overlapped anyway.

206
207
00:16:20,700 --> 00:16:25,860
However, we can still have these blended views left.

207
208
00:16:25,860 --> 00:16:28,180
So let's see what happens when we bring those over.

208
209
00:16:28,180 --> 00:16:36,690
So as you can see, the number of pixel operations
that this blended views take up don't take advantage

209
210
00:16:36,690 --> 00:16:41,540
of this optimization and so the use up
even more pixel operations per frame.

210
211
00:16:41,540 --> 00:16:43,250
So what can you do about it?

211
212
00:16:43,250 --> 00:16:50,110
Well, first it's important to understand how
views get marked as needing to be blended.

212
213
00:16:50,110 --> 00:16:51,940
Contents determine the blendings.

213
214
00:16:51,940 --> 00:16:54,520
So there are three ways that happens.

214
215
00:16:54,520 --> 00:17:01,290
First, views that are drawn or by default part
is opaque and you have to actually set that--

215
216
00:17:01,290 --> 00:17:05,110
set the flag to no and implement drawRect.

216
217
00:17:05,110 --> 00:17:08,080
Once you do that, it's been blended.

217
218
00:17:08,080 --> 00:17:17,350
Second, the use image assets like PNGs,
they often can contained an alpha channel.

218
219
00:17:17,350 --> 00:17:23,240
If you look in your image assets with
preview and hit the Get Info button,

219
220
00:17:23,240 --> 00:17:26,970
you can actually see whether or not your PNGs have alpha.

220
221
00:17:26,970 --> 00:17:33,480
And if you didn't intend for that image asset to be
blended in your system, then you really should go

221
222
00:17:33,480 --> 00:17:38,500
in to your Image Editor, resave
that, and get rid of that alpha.

222
223
00:17:38,500 --> 00:17:46,200
The third way that views can become blended is by
creating opaque-- sorry, creating custom CGImages.

223
224
00:17:46,200 --> 00:17:53,850
And if you use the UIGraphics convenience functions,
we make it really easy to have you pass yes

224
225
00:17:53,850 --> 00:17:58,490
to opaque and then the image ends up being opaque.

225
226
00:17:58,490 --> 00:18:03,340
So these are the ways that contents
become blended or opaque.

226
227
00:18:03,340 --> 00:18:07,480
And the next question is, well, what
else can you do about it, right?

227
228
00:18:07,480 --> 00:18:14,760
Once you've fixed all the accidental blending in your
views, let's say you still have a lot of blending.

228
229
00:18:14,760 --> 00:18:21,030
Well, the next thing to remember is that it's the number
of pixels that are rendered and the number of pixels

229
230
00:18:21,030 --> 00:18:25,140
that are blended that impact the performance of this.

230
231
00:18:25,140 --> 00:18:30,010
And so, if you decompose a large blended
view into the parts that actually need

231
232
00:18:30,010 --> 00:18:33,480
to be blended and the parts that are still opaque.

232
233
00:18:33,480 --> 00:18:39,010
Even though that ends up being more views,
that still ends up with better performance.

233
234
00:18:39,010 --> 00:18:43,670
OK. So that's view blending.

234
235
00:18:43,670 --> 00:18:49,430
Now we're going to move on to talking
about Offscreen rendering.

235
236
00:18:49,430 --> 00:18:51,380
So what is Offscreen rendering?

236
237
00:18:51,380 --> 00:18:58,020
Well, to achieve certain effects on our system,
the compositor or the render server needs

237
238
00:18:58,020 --> 00:19:03,590
to use a temporary offscreen region
in order to achieve the final effect.

238
239
00:19:03,590 --> 00:19:12,870
And one way of thinking about this is how a painter will
use their color pallette and take two colors together

239
240
00:19:12,870 --> 00:19:18,340
and mix them before painting on their final canvas.

240
241
00:19:18,340 --> 00:19:22,710
So why is this slow?

241
242
00:19:22,710 --> 00:19:30,530
Well, besides the fact that you are rendering more pixels,
you're rendering to this offscreen context and then taking

242
243
00:19:30,530 --> 00:19:34,100
that and then rendering to the final display.

243
244
00:19:34,100 --> 00:19:37,880
You're also switching between this
main and offscreen context

244
245
00:19:37,880 --> 00:19:42,520
and they'll stall the graphics pipeline
and, you know, really hurt performance.

245
246
00:19:42,520 --> 00:19:46,740
So let's take a look at how you can
detect this into your own animations.

246
247
00:19:46,740 --> 00:19:51,400
So again, we're going to use the Core
Animation Instrument and we're going

247
248
00:19:51,400 --> 00:19:55,200
to be checking the Color Offscreen-Rendered Yellow flag.

248
249
00:19:55,200 --> 00:20:04,810
Now this shades yellow portions of your animation that had
to be rendered offscreen and then back to the main screen.

249
250
00:20:04,810 --> 00:20:09,110
So this isn't quite as easy as blended views.

250
251
00:20:09,110 --> 00:20:14,890
I can't just tell you to go find the blended views
that aren't supposed to be blended and get rid of them.

251
252
00:20:14,890 --> 00:20:20,930
Avoiding this kind of offscreen rendering
requires some creative solutions.

252
253
00:20:20,930 --> 00:20:28,690
So let's take a look at couple of examples
and some workarounds that we come up for you.

253
254
00:20:28,690 --> 00:20:39,200
So let's say I have an animation where I take an image with
a background color and I fade opacity from solid to blank.

254
255
00:20:39,200 --> 00:20:44,310
So it looks something like this
which have the image, we have--

255
256
00:20:44,310 --> 00:20:50,420
set the background color and we begin an
animation, set the alpha to 0 and it fades away.

256
257
00:20:50,420 --> 00:20:57,450
Now to composite correctly, the image
needs to be composited over the color

257
258
00:20:57,450 --> 00:21:03,170
at full opacity offscreen and then blended into the view.

258
259
00:21:03,170 --> 00:21:05,920
So let's take a look at that.

259
260
00:21:05,920 --> 00:21:15,400
So, you can see that the blue in the iTunes icon
and the greens in the face in the photos look right.

260
261
00:21:15,400 --> 00:21:16,660
They're faded over black.

261
262
00:21:16,660 --> 00:21:18,170
They're just dimmed a little bit.

262
263
00:21:18,170 --> 00:21:28,040
Now, what I mean correctly, one naive way of trying to avoid
this kind of offscreen rendering is just to say what happens

263
264
00:21:28,040 --> 00:21:37,460
if I just blend that orange color into the background
at the lower opacity and then blend in the image.

264
265
00:21:37,460 --> 00:21:40,780
So you basically break this out into two separate layers.

265
266
00:21:40,780 --> 00:21:43,540
Let's take a look at what that looks like.

266
267
00:21:43,540 --> 00:21:47,120
So as you can see, the image doesn't look quite right.

267
268
00:21:47,120 --> 00:21:54,530
You know, the-- the blue isn't quite right and, you
know, the face in the background gets this orange tint.

268
269
00:21:54,530 --> 00:22:00,430
So let's take a look at some other
ways that you might approach this.

269
270
00:22:00,430 --> 00:22:11,340
So one workaround is to composite the background
color and image in drawRect first just like that.

270
271
00:22:11,340 --> 00:22:17,110
And then when you faded out, so here we've actually
drawn it and then when it's actually faded out,

271
272
00:22:17,110 --> 00:22:22,090
when it's being rendered, it doesn't have to
go offscreen and just fades out very nicely.

272
273
00:22:22,090 --> 00:22:30,410
So this falls in the category of thinking about what
the graphic system needs to do to render that offscreen

273
274
00:22:30,410 --> 00:22:34,040
and do it ahead of time using Core Graphics in drawRect.

274
275
00:22:34,040 --> 00:22:36,670
So, one more workaround.

275
276
00:22:36,670 --> 00:22:41,890
So if we're fading over a static
background like here, this is great.

276
277
00:22:41,890 --> 00:22:43,330
We have a black background.

277
278
00:22:43,330 --> 00:22:45,890
You know, nothing is changing behind it.

278
279
00:22:45,890 --> 00:22:47,800
There are no patterns.

279
280
00:22:47,800 --> 00:22:54,390
You can try fading in a view that contains
the background over the view instead.

280
281
00:22:54,390 --> 00:22:55,970
So it might look something like this.

281
282
00:22:55,970 --> 00:23:00,230
We just create a new view with the bounds of our view.

282
283
00:23:00,230 --> 00:23:05,850
We set the background color to black
and then we fade in from 0 to 1 instead.

283
284
00:23:05,850 --> 00:23:07,740
So let's see what that looks like.

284
285
00:23:07,740 --> 00:23:11,000
It's great, it looks exactly the same.

285
286
00:23:11,000 --> 00:23:19,350
So the lesson to this is if you see a situation where
you have offscreen rendering, this often alternate ways

286
287
00:23:19,350 --> 00:23:24,240
of getting the same effect, visually
by using a different technique.

287
288
00:23:24,240 --> 00:23:29,760
Let's take a look at another example.

288
289
00:23:29,760 --> 00:23:39,990
So new on iPad and iOS 4, CALayers now support
this great property called cornerRadius.

289
290
00:23:39,990 --> 00:23:46,230
And this allows you to get these nice
rounded corners on your views really easy,

290
291
00:23:46,230 --> 00:23:50,110
you pop that layer-- you pop that property on.

291
292
00:23:50,110 --> 00:23:54,540
Now, animating a view with a rounded
corner mask, as you will find out,

292
293
00:23:54,540 --> 00:24:01,000
requires that the renderer would go
offscreen, render your image and then apply

293
294
00:24:01,000 --> 00:24:04,570
that mask that contains the rounded corner.

294
295
00:24:04,570 --> 00:24:09,640
Now, this actually applies to all
masking that's non-pixel aligned.

295
296
00:24:09,640 --> 00:24:16,200
So if you have an arbitrary mask layer that you
assign to a CALayer, you'll see this as well.

296
297
00:24:16,200 --> 00:24:24,230
Or if you're moving a view that has clips to
bounds set and it's moving on non-pixel boundaries.

297
298
00:24:24,230 --> 00:24:29,250
In any case, let's take a look
at the rounded corner example.

298
299
00:24:29,250 --> 00:24:31,220
So, what can we do about it?

299
300
00:24:31,220 --> 00:24:33,260
Well, again, we have two Workarounds.

300
301
00:24:33,260 --> 00:24:38,820
The first is to try to achieve the same
effect in Core Graphics ahead of time.

301
302
00:24:38,820 --> 00:24:46,790
New on iPad and iOS 4 is this great UIBezierPath API and
allows us to just to draw a path with that rounded rect

302
303
00:24:46,790 --> 00:24:55,790
with those great rounded corners and we set that as the
clipping region for whatever we draw into our background.

303
304
00:24:55,790 --> 00:24:59,140
So when we draw, the rounded corners come with it.

304
305
00:24:59,140 --> 00:25:03,630
Now of course, this only works if the
corners don't have to clip anything

305
306
00:25:03,630 --> 00:25:06,200
that actually goes outside of the rounded areas.

306
307
00:25:06,200 --> 00:25:09,960
But in our original situation, it works great.

307
308
00:25:09,960 --> 00:25:17,540
So the second workaround is to decompose
rounded corners into separate views.

308
309
00:25:17,540 --> 00:25:24,860
So basically, all that means is that you're creating
four small views that are positioned around your view

309
310
00:25:24,860 --> 00:25:27,690
that have a little black sliver drawn into it.

310
311
00:25:27,690 --> 00:25:31,020
And here are some codes for the top left corner.

311
312
00:25:31,020 --> 00:25:32,260
That's pretty simple.

312
313
00:25:32,260 --> 00:25:37,420
Again, this is one of those cases where
you can achieve the same visual effect just

313
314
00:25:37,420 --> 00:25:41,810
by using a different technique and
you can avoid offscreen rendering.

314
315
00:25:41,810 --> 00:25:48,500
OK, those are some ways that you
can avoid offscreen rendering.

315
316
00:25:48,500 --> 00:25:53,140
Remember fewer pixels to render means smoother animations.

316
317
00:25:53,140 --> 00:25:57,640
And that means fewer rendering passes
also means smoother animations.

317
318
00:25:57,640 --> 00:26:02,110
So let's talk about that new feature
I talked about, dynamic flattening.

318
319
00:26:02,110 --> 00:26:08,070
Now this is new in iOS 4 and on the iPad.

319
320
00:26:08,070 --> 00:26:17,120
And the reason we added this is that animating
changes to a complex view hierarchy can be choppy.

320
321
00:26:17,120 --> 00:26:29,020
So here we have the little subhierarchy that we added to
our existing hierarchy in our app for the Core Animation.

321
322
00:26:29,020 --> 00:26:31,700
Now why do I say this is slow?

322
323
00:26:31,700 --> 00:26:34,410
Well, it renders the hierarchy on every single frame.

323
324
00:26:34,410 --> 00:26:44,990
So as it's scaling in it works over that tree,
renders those subviews together and then scales it.

324
325
00:26:44,990 --> 00:26:48,940
So this animation would be smoother
with a flattened hierarchy, right?

325
326
00:26:48,940 --> 00:26:50,760
You do the work once.

326
327
00:26:50,760 --> 00:26:56,610
You draw it in drawRect and then just have
that scale it overtime, surely a lot faster.

327
328
00:26:56,610 --> 00:27:05,380
But as I'm sure you guys know it's kind of pain to change
your whole view hierarchy and then you lose the dynamism

328
329
00:27:05,380 --> 00:27:08,230
of being able to move views around it independently.

329
330
00:27:08,230 --> 00:27:13,540
So now you can flatten without changing
your view hierarchy using shouldRasterize.

330
331
00:27:13,540 --> 00:27:16,590
Let's see how you can use it.

331
332
00:27:16,590 --> 00:27:19,890
So like I said it's a CALayer property.

332
333
00:27:19,890 --> 00:27:26,380
Generally, the way you want to use it is you want to turn
it on before animations and turn it off after animations.

333
334
00:27:26,380 --> 00:27:29,010
Let's take a look at some code.

334
335
00:27:29,010 --> 00:27:32,890
So this is using the new animateWithDuration using blocks.

335
336
00:27:32,890 --> 00:27:37,100
So I'm just going to quickly walk through this example.

336
337
00:27:37,100 --> 00:27:39,250
So we created that scale before.

337
338
00:27:39,250 --> 00:27:43,270
Before the animation starts, we set shouldRasterize.

338
339
00:27:43,270 --> 00:27:49,920
And then during the animation, we just set the
Transformed to Identities so that brings it all the way up

339
340
00:27:49,920 --> 00:27:56,170
and then when the animation is done the
system will call my completion block here

340
341
00:27:56,170 --> 00:28:00,320
and all that it does is it sets
that shouldRasterize back to no.

341
342
00:28:00,320 --> 00:28:02,500
So let's see what that looks like.

342
343
00:28:02,500 --> 00:28:04,160
Let's see how it works.

343
344
00:28:04,160 --> 00:28:06,550
So here we have the subview hierarchy again.

344
345
00:28:06,550 --> 00:28:17,450
And we're going to hint the compositor that it should
render this view hierarchy offscreen and then cache.

345
346
00:28:17,450 --> 00:28:21,180
Now I just warned you a whole lot
about avoiding offscreen rendering.

346
347
00:28:21,180 --> 00:28:25,050
But I want to assure you this time,
this offscreen rendering for good.

347
348
00:28:25,050 --> 00:28:27,670
And this is how it's going to work.

348
349
00:28:27,670 --> 00:28:33,340
When we render for the first time, it's actually going to
render into this offscreen region and then it's cached.

349
350
00:28:33,340 --> 00:28:36,220
We're actually going to keep this around for frame to frame.

350
351
00:28:36,220 --> 00:28:43,630
And then on each step of the animation, it's
going to get rendered over just like that.

351
352
00:28:43,630 --> 00:28:50,520
So this is actually really, really nice
but it can hurt more than it can help.

352
353
00:28:50,520 --> 00:28:54,040
Don't turn on everywhere because
there's a limited cache size.

353
354
00:28:54,040 --> 00:29:01,210
And if you start setting lots of views with shouldRasterize,
you're going to overflow the cache and that ends

354
355
00:29:01,210 --> 00:29:06,670
up in a really, really bad situation,
ends up being much worse than before

355
356
00:29:06,670 --> 00:29:12,350
because essentially you're rendering every single view
that you set with shouldRasterize offscreen and the back

356
357
00:29:12,350 --> 00:29:14,640
on the screen and we just talked about how doing

357
358
00:29:14,640 --> 00:29:18,430
that in every frame can really, really
hurt your animation performance.

358
359
00:29:18,430 --> 00:29:25,050
And like any good cache, it throws away old results.

359
360
00:29:25,050 --> 00:29:29,690
So if you changed anything in your
view hierarchy during your animation.

360
361
00:29:29,690 --> 00:29:35,090
The render server actually has to throw away
that cached copy and then render a brand new one

361
362
00:29:35,090 --> 00:29:38,410
in order to actually show the proper results.

362
363
00:29:38,410 --> 00:29:43,850
So make sure you don't change anything during your
view hierarchy while you have shouldRasterize on,

363
364
00:29:43,850 --> 00:29:49,570
otherwise you ended up rendering
offscreen without great performance.

364
365
00:29:49,570 --> 00:29:52,030
So that's smooth animations.

365
366
00:29:52,030 --> 00:30:01,030
Remember, rendering fewer pixels means smoother animation
and that applies to blending, that's fewer output pixels

366
367
00:30:01,030 --> 00:30:06,260
that applies to rendering passes as well,
so reduce the amount of offscreen rendering.

367
368
00:30:06,260 --> 00:30:08,240
So let's talk about scrolling.

368
369
00:30:08,240 --> 00:30:11,970
Now, I talked a lot about animations first.

369
370
00:30:11,970 --> 00:30:16,540
But a lot of you probably care a little bit
more about scrolling now why did I do that?

370
371
00:30:16,540 --> 00:30:21,780
Well, it turns out that each frame
scrolling is a small animation.

371
372
00:30:21,780 --> 00:30:29,990
When you flick that scroll view every 160th
of a second is issued in brand new animation

372
373
00:30:29,990 --> 00:30:34,430
and that's calculating a new scroll
view and that's the implicit animation.

373
374
00:30:34,430 --> 00:30:36,540
It's going to prepare and commit that animation.

374
375
00:30:36,540 --> 00:30:39,130
So if you have a new cell coming on screen,

375
376
00:30:39,130 --> 00:30:44,260
your layout subviews gets called, your
self or rowAtIndexPath gets called.

376
377
00:30:44,260 --> 00:30:47,890
And the compositor has to render a brand new frame.

377
378
00:30:47,890 --> 00:30:52,080
So, the animation advice I gave earlier totally applies.

378
379
00:30:52,080 --> 00:30:55,340
Prepare yourself very quickly and then render very quickly.

379
380
00:30:55,340 --> 00:31:00,590
So here's another timeline diagram like I showed you before.

380
381
00:31:00,590 --> 00:31:07,310
As you can see these animations are squished together really
tight because they have to happen within 16 milliseconds

381
382
00:31:07,310 --> 00:31:10,490
in order to get that nice scrolling effect.

382
383
00:31:10,490 --> 00:31:16,590
So first thing that happens is that we create an
animation implicitly by calculating a new scroll position.

383
384
00:31:16,590 --> 00:31:19,530
We prepare and commit the animation.

384
385
00:31:19,530 --> 00:31:26,120
So this is what happens when your cell gets laid
out and this is where all the drawing happens.

385
386
00:31:26,120 --> 00:31:29,140
And finally the frame is rendered.

386
387
00:31:29,140 --> 00:31:33,740
Now, when I say the frame is rendered I really do
mean the whole table view gets rendered, right?

387
388
00:31:33,740 --> 00:31:38,580
Because every time you scroll, each of those
cells is moving in a different position.

388
389
00:31:38,580 --> 00:31:41,730
So, prepare cells quickly.

389
390
00:31:41,730 --> 00:31:45,710
Now, there are two major parts to preparation, right?

390
391
00:31:45,710 --> 00:31:48,730
There's layout and there's drawing.

391
392
00:31:48,730 --> 00:31:55,030
And on the layout side, that's when the table view gets
to tell you, "Well, you've adjusted the scroll position.

392
393
00:31:55,030 --> 00:32:00,080
Now give me your new cell if there's
a new cell appearing on screen.

393
394
00:32:00,080 --> 00:32:04,880
So you want to use the dequeueReusableCellWithIdentifier.

394
395
00:32:04,880 --> 00:32:06,490
We use those table cells.

395
396
00:32:06,490 --> 00:32:14,220
It's not necessary an advanced
tip but we do have to mention it.

396
397
00:32:14,220 --> 00:32:19,720
You will save a ton of time creating objects
and backing stores for each of those cells.

397
398
00:32:19,720 --> 00:32:24,390
And you know be sure to use unique
identifiers for similar cells.

398
399
00:32:24,390 --> 00:32:30,550
If you have lots of different kinds of cells in your table
view, don't spend the time to transform one to another.

399
400
00:32:30,550 --> 00:32:35,170
Use a little bit extra memory and
give them different identifiers.

400
401
00:32:35,170 --> 00:32:39,040
You can save time and you can get
those cells up really quickly.

401
402
00:32:39,040 --> 00:32:45,380
So the second part of preparation is drawing
and we've told a lot of you in the past

402
403
00:32:45,380 --> 00:32:48,060
to flatten a view hierarchy of your cells.

403
404
00:32:48,060 --> 00:32:49,810
And that's actually a really good idea.

404
405
00:32:49,810 --> 00:32:50,790
I like that.

405
406
00:32:50,790 --> 00:32:56,940
Because what it does is it reduces the amount of time
that it takes to render those cells in the table view.

406
407
00:32:56,940 --> 00:32:59,300
And so you end up with a nice scrolling effect, right?

407
408
00:32:59,300 --> 00:33:01,410
It's very, very smooth.

408
409
00:33:01,410 --> 00:33:07,420
However, I have seen some applications
where it scrolls nice and smoothly right

409
410
00:33:07,420 --> 00:33:11,730
up until you get a new cell and then it jumps.

410
411
00:33:11,730 --> 00:33:19,600
Now, what can happen here is too much cell
drawing, you can spend a lot of time drawing all

411
412
00:33:19,600 --> 00:33:25,210
of these views into the same cell and that isn't great.

412
413
00:33:25,210 --> 00:33:27,430
That's not a great experience.

413
414
00:33:27,430 --> 00:33:31,060
Your table view isn't scrolling very smoothly.

414
415
00:33:31,060 --> 00:33:37,160
So there's a nuance point and of course, you're going to
have to measure an experiment to see what works for you.

415
416
00:33:37,160 --> 00:33:42,810
But if you have that kind of scroll view in
your application where it scrolls very smoothly

416
417
00:33:42,810 --> 00:33:45,190
and then it jumps when you get a new cell.

417
418
00:33:45,190 --> 00:33:46,500
First measure it.

418
419
00:33:46,500 --> 00:33:52,220
But if you find that you spend a lot of
time drawing cells I have a tip for you.

419
420
00:33:52,220 --> 00:33:59,890
So elements that need to be rasterized
anyway, text labels, things with pads.

420
421
00:33:59,890 --> 00:34:02,120
Be sure to just flatten those together that make sense.

421
422
00:34:02,120 --> 00:34:03,950
Just flatten all those labels together.

422
423
00:34:03,950 --> 00:34:07,550
Those don't need to be composited by the render server.

423
424
00:34:07,550 --> 00:34:12,430
Do it once in Core Graphics, you'll be happy.

424
425
00:34:12,430 --> 00:34:19,590
But for elements that are just images, let's
say you would put them into an image view,

425
426
00:34:19,590 --> 00:34:25,810
you might consider letting the rasterizer handle--
sorry, the renderer handle a few of those.

426
427
00:34:25,810 --> 00:34:32,930
And basically, what you're doing is you're balancing the
time on the CPU spent when you're creating a new cell

427
428
00:34:32,930 --> 00:34:37,350
and the amount of time spent on
the GPU on every scroll change.

428
429
00:34:37,350 --> 00:34:45,950
So, like I said, there are two halves, you want
to prepare cells quickly and render quickly.

429
430
00:34:45,950 --> 00:34:50,850
Now, all of the lessons that we talked
about from smooth animations apply here.

430
431
00:34:50,850 --> 00:34:54,180
A few pixels to render means, smooth scrolling as well.

431
432
00:34:54,180 --> 00:34:56,420
So simplify the structure of your view hierarchies.

432
433
00:34:56,420 --> 00:35:00,750
If you have any unnecessary or
invisible views, just get rid of them.

433
434
00:35:00,750 --> 00:35:03,800
You want to reduce the amount of
view blending as much as possible.

434
435
00:35:03,800 --> 00:35:09,250
So, use color layers, color blended layers
to see what's going on in your table views,

435
436
00:35:09,250 --> 00:35:12,830
and reduce any offscreen rendering that you might have.

436
437
00:35:12,830 --> 00:35:16,460
That would actually really, really bad in the situation.

437
438
00:35:16,460 --> 00:35:23,410
And again, new to iPad and iOS 4, you can try to
use the dynamic flattening property in order to--

438
439
00:35:23,410 --> 00:35:30,360
you shouldRasterize property rather to flatten
your cell hierarchies if you haven't already.

439
440
00:35:30,360 --> 00:35:35,840
And this might be a nice way of making scrolling
performance just a little bit better for the cost.

440
441
00:35:35,840 --> 00:35:37,570
One caveat though.

441
442
00:35:37,570 --> 00:35:43,810
Your cell animations will not look
great if you keep this on all the time.

442
443
00:35:43,810 --> 00:35:49,540
So if you end up doing a rotation, you want to
turn this off just before the rotation starts.

443
444
00:35:49,540 --> 00:35:55,370
And for any edit animations, you want to turn
this off before the edit animation starts.

444
445
00:35:55,370 --> 00:36:03,090
So, we shipped a lot of devices
that run iPhone OS and iOS 4.

445
446
00:36:03,090 --> 00:36:09,040
Last year we shipped the iPhone 3GS
and the iPod Touch-- new iPod Touch.

446
447
00:36:09,040 --> 00:36:17,590
And these have twice the CPU power of the previous
generation, twice the RAM and the GPUs are way faster

447
448
00:36:17,590 --> 00:36:24,060
but what that means is, it is a big
gap between what you're developing

448
449
00:36:24,060 --> 00:36:28,560
on if you're using an iPhone 3GS and the iPhone 3G.

449
450
00:36:28,560 --> 00:36:33,550
And we have millions of customer who
have iPhone 3Gs and iPod Touches.

450
451
00:36:33,550 --> 00:36:36,330
And we want your apps to look great on them.

451
452
00:36:36,330 --> 00:36:43,310
So if you can, keep around one of these devices and
make sure to test on the devices you intend to target.

452
453
00:36:43,310 --> 00:36:50,250
iOS 4 runs on the 3G, the iPod Touch and iPhone 4.

453
454
00:36:50,250 --> 00:36:53,480
And we want everything to look great across those.

454
455
00:36:53,480 --> 00:36:55,550
Now, I want to talk about the iPad.

455
456
00:36:55,550 --> 00:37:00,820
We shipped this a couple of months
ago and we think it's great.

456
457
00:37:00,820 --> 00:37:04,880
It has even faster CPU with the A4.

457
458
00:37:04,880 --> 00:37:10,080
And even though it has 5 times as many pixels

458
459
00:37:10,080 --> 00:37:15,060
and about the same graphics capability,
we doubled the bandwidth of the BUS.

459
460
00:37:15,060 --> 00:37:19,200
And so we think that this has great
graphics performance as well.

460
461
00:37:19,200 --> 00:37:22,220
And finally, the brand new iPhone 4.

461
462
00:37:22,220 --> 00:37:30,380
Again, it has the A4 chip so the CPU is a lot faster
because, hey, now you have 4 times as many pixels to draw.

462
463
00:37:30,380 --> 00:37:39,860
And even though you have 4 times as many pixels, you're
really going to want to get your hands on one of these

463
464
00:37:39,860 --> 00:37:42,280
to make sure that all your animations look smooth.

464
465
00:37:42,280 --> 00:37:47,330
Because things are going to double and you
want to make sure that everything looks great.

465
466
00:37:48,690 --> 00:37:52,320
So that's animation scrolling.

466
467
00:37:52,320 --> 00:37:57,810
Let's talk a little bit about keeping
your applications snappy and responsive.

467
468
00:37:57,810 --> 00:38:05,340
So the key part of responsiveness is
simply, do not make your users wait.

468
469
00:38:05,340 --> 00:38:08,380
We're going to talk about how you
can measure some of these things.

469
470
00:38:08,380 --> 00:38:15,540
We're going to talk a little bit about launch, interaction
delays and just a couple of notes about CPU optimization.

470
471
00:38:15,540 --> 00:38:26,820
So Time Profiler Instrument, this is new
in iPhone SDK 4, not Xcode 4, iPhone SDK 4.

471
472
00:38:26,820 --> 00:38:33,010
And it's actually wonderful statistical
sampling profiling tool.

472
473
00:38:33,010 --> 00:38:40,740
And what that means is every millisecond you
can see what's happening in your program.

473
474
00:38:40,740 --> 00:38:49,250
It can take a look at, you know, the stacks of exactly
where things are using the CPU and if things are blocking.

474
475
00:38:49,250 --> 00:38:55,740
So, the way you should use this during your development
process is if you come up with a performance issue,

475
476
00:38:55,740 --> 00:38:59,650
use this to measure what's happening during that scenario.

476
477
00:38:59,650 --> 00:39:04,180
Measure first, and then as you drill down,
you can actually find some of the problems.

477
478
00:39:04,180 --> 00:39:08,970
You'll actually see the different landmarks
of your code and be able to see, wow,

478
479
00:39:08,970 --> 00:39:11,400
I didn't realize that that was going to take so long.

479
480
00:39:11,400 --> 00:39:15,550
So by default, this shows time spent on the CPU.

480
481
00:39:15,550 --> 00:39:20,730
If you want, you can use this great check box here.

481
482
00:39:20,730 --> 00:39:25,900
This was just hitting the information
button there called "All Thread States."

482
483
00:39:25,900 --> 00:39:28,620
It actually shows the time spent in blocking as well.

483
484
00:39:28,620 --> 00:39:34,300
Now, for stuff that's running on the
main thread, that's hugely important.

484
485
00:39:34,300 --> 00:39:39,740
You can use this tool to narrow down to exactly
what's happening in your program on the main thread.

485
486
00:39:39,740 --> 00:39:45,290
And if you see things blocking, that's
not kind of the normal, you know,

486
487
00:39:45,290 --> 00:39:51,460
blocking on new events, then you
want to chase down after those.

487
488
00:39:51,460 --> 00:39:59,090
So once you found your problem, you want to measure
exactly how long that particular section of code is taking.

488
489
00:39:59,090 --> 00:40:00,290
So you want to take a baseline.

489
490
00:40:00,290 --> 00:40:02,060
Again, what it looks like right now.

490
491
00:40:02,060 --> 00:40:07,000
And as you make changes, just try to make that
faster you want to actually see real changes.

491
492
00:40:07,000 --> 00:40:12,040
We recommend just simply timing the start
and end using CFAbsoluteTimeGetCurrent.

492
493
00:40:12,040 --> 00:40:18,460
Now for those of you that want to know, this
is wall clock time and it's user time, too.

493
494
00:40:18,460 --> 00:40:20,430
So simply use it like this.

494
495
00:40:20,430 --> 00:40:21,680
It's pretty easy to use.

495
496
00:40:21,680 --> 00:40:26,420
So I want to talk a little bit about launch.

496
497
00:40:26,420 --> 00:40:32,540
If you are at the performance optimization on
iPhone, talk a little bit about it there, too.

497
498
00:40:32,540 --> 00:40:37,070
Now, I encourage everybody to measure, right.

498
499
00:40:37,070 --> 00:40:43,130
But this is a little bit tricky to measure the total
number of time-- the total amount of time during launch.

499
500
00:40:43,130 --> 00:40:46,100
You can start by measuring the amount
of time between the start of name

500
501
00:40:46,100 --> 00:40:48,910
and the end of application did finish launching.

501
502
00:40:48,910 --> 00:40:51,390
That gives you a good sense of what's happening.

502
503
00:40:51,390 --> 00:40:56,350
But the other thing to do maybe is
to time launch using Time Profiler.

503
504
00:40:56,350 --> 00:41:00,990
Now you can use this as an absolute, measurement
because obviously there's sampling going on.

504
505
00:41:00,990 --> 00:41:05,520
But it's actually really, really useful tool for
relative measurement as you're making changes.

505
506
00:41:05,520 --> 00:41:13,450
And it helps you figure out what your
application is actually doing at launch.

506
507
00:41:13,450 --> 00:41:15,200
So what can you do?

507
508
00:41:15,200 --> 00:41:18,870
Well, deal only what's necessary on launch.

508
509
00:41:18,870 --> 00:41:23,680
Can you defer the work that you
see that your application is doing?

509
510
00:41:23,680 --> 00:41:25,990
Could you do it on demand?

510
511
00:41:25,990 --> 00:41:33,460
We have a philosophy in-- our application
development of being lazy.

511
512
00:41:33,460 --> 00:41:41,950
If you can be lazy and do it on demand, that's great,
because the user might not need network ever at all.

512
513
00:41:41,950 --> 00:41:46,340
The second point is, reduce the number of linked frameworks.

513
514
00:41:46,340 --> 00:41:52,130
I know when I'm developing I sometimes try
out the brand new frameworks and add them

514
515
00:41:52,130 --> 00:41:54,150
into my project to try out a brand new feature.

515
516
00:41:54,150 --> 00:41:57,070
That's great, you should experiment.

516
517
00:41:57,070 --> 00:42:00,290
But before you ship and build the final product,

517
518
00:42:00,290 --> 00:42:03,550
you should make sure to remove those
frameworks from your Xcode project.

518
519
00:42:03,550 --> 00:42:10,100
Because when you have those in there, the system will
actually try the load those at launch and you want to reduce

519
520
00:42:10,100 --> 00:42:14,080
that as much as possible because that can
cause I/O and cause initializers to run.

520
521
00:42:14,080 --> 00:42:16,510
You want to reduce that as much as possible.

521
522
00:42:16,510 --> 00:42:23,120
And if you're using third part libraries,
you want to look out for static initializers.

522
523
00:42:23,120 --> 00:42:29,430
Now these are usually C++ methods
that are called to initialize a class

523
524
00:42:29,430 --> 00:42:33,310
and you can detect these using these environment variables.

524
525
00:42:33,310 --> 00:42:37,880
The other thing that you want to
look out for is weak exports.

525
526
00:42:37,880 --> 00:42:41,570
These are somewhat rare but we've
actually seen them in the field.

526
527
00:42:41,570 --> 00:42:45,890
And you can quickly check for these using otool like this.

527
528
00:42:45,890 --> 00:42:51,070
This is how you set up environment variables to
run in Xcode if you haven't seen that before.

528
529
00:42:51,070 --> 00:42:57,120
And we have some sample output of what gets printed with
the print statistics and print initializers options.

529
530
00:42:57,120 --> 00:43:03,010
So interaction delays, the key thing
here, simply do not block the main thread.

530
531
00:43:03,010 --> 00:43:05,840
And by that I mean, not as blocking operations.

531
532
00:43:05,840 --> 00:43:09,910
But if you have any operation that's taking
longer than about few milliseconds or so,

532
533
00:43:09,910 --> 00:43:13,840
you really want to spin it off into the background.

533
534
00:43:13,840 --> 00:43:18,650
We have lots of scroll views on our system
and people love idly playing with them.

534
535
00:43:18,650 --> 00:43:21,450
And if you block for a few frames.

535
536
00:43:21,450 --> 00:43:23,180
It can be really disconcerting.

536
537
00:43:23,180 --> 00:43:26,370
So, long running task should be
spun off into the background.

537
538
00:43:26,370 --> 00:43:30,460
And you should try to factor these
into executable units of works

538
539
00:43:30,460 --> 00:43:34,700
that you can really show progress
to user if it's really long running.

539
540
00:43:34,700 --> 00:43:40,650
Remember to make UI updates back onto the
main thread once you actually do this.

540
541
00:43:40,650 --> 00:43:49,360
And in iOS 4 it's really easy to do
with NSOperationQueue and blocks.

541
542
00:43:49,360 --> 00:43:51,840
So here we have some sample code.

542
543
00:43:51,840 --> 00:43:56,790
And what is this doing is just
creating an image and we're going

543
544
00:43:56,790 --> 00:43:59,280
to do some custom drawing to that on the background thread.

544
545
00:43:59,280 --> 00:44:04,460
And when that's ready, we're going to post
it to the main thread with an image view.

545
546
00:44:04,460 --> 00:44:10,660
So the first thing we do is we just
create an operation with this block.

546
547
00:44:10,660 --> 00:44:15,340
And here, we're just creating image context with options.

547
548
00:44:15,340 --> 00:44:18,680
By the way this is now thread safe in iOS 4.

548
549
00:44:18,680 --> 00:44:20,200
You can totally use this on the background.

549
550
00:44:20,200 --> 00:44:21,530
It's great.

550
551
00:44:21,530 --> 00:44:26,220
And then grab the current-- grab
the image form that current context.

551
552
00:44:26,220 --> 00:44:32,550
Now, so our drawing is all done here and maybe that's
like 100 milliseconds to 200 milliseconds or so.

552
553
00:44:32,550 --> 00:44:33,910
Now we want to post that to the main thread.

553
554
00:44:33,910 --> 00:44:42,550
Now of course, you can't really modify stuff on the
main thread from background threads because a lot

554
555
00:44:42,550 --> 00:44:47,230
of the UIKit code isn't thread safe here.

555
556
00:44:47,230 --> 00:44:48,890
So what can we do about that?

556
557
00:44:48,890 --> 00:44:51,020
How do we get the image to the main thread?

557
558
00:44:51,020 --> 00:44:53,650
Well with blocks, it's really easy.

558
559
00:44:53,650 --> 00:44:59,310
All you do is create a new operation with this
block on the main queue, run on the main thread,

559
560
00:44:59,310 --> 00:45:03,190
and we just create a new UIImageView and use that image.

560
561
00:45:03,190 --> 00:45:06,370
Pretty simple, huh?

561
562
00:45:06,370 --> 00:45:13,370
So next if I have about responsiveness,
always make URL request asynchronous.

562
563
00:45:13,370 --> 00:45:19,710
So I've seen this code, it's really easy to
use sendSynchronousRequest, boom, it's done.

563
564
00:45:19,710 --> 00:45:26,280
Unfortunately, you don't know what the users are
going to have in terms of network connectivity, right.

564
565
00:45:26,280 --> 00:45:33,020
They could be somewhere where the network is a little
bit flaky and they start to make the connection that kind

565
566
00:45:33,020 --> 00:45:39,320
of goes through and, you know, it doesn't
take very long for people to get frustrated.

566
567
00:45:39,320 --> 00:45:42,730
So it's a little bit more code but it's worth it.

567
568
00:45:42,730 --> 00:45:48,590
Use connection with request, implement
the delegate of NSURLConnection and you--

568
569
00:45:48,590 --> 00:45:54,440
this all happen in the background and then your main
thread is nice and free for users to interact with.

569
570
00:45:54,440 --> 00:46:00,410
You'll get callbacks when you need to receive data
when things failed and when it's finished loading.

570
571
00:46:00,410 --> 00:46:06,320
One more note, spikes in memory usage can cause delays.

571
572
00:46:06,320 --> 00:46:07,900
And why is this?

572
573
00:46:07,900 --> 00:46:17,110
Well it turns out that to accommodate
higher memory usage, code is evicted.

573
574
00:46:17,110 --> 00:46:24,470
And what I mean by that is the code
that's on the system is usually at--

574
575
00:46:24,470 --> 00:46:28,860
is usually filling up the rest of the memory that's free.

575
576
00:46:28,860 --> 00:46:35,270
And if you spike memory usage like this, the system actually
has to kick out something in order to give you more memory.

576
577
00:46:35,270 --> 00:46:36,980
And what it usually kicks out is code.

577
578
00:46:36,980 --> 00:46:43,050
And so as you see, it will spike up there
with very little code left in the system.

578
579
00:46:43,050 --> 00:46:46,970
And when you bring memory back down,
it doesn't just magically fill in.

579
580
00:46:46,970 --> 00:46:52,370
As if you read back from the storage
proceed and that can take a long time.

580
581
00:46:52,370 --> 00:46:57,700
This is probably one of the most
common and unexplained delays

581
582
00:46:57,700 --> 00:47:03,540
that people will find whether-- when
their application is unresponsive.

582
583
00:47:03,540 --> 00:47:08,840
You'll do some operations, you'll sample it you say,
"Well, I'm not spending a whole lot of CPU time here.

583
584
00:47:08,840 --> 00:47:10,090
Where is the time going?"

584
585
00:47:10,090 --> 00:47:15,080
Often times, it's reading back the code
that your application needs to proceed,

585
586
00:47:15,080 --> 00:47:19,300
in this frame or code, your code, system libraries.

586
587
00:47:19,300 --> 00:47:26,840
So one final note about responsiveness, we have
some great tools and system including Time Profiler

587
588
00:47:26,840 --> 00:47:32,590
that allows you to actually find hot spots in your code.

588
589
00:47:32,590 --> 00:47:38,130
And as you could see it will actually give you
statistics about each individual line of code

589
590
00:47:38,130 --> 00:47:40,810
and even to the point of each individual instruction.

590
591
00:47:40,810 --> 00:47:42,650
It's pretty handy.

591
592
00:47:42,650 --> 00:47:50,860
So one tip we have about this besides, you know, of
course making sure that your algorithms are as optimized

592
593
00:47:50,860 --> 00:48:00,590
as possible is to use a feature that we have built
into our CPUs and its called "vector processing."

593
594
00:48:00,590 --> 00:48:07,180
And what vector processing is, it's the way that we
can use the chips to process many elements at once.

594
595
00:48:07,180 --> 00:48:10,190
So let's say about four elements
at a time in this situation.

595
596
00:48:10,190 --> 00:48:14,610
So let's say we have some sample code here which is
pretty simple, we're just walking along this array

596
597
00:48:14,610 --> 00:48:19,270
and we're summing up the total values into this foot.

597
598
00:48:19,270 --> 00:48:29,910
In iOS 4, we have a new framework called
"accelerate" and this is great stuff.

598
599
00:48:29,910 --> 00:48:34,740
This is all really, really highly optimized
code that you can just use out of the box

599
600
00:48:34,740 --> 00:48:40,810
that will give us this vector processing
to do lots of operations at once.

600
601
00:48:40,810 --> 00:48:46,020
So in this case, we're using the--
summing the vector elements.

601
602
00:48:46,020 --> 00:48:53,310
And it's one simple line of code and
operates on this vector four at a time.

602
603
00:48:53,310 --> 00:49:00,300
So again, don't make users wait,
measure the problem situations,

603
604
00:49:00,300 --> 00:49:07,190
look for situations where you can improve
the interaction time in your application.

604
605
00:49:07,190 --> 00:49:10,860
So with that I'm going to hand things
off to my colleague Peter Handel

605
606
00:49:10,860 --> 00:49:13,460
and he'll be talking about power and battery life.

606
607
00:49:13,460 --> 00:49:14,690
[Applause] Thank you.

607
608
00:49:14,690 --> 00:49:14,800
[ Applause ]

608
609
00:49:14,800 --> 00:49:19,830
>> Peter Handel: Hi, everyone.

609
610
00:49:19,830 --> 00:49:20,890
My name is Peter Handel.

610
611
00:49:20,890 --> 00:49:25,760
I'm an iOS Power Engineer and I've been
doing that for almost four years now.

611
612
00:49:25,760 --> 00:49:27,440
I'd like to share with you some tips and tricks

612
613
00:49:27,440 --> 00:49:31,480
and how you can improve the battery life
of your application in three key areas.

613
614
00:49:31,480 --> 00:49:36,640
When using the radio to send and receive data, when using
Core Location to figure out where your device is located.

614
615
00:49:36,640 --> 00:49:41,590
And when using the CPU and GPU to get
your work done and draw on the screen.

615
616
00:49:41,590 --> 00:49:48,320
First the network, transmitting data over 3G is
one of the most power intensive things you can do.

616
617
00:49:48,320 --> 00:49:52,490
This is exacerbated by the fact
that 3G networks keep the 3G radios

617
618
00:49:52,490 --> 00:49:56,410
in a high-power state for few seconds
after data transmission.

618
619
00:49:56,410 --> 00:50:01,110
Therefore, if you were to send and receive even
just a little bit of data, every few seconds,

619
620
00:50:01,110 --> 00:50:05,750
you'd keep those power-hungry 3G radios
in a high-power state the entire time.

620
621
00:50:05,750 --> 00:50:09,080
That's one of the quickest ways
I know how to drain your battery.

621
622
00:50:09,080 --> 00:50:15,890
So how can we enjoy the high speed and wide availability
of 3G while still maintaining excellent battery life?

622
623
00:50:15,890 --> 00:50:17,610
Here's a few tips.

623
624
00:50:17,610 --> 00:50:21,770
First off, use the Activity Monitor tool
which is part of Instruments to figure

624
625
00:50:21,770 --> 00:50:25,080
out how much networking your application is doing.

625
626
00:50:25,080 --> 00:50:30,890
Next, coalesce your data into large chunks
rather than transmitting a thin stream of data.

626
627
00:50:30,890 --> 00:50:36,510
If you notice that your application is transmitting a
thin stream of data, this may be because you're pulling

627
628
00:50:36,510 --> 00:50:39,940
across the network to check to see whether
an event has occurred on the server.

628
629
00:50:39,940 --> 00:50:41,590
Try to avoid this at all cost.

629
630
00:50:41,590 --> 00:50:42,510
Let me repeat that.

630
631
00:50:42,510 --> 00:50:45,870
Try to avoid pulling over the network at all costs.

631
632
00:50:45,870 --> 00:50:49,950
We came across application, a little
chat application which checked

632
633
00:50:49,950 --> 00:50:53,280
with the server every few seconds
to see whether a new chat come in.

633
634
00:50:53,280 --> 00:50:56,710
And as you can image, just chewed through the battery.

634
635
00:50:56,710 --> 00:51:01,170
Instead, try to use the Apple Push
Notification service if you can.

635
636
00:51:01,170 --> 00:51:03,970
Also, minimize the amount of data transmitted.

636
637
00:51:03,970 --> 00:51:08,820
Use a compact data format or maybe even
compress your data before you transmit it.

637
638
00:51:08,820 --> 00:51:12,730
And finally, be real careful when
you reuse legacy or third party code

638
639
00:51:12,730 --> 00:51:16,750
because oftentimes this code will
assume that it's just on Ethernet.

639
640
00:51:16,750 --> 00:51:20,740
So for the 3G radio chip, let that chip idle.

640
641
00:51:20,740 --> 00:51:25,680
From a power perspective, Wi-Fi
uses roughly half the power of 3G.

641
642
00:51:25,680 --> 00:51:29,990
Now this obviously depends on network
characteristics but it's kind of rule of thumb.

642
643
00:51:29,990 --> 00:51:33,650
Also, note that the Wi-Fi network
will allow the Wi-Fi radios

643
644
00:51:33,650 --> 00:51:37,160
to enter low power state immediately after transmission.

644
645
00:51:37,160 --> 00:51:43,380
Because of these 2 things, your application may want to know
when it's on Wi-Fi versus when it's on the cell network.

645
646
00:51:43,380 --> 00:51:48,110
To check this, use the kSCNetworkReachability FlagIsWWAN.

646
647
00:51:48,110 --> 00:51:51,510
Where does 2G fit into this mix?

647
648
00:51:51,510 --> 00:51:56,090
Well, from a power perspective, it fits
in roughly halfway between Wi-Fi and 3G.

648
649
00:51:56,090 --> 00:52:01,800
Also, like Wi-Fi, the 2G network will allow the
2G radio to enter the low power state immediately

649
650
00:52:01,800 --> 00:52:05,530
after data transmission, and that's the radios.

650
651
00:52:05,530 --> 00:52:08,070
Next, Core Location.

651
652
00:52:08,070 --> 00:52:13,630
Judging by the number of apps in the App Store that use Core
Location, you guys love it and your customers love it too.

652
653
00:52:13,630 --> 00:52:18,910
If you haven't used it, Core Location is an API that
with just a few lines of code which I have up here,

653
654
00:52:18,910 --> 00:52:23,500
will allow your device to figure out where
it's located to varying degrees of accuracy.

654
655
00:52:23,500 --> 00:52:26,820
However, be sure to only use the
least amount of accuracy you can

655
656
00:52:26,820 --> 00:52:29,790
because the higher level of accuracy uses more power.

656
657
00:52:29,790 --> 00:52:35,170
For example, if you have a coffee shop
finder application which can tell which--

657
658
00:52:35,170 --> 00:52:39,900
and Core Location can tell you that you're here at the
Moscone Center, that's probably good enough to know

658
659
00:52:39,900 --> 00:52:42,240
that there's coffee shop right across the street.

659
660
00:52:42,240 --> 00:52:47,090
So in this situation, you use the nearest--
I'm sorry, you use the 100 meters accuracy.

660
661
00:52:47,090 --> 00:52:50,470
Next, the distanceFilter.

661
662
00:52:50,470 --> 00:52:54,460
This dictates how often you receive
location changed updates.

662
663
00:52:54,460 --> 00:52:58,740
Be sure to set it appropriately because the
default is to receive every single notification.

663
664
00:52:58,740 --> 00:53:01,770
And as you can imagine, this would
lead to a lot of unnecessary events

664
665
00:53:01,770 --> 00:53:06,190
and higher CPU usage and worst battery life.

665
666
00:53:06,190 --> 00:53:12,430
Be sure to call stopUpdatingLocation as soon
as you reach your desired level of accuracy.

666
667
00:53:12,430 --> 00:53:16,770
Also, note that Core Location will
manage the GPS power for you.

667
668
00:53:16,770 --> 00:53:21,790
What this means is that for example in our coffee shop
finder application, if your user is looking at the map

668
669
00:53:21,790 --> 00:53:27,190
and they decided to go in the preferences part of your
application, call stopUpdatingLocation immediately.

669
670
00:53:27,190 --> 00:53:31,970
And then one or few seconds later, they go back to
the map, go ahead and call startUpdatingLocation

670
671
00:53:31,970 --> 00:53:34,770
and Core Location will pick up right where it left off.

671
672
00:53:34,770 --> 00:53:38,480
So for the GPS chip, let that chip idle.

672
673
00:53:38,480 --> 00:53:42,640
Note, the same is true for Core
Motion, which is the new iOS 4 API.

673
674
00:53:42,640 --> 00:53:48,590
After you call the start update functions, be
sure to call the matching stop update functions.

674
675
00:53:48,590 --> 00:53:55,620
Also, if your application goes in the background, be sure
to turn off the sensors when that happens if you like.

675
676
00:53:55,620 --> 00:54:02,360
Note that in-- if your application would like to be
notified of the significant location change or if you want

676
677
00:54:02,360 --> 00:54:07,490
to use region monitoring, instead of just
having Core Location running all the time,

677
678
00:54:07,490 --> 00:54:10,070
use the new iOS 4 API which lets you do this.

678
679
00:54:10,070 --> 00:54:11,960
And I have this-- that up here.

679
680
00:54:11,960 --> 00:54:16,880
And that's Core Location, finally, the CPU and GPU.

680
681
00:54:16,880 --> 00:54:20,800
You might be wondering why we're talking about
performance and power in the same presentation.

681
682
00:54:20,800 --> 00:54:27,030
Well, it turns out that if you optimize for performance,
you get better battery life thrown in for free.

682
683
00:54:27,030 --> 00:54:32,050
This is because fast code uses less
CPU time which uses less power.

683
684
00:54:32,050 --> 00:54:36,450
So for the CPU, let that chip idle.

684
685
00:54:36,450 --> 00:54:39,680
So as you know, the iOS 4 is an
event based operating system.

685
686
00:54:39,680 --> 00:54:44,750
Now as I mentioned earlier in the networking portion
of this talk, there are certain conditions when--

686
687
00:54:44,750 --> 00:54:48,010
there are certain situations where you
might want to uphold to check to see

687
688
00:54:48,010 --> 00:54:50,990
when an event has occurred or something has changed.

688
689
00:54:50,990 --> 00:54:53,990
Try to avoid this and instead subscribe to an event.

689
690
00:54:53,990 --> 00:54:59,180
But we don't have events for everything so
in some situations you may have to pull.

690
691
00:54:59,180 --> 00:55:01,030
Try to reduce the frequency with which you pull.

691
692
00:55:01,030 --> 00:55:06,110
For example if you pull every 30th of a second, try dropping
that down to every tenth of a second or even every second

692
693
00:55:06,110 --> 00:55:09,050
to see if there's any user-visible impact.

693
694
00:55:09,050 --> 00:55:14,010
For example, we see a lot of sample code on
the Internet which recommends that you figure

694
695
00:55:14,010 --> 00:55:19,060
out whether the device is being shaken like continuously
pulling and using your accelerometer to do that.

695
696
00:55:19,060 --> 00:55:19,650
Don't do this.

696
697
00:55:19,650 --> 00:55:23,700
Instead, use the Shake API to figure
out when your device is being shaken.

697
698
00:55:23,700 --> 00:55:25,980
Next, be bursty.

698
699
00:55:25,980 --> 00:55:29,960
Try to consolidate your CPU usage into short bursts.

699
700
00:55:29,960 --> 00:55:33,410
This will allow the CPU to enter
that idle state I've talking about.

700
701
00:55:33,410 --> 00:55:39,380
Note that this may require you to restructure your
code or possibly you can use a different algorithm.

701
702
00:55:39,380 --> 00:55:41,690
How do you know when your code is being nice and bursty?

702
703
00:55:41,690 --> 00:55:49,360
Well, use the Time Profiler tool as part-- which is part
of the instruments to check your CPU activity level.

703
704
00:55:49,360 --> 00:55:51,650
For example, we found that during audio playback.

704
705
00:55:51,650 --> 00:55:57,700
We were able to get much better battery life by
decompressing large chunks of audio at once rather

705
706
00:55:57,700 --> 00:56:00,320
than decompressing small pieces continually.

706
707
00:56:00,320 --> 00:56:04,690
Next, procrastination, because
who doesn't like to procrastinate?

707
708
00:56:04,690 --> 00:56:08,190
Because if you put it off long enough,
you just might not have to do it all.

708
709
00:56:08,190 --> 00:56:13,590
For example, we came across a game, which check
the-- which stayed at state every few seconds.

709
710
00:56:13,590 --> 00:56:15,790
You can imagine it's not really good for the CPU.

710
711
00:56:15,790 --> 00:56:17,750
It's not very good for battery life either.

711
712
00:56:17,750 --> 00:56:22,540
Instead, maybe you could save the state when
the user reaches a milestone or a checkpoint

712
713
00:56:22,540 --> 00:56:25,630
or maybe even the user quits the game, the time safety.

713
714
00:56:25,630 --> 00:56:28,540
When using the GPU, pick a fixed frame rate.

714
715
00:56:28,540 --> 00:56:37,680
We recommend about 30 frames per second and enforce
this using the CADisplayLink rather than using NSTimer.

715
716
00:56:37,680 --> 00:56:41,660
This will help you minimize the appearance of
dropped frames and also help you avoid the situation

716
717
00:56:41,660 --> 00:56:44,130
where your app is continuously drawing as quick as possible.

717
718
00:56:44,130 --> 00:56:50,170
On the other end of the spectrum, if a
frame has not changed, don't redraw it.

718
719
00:56:50,170 --> 00:56:54,160
For example, if you have a chess application
and your user is looking at the pieces,

719
720
00:56:54,160 --> 00:57:00,630
contemplating the next brilliant move, don't be updating
the screen every 30 frames a second if nothing has changed.

720
721
00:57:00,630 --> 00:57:05,080
Finally, be sure to check out the Energy
Diagnostics Tool which is part of instruments.

721
722
00:57:05,080 --> 00:57:09,540
And I was in the session this morning, session
309 which delved into this extensively.

722
723
00:57:09,540 --> 00:57:12,120
So be sure to check out the video once it's available.

723
724
00:57:12,120 --> 00:57:17,930
So to summarize, for the radios we learned
that data transmission is very expensive.

724
725
00:57:17,930 --> 00:57:21,220
So we coalesce and compress data as much as possible.

725
726
00:57:21,220 --> 00:57:24,890
With Core Location, we use the least
amount of accuracy we can get away with

726
727
00:57:24,890 --> 00:57:28,490
and we call stop obtaining location as soon as we can.

727
728
00:57:28,490 --> 00:57:33,520
And on the CPU and GPU, we optimize our
performance and get better battery life for free,

728
729
00:57:33,520 --> 00:57:36,190
with bursty we procrastinate as much as possible.

729
730
00:57:36,190 --> 00:57:42,350
And on the GPU, we used the fixed frame rate, 30 frames
per second and we don't unnecessarily redraw the screen.

730
731
00:57:42,350 --> 00:57:45,160
So to summarize, let those chips idle.

731
732
00:57:45,160 --> 00:57:45,680
Thank you.

732
733
00:57:45,680 --> 00:57:46,510
Dave.

733
734
00:57:46,510 --> 00:57:52,200
[ Applause ]

734
735
00:57:52,200 --> 00:57:53,710
>> David Chan: Thanks Peter.

735
736
00:57:53,710 --> 00:57:59,430
So in summary, use your knowledge about the
systems, come up with creative solutions.

736
737
00:57:59,430 --> 00:58:06,550
Always measure the baseline and the changes you make to
make sure that the changes you're making are improvements.

737
738
00:58:06,550 --> 00:58:11,030
About animations, fewer pixels to
render, means smooth animations.

738
739
00:58:11,030 --> 00:58:15,520
Make sure to prepare yourselves and
render very quickly for smooth scrolling.

739
740
00:58:15,520 --> 00:58:17,940
Don't block the main thread and let those chips idle.

740
741
00:58:17,940 --> 00:58:20,320
Thank you for coming to our talk.

741
742
00:58:20,320 --> 00:58:22,910
Here are some related sessions for more information.

742
743
00:58:22,910 --> 00:58:26,750
Be sure to come tomorrow to part 2 of this talk.

743
744
00:58:26,750 --> 00:58:34,430
We'll be covering memory, databases, how
to use the data APIs on our system and I/O.

744
745
00:58:34,430 --> 00:58:40,220
And right after this, there's an optimizing
core data performance on iPhone OS session

745
746
00:58:40,220 --> 00:58:43,230
that I highly recommend you go through if you use core data

746
747
00:58:43,230 --> 00:58:46,280
or you're planning using core data
in any of your applications.

747
748
00:58:46,280 --> 00:58:49,060
Here are some other session that have already happened

748
749
00:58:49,060 --> 00:58:52,270
that are great reference material for
some topics that we covered today.

749
750
00:58:52,270 --> 00:58:53,540
Thank you very much for coming.

750
