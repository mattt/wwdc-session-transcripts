X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:12,516 --> 00:00:16,596 A:middle
[ Applause ]

2
00:00:17,096 --> 00:00:18,166 A:middle
>> Hello everyone.

3
00:00:18,166 --> 00:00:20,236 A:middle
Welcome to Introducing
HealthKit.

4
00:00:20,756 --> 00:00:24,776 A:middle
My name is Justin, I'm an iOS
engineer and I'll be joined

5
00:00:24,776 --> 00:00:27,106 A:middle
up here in a little while
by my colleague, Siji.

6
00:00:28,006 --> 00:00:30,486 A:middle
Siji and I got to work
together on HealthKit

7
00:00:30,666 --> 00:00:33,066 A:middle
and we're really excited
to show it to you today.

8
00:00:34,156 --> 00:00:39,266 A:middle
So, there are a ton of
health and fitness apps

9
00:00:39,446 --> 00:00:40,576 A:middle
on the app store today.

10
00:00:41,066 --> 00:00:43,416 A:middle
They do all sorts
of awesome things

11
00:00:43,496 --> 00:00:46,796 A:middle
that let our users get
healthy and stay healthy.

12
00:00:47,526 --> 00:00:49,496 A:middle
The problem is not a lot

13
00:00:49,496 --> 00:00:52,136 A:middle
of these apps can share
data between each other.

14
00:00:53,076 --> 00:00:56,586 A:middle
This makes it really hard for
our users to get a cohesive view

15
00:00:56,586 --> 00:00:57,396 A:middle
of their current health.

16
00:00:58,906 --> 00:01:02,576 A:middle
The few apps that can share
data have to write all sorts

17

18
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

19
00:00:58,906 --> 00:01:02,576 A:middle
The few apps that can share
data have to write all sorts

20
00:01:02,576 --> 00:01:06,336 A:middle
of custom code to do so, which
means you spend your time

21
00:01:06,506 --> 00:01:09,706 A:middle
and energy working on
features that aren't core

22
00:01:09,706 --> 00:01:11,716 A:middle
to the experience of
your applications.

23
00:01:13,466 --> 00:01:17,156 A:middle
Now, we recognize that
different applications have

24
00:01:17,206 --> 00:01:17,886 A:middle
different needs.

25
00:01:18,486 --> 00:01:20,306 A:middle
The way we see it
they can be grouped

26
00:01:20,306 --> 00:01:22,316 A:middle
into three main categories.

27
00:01:22,736 --> 00:01:25,226 A:middle
First, there are applications

28
00:01:25,226 --> 00:01:28,846 A:middle
that perform statistical
analysis using graphs or trends.

29
00:01:30,496 --> 00:01:33,976 A:middle
Next there are applications that
let users enter information.

30
00:01:34,496 --> 00:01:39,276 A:middle
Last, there are applications
put out by health providers

31
00:01:39,396 --> 00:01:42,476 A:middle
that let users sync data with
their personal medical record.

32
00:01:43,446 --> 00:01:46,986 A:middle
These are three very different
scenarios but we built HealthKit

33
00:01:46,986 --> 00:01:49,416 A:middle
so that it can handle all
of them and we're going

34
00:01:49,416 --> 00:01:52,746 A:middle
to show you how it
does that today.

35
00:01:52,896 --> 00:01:55,936 A:middle
Throughout this talk we're going
to refer to the health app.

36
00:01:56,756 --> 00:01:59,156 A:middle
This is talking about the
new health application

37
00:01:59,156 --> 00:02:01,506 A:middle
that we're introducing
with iOS 8.

38

39
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

40
00:01:59,156 --> 00:02:01,506 A:middle
that we're introducing
with iOS 8.

41
00:02:03,156 --> 00:02:04,606 A:middle
So here's our agenda for today.

42
00:02:05,646 --> 00:02:07,156 A:middle
We're going to start
off by walking you

43
00:02:07,156 --> 00:02:10,765 A:middle
through the HealthKit API so you
can learn how to create data,

44
00:02:10,765 --> 00:02:14,636 A:middle
how to save data and how
to ask for data as well.

45
00:02:15,586 --> 00:02:17,926 A:middle
Then Siji is going to come
up here and give you a demo

46
00:02:18,106 --> 00:02:20,266 A:middle
so you can see how to
incorporate HealthKit

47
00:02:20,356 --> 00:02:21,616 A:middle
into your own applications.

48
00:02:22,486 --> 00:02:25,716 A:middle
We'll finish things off with
some HealthKit best practices.

49
00:02:27,896 --> 00:02:31,406 A:middle
HealthKit is a framework
that lets you store

50
00:02:31,406 --> 00:02:33,996 A:middle
and retrieve health and
fitness information.

51
00:02:34,326 --> 00:02:36,886 A:middle
So data is really important.

52
00:02:37,296 --> 00:02:39,166 A:middle
We're going to start
off by talking

53
00:02:39,166 --> 00:02:42,846 A:middle
about what data is in HealthKit.

54
00:02:43,536 --> 00:02:47,426 A:middle
Storing health information in a
way that can scale to work all

55
00:02:47,426 --> 00:02:50,816 A:middle
across the world has presented
some challenging problems.

56
00:02:51,796 --> 00:02:54,996 A:middle
Every time you step on your
scale, your weight may be pounds

57
00:02:54,996 --> 00:02:57,536 A:middle
in the United States,
stones in England

58
00:02:57,536 --> 00:02:59,876 A:middle
or kilograms in many
other areas.

59

60
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

61
00:03:00,836 --> 00:03:03,826 A:middle
We didn't want you to have to
do unit conversion yourself

62
00:03:04,256 --> 00:03:09,226 A:middle
so we handle unit conversion
for you right in HealthKit.

63
00:03:09,306 --> 00:03:12,306 A:middle
Units are handled by HKUnit

64
00:03:14,476 --> 00:03:18,286 A:middle
and HKUnit represents a
particular unit in the metric

65
00:03:18,536 --> 00:03:20,046 A:middle
or imperial unit system.

66
00:03:21,246 --> 00:03:25,286 A:middle
These can be simple such as
grams or they can be complex

67
00:03:25,346 --> 00:03:27,086 A:middle
like milligrams per deciliter.

68
00:03:28,796 --> 00:03:31,696 A:middle
Base units are classified
into types.

69
00:03:32,646 --> 00:03:35,576 A:middle
Types define which units are
compatible with each other.

70
00:03:36,286 --> 00:03:39,366 A:middle
For example, a mass units
value can be converted

71
00:03:39,476 --> 00:03:40,716 A:middle
to any other mass unit.

72
00:03:41,616 --> 00:03:45,706 A:middle
Here you can see that milligrams
per deciliter is an example

73
00:03:45,706 --> 00:03:47,326 A:middle
of a mass per volume unit.

74
00:03:47,836 --> 00:03:51,886 A:middle
We give you a couple of
different ways to create units.

75
00:03:52,666 --> 00:03:56,146 A:middle
First, you can specify
them explicitly in code.

76
00:03:56,886 --> 00:03:58,616 A:middle
Here we're creating a gram unit

77
00:03:59,776 --> 00:04:01,966 A:middle
and then we're creating
a deciliter unit

78

79
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

80
00:03:59,776 --> 00:04:01,966 A:middle
and then we're creating
a deciliter unit

81
00:04:02,976 --> 00:04:06,576 A:middle
and we're combining the two to
make a grams per deciliter unit.

82
00:04:07,816 --> 00:04:10,016 A:middle
This works really
well for simple units

83
00:04:10,096 --> 00:04:12,536 A:middle
but as you can see it
gets pretty unwieldy

84
00:04:12,626 --> 00:04:14,566 A:middle
as we expand to more
complex ones.

85
00:04:14,966 --> 00:04:16,426 A:middle
To make things easier on you,

86
00:04:16,646 --> 00:04:20,146 A:middle
we let you specify units
using unit strings like so.

87
00:04:21,286 --> 00:04:24,016 A:middle
So this line will
create an identical unit

88
00:04:24,106 --> 00:04:27,706 A:middle
to the three lines above it.

89
00:04:27,966 --> 00:04:30,416 A:middle
Once you have your unit, the
next thing you're going to want

90
00:04:30,416 --> 00:04:32,786 A:middle
to do is create an HKQuantity.

91
00:04:34,046 --> 00:04:38,416 A:middle
An HKQuantity is a double value
relative to a particular unit.

92
00:04:39,726 --> 00:04:42,486 A:middle
What's really cool about
quantities though is

93
00:04:42,486 --> 00:04:45,316 A:middle
that they can be used to
do unit conversion for you.

94
00:04:46,386 --> 00:04:47,676 A:middle
Let's take a look
at how they do that.

95
00:04:49,066 --> 00:04:52,816 A:middle
Here we start off by making
a quantity of 20 grams.

96
00:04:54,036 --> 00:04:57,506 A:middle
Next we can ask for its
double value in kilograms.

97
00:04:58,006 --> 00:05:01,326 A:middle
This will give us back .02.

98

99
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

100
00:04:58,006 --> 00:05:01,326 A:middle
This will give us back .02.

101
00:05:02,616 --> 00:05:06,226 A:middle
Unfortunately, not all
units play nicely together.

102
00:05:07,056 --> 00:05:09,316 A:middle
If you ask a quantity
for its value

103
00:05:09,316 --> 00:05:11,116 A:middle
in a unit it's not
compatible with,

104
00:05:11,466 --> 00:05:12,986 A:middle
we're going to throw
an exception.

105
00:05:13,726 --> 00:05:17,206 A:middle
You can always guard yourself
in code by asking a quantity

106
00:05:17,206 --> 00:05:19,416 A:middle
if it's compatible
with a particular unit.

107
00:05:20,316 --> 00:05:21,446 A:middle
So return a BOOL.

108
00:05:23,386 --> 00:05:26,706 A:middle
So now that you have your
quantity the question you should

109
00:05:26,706 --> 00:05:29,976 A:middle
be asking yourself is what
is this a quantity of?

110
00:05:30,286 --> 00:05:31,826 A:middle
To answer that question
we're going

111
00:05:31,826 --> 00:05:35,186 A:middle
to take a look at object types.

112
00:05:35,376 --> 00:05:38,646 A:middle
Object types represent all of
the different kinds of data

113
00:05:38,646 --> 00:05:40,496 A:middle
that we can store in HealthKit.

114
00:05:41,216 --> 00:05:44,006 A:middle
There are over 60
different types.

115
00:05:44,836 --> 00:05:47,026 A:middle
Major groups of types
are organized

116
00:05:47,096 --> 00:05:48,386 A:middle
into their own classes.

117
00:05:49,146 --> 00:05:52,966 A:middle
All of these classes
inherit from HKObject Type.

118
00:05:55,476 --> 00:05:58,986 A:middle
Characteristic types are
characteristics of the user

119
00:05:59,186 --> 00:06:01,626 A:middle
or traits that don't
change over time.

120

121
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

122
00:05:59,186 --> 00:06:01,626 A:middle
or traits that don't
change over time.

123
00:06:02,806 --> 00:06:05,406 A:middle
These are things such as their
blood type or date of birth.

124
00:06:07,236 --> 00:06:10,626 A:middle
Sample types on the other
hand are traits of the user

125
00:06:10,626 --> 00:06:12,106 A:middle
that do change over time.

126
00:06:13,206 --> 00:06:18,286 A:middle
As such, they can be sampled
at a particular point in time.

127
00:06:18,776 --> 00:06:21,456 A:middle
One kind of sample
type is HKQuantityType.

128
00:06:22,856 --> 00:06:24,016 A:middle
These are the kinds of data

129
00:06:24,016 --> 00:06:26,536 A:middle
that can be represented
by an HKQuantity.

130
00:06:27,046 --> 00:06:30,286 A:middle
They are by far the most common
kinds of data in HealthKit

131
00:06:30,286 --> 00:06:33,946 A:middle
and represent everything from
blood pressure to potassium

132
00:06:33,976 --> 00:06:38,036 A:middle
to the number of
steps you've taken.

133
00:06:38,126 --> 00:06:40,486 A:middle
Last we have HKCategoryType.

134
00:06:41,466 --> 00:06:45,326 A:middle
Category types describe the kind
of data that can be categorized

135
00:06:45,426 --> 00:06:47,516 A:middle
into an enumeration of values.

136
00:06:48,176 --> 00:06:51,366 A:middle
An example of category
type is sleep analysis,

137
00:06:51,736 --> 00:06:53,966 A:middle
which is how we store
sleep in HealthKit.

138
00:06:55,236 --> 00:06:58,496 A:middle
Let's talk about how you
would create an instance

139
00:06:58,696 --> 00:07:00,406 A:middle
of an HKObject Type.

140

141
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

142
00:06:58,696 --> 00:07:00,406 A:middle
of an HKObject Type.

143
00:07:01,056 --> 00:07:04,036 A:middle
Every type has its
own type identifier.

144
00:07:05,036 --> 00:07:08,006 A:middle
You cannot create your own
types or type identifiers,

145
00:07:08,196 --> 00:07:10,936 A:middle
but it's important to understand
how they're structured

146
00:07:11,266 --> 00:07:15,046 A:middle
so that you can use auto
complete to your advantage.

147
00:07:15,546 --> 00:07:18,486 A:middle
Here we have our
identifier for heart rate.

148
00:07:20,196 --> 00:07:22,236 A:middle
The first part of
the identifier is

149
00:07:22,236 --> 00:07:25,156 A:middle
which object type
subclass it represents.

150
00:07:26,096 --> 00:07:29,486 A:middle
As you can see, heart
rate is a quantity type.

151
00:07:30,836 --> 00:07:34,666 A:middle
The second part of the
identifier is the type name

152
00:07:34,826 --> 00:07:37,406 A:middle
or what you would call the type.

153
00:07:38,086 --> 00:07:40,806 A:middle
Once you have your type
identifier, you can pass it

154
00:07:40,856 --> 00:07:44,026 A:middle
to one of these three
constructors on HKObjectType.

155
00:07:44,556 --> 00:07:47,556 A:middle
It's important to note
that your identifier

156
00:07:47,556 --> 00:07:50,186 A:middle
and your constructor
need to match up.

157
00:07:50,676 --> 00:07:53,726 A:middle
So if you were to pass a
category type identifier

158
00:07:54,236 --> 00:08:00,956 A:middle
to quantity type for identifier,
you're going to get back nil.

159

160
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

161
00:07:54,236 --> 00:08:00,956 A:middle
to quantity type for identifier,
you're going to get back nil.

162
00:08:01,166 --> 00:08:06,386 A:middle
So, now we have a quantity
and we have an object type.

163
00:08:06,836 --> 00:08:09,156 A:middle
It sounds like you're
ready to create some data.

164
00:08:10,696 --> 00:08:14,846 A:middle
All data stored in HealthKit
is a subclass of HKObject.

165
00:08:16,176 --> 00:08:20,436 A:middle
Here we have a diagram of
the HKObject class hierarchy.

166
00:08:21,676 --> 00:08:23,726 A:middle
You might notice this
is pretty similar

167
00:08:23,846 --> 00:08:26,886 A:middle
to the hierarchy we just
say for HKObjectType.

168
00:08:27,936 --> 00:08:30,186 A:middle
This is by design
as object types

169
00:08:30,536 --> 00:08:33,176 A:middle
and objects are very
closely tied together.

170
00:08:34,086 --> 00:08:36,596 A:middle
Let's take a look at some
of these different classes.

171
00:08:37,135 --> 00:08:40,296 A:middle
We'll start with
HKQuantitySample.

172
00:08:41,206 --> 00:08:44,786 A:middle
This is by far the most common
kind of HK object in HealthKit.

173
00:08:45,206 --> 00:08:47,356 A:middle
They're how we store
quantities in the database.

174
00:08:47,836 --> 00:08:51,286 A:middle
Every quantity sample
has a quantity type.

175
00:08:52,226 --> 00:08:55,246 A:middle
This is what kind of data
the sample represents.

176
00:08:56,776 --> 00:09:00,816 A:middle
They also have a quantity, which
is the value of the sample.

177

178
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

179
00:08:56,776 --> 00:09:00,816 A:middle
They also have a quantity, which
is the value of the sample.

180
00:09:02,016 --> 00:09:04,616 A:middle
It's important to note
that your quantity's unit

181
00:09:04,806 --> 00:09:06,956 A:middle
and your quantity
type need to match up.

182
00:09:07,806 --> 00:09:10,876 A:middle
Every quantity type expects
a certain kind of unit

183
00:09:11,096 --> 00:09:15,906 A:middle
and if there's a mismatch here
then we'll throw an exception.

184
00:09:16,096 --> 00:09:17,936 A:middle
Next we have HKCategorySample.

185
00:09:18,776 --> 00:09:21,726 A:middle
Category samples are very
similar to quantity samples.

186
00:09:22,746 --> 00:09:26,396 A:middle
They have a category type,
which again describes what kind

187
00:09:26,396 --> 00:09:29,986 A:middle
of data the sample represents
and they have a value.

188
00:09:31,666 --> 00:09:35,336 A:middle
Now, remember the category
types are the kinds of data

189
00:09:35,336 --> 00:09:39,086 A:middle
that can be categorized into
an enumeration of values.

190
00:09:40,146 --> 00:09:42,986 A:middle
As such, every category
type is paired

191
00:09:43,296 --> 00:09:44,906 A:middle
with a corresponding enum.

192
00:09:45,966 --> 00:09:49,336 A:middle
This value property must be one
of the members of that enum.

193
00:09:50,286 --> 00:09:54,146 A:middle
If an invalid value is provided,
we throw an exception just

194
00:09:54,146 --> 00:09:56,006 A:middle
like we do for quantity samples.

195
00:09:58,356 --> 00:10:02,846 A:middle
Both of these inherit
from HKSample.

196

197
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

198
00:09:58,356 --> 00:10:02,846 A:middle
Both of these inherit
from HKSample.

199
00:10:02,926 --> 00:10:05,416 A:middle
Remember that samples
are the kinds of data

200
00:10:05,416 --> 00:10:08,466 A:middle
that can be sampled at a
particular point in time.

201
00:10:09,406 --> 00:10:12,446 A:middle
To support this every
sample has both a start date

202
00:10:12,446 --> 00:10:13,486 A:middle
and an end date.

203
00:10:14,656 --> 00:10:16,646 A:middle
Why both a state date and
end date you might ask?

204
00:10:17,056 --> 00:10:19,156 A:middle
Well, for some kinds of data

205
00:10:19,336 --> 00:10:23,146 A:middle
such as your weight the
reading is pretty instantaneous

206
00:10:23,186 --> 00:10:26,206 A:middle
so your start date and end date
should probably be the same.

207
00:10:26,846 --> 00:10:30,356 A:middle
For other kinds of data though
your reading might take place

208
00:10:30,356 --> 00:10:31,616 A:middle
over a period of time.

209
00:10:32,346 --> 00:10:34,876 A:middle
You might want to say that
your heart rate was an average

210
00:10:34,876 --> 00:10:38,186 A:middle
of 80 beats per minute over
the course of 30 seconds.

211
00:10:40,116 --> 00:10:42,776 A:middle
Every sample also
has a sample type.

212
00:10:43,776 --> 00:10:46,436 A:middle
This is going to be the
same as your category type

213
00:10:46,566 --> 00:10:48,416 A:middle
or quantity type depending

214
00:10:48,466 --> 00:10:53,436 A:middle
on which subclass you
choose to implement.

215
00:10:53,436 --> 00:10:55,776 A:middle
All of these inherit
from HKObject.

216
00:10:57,436 --> 00:11:01,836 A:middle
Every object has a UUID
which is a unique identifier

217

218
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

219
00:10:57,436 --> 00:11:01,836 A:middle
Every object has a UUID
which is a unique identifier

220
00:11:01,836 --> 00:11:04,396 A:middle
that has persisted for the
lifetime of the object.

221
00:11:04,736 --> 00:11:08,416 A:middle
So you can count on this
always being the same.

222
00:11:08,626 --> 00:11:10,136 A:middle
They also have a source.

223
00:11:10,996 --> 00:11:15,616 A:middle
Because health information is so
sensitive we wanted to make sure

224
00:11:15,616 --> 00:11:18,516 A:middle
that every object could
identify where it came from.

225
00:11:19,916 --> 00:11:22,666 A:middle
Each application
represents its own source

226
00:11:22,986 --> 00:11:25,176 A:middle
but sources can also
be pieces of hardware

227
00:11:25,426 --> 00:11:27,266 A:middle
such as a Bluetooth
heart rate monitor

228
00:11:27,266 --> 00:11:31,526 A:middle
or the step tracker
in your phone.

229
00:11:31,726 --> 00:11:35,616 A:middle
Metadata is an important part of
the extensibility of an object.

230
00:11:36,736 --> 00:11:39,436 A:middle
You can create an object with
whatever metadata you like.

231
00:11:40,816 --> 00:11:45,636 A:middle
Note that metadata is a regular
NSDictionary except it can only

232
00:11:45,636 --> 00:11:48,446 A:middle
store strings as
keys and strings,

233
00:11:48,446 --> 00:11:50,406 A:middle
numbers and dates as values.

234
00:11:51,436 --> 00:11:54,546 A:middle
We give you a few
predefined metadata keys

235
00:11:54,546 --> 00:11:58,876 A:middle
which we think might be
useful but we encourage you

236
00:11:58,876 --> 00:12:01,096 A:middle
to create your own
metadata keys as well.

237

238
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

239
00:11:58,876 --> 00:12:01,096 A:middle
to create your own
metadata keys as well.

240
00:12:03,656 --> 00:12:06,036 A:middle
Now you may have
noticed that all

241
00:12:06,036 --> 00:12:08,206 A:middle
of the properties you
saw here are read only.

242
00:12:09,476 --> 00:12:12,616 A:middle
This is because all data
in HealthKit is immutable.

243
00:12:13,206 --> 00:12:16,046 A:middle
As great as it would be to
go back and change my height,

244
00:12:16,046 --> 00:12:17,876 A:middle
it really doesn't
make any sense.

245
00:12:18,686 --> 00:12:21,486 A:middle
So, you can create
objects using constructors

246
00:12:21,586 --> 00:12:24,776 A:middle
on HKQuantitySample
and HKCategorySample.

247
00:12:25,306 --> 00:12:29,946 A:middle
This is an example of how
you might create an object

248
00:12:29,946 --> 00:12:31,806 A:middle
to represent someone's
body temperature.

249
00:12:33,496 --> 00:12:35,546 A:middle
First we create our
quantity type,

250
00:12:35,966 --> 00:12:37,746 A:middle
which in this case
is the quantity type

251
00:12:38,056 --> 00:12:39,106 A:middle
for body temperature.

252
00:12:39,646 --> 00:12:42,926 A:middle
Next, we create our quantity.

253
00:12:43,696 --> 00:12:45,896 A:middle
Let's say this person is
feeling pretty healthy today

254
00:12:46,166 --> 00:12:51,126 A:middle
so their temperature is
98.6 degrees Fahrenheit.

255
00:12:51,616 --> 00:12:54,786 A:middle
Last we create some metadata.

256
00:12:55,376 --> 00:12:56,826 A:middle
This piece of metadata says

257
00:12:56,826 --> 00:12:59,736 A:middle
that the person probably took
their body temperature using an

258
00:12:59,736 --> 00:13:00,476 A:middle
ear thermometer.

259

260
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

261
00:12:59,736 --> 00:13:00,476 A:middle
ear thermometer.

262
00:13:02,876 --> 00:13:06,246 A:middle
We can then pass all of
this to HKQuantitySamples,

263
00:13:06,486 --> 00:13:09,666 A:middle
quantity sample with type
and give it a start date

264
00:13:09,666 --> 00:13:13,956 A:middle
and end date of right now.

265
00:13:14,266 --> 00:13:18,596 A:middle
Now that you have your data,
what do you actually do with it?

266
00:13:19,106 --> 00:13:20,516 A:middle
Well, to really do anything

267
00:13:20,516 --> 00:13:23,966 A:middle
with HealthKit the first thing
you need is an HKHealthStore.

268
00:13:24,556 --> 00:13:27,086 A:middle
You can think of
your Health Store

269
00:13:27,086 --> 00:13:28,976 A:middle
as your link to the database.

270
00:13:29,536 --> 00:13:33,236 A:middle
It lets you save
objects and as we'll find

271
00:13:33,236 --> 00:13:38,396 A:middle
out in a little bit it lets
you ask for data as well.

272
00:13:38,396 --> 00:13:41,566 A:middle
Remember though that you really
only need one Health Store.

273
00:13:42,376 --> 00:13:45,096 A:middle
They should be long lived and
you don't really get anything

274
00:13:45,096 --> 00:13:47,216 A:middle
out of having multiple
ones floating around.

275
00:13:47,526 --> 00:13:51,986 A:middle
So create one, hold on
to it and you're done.

276
00:13:52,186 --> 00:13:54,866 A:middle
Here's an example of us
saving some data to HealthKit.

277
00:13:56,356 --> 00:14:00,076 A:middle
First, we create
our Health Store.

278

279
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

280
00:13:56,356 --> 00:14:00,076 A:middle
First, we create
our Health Store.

281
00:14:00,296 --> 00:14:02,176 A:middle
Next, we create a
quantity sample.

282
00:14:02,756 --> 00:14:05,486 A:middle
We can then pass our sample

283
00:14:05,596 --> 00:14:08,926 A:middle
to our Health Store using
safe object with completion

284
00:14:09,836 --> 00:14:13,816 A:middle
and voila we have officially
saved data in HealthKit.

285
00:14:14,386 --> 00:14:18,156 A:middle
So, saving data is great

286
00:14:18,666 --> 00:14:21,246 A:middle
but it's not really any
fun unless we can ask

287
00:14:21,246 --> 00:14:22,246 A:middle
for it back, right?

288
00:14:23,176 --> 00:14:27,446 A:middle
HealthKit gives you lots
of ways to ask for data.

289
00:14:27,876 --> 00:14:31,286 A:middle
The easiest information to get
are characteristics of the user.

290
00:14:32,206 --> 00:14:35,656 A:middle
Because these don't change
over time we really only care

291
00:14:35,656 --> 00:14:36,836 A:middle
about the current value.

292
00:14:36,956 --> 00:14:39,596 A:middle
So you can just ask your
Health Store directly.

293
00:14:40,136 --> 00:14:43,836 A:middle
Here's an example of us
asking our Health Store

294
00:14:43,926 --> 00:14:45,506 A:middle
for the user's date of birth.

295
00:14:46,996 --> 00:14:50,726 A:middle
This doesn't work for everything
though so to ask for the bulk

296
00:14:50,726 --> 00:14:53,166 A:middle
of our data we're going to
need something a little more

297
00:14:53,166 --> 00:14:53,826 A:middle
heavy duty.

298
00:14:55,036 --> 00:14:57,286 A:middle
This is where queries come in.

299
00:14:57,776 --> 00:15:01,076 A:middle
Queries provide a structured
mechanism for you to look

300

301
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

302
00:14:57,776 --> 00:15:01,076 A:middle
Queries provide a structured
mechanism for you to look

303
00:15:01,076 --> 00:15:03,136 A:middle
at health data in
a variety of ways.

304
00:15:03,656 --> 00:15:07,336 A:middle
All queries inherit
from HKQuery.

305
00:15:07,936 --> 00:15:12,416 A:middle
An HKQuery has a sample
type which is what kind

306
00:15:12,416 --> 00:15:14,026 A:middle
of data is being queried for.

307
00:15:15,696 --> 00:15:17,456 A:middle
They also have a predicate.

308
00:15:18,386 --> 00:15:21,796 A:middle
Predicate is an NSPredicate
that filters which objects are

309
00:15:21,796 --> 00:15:23,246 A:middle
to be returned by the query.

310
00:15:24,576 --> 00:15:26,926 A:middle
You can create predicates in
a couple of different ways.

311
00:15:27,866 --> 00:15:30,826 A:middle
First, you can use regular
NS predicate constructors

312
00:15:30,866 --> 00:15:33,656 A:middle
which you may already
be used to.

313
00:15:33,886 --> 00:15:36,236 A:middle
We give you a constant
for every key path

314
00:15:36,236 --> 00:15:37,986 A:middle
that you can use
with predicates.

315
00:15:38,476 --> 00:15:43,046 A:middle
This is a really powerful tool,
but we wanted to make it easier

316
00:15:43,046 --> 00:15:46,216 A:middle
on you to create the predicates
that are most commonly used.

317
00:15:47,036 --> 00:15:50,616 A:middle
So we provide some convenience
constructors right on HKQuery.

318
00:15:51,856 --> 00:15:53,546 A:middle
Note that these two
methods are going

319
00:15:53,546 --> 00:15:55,096 A:middle
to create identical predicates

320
00:15:55,276 --> 00:15:59,996 A:middle
so you can use whichever method
you feel more comfortable with.

321

322
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

323
00:16:00,696 --> 00:16:03,456 A:middle
Now, let's say that
you're working

324
00:16:03,516 --> 00:16:05,056 A:middle
on a brand new application.

325
00:16:06,086 --> 00:16:08,226 A:middle
This app is for a fancy
new health tracker

326
00:16:08,226 --> 00:16:10,146 A:middle
that can measure the
user's blood sugar

327
00:16:10,236 --> 00:16:11,606 A:middle
and sync it to their phone.

328
00:16:13,096 --> 00:16:15,926 A:middle
Your app already saves
all its data in HealthKit.

329
00:16:16,366 --> 00:16:17,966 A:middle
Now you want to create a screen

330
00:16:17,966 --> 00:16:20,996 A:middle
that will show the user their
most recent blood sugar reading.

331
00:16:22,026 --> 00:16:24,316 A:middle
You can do this with
HKSampleQuery.

332
00:16:24,796 --> 00:16:27,596 A:middle
Every sample query has a limit.

333
00:16:28,286 --> 00:16:30,446 A:middle
This defines how many
objects are going

334
00:16:30,446 --> 00:16:31,846 A:middle
to be returned by the query.

335
00:16:32,746 --> 00:16:34,366 A:middle
If you don't want to
limit your results,

336
00:16:34,496 --> 00:16:37,646 A:middle
you can specify
HKObjectQueryNoLimit.

337
00:16:39,456 --> 00:16:41,216 A:middle
They also have a sort order.

338
00:16:42,096 --> 00:16:44,296 A:middle
This is an array of
NSSortDescriptors

339
00:16:44,496 --> 00:16:45,566 A:middle
that dictates the order

340
00:16:45,566 --> 00:16:47,246 A:middle
for which you will
receive your result.

341
00:16:47,816 --> 00:16:52,016 A:middle
Here's an example of us
creating a sample query

342
00:16:52,086 --> 00:16:54,066 A:middle
to get our most recent
blood sugar reading.

343
00:16:55,636 --> 00:16:57,606 A:middle
First, we create
our quantity type,

344
00:16:58,146 --> 00:16:59,546 A:middle
which in this case
is blood sugar.

345

346
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

347
00:17:01,076 --> 00:17:03,396 A:middle
Next we create our
sort descriptor.

348
00:17:04,306 --> 00:17:07,596 A:middle
Because we want the most recent
we want to order our results

349
00:17:07,646 --> 00:17:10,465 A:middle
in end date in descending order.

350
00:17:11,665 --> 00:17:16,036 A:middle
When we create our sample query,
we admit it with a sample type

351
00:17:16,036 --> 00:17:20,175 A:middle
of blood sugar, a nil
predicate because we don't want

352
00:17:20,175 --> 00:17:23,746 A:middle
to filter our results,
a limit of 1

353
00:17:23,866 --> 00:17:25,776 A:middle
because we want the
1 most recent

354
00:17:26,646 --> 00:17:30,446 A:middle
and an array containing the
sort descriptor we just created.

355
00:17:31,026 --> 00:17:35,786 A:middle
In our result handler because
we know there's only going to be

356
00:17:35,786 --> 00:17:40,576 A:middle
at most 1 result, we ask our
results for the last object.

357
00:17:41,066 --> 00:17:46,126 A:middle
That worked pretty
well but you realized

358
00:17:46,176 --> 00:17:47,946 A:middle
that every time a
new reading comes

359
00:17:47,946 --> 00:17:50,306 A:middle
over from your health
tracker, nothing happens.

360
00:17:50,666 --> 00:17:54,146 A:middle
It will be really great if every
time you received a new reading

361
00:17:54,426 --> 00:17:57,316 A:middle
the display would just
update all by itself.

362
00:17:58,806 --> 00:18:01,836 A:middle
You could create some kind
of pull mechanism to do this

363

364
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

365
00:17:58,806 --> 00:18:01,836 A:middle
You could create some kind
of pull mechanism to do this

366
00:18:01,956 --> 00:18:05,326 A:middle
where every 30 seconds or so you
checked what the most recent is,

367
00:18:05,406 --> 00:18:08,466 A:middle
but it would be a lot nicer
if you could just be alerted

368
00:18:08,546 --> 00:18:09,906 A:middle
when things actually change.

369
00:18:10,616 --> 00:18:13,766 A:middle
This is the job of
HKObserverQuery.

370
00:18:15,106 --> 00:18:16,876 A:middle
Observer queries
are very simple.

371
00:18:17,286 --> 00:18:20,026 A:middle
All they do is watch for
changes in the database.

372
00:18:20,116 --> 00:18:24,366 A:middle
They are a little bit different
than sample queries in the sense

373
00:18:24,416 --> 00:18:25,476 A:middle
that they're long running.

374
00:18:25,736 --> 00:18:27,186 A:middle
So your update handler is going

375
00:18:27,186 --> 00:18:30,186 A:middle
to be called every time
a new object is saved

376
00:18:30,186 --> 00:18:31,816 A:middle
or removed from the database.

377
00:18:32,336 --> 00:18:37,176 A:middle
You might notice that in
your update handler there's a

378
00:18:37,176 --> 00:18:38,036 A:middle
completion handler.

379
00:18:38,446 --> 00:18:41,336 A:middle
This is for a feature that
we won't have time to go

380
00:18:41,336 --> 00:18:43,146 A:middle
into today called
background delivery.

381
00:18:44,346 --> 00:18:46,386 A:middle
If you have any questions
about background delivery,

382
00:18:46,746 --> 00:18:50,936 A:middle
please come by one of our labs.

383
00:18:51,156 --> 00:18:53,136 A:middle
Here's us creating
an observer query.

384
00:18:54,246 --> 00:18:57,576 A:middle
All we do is tell it that we
want all blood sugar readings

385
00:18:57,986 --> 00:19:01,366 A:middle
and our update handler will be
called every time a new blood

386

387
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

388
00:18:57,986 --> 00:19:01,366 A:middle
and our update handler will be
called every time a new blood

389
00:19:01,366 --> 00:19:07,496 A:middle
sugar reading is saved or
removed from the database.

390
00:19:07,606 --> 00:19:11,666 A:middle
Now, let's say that your
health app, that your app,

391
00:19:11,666 --> 00:19:13,696 A:middle
is partnering with
a health provider.

392
00:19:13,696 --> 00:19:18,226 A:middle
What it's supposed to do is take
all the blood sugar readings

393
00:19:18,306 --> 00:19:21,686 A:middle
that its created and
sync them to the Cloud.

394
00:19:22,396 --> 00:19:26,116 A:middle
You could do this using a sample
query where every time you query

395
00:19:26,116 --> 00:19:28,656 A:middle
for all the objects in
the database and figure

396
00:19:28,656 --> 00:19:32,516 A:middle
out which ones you haven't seen
yet probably using their UUID,

397
00:19:33,546 --> 00:19:37,616 A:middle
but this is a lot of work and
it would be a lot nicer if,

398
00:19:37,616 --> 00:19:39,976 A:middle
and it would be a waste
to pull all of the objects

399
00:19:39,976 --> 00:19:41,696 A:middle
from the database just to find

400
00:19:41,696 --> 00:19:43,956 A:middle
out that nothing has
actually changed.

401
00:19:45,116 --> 00:19:49,176 A:middle
This is the perfect job
for HKAnchoredObjectQuery.

402
00:19:49,796 --> 00:19:52,926 A:middle
An anchored object
query has a limit,

403
00:19:53,206 --> 00:19:55,726 A:middle
which again defines
how many results are

404
00:19:55,726 --> 00:19:57,346 A:middle
to be returned by the query.

405
00:19:58,516 --> 00:20:04,506 A:middle
It also has an anchor,
but what's an anchor?

406

407
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

408
00:19:58,516 --> 00:20:04,506 A:middle
It also has an anchor,
but what's an anchor?

409
00:20:05,696 --> 00:20:09,226 A:middle
Well, behind the scenes
every object stored

410
00:20:09,226 --> 00:20:12,086 A:middle
in HealthKit has its own
anchor in the database.

411
00:20:12,886 --> 00:20:15,476 A:middle
Your query anchor says
that you want everything

412
00:20:15,586 --> 00:20:16,776 A:middle
after a certain point.

413
00:20:17,796 --> 00:20:20,826 A:middle
So, if you're to provide
a query anchor of 0,

414
00:20:21,446 --> 00:20:22,876 A:middle
you would get back everything.

415
00:20:23,806 --> 00:20:26,416 A:middle
If you were to provide
a query anchor of 3,

416
00:20:27,006 --> 00:20:30,376 A:middle
you would only get back
objects 4, 5 and 6.

417
00:20:31,806 --> 00:20:34,446 A:middle
So in creating an
anchored object query,

418
00:20:34,896 --> 00:20:37,056 A:middle
your anchor should
represent the last piece

419
00:20:37,056 --> 00:20:38,446 A:middle
of data that you've seen.

420
00:20:39,326 --> 00:20:43,056 A:middle
If you haven't seen any data
yet, then you can specify 0,

421
00:20:43,166 --> 00:20:45,336 A:middle
which means you don't
have an anchor.

422
00:20:46,636 --> 00:20:49,266 A:middle
In your call back, you
will receive a new anchor,

423
00:20:49,386 --> 00:20:50,946 A:middle
which you can then use
in subsequent queries.

424
00:20:54,096 --> 00:20:57,246 A:middle
Here's an example of us creating
an anchored object query.

425
00:20:57,846 --> 00:21:02,926 A:middle
At some point in time probably
during our initializer we set

426

427
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

428
00:20:57,846 --> 00:21:02,926 A:middle
At some point in time probably
during our initializer we set

429
00:21:02,926 --> 00:21:04,696 A:middle
our last anchor to be 0.

430
00:21:06,756 --> 00:21:08,186 A:middle
When we create our query,

431
00:21:08,436 --> 00:21:10,716 A:middle
we tell it we want all
blood sugar readings

432
00:21:11,256 --> 00:21:13,856 A:middle
that have occurred
since our last anchor

433
00:21:14,936 --> 00:21:16,526 A:middle
and we don't want to
limit our results.

434
00:21:17,876 --> 00:21:20,766 A:middle
In our completion handler, we
will get our results as well

435
00:21:20,766 --> 00:21:23,686 A:middle
as a new anchor, which we can
then use in our next query.

436
00:21:24,696 --> 00:21:27,306 A:middle
Let's see how this would
work with some actual data.

437
00:21:28,656 --> 00:21:31,406 A:middle
Let's say our database
has 3 objects in it.

438
00:21:31,526 --> 00:21:32,786 A:middle
Since I haven't seen anything

439
00:21:32,786 --> 00:21:35,596 A:middle
yet we'll say my
current anchor is 0.

440
00:21:36,896 --> 00:21:40,496 A:middle
When I run my query, I'll
get back objects 1, 2 and 3

441
00:21:41,046 --> 00:21:43,736 A:middle
and my current anchor
will now be 3.

442
00:21:45,306 --> 00:21:50,416 A:middle
Next, 2 objects are
added to the database.

443
00:21:50,416 --> 00:21:54,196 A:middle
When I run another query,
I'll get back objects 4 and 5

444
00:21:54,836 --> 00:22:01,056 A:middle
and my current anchor
will now be 5.

445

446
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

447
00:21:54,836 --> 00:22:01,056 A:middle
and my current anchor
will now be 5.

448
00:22:01,266 --> 00:22:03,676 A:middle
So, I've shown you a
few different queries

449
00:22:03,986 --> 00:22:07,536 A:middle
and some situations that they're
useful in but we haven't talked

450
00:22:07,536 --> 00:22:09,446 A:middle
about how to actually
run your queries.

451
00:22:10,646 --> 00:22:13,516 A:middle
This is done using two
methods on HKHealthStore,

452
00:22:14,076 --> 00:22:15,946 A:middle
executeQuery and stopQuery.

453
00:22:17,736 --> 00:22:20,256 A:middle
ExecuteQuery tells a
query to begin running.

454
00:22:21,376 --> 00:22:24,156 A:middle
At any point in time
you can call stopQuery

455
00:22:24,466 --> 00:22:27,366 A:middle
which will kill your query
and prevent any callbacks

456
00:22:27,366 --> 00:22:29,516 A:middle
that haven't happened yet.

457
00:22:30,056 --> 00:22:32,796 A:middle
You can call stopQuery as
many times as you want,

458
00:22:33,126 --> 00:22:37,136 A:middle
it doesn't matter, but you
can only execute a query once.

459
00:22:37,636 --> 00:22:42,296 A:middle
This is because once a query
is stopped its callbacks are

460
00:22:42,296 --> 00:22:44,416 A:middle
invalidated to prevent
retained cycles.

461
00:22:45,986 --> 00:22:47,746 A:middle
Remember, though
that you only need

462
00:22:47,746 --> 00:22:50,956 A:middle
to stop long running queries
such as the observer query.

463
00:22:51,836 --> 00:22:55,176 A:middle
Other queries know to stop
themselves once they received

464
00:22:55,296 --> 00:22:59,256 A:middle
their initial data.

465
00:22:59,436 --> 00:23:01,576 A:middle
Now, all of the queries
that we've talked

466

467
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

468
00:22:59,436 --> 00:23:01,576 A:middle
Now, all of the queries
that we've talked

469
00:23:01,576 --> 00:23:05,366 A:middle
about so far let you get actual
objects from the database,

470
00:23:06,076 --> 00:23:08,146 A:middle
but oftentimes we don't care

471
00:23:08,146 --> 00:23:10,606 A:middle
about the individual
objects themselves.

472
00:23:10,606 --> 00:23:16,496 A:middle
What we really care about
are statistics on our data.

473
00:23:16,666 --> 00:23:19,456 A:middle
You could use a sample
query and iterate

474
00:23:19,456 --> 00:23:22,156 A:middle
over all your results summing
their quantities together

475
00:23:22,706 --> 00:23:26,156 A:middle
but this would be a lot of
work and a lot of objects

476
00:23:26,156 --> 00:23:29,466 A:middle
in memory considering all we
really care about is the sum.

477
00:23:30,816 --> 00:23:34,456 A:middle
To support operations like this
statistics are a first class

478
00:23:34,506 --> 00:23:37,376 A:middle
citizen in HealthKit.

479
00:23:38,486 --> 00:23:41,346 A:middle
Statistics are handled
by HKStatistics.

480
00:23:41,876 --> 00:23:47,416 A:middle
An HKStatisticsObject is an
aggregation of multiple kids

481
00:23:47,416 --> 00:23:52,856 A:middle
of statistics such as
sum, min, max and average.

482
00:23:53,236 --> 00:23:56,656 A:middle
You can ask for statistics
across all data or only

483
00:23:56,656 --> 00:23:59,436 A:middle
for statistics that came
from a particular source.

484
00:23:59,866 --> 00:24:03,086 A:middle
Because we're talking

485

486
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

487
00:23:59,866 --> 00:24:03,086 A:middle
Because we're talking

488
00:24:03,086 --> 00:24:06,546 A:middle
about numerical analysis
statistics are only valid

489
00:24:06,636 --> 00:24:09,656 A:middle
for quantity types.

490
00:24:10,036 --> 00:24:13,266 A:middle
Remember though that not
all types are the same.

491
00:24:14,156 --> 00:24:16,516 A:middle
We care about different
statistics depending

492
00:24:16,516 --> 00:24:18,476 A:middle
on what kind of data
we're looking at.

493
00:24:19,646 --> 00:24:23,106 A:middle
We classify types as either
discrete or cumulative.

494
00:24:25,276 --> 00:24:27,656 A:middle
Discrete types are
things like your height,

495
00:24:28,066 --> 00:24:29,456 A:middle
weight or blood pressure.

496
00:24:30,266 --> 00:24:33,646 A:middle
They're the kinds of data where
an individual sample has all

497
00:24:33,646 --> 00:24:36,556 A:middle
of the context you need to
make sense of its quantity.

498
00:24:37,336 --> 00:24:39,256 A:middle
The only statistics we care

499
00:24:39,256 --> 00:24:42,636 A:middle
about for discrete types
are min, max and average.

500
00:24:43,536 --> 00:24:45,506 A:middle
If I were to take all
of my weight readings

501
00:24:45,576 --> 00:24:46,476 A:middle
and add them together,

502
00:24:46,956 --> 00:24:49,666 A:middle
I wouldn't get any useful
information whatsoever.

503
00:24:52,256 --> 00:24:56,986 A:middle
Cumulative types are things like
your step count or the number

504
00:24:56,986 --> 00:24:58,096 A:middle
of calories that you've burned.

505
00:24:59,286 --> 00:25:02,046 A:middle
In contrast to discrete
types, I really don't care

506

507
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

508
00:24:59,286 --> 00:25:02,046 A:middle
In contrast to discrete
types, I really don't care

509
00:25:02,046 --> 00:25:03,406 A:middle
about an individual sample.

510
00:25:04,016 --> 00:25:06,426 A:middle
What I care about is an
aggregation of samples

511
00:25:06,506 --> 00:25:07,506 A:middle
over a period of time.

512
00:25:08,326 --> 00:25:11,006 A:middle
For example, that I
took 7,000 steps today.

513
00:25:11,916 --> 00:25:13,936 A:middle
So the only statistic we care

514
00:25:13,936 --> 00:25:20,896 A:middle
about on cumulative
types is sum.

515
00:25:21,096 --> 00:25:23,596 A:middle
So every quantity
type is classified

516
00:25:23,596 --> 00:25:25,906 A:middle
as either discrete
or cumulative.

517
00:25:26,086 --> 00:25:32,026 A:middle
In our type identifier's header,
every type identifier is listed

518
00:25:32,166 --> 00:25:33,496 A:middle
with its aggregation style.

519
00:25:33,706 --> 00:25:37,646 A:middle
If you want to check
in code though,

520
00:25:37,916 --> 00:25:41,076 A:middle
HKQuantityType has an
aggregation style property

521
00:25:41,186 --> 00:25:44,176 A:middle
that will return either
cumulative or discrete.

522
00:25:44,686 --> 00:25:47,236 A:middle
Back to statistics.

523
00:25:48,436 --> 00:25:51,636 A:middle
As you may or may not
know, generating statistics

524
00:25:51,766 --> 00:25:54,706 A:middle
on large amounts of data
can be rather expensive.

525
00:25:56,016 --> 00:25:59,276 A:middle
Because of this we had you
tell us what you want ahead

526
00:25:59,496 --> 00:26:03,696 A:middle
of time using a bit mask
of HKStatisticsOptions.

527

528
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

529
00:25:59,496 --> 00:26:03,696 A:middle
of time using a bit mask
of HKStatisticsOptions.

530
00:26:06,056 --> 00:26:09,296 A:middle
Average, min, max and
sum each have their own

531
00:26:09,296 --> 00:26:10,266 A:middle
statistics option.

532
00:26:11,136 --> 00:26:13,466 A:middle
These are marked as either
discrete or cumulative.

533
00:26:14,416 --> 00:26:17,756 A:middle
If you ask a cumulative
type for discrete statistic,

534
00:26:17,756 --> 00:26:19,236 A:middle
we're going to throw
an exception.

535
00:26:19,806 --> 00:26:23,106 A:middle
A little bit less
straightforward is separate

536
00:26:23,106 --> 00:26:23,716 A:middle
by source.

537
00:26:24,716 --> 00:26:27,196 A:middle
This lets you ask in
HKStatisticsObject

538
00:26:27,586 --> 00:26:30,626 A:middle
for the statistics that came
from a particular source,

539
00:26:31,566 --> 00:26:32,826 A:middle
but why is this important?

540
00:26:33,366 --> 00:26:38,926 A:middle
Let's say we have 2 sources,
Source A and Source B.

541
00:26:39,576 --> 00:26:42,156 A:middle
Both of these sources
are writing step data

542
00:26:42,156 --> 00:26:43,766 A:middle
to HealthKit at the same time.

543
00:26:45,036 --> 00:26:47,486 A:middle
Now let's say that I
want to sum up my steps.

544
00:26:47,486 --> 00:26:50,536 A:middle
I could take all of the
samples in the database

545
00:26:50,666 --> 00:26:51,646 A:middle
and add them together,

546
00:26:51,926 --> 00:26:56,296 A:middle
which would give me 41,
which is also wrong.

547
00:26:57,036 --> 00:27:00,096 A:middle
Because these sources were
saving data at the same time,

548

549
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

550
00:26:57,036 --> 00:27:00,096 A:middle
Because these sources were
saving data at the same time,

551
00:27:00,606 --> 00:27:03,036 A:middle
in many cases I was
actually double counting.

552
00:27:03,706 --> 00:27:07,826 A:middle
To handle this we let the
user specify in the health app

553
00:27:08,266 --> 00:27:10,576 A:middle
which sources are
most important to them

554
00:27:10,796 --> 00:27:12,806 A:middle
for a particular quantity type.

555
00:27:13,326 --> 00:27:15,726 A:middle
We then use this
information to try to figure

556
00:27:15,726 --> 00:27:17,186 A:middle
out what actually happened.

557
00:27:18,676 --> 00:27:20,406 A:middle
If you don't like
our merge strategy,

558
00:27:20,536 --> 00:27:24,106 A:middle
then you can always perform your
own by separating by source.

559
00:27:24,636 --> 00:27:28,336 A:middle
Now back to your application.

560
00:27:29,256 --> 00:27:31,706 A:middle
Let's say that your health
tracker just got an awesome

561
00:27:31,706 --> 00:27:32,266 A:middle
new feature.

562
00:27:32,496 --> 00:27:34,166 A:middle
Now it can count the user steps.

563
00:27:34,876 --> 00:27:37,596 A:middle
To support this you want
to have a new screen

564
00:27:37,596 --> 00:27:40,046 A:middle
that shows the user their
total steps for the day.

565
00:27:41,746 --> 00:27:44,886 A:middle
This is a sum so you know
you want to use statistics

566
00:27:45,316 --> 00:27:47,586 A:middle
but how do you actually
generate statistics?

567
00:27:48,976 --> 00:27:51,686 A:middle
This is done through
HKStatisticsQuery.

568
00:27:52,526 --> 00:27:56,416 A:middle
Statistics queries take a bit
mask of statistics options

569
00:27:57,146 --> 00:27:59,176 A:middle
and return a statistics object.

570

571
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

572
00:28:00,166 --> 00:28:04,346 A:middle
So here's an example of us
creating a statistics query.

573
00:28:06,336 --> 00:28:08,526 A:middle
First we get our quantity type

574
00:28:08,896 --> 00:28:13,096 A:middle
which in this case
is step count.

575
00:28:13,226 --> 00:28:15,656 A:middle
Next we perform some
date calculations

576
00:28:16,086 --> 00:28:21,166 A:middle
to only return objects
that happen today.

577
00:28:21,356 --> 00:28:22,986 A:middle
We create our statistics
options,

578
00:28:22,986 --> 00:28:24,376 A:middle
which in this case is sum,

579
00:28:25,396 --> 00:28:28,636 A:middle
and then when we create our
query we tell it we want all

580
00:28:28,636 --> 00:28:32,296 A:middle
steps that happen today and
we want to take their sum

581
00:28:33,706 --> 00:28:35,956 A:middle
and in our completion
handler we'll be given an

582
00:28:35,956 --> 00:28:39,586 A:middle
HKStatisticsObject that we can
then ask for its sum quantity.

583
00:28:41,476 --> 00:28:44,516 A:middle
Well, you feel like a
rock star right now.

584
00:28:45,326 --> 00:28:48,156 A:middle
Using your UI code from your
blood sugar screen you're able

585
00:28:48,156 --> 00:28:50,206 A:middle
to bust this out
in like 5 minutes.

586
00:28:50,936 --> 00:28:54,956 A:middle
With all of that extra time you
decide it would be really cool

587
00:28:55,156 --> 00:28:58,326 A:middle
if you could show the user their
daily step count throughout

588
00:28:58,326 --> 00:28:59,366 A:middle
the week.

589

590
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

591
00:29:00,776 --> 00:29:01,826 A:middle
How do you do this?

592
00:29:02,506 --> 00:29:06,306 A:middle
You could execute 7 statistics
queries, 1 for each day,

593
00:29:07,046 --> 00:29:09,476 A:middle
and once they all
return use their results

594
00:29:09,526 --> 00:29:11,426 A:middle
to draw your chart.

595
00:29:11,766 --> 00:29:13,426 A:middle
This sounds like a
lot of effort though.

596
00:29:14,556 --> 00:29:18,336 A:middle
This is actually the perfect
job for HKStatisticsCollection.

597
00:29:19,256 --> 00:29:23,336 A:middle
From a high level statistics
collection is just a collection

598
00:29:23,416 --> 00:29:24,616 A:middle
of statistics objects.

599
00:29:25,176 --> 00:29:29,026 A:middle
It splits time up into a
series of time intervals

600
00:29:29,116 --> 00:29:31,906 A:middle
and generates statistics on
each of those time intervals.

601
00:29:32,426 --> 00:29:36,976 A:middle
Let's take a look at
how this actually works.

602
00:29:44,046 --> 00:29:45,846 A:middle
In this diagram, each

603
00:29:45,846 --> 00:29:49,676 A:middle
of our gray boxes represents
its own HKStatisticsObject.

604
00:29:51,156 --> 00:29:54,156 A:middle
We call our Delta T
our interval components

605
00:29:54,396 --> 00:29:56,376 A:middle
and this is an NSDateComponents
object.

606
00:29:57,326 --> 00:30:00,766 A:middle
The reason why we chose
to use NSDateComponents is

607

608
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

609
00:29:57,326 --> 00:30:00,766 A:middle
The reason why we chose
to use NSDateComponents is

610
00:30:00,766 --> 00:30:02,946 A:middle
because when we talk
about health information

611
00:30:03,256 --> 00:30:06,996 A:middle
in a historical way, we tend
to talk about it in days,

612
00:30:06,996 --> 00:30:08,766 A:middle
weeks, months and years.

613
00:30:09,516 --> 00:30:13,306 A:middle
To do this properly, you
need to use date components.

614
00:30:14,726 --> 00:30:16,796 A:middle
If you're curious about
date calculations,

615
00:30:16,926 --> 00:30:18,956 A:middle
please see last year's video,

616
00:30:19,086 --> 00:30:21,716 A:middle
Solutions to Common Date
and Time Challenges.

617
00:30:24,116 --> 00:30:27,756 A:middle
So, now let's say we have
interval components of 1 day.

618
00:30:28,806 --> 00:30:32,556 A:middle
The problem is we don't know if
you want your day to be midnight

619
00:30:32,616 --> 00:30:36,366 A:middle
to midnight, noon to noon or
something completely different.

620
00:30:37,686 --> 00:30:40,166 A:middle
To handle this we have you
give us an anchor date.

621
00:30:41,446 --> 00:30:44,756 A:middle
All the anchor date does is
tell you what the edge of one

622
00:30:44,756 --> 00:30:47,976 A:middle
of your time intervals
is and that's all we need

623
00:30:48,096 --> 00:30:50,416 A:middle
to create a collection
of statistics for you.

624
00:30:51,536 --> 00:30:54,496 A:middle
Let's see how this would
look with some actual data.

625
00:30:55,756 --> 00:30:58,526 A:middle
Once we get your anchor date
and your interval components,

626
00:30:58,526 --> 00:31:01,636 A:middle
we split up all of time in
the series of time intervals.

627

628
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

629
00:30:58,526 --> 00:31:01,636 A:middle
we split up all of time in
the series of time intervals.

630
00:31:02,576 --> 00:31:05,746 A:middle
We can then group data into
these different time intervals

631
00:31:06,276 --> 00:31:11,946 A:middle
and collect statistics on
it such as ask for it sum.

632
00:31:12,116 --> 00:31:15,036 A:middle
So, this is what a
statistics collection is,

633
00:31:15,546 --> 00:31:17,936 A:middle
but how do you actually
interact with this object?

634
00:31:18,656 --> 00:31:21,186 A:middle
Because we don't force you
to give us a start date

635
00:31:21,186 --> 00:31:23,926 A:middle
or an end date, there's
potentially an infinite number

636
00:31:23,926 --> 00:31:24,686 A:middle
of statistics.

637
00:31:25,256 --> 00:31:29,356 A:middle
The first thing you can do
is ask for an array of all

638
00:31:29,356 --> 00:31:30,826 A:middle
of the populated statistics.

639
00:31:31,846 --> 00:31:33,716 A:middle
Populated statistics
are the ones

640
00:31:33,716 --> 00:31:37,926 A:middle
where their time interval
actually had data in it.

641
00:31:38,196 --> 00:31:39,646 A:middle
You can ask for the statistics

642
00:31:39,646 --> 00:31:41,166 A:middle
that occurred on
a particular date.

643
00:31:42,256 --> 00:31:44,086 A:middle
What this will do is find

644
00:31:44,086 --> 00:31:46,306 A:middle
out which time period
your date falls into

645
00:31:46,686 --> 00:31:50,106 A:middle
and give you back the statistics
from that time period whether

646
00:31:50,106 --> 00:31:53,456 A:middle
or not there was any data.

647
00:31:53,456 --> 00:31:55,476 A:middle
Last you can enumerate
across all

648
00:31:55,476 --> 00:31:57,776 A:middle
of the statistics
between two dates.

649
00:31:58,566 --> 00:32:00,096 A:middle
This will return both populated

650

651
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

652
00:31:58,566 --> 00:32:00,096 A:middle
This will return both populated

653
00:32:00,296 --> 00:32:02,486 A:middle
and non-populated
statistics objects.

654
00:32:03,016 --> 00:32:07,976 A:middle
So this seems like it's
going to work pretty well.

655
00:32:08,996 --> 00:32:12,006 A:middle
All you need to do is specify
an anchor date of Sunday

656
00:32:12,006 --> 00:32:14,426 A:middle
at midnight and interval
components

657
00:32:14,426 --> 00:32:18,716 A:middle
of one day and that's about it.

658
00:32:18,716 --> 00:32:21,866 A:middle
So, how do you actually create
a statistics collection?

659
00:32:22,886 --> 00:32:25,696 A:middle
This is done with an
HKStatisticsCollectionQuery.

660
00:32:28,036 --> 00:32:30,956 A:middle
These take a bit mask
of statistics options,

661
00:32:31,616 --> 00:32:35,516 A:middle
an anchor date and an
interval component's object

662
00:32:35,626 --> 00:32:38,986 A:middle
and give you back an
HKStatisticsCollection.

663
00:32:39,376 --> 00:32:41,046 A:middle
It's that easy.

664
00:32:42,676 --> 00:32:45,206 A:middle
Now I'm going to hand
things over to Siji

665
00:32:45,206 --> 00:32:47,546 A:middle
so that she can show you
how to incorporate HealthKit

666
00:32:47,706 --> 00:32:48,946 A:middle
into your own applications.

667
00:32:49,736 --> 00:32:50,806 A:middle
>> Thank you, Justin.

668
00:32:51,226 --> 00:32:52,896 A:middle
Hey everybody, good morning.

669
00:32:52,896 --> 00:32:55,666 A:middle
I am Siji Rachel Tom and I'm one
of the engineers on HealthKit.

670
00:32:55,796 --> 00:32:57,256 A:middle
I'm really excited
to be here today

671
00:32:57,256 --> 00:32:58,646 A:middle
to give you this quick demo.

672
00:32:58,706 --> 00:33:01,866 A:middle
So there are 3 things that
you will see in this demo.

673

674
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

675
00:32:58,706 --> 00:33:01,866 A:middle
So there are 3 things that
you will see in this demo.

676
00:33:02,926 --> 00:33:06,366 A:middle
First you'll see how you
can leverage HealthKit

677
00:33:06,366 --> 00:33:08,206 A:middle
to retrieve existing information

678
00:33:08,206 --> 00:33:09,756 A:middle
about the user from
Health Store.

679
00:33:10,366 --> 00:33:12,466 A:middle
Now this information
might have been inserted

680
00:33:12,466 --> 00:33:14,706 A:middle
into Health Store
by some other app.

681
00:33:15,336 --> 00:33:17,656 A:middle
Second, you'll see
how you can read

682
00:33:17,656 --> 00:33:21,716 A:middle
and write your own data objects
into Health Store, and third,

683
00:33:21,716 --> 00:33:24,456 A:middle
you'll see some examples of the
queries that Justin spoke about.

684
00:33:24,456 --> 00:33:28,346 A:middle
Now for the purpose of this
demo I'm going to walk you

685
00:33:28,346 --> 00:33:30,466 A:middle
through making a
fitness tracking app.

686
00:33:31,216 --> 00:33:34,846 A:middle
The goal of this app would be
to track your net energy burn

687
00:33:34,846 --> 00:33:37,236 A:middle
through a given day
and we are going

688
00:33:37,236 --> 00:33:40,116 A:middle
to define the net energy
burn as a total energy burn

689
00:33:40,116 --> 00:33:44,076 A:middle
by activity subtracted by
the total energy consumed.

690
00:33:44,696 --> 00:33:47,026 A:middle
With that in mind let's go
take a quick look at the demo.

691
00:33:49,866 --> 00:33:51,916 A:middle
So we know we are going
to be using HealthKit

692
00:33:51,916 --> 00:33:54,416 A:middle
for our data storage
needs, but before we can do

693
00:33:54,416 --> 00:33:57,336 A:middle
that we need the user's
permission and this is the code

694
00:33:57,336 --> 00:33:59,406 A:middle
that you will write to
get the user's permission.

695
00:33:59,746 --> 00:34:03,006 A:middle
So first you check whether
HealthKit is supported

696

697
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

698
00:33:59,746 --> 00:34:03,006 A:middle
So first you check whether
HealthKit is supported

699
00:34:03,006 --> 00:34:06,296 A:middle
on the current iOS device and
this is because some devices

700
00:34:06,296 --> 00:34:08,996 A:middle
such as the iPad does
not support HealthKit.

701
00:34:09,996 --> 00:34:12,126 A:middle
Next you create an
instance of Health Store

702
00:34:12,126 --> 00:34:15,966 A:middle
and then use Health
Store's authorization APIs

703
00:34:16,136 --> 00:34:18,436 A:middle
to request read and
shared access

704
00:34:18,476 --> 00:34:20,436 A:middle
to these different
sets of data types.

705
00:34:21,826 --> 00:34:24,426 A:middle
Now I have already set up
my device to be authorized,

706
00:34:24,426 --> 00:34:27,366 A:middle
but the first time you run
this piece of code you're going

707
00:34:27,366 --> 00:34:30,025 A:middle
to get this dialogue popup that
requests permissions from you.

708
00:34:30,025 --> 00:34:33,485 A:middle
So now let's look at the app.

709
00:34:35,856 --> 00:34:38,976 A:middle
Since we are dealing with
user's specific energy burn

710
00:34:38,976 --> 00:34:40,636 A:middle
calculations, let's assume

711
00:34:40,636 --> 00:34:43,496 A:middle
that we need some user's
specific statistics as well.

712
00:34:43,496 --> 00:34:46,246 A:middle
For instance the user's
age, height and weight.

713
00:34:46,815 --> 00:34:47,926 A:middle
Now I've set up the app

714
00:34:47,985 --> 00:34:50,985 A:middle
such that the user can enter
these details, but it will be

715
00:34:50,985 --> 00:34:53,556 A:middle
so much cooler if we can
look at Health Store and see

716
00:34:53,556 --> 00:34:56,226 A:middle
if these values already exist
and if so just retrieve it

717
00:34:56,226 --> 00:34:57,886 A:middle
and display it for the
user's confirmation.

718
00:34:58,806 --> 00:35:02,406 A:middle
So let's go and write
code to do just that.

719

720
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

721
00:34:58,806 --> 00:35:02,406 A:middle
So let's go and write
code to do just that.

722
00:35:03,056 --> 00:35:06,206 A:middle
A quick note before that I'm not
doing much edit handling code

723
00:35:06,206 --> 00:35:07,666 A:middle
in this demo but
there is sample code

724
00:35:07,666 --> 00:35:08,956 A:middle
for this app uploaded online

725
00:35:08,956 --> 00:35:10,246 A:middle
and that will be a
much better guide.

726
00:35:11,446 --> 00:35:14,486 A:middle
Now, to get the user's
age, we need birth date.

727
00:35:14,976 --> 00:35:17,866 A:middle
Birth date is a characteristic
data type in HealthKit

728
00:35:17,866 --> 00:35:20,816 A:middle
and Health Store has this
convenient synchronous

729
00:35:20,816 --> 00:35:22,676 A:middle
that directly access
user's birthday.

730
00:35:22,676 --> 00:35:25,076 A:middle
So let's go ahead and
use that method here

731
00:35:25,076 --> 00:35:29,206 A:middle
and once we have the
birth date it's simple

732
00:35:29,206 --> 00:35:31,006 A:middle
to get the user's age.

733
00:35:32,216 --> 00:35:36,206 A:middle
Notice here I am passing
the age completion block.

734
00:35:36,796 --> 00:35:38,736 A:middle
Let's run this code and see.

735
00:35:42,536 --> 00:35:46,926 A:middle
Tah-dah. Age does show up
and how this happened is

736
00:35:46,926 --> 00:35:49,066 A:middle
because earlier today I
used Apple's health app

737
00:35:49,066 --> 00:35:52,066 A:middle
to insert my birth
date into Health Store.

738
00:35:52,976 --> 00:35:55,586 A:middle
Let's look at user
height and weight next.

739
00:35:56,736 --> 00:36:00,386 A:middle
So, height and weight are
quantity data types in HealthKit

740

741
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

742
00:35:56,736 --> 00:36:00,386 A:middle
So, height and weight are
quantity data types in HealthKit

743
00:36:00,386 --> 00:36:03,666 A:middle
and to get quantity samples
out of Health Store we need

744
00:36:03,666 --> 00:36:04,776 A:middle
to write a sample query.

745
00:36:05,266 --> 00:36:07,376 A:middle
So let's go ahead and write
our first sample query

746
00:36:07,376 --> 00:36:09,726 A:middle
in this convenient
method which will give us

747
00:36:09,726 --> 00:36:14,116 A:middle
like the most recently quantity
sample of any given data type.

748
00:36:14,116 --> 00:36:17,056 A:middle
So this is our first
sample query.

749
00:36:17,056 --> 00:36:20,496 A:middle
Now I want a single most
recent quantity sample

750
00:36:20,496 --> 00:36:23,136 A:middle
of a given data type and
so for that I'm first going

751
00:36:23,136 --> 00:36:25,786 A:middle
to sort my existing
samples in descending order

752
00:36:25,786 --> 00:36:29,126 A:middle
and then I'm going to
specify a limit of 1

753
00:36:29,126 --> 00:36:30,816 A:middle
to get just the first
one out of it.

754
00:36:32,016 --> 00:36:35,016 A:middle
I don't want to filter the
data so my predicate is nil

755
00:36:35,166 --> 00:36:36,966 A:middle
and the data type
that I'm interested

756
00:36:36,966 --> 00:36:38,336 A:middle
in is passed into this method.

757
00:36:38,336 --> 00:36:44,646 A:middle
Now when this query
returns, I get an array back

758
00:36:45,286 --> 00:36:47,736 A:middle
and this is an array
of quantity samples.

759
00:36:48,316 --> 00:36:51,686 A:middle
In our case if there is a
valid quantity sample existing

760
00:36:51,686 --> 00:36:53,036 A:middle
in Health Store,
then you're going

761
00:36:53,036 --> 00:36:55,546 A:middle
to get just 1 quantity
sample back.

762
00:36:55,546 --> 00:36:59,036 A:middle
So what we're going to do is get
the quantity object associated

763
00:36:59,036 --> 00:37:01,226 A:middle
with that quantity
sample back and then pass

764

765
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

766
00:36:59,036 --> 00:37:01,226 A:middle
with that quantity
sample back and then pass

767
00:37:01,266 --> 00:37:02,536 A:middle
that in this completion block.

768
00:37:03,216 --> 00:37:05,446 A:middle
So let's go and write
code to that.

769
00:37:07,116 --> 00:37:09,216 A:middle
So this gets the first
object and passes it

770
00:37:09,216 --> 00:37:10,146 A:middle
in the completion block.

771
00:37:10,706 --> 00:37:13,786 A:middle
Very important once you've
written a query is please don't

772
00:37:13,786 --> 00:37:18,126 A:middle
forget to execute the query.

773
00:37:18,126 --> 00:37:21,596 A:middle
Okay. Now let's use
this convenient method

774
00:37:21,596 --> 00:37:23,646 A:middle
to actually get the
user's height.

775
00:37:24,076 --> 00:37:27,026 A:middle
So let's first go can call
that method we just wrote.

776
00:37:27,596 --> 00:37:32,186 A:middle
Now user height is a quantity
type with identifier height

777
00:37:32,596 --> 00:37:36,976 A:middle
and so I pass that in and when
the query returns I get the most

778
00:37:36,976 --> 00:37:39,546 A:middle
recent quantity object
and as Justin was talking

779
00:37:39,546 --> 00:37:42,646 A:middle
about earlier a quantity
object is nothing

780
00:37:42,646 --> 00:37:45,446 A:middle
but a double value associated
with a particular unit.

781
00:37:45,816 --> 00:37:51,596 A:middle
I want to show my height
in inches and so I am going

782
00:37:51,596 --> 00:37:55,166 A:middle
to specify HKUnit inchUnit.

783
00:37:55,166 --> 00:38:00,256 A:middle
Once I have the height
we need to pass it back

784

785
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

786
00:37:55,166 --> 00:38:00,256 A:middle
Once I have the height
we need to pass it back

787
00:38:00,256 --> 00:38:03,946 A:middle
to the view controller who
wants it but note that queries

788
00:38:03,946 --> 00:38:07,596 A:middle
from Health Store always are
done anonymous background queues

789
00:38:07,596 --> 00:38:10,286 A:middle
so we need to make sure we
switch back to the main queue

790
00:38:10,816 --> 00:38:13,176 A:middle
and it should give
us the height.

791
00:38:14,046 --> 00:38:16,476 A:middle
Now, I have already set up
code to do the exact same

792
00:38:16,476 --> 00:38:17,896 A:middle
for getting the user's weight.

793
00:38:18,116 --> 00:38:20,446 A:middle
The only difference is
that the identifier here is

794
00:38:20,446 --> 00:38:24,116 A:middle
that for body mass and the unit
I'm interested in is pound.

795
00:38:25,236 --> 00:38:27,486 A:middle
Now let's run this code.

796
00:38:28,916 --> 00:38:31,176 A:middle
There it works, you guys.

797
00:38:31,716 --> 00:38:31,986 A:middle
Okay.

798
00:38:33,516 --> 00:38:38,546 A:middle
[ Applause ]

799
00:38:39,046 --> 00:38:39,746 A:middle
Let's move on.

800
00:38:40,116 --> 00:38:43,286 A:middle
So we are interested in
getting the net energy burn,

801
00:38:43,286 --> 00:38:45,706 A:middle
which we define as
the total energy burn

802
00:38:45,706 --> 00:38:48,726 A:middle
by activity subtracted by
the total energy consumed.

803
00:38:49,386 --> 00:38:51,716 A:middle
So let's give the user a
chance to enter details

804
00:38:51,716 --> 00:38:52,986 A:middle
about the energy consumed.

805
00:38:52,986 --> 00:38:56,996 A:middle
I've already setup this
app to show a possible list

806
00:38:56,996 --> 00:39:00,376 A:middle
of food items consumed but
this app doesn't do much else

807

808
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

809
00:38:56,996 --> 00:39:00,376 A:middle
of food items consumed but
this app doesn't do much else

810
00:39:00,376 --> 00:39:00,906 A:middle
right now.

811
00:39:01,466 --> 00:39:05,226 A:middle
What I want it to be able to
do is when I select an item

812
00:39:05,226 --> 00:39:07,996 A:middle
and I want to save that item
details into Health Store

813
00:39:07,996 --> 00:39:10,176 A:middle
and when I come back to
this main screen I want

814
00:39:10,176 --> 00:39:12,826 A:middle
to retrieve those
details and display it.

815
00:39:12,826 --> 00:39:15,536 A:middle
So let's go and write
code to do that now.

816
00:39:15,876 --> 00:39:19,956 A:middle
Again a quick note so food
item is a lot more rich

817
00:39:20,026 --> 00:39:22,856 A:middle
than just calories but for the
purpose of this demo we're going

818
00:39:22,856 --> 00:39:24,846 A:middle
to focus on saving just
the calorie information.

819
00:39:25,426 --> 00:39:30,426 A:middle
So, I'm going to treat each
food item as a quantity sample

820
00:39:30,426 --> 00:39:32,676 A:middle
and I want to save
the food item's name

821
00:39:32,676 --> 00:39:34,016 A:middle
and calorie information.

822
00:39:34,546 --> 00:39:37,476 A:middle
I'll save the name as metadata
and calorie information

823
00:39:37,476 --> 00:39:40,016 A:middle
as quantity object associated
with that quantity sample.

824
00:39:40,636 --> 00:39:43,666 A:middle
So let's go create our
first quantity sample.

825
00:39:47,176 --> 00:39:52,056 A:middle
Now the data type that I'm going
to save this food sample as is

826
00:39:52,056 --> 00:39:55,106 A:middle
that of dietary calories
and so let's specify that.

827
00:39:56,026 --> 00:39:58,356 A:middle
The quantity object as we
just mentioned will be the

828
00:39:58,356 --> 00:39:59,096 A:middle
calorie count.

829

830
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

831
00:40:00,216 --> 00:40:09,796 A:middle
So it will be kilocalorie unit
and the double value is passed

832
00:40:09,796 --> 00:40:14,556 A:middle
into this method and
that's our quantity object.

833
00:40:15,146 --> 00:40:16,826 A:middle
Now I'm just going to
save this food sample

834
00:40:16,826 --> 00:40:17,916 A:middle
with the current date and time

835
00:40:17,916 --> 00:40:22,666 A:middle
and as I mentioned earlier the
metadata will have the food name

836
00:40:22,666 --> 00:40:24,046 A:middle
associated with it.

837
00:40:24,046 --> 00:40:27,236 A:middle
Notice here that HealthKit
actually provides these

838
00:40:27,236 --> 00:40:29,946 A:middle
convenient strings to be
used as keys in metadata

839
00:40:29,946 --> 00:40:33,676 A:middle
and so we're just going to use
the food type key and that's it.

840
00:40:33,676 --> 00:40:36,306 A:middle
We have officially
created our first sample.

841
00:40:36,506 --> 00:40:38,596 A:middle
Let's go and save
this into the database

842
00:40:38,656 --> 00:40:43,326 A:middle
into Health Store
and there, done.

843
00:40:44,516 --> 00:40:47,546 A:middle
Awesome. So now that we have
saved these items let's write

844
00:40:47,546 --> 00:40:49,476 A:middle
code to fetch these
items out and display it.

845
00:40:49,476 --> 00:40:51,776 A:middle
We already know what
we are going to use

846
00:40:51,776 --> 00:40:53,556 A:middle
to get quantity samples
out of Health Store.

847
00:40:53,556 --> 00:40:55,816 A:middle
Let's write a sample query.

848
00:40:55,816 --> 00:41:00,866 A:middle
The sample type I'm interested
in is that of dietary calories

849

850
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

851
00:40:55,816 --> 00:41:00,866 A:middle
The sample type I'm interested
in is that of dietary calories

852
00:41:00,866 --> 00:41:03,186 A:middle
because that's what
I saved it in as.

853
00:41:04,436 --> 00:41:07,786 A:middle
Now, in this case, I want
to filter samples out

854
00:41:07,786 --> 00:41:10,786 A:middle
and get only those samples that
were inserted in for today.

855
00:41:11,056 --> 00:41:13,756 A:middle
So I'll have a predicate with
a start date and an end date

856
00:41:13,756 --> 00:41:17,786 A:middle
and start date and
end date will be start

857
00:41:17,786 --> 00:41:19,276 A:middle
of today and end of today.

858
00:41:20,416 --> 00:41:23,096 A:middle
Now I don't really care about
the number of samples as long

859
00:41:23,096 --> 00:41:25,396 A:middle
as I get all of them back
and I don't want to sort them

860
00:41:25,396 --> 00:41:26,766 A:middle
so I'm going to specify
nil here.

861
00:41:28,036 --> 00:41:30,186 A:middle
Again, when this query returns,

862
00:41:30,316 --> 00:41:33,316 A:middle
I'm going to get all the
quantity samples back

863
00:41:33,316 --> 00:41:36,196 A:middle
and what I want to do is
retrieve relevant information

864
00:41:36,196 --> 00:41:37,576 A:middle
from each quantity sample,

865
00:41:37,916 --> 00:41:40,336 A:middle
which in our case will
be the food item's name

866
00:41:40,336 --> 00:41:42,756 A:middle
and calorie information
and I'm going

867
00:41:42,756 --> 00:41:44,636 A:middle
to package that into an array.

868
00:41:45,296 --> 00:41:47,406 A:middle
So that's what this
code does here.

869
00:41:47,406 --> 00:41:50,026 A:middle
Notice here that I get back
the calorie information

870
00:41:50,026 --> 00:41:51,636 A:middle
and the calorie name.

871
00:41:51,846 --> 00:41:55,806 A:middle
I put that into this array and
once I have the array I'm going

872
00:41:55,806 --> 00:41:57,566 A:middle
to switch back to the main
queue and send it back

873
00:41:57,566 --> 00:41:59,026 A:middle
in the completion block.

874

875
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

876
00:42:01,256 --> 00:42:03,166 A:middle
As always, let's not forget

877
00:42:03,166 --> 00:42:08,856 A:middle
to execute the query once
we have written a query.

878
00:42:09,566 --> 00:42:13,176 A:middle
Let's see whether this works.

879
00:42:13,436 --> 00:42:17,356 A:middle
So I had oatmeal.

880
00:42:17,356 --> 00:42:20,846 A:middle
Yay, that worked and bananas.

881
00:42:21,356 --> 00:42:24,846 A:middle
So, now that we have entered
these details we can actually go

882
00:42:24,846 --> 00:42:26,786 A:middle
ahead and compute
net energy burn.

883
00:42:27,406 --> 00:42:29,346 A:middle
So we're going to
define net energy burn

884
00:42:29,346 --> 00:42:32,906 A:middle
as total energy burn subtracted
by the total energy consumed.

885
00:42:33,096 --> 00:42:38,466 A:middle
So ideally the total here would
be this total energy consumed

886
00:42:39,036 --> 00:42:41,346 A:middle
but what about the
total energy burn?

887
00:42:41,346 --> 00:42:44,856 A:middle
So let's assume now that I'm
wearing this imaginary fitness

888
00:42:44,856 --> 00:42:47,806 A:middle
tracker device here and
every time I sync my iPhone

889
00:42:47,806 --> 00:42:51,996 A:middle
with this fitness tracker device
it inserts active energy burn

890
00:42:51,996 --> 00:42:53,056 A:middle
samples into Health Store.

891
00:42:54,336 --> 00:42:57,076 A:middle
So, let's write code to
actually get the total of all

892
00:42:57,076 --> 00:42:57,936 A:middle
of these quantity samples.

893

894
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

895
00:43:03,656 --> 00:43:06,706 A:middle
Now I could write a sample query
get all the quantity samples

896
00:43:06,706 --> 00:43:09,346 A:middle
that I'm interested in and
then iteratively go over it

897
00:43:09,346 --> 00:43:12,066 A:middle
and compute the values,
but really what I want

898
00:43:12,066 --> 00:43:13,716 A:middle
to do here is use
a statistics query

899
00:43:13,716 --> 00:43:15,126 A:middle
because that's what
this is meant to do.

900
00:43:15,716 --> 00:43:19,546 A:middle
So as always let's have
a convenience method

901
00:43:19,546 --> 00:43:22,426 A:middle
and let's write our
first statistics query.

902
00:43:22,996 --> 00:43:26,356 A:middle
The quantity type that I'm
interested in will be passed

903
00:43:26,356 --> 00:43:29,866 A:middle
into this method and, again,

904
00:43:29,936 --> 00:43:33,396 A:middle
the predicate will be filtering
based on start date and end date

905
00:43:33,396 --> 00:43:36,826 A:middle
because I'm interested only
in samples that are relevant

906
00:43:36,826 --> 00:43:40,516 A:middle
for today and start date and
end date are going to be start

907
00:43:40,516 --> 00:43:41,806 A:middle
of today and end of today.

908
00:43:43,386 --> 00:43:45,236 A:middle
This is interesting part here.

909
00:43:45,236 --> 00:43:48,086 A:middle
I'm going to specify cumulative
sum because that's the quantity

910
00:43:48,086 --> 00:43:52,736 A:middle
that I'm interested in and
when this query returns note

911
00:43:52,736 --> 00:43:55,656 A:middle
that we are going to get
an HKStatistics object back

912
00:43:55,656 --> 00:43:58,766 A:middle
and what I want to do is get
the quantity object associated

913
00:43:58,766 --> 00:44:01,116 A:middle
with this statistics object
back and pass it along.

914

915
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

916
00:43:58,766 --> 00:44:01,116 A:middle
with this statistics object
back and pass it along.

917
00:44:01,816 --> 00:44:09,516 A:middle
So I do that and let's not
forget to execute the query.

918
00:44:09,686 --> 00:44:13,826 A:middle
Now let's actually get the total
energy consumed with this query.

919
00:44:13,826 --> 00:44:15,916 A:middle
So let's call the convenience
method that we just wrote

920
00:44:16,566 --> 00:44:20,116 A:middle
and the energy type that
I'm interested in is

921
00:44:20,116 --> 00:44:25,056 A:middle
that of dietary calories because
that's what I saved it as.

922
00:44:25,286 --> 00:44:27,676 A:middle
Finally when I get
the quantity back,

923
00:44:28,806 --> 00:44:31,576 A:middle
I know that I want the
unit as kilocalorie unit.

924
00:44:32,976 --> 00:44:37,296 A:middle
As always, let's switch back to
the main queue and return this.

925
00:44:37,516 --> 00:44:39,966 A:middle
Now I've already set up
code to do the exact same

926
00:44:39,966 --> 00:44:42,086 A:middle
for active energy burn
samples that were inserted

927
00:44:42,086 --> 00:44:44,256 A:middle
by my fitness tracker device.

928
00:44:45,676 --> 00:44:48,156 A:middle
The only difference here
is that of the data type,

929
00:44:48,156 --> 00:44:49,976 A:middle
which will now be
active energy burn.

930
00:44:49,976 --> 00:44:53,236 A:middle
Now let's see whether
this works.

931
00:44:53,236 --> 00:45:02,136 A:middle
Okay. I should see 255
calories here and that works

932

933
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

934
00:44:53,236 --> 00:45:02,136 A:middle
Okay. I should see 255
calories here and that works

935
00:45:02,206 --> 00:45:04,176 A:middle
and now let's see
whether syncing works

936
00:45:04,176 --> 00:45:07,406 A:middle
and so I actually get my net
energy burn and there I'm

937
00:45:07,406 --> 00:45:09,206 A:middle
on track with my
net energy burned

938
00:45:09,206 --> 00:45:11,166 A:middle
and that was my quick demo.

939
00:45:11,496 --> 00:45:13,746 A:middle
So we saw in less than
10 minutes how we manage

940
00:45:13,746 --> 00:45:15,786 A:middle
to integrate HealthKit
with our app.

941
00:45:15,786 --> 00:45:17,756 A:middle
I hope you guys enjoyed it.

942
00:45:17,886 --> 00:45:21,966 A:middle
So the sample code for this
demo is already uploaded online.

943
00:45:21,966 --> 00:45:23,926 A:middle
Please come to our labs if
you have any more questions.

944
00:45:24,436 --> 00:45:25,696 A:middle
Over to Justin.

945
00:45:26,516 --> 00:45:32,826 A:middle
[ Applause ]

946
00:45:33,326 --> 00:45:34,206 A:middle
>> Thanks so much, Siji.

947
00:45:35,266 --> 00:45:38,256 A:middle
As you all can see, it's really
easy to incorporate HealthKit

948
00:45:38,346 --> 00:45:39,616 A:middle
into your own applications.

949
00:45:39,766 --> 00:45:42,896 A:middle
Next we're going to talk through
some HealthKit best practices.

950
00:45:43,636 --> 00:45:47,176 A:middle
So, before you can use HealthKit
the first thing you need

951
00:45:47,176 --> 00:45:50,236 A:middle
to do is let us know that
you intend to use it.

952
00:45:51,146 --> 00:45:53,786 A:middle
To support this, we've
built HealthKit right

953
00:45:53,786 --> 00:45:57,676 A:middle
in the capabilities pane of
Xcode so that you can manage it

954
00:45:57,676 --> 00:45:59,916 A:middle
in the same way you're
used to managing things

955

956
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

957
00:46:00,006 --> 00:46:03,626 A:middle
like Game Center or Passbook.

958
00:46:04,216 --> 00:46:07,756 A:middle
Once you've given your app the
HealthKit capability the last

959
00:46:07,756 --> 00:46:10,126 A:middle
thing you need is
permission from the user

960
00:46:10,126 --> 00:46:11,476 A:middle
to access their health data,

961
00:46:12,406 --> 00:46:16,226 A:middle
but remember health
data is really sensitive

962
00:46:16,396 --> 00:46:17,766 A:middle
to many of our users.

963
00:46:18,646 --> 00:46:21,856 A:middle
We want to encourage our
users to only give apps access

964
00:46:21,936 --> 00:46:24,476 A:middle
to the information that they
feel comfortable sharing.

965
00:46:25,406 --> 00:46:28,496 A:middle
To support this we let users
give your app permission

966
00:46:28,546 --> 00:46:30,636 A:middle
on a per object type basis.

967
00:46:31,926 --> 00:46:35,736 A:middle
That way if the only thing your
application needs is step data,

968
00:46:36,136 --> 00:46:37,586 A:middle
they don't need to
give it access

969
00:46:37,626 --> 00:46:41,166 A:middle
to what may be more
sensitive kinds of data.

970
00:46:41,856 --> 00:46:44,656 A:middle
We also let them give
your apps separate read

971
00:46:44,656 --> 00:46:48,206 A:middle
and write permissions
per object type.

972
00:46:48,386 --> 00:46:50,196 A:middle
A user might be totally fine

973
00:46:50,196 --> 00:46:52,816 A:middle
with your application
saving data to HealthKit

974
00:46:53,376 --> 00:46:56,606 A:middle
but not want it reading data
that came from other sources.

975
00:46:58,256 --> 00:47:00,726 A:middle
To request access
for a set of types,

976

977
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

978
00:46:58,256 --> 00:47:00,726 A:middle
To request access
for a set of types,

979
00:47:00,956 --> 00:47:06,386 A:middle
you can use HKHealthStore's
request to authorization

980
00:47:06,646 --> 00:47:09,386 A:middle
to share types, read
types, completion.

981
00:47:10,756 --> 00:47:13,256 A:middle
They should be called
before you start interacting

982
00:47:13,256 --> 00:47:15,566 A:middle
with your Health Store
so that you can ensure

983
00:47:15,566 --> 00:47:20,326 A:middle
that the user has been given a
chance to grant your app access.

984
00:47:21,086 --> 00:47:25,016 A:middle
Once you ask for authorization
to a new type the user is going

985
00:47:25,016 --> 00:47:27,506 A:middle
to be presented with
this authorization sheet.

986
00:47:28,006 --> 00:47:30,716 A:middle
This is a little bit different

987
00:47:30,756 --> 00:47:33,866 A:middle
than the authorization alert
you may be used to seeing

988
00:47:33,916 --> 00:47:34,956 A:middle
from other frameworks.

989
00:47:35,456 --> 00:47:38,026 A:middle
This is specially designed

990
00:47:38,026 --> 00:47:40,526 A:middle
so that the user can
manage multiple permissions

991
00:47:40,606 --> 00:47:42,866 A:middle
for your application
at the same time.

992
00:47:43,976 --> 00:47:46,596 A:middle
To give your user the
best experience possible,

993
00:47:46,596 --> 00:47:50,206 A:middle
you should request authorization
for all types you intend

994
00:47:50,206 --> 00:47:53,946 A:middle
to use at the same time.

995
00:47:54,156 --> 00:47:56,566 A:middle
Once you've requested
authorization the next thing

996
00:47:56,566 --> 00:47:59,216 A:middle
you're probably going
to want to do is check

997
00:47:59,216 --> 00:48:00,556 A:middle
if you've been granted access.

998

999
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1000
00:47:59,216 --> 00:48:00,556 A:middle
if you've been granted access.

1001
00:48:01,946 --> 00:48:04,796 A:middle
In HealthKit, we let you see
whether you've been granted

1002
00:48:04,906 --> 00:48:07,996 A:middle
sharing or write access
to a particular type,

1003
00:48:09,016 --> 00:48:11,416 A:middle
but you can't see if you've
been granted read access.

1004
00:48:12,706 --> 00:48:15,776 A:middle
This is because for some
kinds of information knowing

1005
00:48:15,776 --> 00:48:19,276 A:middle
that the user blocked your
app can be just as private

1006
00:48:19,316 --> 00:48:21,806 A:middle
as knowing the data itself.

1007
00:48:22,766 --> 00:48:25,496 A:middle
For example, if a user
were to block your app

1008
00:48:25,496 --> 00:48:28,386 A:middle
from reading their blood
sugar, it might indicate

1009
00:48:28,386 --> 00:48:30,406 A:middle
that they're diabetic
and we don't want

1010
00:48:30,406 --> 00:48:31,456 A:middle
to leak this information.

1011
00:48:32,016 --> 00:48:35,526 A:middle
You can check your
authorization status

1012
00:48:35,606 --> 00:48:39,316 A:middle
for a particular type using
HKHealthStore's authorization

1013
00:48:39,316 --> 00:48:44,816 A:middle
status for type.

1014
00:48:44,816 --> 00:48:46,946 A:middle
Our users are spread
all around the world.

1015
00:48:47,926 --> 00:48:51,176 A:middle
To be able to reach all of these
people it's really important

1016
00:48:51,176 --> 00:48:53,286 A:middle
that your app supports
localization.

1017
00:48:54,516 --> 00:48:57,566 A:middle
Foundation already has
a set of NSFormatters

1018
00:48:58,196 --> 00:49:00,596 A:middle
that let you localize
things such as numbers,

1019

1020
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1021
00:48:58,196 --> 00:49:00,596 A:middle
that let you localize
things such as numbers,

1022
00:49:00,776 --> 00:49:02,136 A:middle
dates and even by count.

1023
00:49:03,446 --> 00:49:07,446 A:middle
You could use a number formatter
to localize a quantity's value

1024
00:49:07,446 --> 00:49:10,306 A:middle
but you'd have to
localize the unit yourself.

1025
00:49:11,486 --> 00:49:15,296 A:middle
To help you localize some
kinds of the data that we keep

1026
00:49:15,296 --> 00:49:18,396 A:middle
in HealthKit, we've added
3 brand new formatters

1027
00:49:18,396 --> 00:49:22,416 A:middle
to foundation; NSMassFormatter,
NSLengthFormatter

1028
00:49:22,416 --> 00:49:23,916 A:middle
and NSEnergyFormatter.

1029
00:49:25,236 --> 00:49:27,886 A:middle
These let you display
things such as weight,

1030
00:49:27,886 --> 00:49:30,406 A:middle
energy and distance in
a way that's pertinent

1031
00:49:30,406 --> 00:49:32,456 A:middle
to the user's current locale.

1032
00:49:33,316 --> 00:49:36,106 A:middle
Let's take a look at how you
might use NSMassFormatter.

1033
00:49:37,516 --> 00:49:41,986 A:middle
First, we create our formatter
and we tell it that it's

1034
00:49:41,986 --> 00:49:44,096 A:middle
to be used for person mass.

1035
00:49:44,496 --> 00:49:47,316 A:middle
This is pretty important because
depending on your region,

1036
00:49:47,616 --> 00:49:50,206 A:middle
you might use a different
unit to measure the weight

1037
00:49:50,206 --> 00:49:55,116 A:middle
of a person than you would to
measure the weight of an object.

1038
00:49:55,276 --> 00:49:56,856 A:middle
Next we create our quantity

1039
00:49:56,856 --> 00:49:59,196 A:middle
and get its double
value in kilograms.

1040
00:49:59,716 --> 00:50:04,066 A:middle
We then pass this weight in
kilograms to our formatter

1041

1042
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1043
00:49:59,716 --> 00:50:04,066 A:middle
We then pass this weight in
kilograms to our formatter

1044
00:50:04,326 --> 00:50:06,956 A:middle
and it gives us a localized
string including the

1045
00:50:06,956 --> 00:50:07,586 A:middle
unit string.

1046
00:50:08,806 --> 00:50:11,796 A:middle
Note that our formatter
explicitly takes its value

1047
00:50:11,796 --> 00:50:12,646 A:middle
in kilograms.

1048
00:50:13,296 --> 00:50:15,406 A:middle
Behind the scenes it
will convert this value

1049
00:50:15,546 --> 00:50:16,426 A:middle
to the proper unit.

1050
00:50:18,196 --> 00:50:22,326 A:middle
This works great if all you're
doing is putting a value

1051
00:50:22,326 --> 00:50:25,206 A:middle
in a label but often
times you need to know

1052
00:50:25,206 --> 00:50:28,106 A:middle
which unit was actually used.

1053
00:50:28,726 --> 00:50:33,176 A:middle
To support this you can pass an
NS mass formatter unit pointer

1054
00:50:33,726 --> 00:50:35,736 A:middle
to your formatter
and it will be filled

1055
00:50:35,736 --> 00:50:38,086 A:middle
with whatever unit was
used by the formatter.

1056
00:50:38,086 --> 00:50:44,536 A:middle
So, we've talked about
a lot of stuff today.

1057
00:50:45,736 --> 00:50:47,826 A:middle
What I really want you
to take away from this is

1058
00:50:47,826 --> 00:50:50,876 A:middle
that HealthKit makes it
easy for you to store

1059
00:50:50,876 --> 00:50:52,026 A:middle
and share health data

1060
00:50:52,766 --> 00:50:55,576 A:middle
which means you can spend your
time doing what you do best

1061
00:50:56,556 --> 00:50:58,916 A:middle
keeping our users
happy and healthy.

1062

1063
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1064
00:51:01,236 --> 00:51:04,226 A:middle
Before you go there's one thing
that I would love for all of you

1065
00:51:04,226 --> 00:51:05,606 A:middle
to do after this session.

1066
00:51:06,766 --> 00:51:10,386 A:middle
Try out HealthKit for yourself,
see what you can make with it.

1067
00:51:11,376 --> 00:51:14,426 A:middle
Check out our sample code so
you can see some examples of how

1068
00:51:14,426 --> 00:51:15,976 A:middle
to properly use HealthKit.

1069
00:51:17,036 --> 00:51:19,246 A:middle
For more information
you can reach out to one

1070
00:51:19,246 --> 00:51:22,596 A:middle
of our awesome evangelists Dave
DeLong or David Harrington.

1071
00:51:23,556 --> 00:51:27,376 A:middle
Our sample code is already
available on developer.apple.com

1072
00:51:27,846 --> 00:51:29,586 A:middle
and we encourage
you to ask questions

1073
00:51:29,646 --> 00:51:31,276 A:middle
on our Apple Developer forums.

1074
00:51:32,736 --> 00:51:35,926 A:middle
We have one related
session, which unfortunately,

1075
00:51:36,066 --> 00:51:38,496 A:middle
has already passed, but
you should totally check it

1076
00:51:38,496 --> 00:51:41,336 A:middle
out online and it has
some great information

1077
00:51:41,336 --> 00:51:44,676 A:middle
on how Bluetooth devices are
integrated right into HealthKit.

1078
00:51:45,616 --> 00:51:48,976 A:middle
Thank you and everybody
have a fantastic WWDC.

1079
00:51:49,516 --> 00:51:54,500 A:middle
[ Applause ]

1080
