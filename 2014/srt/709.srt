X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:11,216 --> 00:00:11,726 A:middle
>> Good morning.

2
00:00:12,806 --> 00:00:17,546 A:middle
Welcome to Session 709, "Cross
Platform Nearby Networking".

3
00:00:19,226 --> 00:00:21,766 A:middle
My name is Demijan, and
I'm a Software Engineer

4
00:00:21,826 --> 00:00:23,896 A:middle
in the Real-time
Networking Team at Apple.

5
00:00:24,566 --> 00:00:28,196 A:middle
Last year we introduced a new
framework called Multipeer

6
00:00:28,196 --> 00:00:31,406 A:middle
Connectivity in iOS,
which makes it really,

7
00:00:31,406 --> 00:00:36,186 A:middle
really easy to discover and
communicate with nearby devices.

8
00:00:37,306 --> 00:00:42,186 A:middle
Building a network with nearby
devices can be accomplished

9
00:00:42,496 --> 00:00:44,266 A:middle
with only a few lines of code.

10
00:00:45,036 --> 00:00:48,956 A:middle
Many, many apps have decided
to adopt Multipeer Connectivity

11
00:00:49,216 --> 00:00:51,106 A:middle
for their nearby
networking needs.

12
00:00:51,966 --> 00:00:55,376 A:middle
And some of the use cases we've
seen have really made us smile,

13
00:00:55,906 --> 00:00:58,266 A:middle
so I'd like to mention
some of them to you today.

14
00:00:59,846 --> 00:01:05,686 A:middle
First, iTranslate Voice:
iTranslate Voice is an app

15

16
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

17
00:00:59,846 --> 00:01:05,686 A:middle
First, iTranslate Voice:
iTranslate Voice is an app

18
00:01:06,426 --> 00:01:09,676 A:middle
that brings real-time
translation to iOS users.

19
00:01:11,556 --> 00:01:13,526 A:middle
They use Multipeer Connectivity

20
00:01:13,766 --> 00:01:17,486 A:middle
to connect multiple devices
together and enable people

21
00:01:17,486 --> 00:01:19,546 A:middle
who don't share a
common language

22
00:01:19,806 --> 00:01:22,216 A:middle
to communicate with each other.

23
00:01:22,216 --> 00:01:25,986 A:middle
One person speaks a
sentence into their device

24
00:01:25,986 --> 00:01:31,176 A:middle
in their language, and the other
person hears the translation

25
00:01:31,176 --> 00:01:33,426 A:middle
of that sentence on
the other device.

26
00:01:34,206 --> 00:01:36,936 A:middle
It's really, really cool.

27
00:01:37,276 --> 00:01:40,466 A:middle
Second example is an app
called Metronome Touch.

28
00:01:41,316 --> 00:01:45,036 A:middle
Metronome Touch synchronizes
multiple metronomes,

29
00:01:45,606 --> 00:01:50,406 A:middle
and a metronome is a tool
that musicians use to play

30
00:01:50,406 --> 00:01:53,316 A:middle
to the same beat or
follow the same tempo.

31
00:01:54,686 --> 00:01:58,256 A:middle
Now Metronome Touch uses
Multipeer Connectivity

32
00:01:58,526 --> 00:02:01,746 A:middle
to accurately synchronize
multiple iOS devices

33

34
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

35
00:01:58,526 --> 00:02:01,746 A:middle
to accurately synchronize
multiple iOS devices

36
00:02:02,196 --> 00:02:06,266 A:middle
so that the metronome on each
device ticks in perfect sync.

37
00:02:06,876 --> 00:02:13,946 A:middle
And, third, FireChat,
FireChat brings nearby chatting

38
00:02:14,186 --> 00:02:15,176 A:middle
to our customers.

39
00:02:15,886 --> 00:02:20,146 A:middle
People who are nearby can now
communicate with each other even

40
00:02:20,146 --> 00:02:22,186 A:middle
when there is no internet
connection available.

41
00:02:23,036 --> 00:02:25,806 A:middle
This type of application
can be particularly useful

42
00:02:26,046 --> 00:02:29,346 A:middle
in environments, like subway
stations or airplanes,

43
00:02:29,346 --> 00:02:31,726 A:middle
for example, but
also in countries

44
00:02:32,036 --> 00:02:33,686 A:middle
with limited internet access.

45
00:02:34,556 --> 00:02:38,156 A:middle
We've seen many other use cases
for Multipeer Connectivity

46
00:02:38,376 --> 00:02:41,246 A:middle
and some of the prevalent ones
have been to exchange data,

47
00:02:41,706 --> 00:02:44,656 A:middle
such as files, and to
to-do lists for example,

48
00:02:45,116 --> 00:02:47,136 A:middle
and remote control
functionality.

49
00:02:48,426 --> 00:02:52,256 A:middle
Now throughout the year we've
heard a lot of good feedback

50
00:02:52,256 --> 00:02:54,706 A:middle
from you guys and we've
heard a lot of good ideas,

51
00:02:55,396 --> 00:02:59,526 A:middle
but one request that has come
up over and over again has been

52
00:02:59,526 --> 00:03:02,356 A:middle
to bring Multipeer
Connectivity to the Mac.

53

54
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

55
00:02:59,526 --> 00:03:02,356 A:middle
to bring Multipeer
Connectivity to the Mac.

56
00:03:03,706 --> 00:03:06,396 A:middle
So this year I'm
really happy to announce

57
00:03:06,716 --> 00:03:08,976 A:middle
that we're bringing
Multipeer Connectivity

58
00:03:09,276 --> 00:03:11,946 A:middle
to OS X starting with Yosemite.

59
00:03:12,416 --> 00:03:14,826 A:middle
From now on you will be able

60
00:03:14,826 --> 00:03:19,826 A:middle
to do cross-platform nearby
networking between iOS

61
00:03:19,826 --> 00:03:24,166 A:middle
and OS X devices just as easily
as you have been so far on iOS.

62
00:03:25,956 --> 00:03:28,476 A:middle
And the API is exactly the same,

63
00:03:28,786 --> 00:03:32,486 A:middle
so you should be
ready in no time.

64
00:03:32,526 --> 00:03:35,496 A:middle
All right, so let's talk
about the agenda for today.

65
00:03:36,516 --> 00:03:40,416 A:middle
First, I want to talk about
some basics so we set the stage

66
00:03:40,416 --> 00:03:41,446 A:middle
for the rest of the talk.

67
00:03:42,366 --> 00:03:45,786 A:middle
Then I will talk about
Multipeer Connectivity on OS X,

68
00:03:46,406 --> 00:03:50,656 A:middle
where I'll focus on some of
the specifics that are true

69
00:03:50,656 --> 00:03:54,636 A:middle
for development on OS X and
for the OS X experience.

70
00:03:55,786 --> 00:03:58,486 A:middle
Next, I will talk about
a few best practices.

71
00:03:59,326 --> 00:04:03,106 A:middle
And, finally, I'd like to cover
a few more advanced topics,

72

73
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

74
00:03:59,326 --> 00:04:03,106 A:middle
And, finally, I'd like to cover
a few more advanced topics,

75
00:04:03,426 --> 00:04:06,566 A:middle
namely custom discovery
and authentication.

76
00:04:08,516 --> 00:04:10,646 A:middle
So let's start with the basics.

77
00:04:11,396 --> 00:04:15,446 A:middle
Multipeer Connectivity supports
three wireless technologies

78
00:04:15,446 --> 00:04:21,696 A:middle
on iOS-Bluetooth, Infrastructure
Wi-Fi, and Peer-to-Peer Wi-Fi.

79
00:04:22,736 --> 00:04:28,466 A:middle
On OS X we will support
Ethernet, Infrastructure Wi-Fi,

80
00:04:29,016 --> 00:04:30,896 A:middle
and Peer-to-Peer Wi-Fi, as well.

81
00:04:32,136 --> 00:04:35,426 A:middle
So I'd like to talk about
Peer-to-Peer Wi-Fi for a moment.

82
00:04:35,936 --> 00:04:39,506 A:middle
Peer-to-Peer Wi-Fi
enables you to communicate

83
00:04:39,506 --> 00:04:42,786 A:middle
with other nearby devices
even if they're not connected

84
00:04:42,786 --> 00:04:46,216 A:middle
to the same access point,
or if they're not connected

85
00:04:46,216 --> 00:04:47,386 A:middle
to an access point at all.

86
00:04:48,616 --> 00:04:50,186 A:middle
So, many of you have wondered

87
00:04:50,186 --> 00:04:52,666 A:middle
which devices support
Peer-to-Peer networking.

88
00:04:53,006 --> 00:04:55,556 A:middle
So I'd like to talk
about that a bit.

89
00:04:55,936 --> 00:04:57,916 A:middle
Well, on iOS it's pretty simple.

90
00:04:58,446 --> 00:05:02,776 A:middle
If your iOS device has the new
Lightning Connector then it

91

92
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

93
00:04:58,446 --> 00:05:02,776 A:middle
If your iOS device has the new
Lightning Connector then it

94
00:05:02,776 --> 00:05:04,486 A:middle
supports Peer-to-Peer Wi-Fi.

95
00:05:04,946 --> 00:05:08,376 A:middle
If it doesn't, it won't
support Peer-to-Peer Wi-Fi,

96
00:05:08,866 --> 00:05:11,376 A:middle
but on those devices you
can still use Bluetooth

97
00:05:11,726 --> 00:05:13,046 A:middle
and Infrastructure Wi-Fi.

98
00:05:14,276 --> 00:05:17,256 A:middle
For Macs, the story
is also pretty simple.

99
00:05:17,536 --> 00:05:21,106 A:middle
If you have a Mac that
was released in 2012

100
00:05:21,476 --> 00:05:25,826 A:middle
or later then it will have
support for Peer-to-Peer Wi-Fi.

101
00:05:27,016 --> 00:05:30,446 A:middle
Okay, so let's establish
some terminology

102
00:05:30,446 --> 00:05:32,246 A:middle
that we will use throughout
the rest of the talk.

103
00:05:32,596 --> 00:05:37,326 A:middle
First, nearby, by nearby I
will mean anything that is

104
00:05:37,326 --> 00:05:40,146 A:middle
within the range of supported
wireless technologies.

105
00:05:40,996 --> 00:05:44,776 A:middle
A peer, a peer will be a device,

106
00:05:44,826 --> 00:05:47,236 A:middle
either our own or
a nearby device.

107
00:05:48,696 --> 00:05:52,586 A:middle
An advertiser will be a device
that makes itself discoverable

108
00:05:52,586 --> 00:05:54,096 A:middle
to other devices nearby.

109
00:05:55,226 --> 00:05:58,546 A:middle
And the browser will be a
device that is searching

110
00:05:58,616 --> 00:06:01,266 A:middle
or discovering other
nearby devices.

111

112
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

113
00:05:58,616 --> 00:06:01,266 A:middle
or discovering other
nearby devices.

114
00:06:02,566 --> 00:06:05,476 A:middle
Multipeer Connectivity
happens in two phases.

115
00:06:06,206 --> 00:06:08,036 A:middle
First, the discovery phase,

116
00:06:08,976 --> 00:06:10,946 A:middle
where the devices
discover each other

117
00:06:11,226 --> 00:06:13,216 A:middle
and establish a communication
session

118
00:06:13,216 --> 00:06:15,126 A:middle
by sending invitations
to each other.

119
00:06:16,096 --> 00:06:19,916 A:middle
Then when they're connected into
a session, the second phase,

120
00:06:19,916 --> 00:06:21,636 A:middle
called the session
phase, begins,

121
00:06:21,926 --> 00:06:23,696 A:middle
where they can exchange
data with each other.

122
00:06:24,726 --> 00:06:27,446 A:middle
So let's start with
the discovery phase.

123
00:06:28,436 --> 00:06:30,766 A:middle
The first approach
to discovery phase

124
00:06:30,766 --> 00:06:34,536 A:middle
that we support is UI-based
and it's the most simple one.

125
00:06:36,056 --> 00:06:39,916 A:middle
We have a browser
and an advertiser.

126
00:06:40,976 --> 00:06:44,776 A:middle
An advertiser has to
instantiate a peer ID object,

127
00:06:45,226 --> 00:06:48,696 A:middle
a session object, and an
advertiser assistant object.

128
00:06:49,326 --> 00:06:51,736 A:middle
It then starts by
calling the start method.

129
00:06:53,326 --> 00:06:56,426 A:middle
The browser similarly
instantiates a peer ID,

130
00:06:56,946 --> 00:06:59,376 A:middle
a session, and the
browser view controller.

131

132
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

133
00:07:00,076 --> 00:07:02,426 A:middle
It then presents the
browser view controller

134
00:07:02,426 --> 00:07:04,586 A:middle
to the user to start browsing.

135
00:07:05,786 --> 00:07:09,066 A:middle
The rest of the process will
be entirely user-driven,

136
00:07:09,366 --> 00:07:12,816 A:middle
and you will be notified when
the peers connect into a session

137
00:07:13,206 --> 00:07:16,796 A:middle
with the session delegate
method, peer:didChangeState,

138
00:07:17,486 --> 00:07:20,446 A:middle
where the state will be
specified as connected.

139
00:07:20,676 --> 00:07:24,586 A:middle
So that was the UI-based
approach.

140
00:07:25,296 --> 00:07:27,116 A:middle
The programmatic
approach requires you

141
00:07:27,116 --> 00:07:28,386 A:middle
to do a little bit more work,

142
00:07:28,386 --> 00:07:30,646 A:middle
but it gives you much
more flexibility.

143
00:07:31,206 --> 00:07:35,296 A:middle
So, again, we have a
browser and an advertiser.

144
00:07:36,606 --> 00:07:40,646 A:middle
The advertiser instantiates a
nearby service object instead

145
00:07:40,646 --> 00:07:42,306 A:middle
of an advertiser
assistant object.

146
00:07:43,406 --> 00:07:47,526 A:middle
And the browser instantiates a
nearby service browser object

147
00:07:47,526 --> 00:07:49,176 A:middle
instead of the browser
view controller.

148
00:07:50,936 --> 00:07:55,926 A:middle
The browser starts by calling
startBrowsingForPeers method,

149
00:07:56,016 --> 00:08:00,826 A:middle
and the advertiser starts by
calling startAdvertisingPeer.

150

151
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

152
00:07:56,016 --> 00:08:00,826 A:middle
and the advertiser starts by
calling startAdvertisingPeer.

153
00:08:01,306 --> 00:08:03,956 A:middle
So now both of them
are-the browser is browsing,

154
00:08:04,176 --> 00:08:05,846 A:middle
and the advertiser
is advertising.

155
00:08:07,236 --> 00:08:11,346 A:middle
When the browser discovers the
advertiser you will be notified

156
00:08:11,346 --> 00:08:13,656 A:middle
with a delegate method,
foundPeer.

157
00:08:14,446 --> 00:08:18,006 A:middle
At that time the browser
can send an invitation

158
00:08:18,276 --> 00:08:23,426 A:middle
to the advertiser by calling
the invitePeer method.

159
00:08:23,816 --> 00:08:29,526 A:middle
When the browser calls the
invitePeer method an invitation

160
00:08:29,526 --> 00:08:31,386 A:middle
will be sent out
to the advertiser,

161
00:08:31,906 --> 00:08:34,785 A:middle
and when the advertiser receives
the invitation you will be

162
00:08:34,785 --> 00:08:38,226 A:middle
notified with the did receive
invitation from peer method.

163
00:08:38,716 --> 00:08:42,456 A:middle
At that time, the advertiser
has to decide whether it wants

164
00:08:42,456 --> 00:08:46,786 A:middle
to accept or reject
the invitation.

165
00:08:47,216 --> 00:08:49,386 A:middle
And let's say it
accepts the invitation,

166
00:08:50,516 --> 00:08:52,966 A:middle
then a message will be
sent back to the browser,

167
00:08:52,966 --> 00:08:55,296 A:middle
and they will start
connecting into a session.

168
00:08:56,036 --> 00:08:58,576 A:middle
When they connect with
each other, again,

169
00:08:58,926 --> 00:09:00,966 A:middle
you will be notified
with the delegate method,

170

171
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

172
00:08:58,926 --> 00:09:00,966 A:middle
you will be notified
with the delegate method,

173
00:09:01,116 --> 00:09:05,726 A:middle
peer:DidChangeState, where
the state will be specified

174
00:09:06,066 --> 00:09:06,836 A:middle
as connected.

175
00:09:07,406 --> 00:09:11,506 A:middle
So this was the discovery phase.

176
00:09:11,956 --> 00:09:14,156 A:middle
Let's now cover the
session phase.

177
00:09:15,366 --> 00:09:17,136 A:middle
So in the session
phase we assume

178
00:09:17,136 --> 00:09:19,176 A:middle
that the nearby peers
are already connected

179
00:09:19,176 --> 00:09:22,206 A:middle
with each other, and now what
they want to do is they want

180
00:09:22,296 --> 00:09:23,946 A:middle
to exchange data
with each other.

181
00:09:24,086 --> 00:09:29,386 A:middle
Well, Multipeer Connectivity
supports three sets of APIs

182
00:09:29,606 --> 00:09:32,856 A:middle
for exchanging that
data-messages,

183
00:09:33,816 --> 00:09:36,656 A:middle
streaming, and resources.

184
00:09:37,876 --> 00:09:39,356 A:middle
Let's start with messages.

185
00:09:39,966 --> 00:09:45,656 A:middle
A message is a chunk of data
with well-defined boundaries.

186
00:09:45,726 --> 00:09:50,766 A:middle
If you want to send a message
you can use the sendData method,

187
00:09:51,146 --> 00:09:54,746 A:middle
where you will pass the
message as the first parameter,

188
00:09:54,926 --> 00:09:57,326 A:middle
encapsulated in an
NSData object.

189
00:09:58,106 --> 00:10:02,086 A:middle
You will also have to specify
an array of peers that you want

190

191
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

192
00:09:58,106 --> 00:10:02,086 A:middle
You will also have to specify
an array of peers that you want

193
00:10:02,466 --> 00:10:03,906 A:middle
to receive the message.

194
00:10:04,866 --> 00:10:07,316 A:middle
When you receive a message
you will be notified

195
00:10:07,346 --> 00:10:11,016 A:middle
with a delegate method,
didReceiveData, which will pass

196
00:10:11,086 --> 00:10:13,726 A:middle
to you the message
and the sender.

197
00:10:14,116 --> 00:10:18,586 A:middle
Now if you want to send really
large amounts of data or data

198
00:10:18,586 --> 00:10:22,696 A:middle
without well-defined boundaries,
such as a live audio stream,

199
00:10:22,696 --> 00:10:26,276 A:middle
for example, then you might
be better served using our

200
00:10:26,276 --> 00:10:27,366 A:middle
streaming APIs.

201
00:10:28,536 --> 00:10:31,486 A:middle
And to start a stream
you can call the method,

202
00:10:31,486 --> 00:10:35,836 A:middle
startStreamWithName, which
will give you an NSOutputStream

203
00:10:35,836 --> 00:10:39,516 A:middle
object that you can use to
stream data to the recipient.

204
00:10:40,036 --> 00:10:42,866 A:middle
The recipient will be notified

205
00:10:42,866 --> 00:10:44,886 A:middle
where the delegate
method didReceiveStream,

206
00:10:45,256 --> 00:10:48,816 A:middle
and that method will give
it an NSInputStream object

207
00:10:48,886 --> 00:10:54,036 A:middle
that the recipient can use
to receive streaming data.

208
00:10:54,206 --> 00:11:01,136 A:middle
And, third, resources, we
support files and web URLs

209

210
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

211
00:10:54,206 --> 00:11:01,136 A:middle
And, third, resources, we
support files and web URLs

212
00:11:01,136 --> 00:11:04,376 A:middle
to send as resources, and
you can send a resource

213
00:11:04,376 --> 00:11:09,096 A:middle
by using sendResourceAtURL
method, where you specify

214
00:11:09,096 --> 00:11:12,376 A:middle
that the URL method of the
resource you want to send

215
00:11:12,716 --> 00:11:14,906 A:middle
and you specify which peer
you want to send it to.

216
00:11:16,276 --> 00:11:18,176 A:middle
You will also have to pass

217
00:11:18,176 --> 00:11:20,036 A:middle
to the framework a
completion handler,

218
00:11:20,446 --> 00:11:22,716 A:middle
and that completion
handler will be called

219
00:11:22,986 --> 00:11:25,186 A:middle
when the resource has
finished transmitting

220
00:11:25,566 --> 00:11:28,336 A:middle
or if something went wrong
during the transmission.

221
00:11:28,906 --> 00:11:33,316 A:middle
Now the receiver, when it
starts receiving a resource,

222
00:11:33,556 --> 00:11:35,496 A:middle
will be notified with
a delegate method,

223
00:11:35,796 --> 00:11:38,106 A:middle
didStartReceiving
ResourceWithName,

224
00:11:38,956 --> 00:11:42,386 A:middle
and when the resource finishes
being received it will be

225
00:11:42,386 --> 00:11:46,186 A:middle
notified with a delegate method,
didFinishResourceWithName.

226
00:11:47,356 --> 00:11:50,566 A:middle
Okay, so in summary, we've
covered the discovery phase

227
00:11:50,936 --> 00:11:51,946 A:middle
and the session phase.

228
00:11:52,496 --> 00:11:56,166 A:middle
You can do UI-based discovery
or programmatic discovery,

229
00:11:56,166 --> 00:11:57,996 A:middle
which gives you a
bit more flexibility,

230
00:11:58,586 --> 00:12:01,916 A:middle
and in the session phase you
can use APIs to send data

231

232
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

233
00:11:58,586 --> 00:12:01,916 A:middle
and in the session phase you
can use APIs to send data

234
00:12:02,316 --> 00:12:07,586 A:middle
where we support messages,
streaming and resources.

235
00:12:09,066 --> 00:12:13,476 A:middle
Much more in-depth information
about these topics can be seen

236
00:12:13,736 --> 00:12:17,326 A:middle
at our last year's
WWDC presentation,

237
00:12:17,486 --> 00:12:18,596 A:middle
which you can see online.

238
00:12:21,776 --> 00:12:27,226 A:middle
All right, let's proceed with
Multipeer Connectivity on OS X.

239
00:12:28,116 --> 00:12:34,886 A:middle
The good news is that the APIs
on OS X are exactly the same

240
00:12:35,126 --> 00:12:40,726 A:middle
as APIs on iOS, nevertheless,
there are some differences

241
00:12:41,016 --> 00:12:43,846 A:middle
that are different to the
OS X experience and I would

242
00:12:43,846 --> 00:12:47,156 A:middle
like to talk about those now.

243
00:12:47,466 --> 00:12:50,566 A:middle
Let's start with
UI-based discovery.

244
00:12:51,586 --> 00:12:53,596 A:middle
Imagine I have an app.

245
00:12:54,056 --> 00:12:56,186 A:middle
I have a Mac, which
is running an app

246
00:12:56,546 --> 00:12:58,346 A:middle
that uses Multipeer
Connectivity.

247
00:12:58,916 --> 00:13:01,286 A:middle
I want to see if
somebody is around,

248

249
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

250
00:12:58,916 --> 00:13:01,286 A:middle
I want to see if
somebody is around,

251
00:13:01,516 --> 00:13:03,696 A:middle
so I bring up the
browser view controller.

252
00:13:05,116 --> 00:13:08,636 A:middle
The browser's view controller
is presented as a modal sheet,

253
00:13:08,946 --> 00:13:13,276 A:middle
and in the lower left corner you
can see an activity indicator,

254
00:13:13,586 --> 00:13:15,626 A:middle
which indicates to us
that we're browsing.

255
00:13:16,516 --> 00:13:18,056 A:middle
Currently there is
no one nearby.

256
00:13:19,966 --> 00:13:22,746 A:middle
Let's then assume
that Gabe comes nearby

257
00:13:22,846 --> 00:13:24,586 A:middle
and Gabe is also running an app

258
00:13:24,956 --> 00:13:26,666 A:middle
that uses Multipeer
Connectivity.

259
00:13:27,676 --> 00:13:31,306 A:middle
Moments later, we'll see in
our UI that Gabe is nearby,

260
00:13:32,806 --> 00:13:37,606 A:middle
and if I want to invite
Gabe into a session I have

261
00:13:37,656 --> 00:13:40,126 A:middle
to press the Invite
button in the table view.

262
00:13:40,786 --> 00:13:42,926 A:middle
So I go ahead and do that.

263
00:13:43,746 --> 00:13:46,336 A:middle
When I do that, an invitation
will be sent out to Gabe.

264
00:13:46,726 --> 00:13:50,286 A:middle
And when Gabe receives the
invitation, we will present,

265
00:13:50,286 --> 00:13:53,786 A:middle
the framework will present an
alert that will notify Gabe

266
00:13:53,786 --> 00:13:55,856 A:middle
that I want to connect to him.

267
00:13:56,496 --> 00:14:00,476 A:middle
At this time Gabe needs
to decide whether he wants

268

269
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

270
00:13:56,496 --> 00:14:00,476 A:middle
At this time Gabe needs
to decide whether he wants

271
00:14:00,516 --> 00:14:02,456 A:middle
to accept or decline
the invitation.

272
00:14:02,716 --> 00:14:06,016 A:middle
So let's assume Gabe is
game and wants to accept,

273
00:14:06,016 --> 00:14:08,696 A:middle
and accepts the invitation,
so he clicks on Accept.

274
00:14:08,696 --> 00:14:11,286 A:middle
And an accept message
is sent back to me.

275
00:14:11,896 --> 00:14:14,816 A:middle
At that moment we
will start connecting,

276
00:14:14,816 --> 00:14:17,446 A:middle
and when we're finished
connecting it will say

277
00:14:17,446 --> 00:14:21,406 A:middle
so in the UI next to Gabe,
and I will be able to click

278
00:14:21,406 --> 00:14:24,816 A:middle
on the Done button, which
will dismiss the browser view

279
00:14:24,816 --> 00:14:27,706 A:middle
controller, and I
am connected to Gabe

280
00:14:28,026 --> 00:14:31,626 A:middle
and start exchanging
data with him.

281
00:14:32,256 --> 00:14:38,106 A:middle
So this was the flow for
UI discovery on Mac OS X.

282
00:14:38,946 --> 00:14:41,666 A:middle
Let's now see how you can
implement this in code.

283
00:14:42,906 --> 00:14:45,276 A:middle
Now, first, you have to
instantiate an advertiser,

284
00:14:45,516 --> 00:14:47,966 A:middle
and this is done much
the same, like on iOS.

285
00:14:48,456 --> 00:14:51,346 A:middle
First, you instantiate the
advertiser assistant object

286
00:14:51,836 --> 00:14:54,226 A:middle
and you start it.

287
00:14:55,826 --> 00:14:59,546 A:middle
Now for the
MCBrowserViewController on OS X,

288

289
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

290
00:15:00,166 --> 00:15:05,596 A:middle
subclass is NSViewController,
unlike UIViewController in iOS.

291
00:15:06,646 --> 00:15:10,096 A:middle
Note that NSViewController
has seen substantial changes

292
00:15:10,096 --> 00:15:13,446 A:middle
in Yosemite, and you can see
or you can hear much more

293
00:15:13,446 --> 00:15:16,176 A:middle
about those changes in
the session, "Storyboards

294
00:15:16,176 --> 00:15:17,146 A:middle
and View Controllers".

295
00:15:18,246 --> 00:15:21,636 A:middle
So to set up the browser
view controller on OS X,

296
00:15:21,636 --> 00:15:24,856 A:middle
I have to instantiate it, and
I have to set the delegate.

297
00:15:26,346 --> 00:15:29,596 A:middle
Then I have to-then I present
the browser view controller

298
00:15:29,936 --> 00:15:32,666 A:middle
by using one of the new
NSViewController APIs,

299
00:15:33,456 --> 00:15:35,526 A:middle
presentViewControllerAsSheet,

300
00:15:36,266 --> 00:15:39,096 A:middle
and I pass the browser
view controller object.

301
00:15:41,056 --> 00:15:45,416 A:middle
Note that "self" here is a
subclass of an NSViewController.

302
00:15:46,066 --> 00:15:47,926 A:middle
We realize that you might be,

303
00:15:47,926 --> 00:15:52,236 A:middle
that your architecture might not
be based on NSViewControllers,

304
00:15:52,596 --> 00:15:54,126 A:middle
and in that case you might want

305
00:15:54,126 --> 00:15:56,516 A:middle
to present the view
controller using the

306
00:15:56,576 --> 00:15:58,386 A:middle
NSAppBeginSheet method.

307
00:15:59,236 --> 00:16:02,056 A:middle
Well, if you want to do
that you can do that,

308

309
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

310
00:15:59,236 --> 00:16:02,056 A:middle
Well, if you want to do
that you can do that,

311
00:16:02,056 --> 00:16:04,876 A:middle
but first you will have
to get an NSWindow object

312
00:16:05,236 --> 00:16:06,546 A:middle
for the browser view controller.

313
00:16:07,196 --> 00:16:10,496 A:middle
And you can do so by using
one of the new methods

314
00:16:10,496 --> 00:16:14,286 A:middle
on NS window called
windowWithContentViewController.

315
00:16:15,146 --> 00:16:17,816 A:middle
That method will give
you back an NS window

316
00:16:17,966 --> 00:16:21,346 A:middle
for the browser view
controller, and once you have

317
00:16:21,486 --> 00:16:25,706 A:middle
that NSWindow object you
can use the beginSheet API

318
00:16:26,366 --> 00:16:28,776 A:middle
to present the browser view
controller to the user.

319
00:16:29,696 --> 00:16:32,816 A:middle
When the user is done using
the browser, it will click

320
00:16:32,816 --> 00:16:35,186 A:middle
on either Done or Cancel button,

321
00:16:35,386 --> 00:16:39,006 A:middle
and when that happens you will
be notified via the delegate

322
00:16:39,006 --> 00:16:41,926 A:middle
methods,
browserViewControllerDidFinish

323
00:16:42,236 --> 00:16:44,396 A:middle
and browserView
ControllerWasCancelled,

324
00:16:44,396 --> 00:16:45,096 A:middle
respectively.

325
00:16:46,146 --> 00:16:48,806 A:middle
In those methods you'll have
the opportunity to react

326
00:16:48,966 --> 00:16:53,076 A:middle
to whatever action the user
has taken and you will have

327
00:16:53,076 --> 00:16:55,326 A:middle
to dismiss the browser
view controller

328
00:16:55,656 --> 00:16:58,176 A:middle
by using the
dismissViewController method.

329
00:16:58,736 --> 00:17:01,486 A:middle
Next, I want to talk
about entitlements.

330

331
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

332
00:16:58,736 --> 00:17:01,486 A:middle
Next, I want to talk
about entitlements.

333
00:17:02,796 --> 00:17:07,136 A:middle
If you are sandboxed, either
voluntarily or because you ship

334
00:17:07,136 --> 00:17:08,955 A:middle
on the app store you will have

335
00:17:09,026 --> 00:17:11,346 A:middle
to set entitlements
appropriately.

336
00:17:11,925 --> 00:17:15,965 A:middle
Multipeer Connectivity you
need support for both incoming

337
00:17:16,316 --> 00:17:18,915 A:middle
and outgoing connections,
so you'll have

338
00:17:18,976 --> 00:17:21,566 A:middle
to enable entitlements
for these operations.

339
00:17:22,156 --> 00:17:25,226 A:middle
If you don't do that, then
Multipeer Connectivity

340
00:17:25,226 --> 00:17:28,656 A:middle
on OS X just won't work,
so make sure you do that.

341
00:17:29,876 --> 00:17:32,086 A:middle
And that's really
everything that is different.

342
00:17:32,786 --> 00:17:35,196 A:middle
Everything else, like
programmatic discovery

343
00:17:35,466 --> 00:17:41,026 A:middle
and sending data, for instance,
is exactly the same as on iOS,

344
00:17:41,376 --> 00:17:44,406 A:middle
so you should be
ready in no time.

345
00:17:44,826 --> 00:17:47,446 A:middle
Okay, at this point I would
like to invite Eric on stage,

346
00:17:47,446 --> 00:17:48,706 A:middle
who will show you a demo.

347
00:17:49,406 --> 00:17:50,706 A:middle
>> Thanks, good morning,
everyone.

348
00:17:51,016 --> 00:17:53,946 A:middle
My name is Eric, and today I'd
like to show you a quick demo

349
00:17:53,946 --> 00:17:57,976 A:middle
of Multipeer Connectivity,
so let's switch over.

350
00:17:59,456 --> 00:18:02,156 A:middle
Great, so let's say
we're at a party

351

352
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

353
00:17:59,456 --> 00:18:02,156 A:middle
Great, so let's say
we're at a party

354
00:18:02,366 --> 00:18:03,856 A:middle
and everyone is taking photos.

355
00:18:04,196 --> 00:18:06,516 A:middle
It would be really cool if we
could collect all those photos

356
00:18:06,616 --> 00:18:08,816 A:middle
onto a map and display them

357
00:18:08,816 --> 00:18:12,376 A:middle
on a really large screen
for everyone to see.

358
00:18:12,376 --> 00:18:14,296 A:middle
To simulate this
sort of application,

359
00:18:14,626 --> 00:18:17,326 A:middle
today we have two iOS devices.

360
00:18:17,446 --> 00:18:20,286 A:middle
Here I have a white
iPhone and a pink iPhone,

361
00:18:20,816 --> 00:18:22,656 A:middle
and we also have a Mac,

362
00:18:23,216 --> 00:18:25,566 A:middle
and we'll be using
Multipeer Connectivity

363
00:18:25,686 --> 00:18:26,816 A:middle
to connect them together.

364
00:18:27,206 --> 00:18:31,086 A:middle
And whenever the iOS devices
take photos they'll transmit

365
00:18:31,086 --> 00:18:32,296 A:middle
them over to the Mac.

366
00:18:32,736 --> 00:18:34,736 A:middle
So let's take a look
at this in more detail.

367
00:18:35,286 --> 00:18:37,436 A:middle
Over here we have the Mac app,

368
00:18:38,036 --> 00:18:40,896 A:middle
on the left-hand side
we'll have a photo roll,

369
00:18:40,986 --> 00:18:44,406 A:middle
where the new photos will
pop in, and over here

370
00:18:44,406 --> 00:18:46,436 A:middle
on the right-hand side
we'll have a larger view

371
00:18:46,506 --> 00:18:49,056 A:middle
of the latest photo that we got.

372
00:18:49,056 --> 00:18:51,126 A:middle
Down here in the corner we
have a little Browse button.

373
00:18:51,606 --> 00:18:53,166 A:middle
So let's get started.

374
00:18:53,286 --> 00:18:56,166 A:middle
I'll go ahead and click
on the Browse button.

375
00:18:56,346 --> 00:18:58,226 A:middle
So here's the browser
that we saw earlier.

376
00:18:58,796 --> 00:19:00,456 A:middle
Right now it's currently empty.

377

378
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

379
00:18:58,796 --> 00:19:00,456 A:middle
Right now it's currently empty.

380
00:19:00,816 --> 00:19:04,916 A:middle
When I launch the iPhone app
it will start advertising,

381
00:19:05,216 --> 00:19:07,516 A:middle
and the browser will
be able to discover it,

382
00:19:07,516 --> 00:19:08,606 A:middle
and it'll pop up in the list.

383
00:19:09,026 --> 00:19:13,606 A:middle
So I'll go ahead and do
that here, so there it is.

384
00:19:14,026 --> 00:19:19,346 A:middle
And I can go ahead and do
the same on the other iPhone.

385
00:19:19,496 --> 00:19:23,126 A:middle
Great, so now we have
both of the devices.

386
00:19:23,126 --> 00:19:25,616 A:middle
We can go ahead and
invite the white iPhone.

387
00:19:25,806 --> 00:19:28,956 A:middle
Over here I received the
invitation, so I'll go ahead

388
00:19:28,956 --> 00:19:32,276 A:middle
and tap Accept, and we
can see that it connected.

389
00:19:33,086 --> 00:19:36,166 A:middle
I'll do the same for the
pink iPhone, so invite it,

390
00:19:36,476 --> 00:19:37,666 A:middle
and over here I'll accept.

391
00:19:38,816 --> 00:19:42,276 A:middle
Great, so now both of the
devices are connected,

392
00:19:42,336 --> 00:19:44,206 A:middle
we can go ahead and
click on the Done button

393
00:19:44,406 --> 00:19:48,136 A:middle
to dismiss the browser, and we
can start taking some photos.

394
00:19:48,796 --> 00:19:51,746 A:middle
So I'll grab the white
iPhone, and let's see

395
00:19:51,866 --> 00:19:53,976 A:middle
if we can get a shot of
this camera right here.

396
00:19:54,136 --> 00:20:00,676 A:middle
Great, so it's sort of an
antique camera, I guess.

397

398
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

399
00:19:54,136 --> 00:20:00,676 A:middle
Great, so it's sort of an
antique camera, I guess.

400
00:20:00,676 --> 00:20:04,636 A:middle
Let's see that with the
phone, we can compare them.

401
00:20:05,306 --> 00:20:09,976 A:middle
So you can see how far
we've come with the cameras.

402
00:20:09,976 --> 00:20:12,426 A:middle
Here's let me switch over
to the pink iPhone phone,

403
00:20:12,426 --> 00:20:15,856 A:middle
and let me take a picture
of this little rabbit thing.

404
00:20:17,786 --> 00:20:25,116 A:middle
Great, let's see, maybe I can
take one of myself, and then,

405
00:20:26,256 --> 00:20:28,486 A:middle
let's see, we'll switch over.

406
00:20:29,006 --> 00:20:31,796 A:middle
Here's a little thing
of bismuth.

407
00:20:32,696 --> 00:20:38,026 A:middle
Great, okay, so let's see
if we can take a quick look

408
00:20:38,026 --> 00:20:40,286 A:middle
at what the iOS side looks like.

409
00:20:41,996 --> 00:20:46,616 A:middle
Okay, great, now that
was a quick demonstration

410
00:20:46,806 --> 00:20:50,716 A:middle
of cross-platform nearby
networking with Multipeer.

411
00:20:50,716 --> 00:20:53,216 A:middle
So let's talk a little bit
about how I built the demo.

412
00:20:53,216 --> 00:20:57,176 A:middle
On the iOS side, I took a piece
of sample code called AB Cam

413
00:20:57,426 --> 00:20:59,796 A:middle
that teaches you how
to use the camera.

414

415
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

416
00:21:00,296 --> 00:21:02,576 A:middle
Whenever we save
a new still image,

417
00:21:03,036 --> 00:21:05,736 A:middle
all we do is we take
the URL for the new file

418
00:21:05,736 --> 00:21:08,526 A:middle
and we use the sendResource
API we just saw,

419
00:21:08,886 --> 00:21:11,116 A:middle
and that sends it
over to the Mac side.

420
00:21:11,976 --> 00:21:14,866 A:middle
Over here on the Mac
side I took a piece

421
00:21:14,866 --> 00:21:16,486 A:middle
of sample code called
Image Browser

422
00:21:17,116 --> 00:21:18,516 A:middle
and it just teaches you how

423
00:21:18,516 --> 00:21:24,366 A:middle
to display a grid of
images, like this.

424
00:21:24,546 --> 00:21:27,286 A:middle
I added in Multipeer
Connectivity to bring

425
00:21:27,286 --> 00:21:30,806 A:middle
up the browser, and whenever we
receive a new resource we just

426
00:21:30,806 --> 00:21:34,576 A:middle
add that into the image
list's data source array.

427
00:21:35,546 --> 00:21:38,276 A:middle
So if you'd like to
learn more about how

428
00:21:38,276 --> 00:21:39,926 A:middle
to use Multipeer Connectivity

429
00:21:39,926 --> 00:21:41,996 A:middle
in your own apps we
hope you will check

430
00:21:41,996 --> 00:21:43,916 A:middle
out last year's iOS sample code,

431
00:21:44,236 --> 00:21:46,186 A:middle
it's called Multipeer
Group Chat.

432
00:21:46,186 --> 00:21:49,046 A:middle
And we're really looking
forward to seeing what sort

433
00:21:49,046 --> 00:21:51,256 A:middle
of new apps you guys
can come up with.

434
00:21:51,586 --> 00:21:53,376 A:middle
With that, I'd like to
hand it back to Demijan.

435
00:21:53,876 --> 00:21:54,866 A:middle
Thanks, everyone.

436
00:21:55,146 --> 00:21:55,826 A:middle
>> Thank you, Eric.

437
00:21:59,156 --> 00:22:02,726 A:middle
So Multipeer Connectivity
on OS X is much

438

439
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

440
00:21:59,156 --> 00:22:02,726 A:middle
So Multipeer Connectivity
on OS X is much

441
00:22:02,726 --> 00:22:04,936 A:middle
like Multipeer Connectivity
on iOS.

442
00:22:05,786 --> 00:22:10,846 A:middle
In this section we've shown you
the UI-based discovery on OS X,

443
00:22:10,846 --> 00:22:14,176 A:middle
and we've told you which
entitlements you need to enable

444
00:22:14,446 --> 00:22:19,186 A:middle
to make Multipeer
Connectivity work in OS X apps.

445
00:22:19,566 --> 00:22:23,126 A:middle
Next I'd like to talk
about a few best practices

446
00:22:23,506 --> 00:22:26,706 A:middle
that we thought you
guys should be aware of.

447
00:22:27,516 --> 00:22:32,996 A:middle
So let's assume we have two
devices, a Mac and a phone,

448
00:22:33,636 --> 00:22:36,166 A:middle
and let's say the
Mac is advertising

449
00:22:36,926 --> 00:22:38,706 A:middle
and the iPhone is browsing.

450
00:22:40,586 --> 00:22:43,806 A:middle
Moments later the iPhone
will discover the Mac

451
00:22:44,206 --> 00:22:47,716 A:middle
and it will have a reference or
it will have its peerID object.

452
00:22:49,026 --> 00:22:53,656 A:middle
Then let's assume that for
some reason the Mac goes away.

453
00:22:54,656 --> 00:22:57,396 A:middle
For instance, the user
could have closed the lid

454
00:22:57,526 --> 00:23:02,056 A:middle
for some reason or the user
could have reset the system

455

456
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

457
00:22:57,526 --> 00:23:02,056 A:middle
for some reason or the user
could have reset the system

458
00:23:02,056 --> 00:23:03,376 A:middle
because of a software update.

459
00:23:05,476 --> 00:23:11,336 A:middle
When the Mac comes back it will
instantiate a new peerID object

460
00:23:11,336 --> 00:23:15,506 A:middle
and a new advertiser, and
the iPhone will discover it,

461
00:23:15,926 --> 00:23:18,756 A:middle
but it will see a new
object for the peer,

462
00:23:18,896 --> 00:23:22,216 A:middle
which actually corresponds
to the same Mac.

463
00:23:22,636 --> 00:23:27,016 A:middle
So this can lead to many issues
because iPhone doesn't know

464
00:23:27,016 --> 00:23:30,896 A:middle
that these two objects actually
correspond to the same device.

465
00:23:32,246 --> 00:23:35,976 A:middle
So in order to circumvent
that problem, we recommend

466
00:23:36,266 --> 00:23:38,456 A:middle
that you reuse peerID objects.

467
00:23:39,246 --> 00:23:41,736 A:middle
After you've created
a peerID object

468
00:23:41,736 --> 00:23:45,456 A:middle
for the first time you can
store it in the user defaults,

469
00:23:45,896 --> 00:23:48,946 A:middle
so the next time you need it you
don't have to create a new one.

470
00:23:49,496 --> 00:23:53,936 A:middle
So if the Mac, when
it comes back,

471
00:23:53,936 --> 00:23:57,926 A:middle
reuses the first peerID object,
the iPhone won't be confused

472
00:23:57,926 --> 00:24:00,966 A:middle
and it will only have one
object that represents the Mac.

473

474
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

475
00:23:57,926 --> 00:24:00,966 A:middle
and it will only have one
object that represents the Mac.

476
00:24:03,126 --> 00:24:05,396 A:middle
Now let's see how you
guys can do this in code.

477
00:24:06,766 --> 00:24:09,906 A:middle
Once you've instantiated
the peerID object,

478
00:24:09,906 --> 00:24:11,996 A:middle
you'll need to store it
in the user defaults.

479
00:24:12,506 --> 00:24:14,216 A:middle
And to do so, you'll first have

480
00:24:14,266 --> 00:24:16,946 A:middle
to serialize the
peerID object using the

481
00:24:16,946 --> 00:24:19,726 A:middle
archivedDataWithRootObject
method.

482
00:24:20,696 --> 00:24:23,116 A:middle
Once the peer is serialized

483
00:24:23,336 --> 00:24:27,046 A:middle
into an NSData object you can
save it in the user defaults.

484
00:24:27,736 --> 00:24:30,396 A:middle
Later when you need to
de-serialize it and retrieve it

485
00:24:30,396 --> 00:24:32,406 A:middle
from the defaults
you'll first have

486
00:24:32,446 --> 00:24:36,426 A:middle
to de-serialize it using
unarchiveObjectWithData method,

487
00:24:37,026 --> 00:24:40,256 A:middle
and then when you have the
original peerID object you can

488
00:24:40,256 --> 00:24:41,696 A:middle
use it in your application.

489
00:24:42,076 --> 00:24:47,216 A:middle
Next auto inviting, many of
you have made applications

490
00:24:47,496 --> 00:24:51,236 A:middle
that both advertise and
browse at the same time,

491
00:24:51,736 --> 00:24:55,776 A:middle
and when a browser sees an
advertiser it immediately sends

492
00:24:55,776 --> 00:24:56,456 A:middle
an invitation.

493
00:24:56,676 --> 00:24:58,656 A:middle
Basically, what you want
to achieve with this is,

494
00:24:58,656 --> 00:25:01,636 A:middle
if you want to abstract
away the connection process

495

496
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

497
00:24:58,656 --> 00:25:01,636 A:middle
if you want to abstract
away the connection process

498
00:25:01,636 --> 00:25:02,266 A:middle
from the user.

499
00:25:02,526 --> 00:25:05,836 A:middle
As soon as another user is
seen you want the devices

500
00:25:05,906 --> 00:25:06,866 A:middle
to connect to each other.

501
00:25:07,586 --> 00:25:10,126 A:middle
So let's assume we
have a Mac and a phone,

502
00:25:10,666 --> 00:25:12,796 A:middle
and both are browsing
and advertising.

503
00:25:13,706 --> 00:25:15,926 A:middle
So soon they will
discover each other,

504
00:25:15,926 --> 00:25:20,216 A:middle
and they will have a peerID
object of the other peer.

505
00:25:20,476 --> 00:25:23,296 A:middle
But now the question
is who will be the one

506
00:25:23,516 --> 00:25:24,676 A:middle
to send an invitation?

507
00:25:25,226 --> 00:25:27,366 A:middle
And here's where many
of you get confused.

508
00:25:28,796 --> 00:25:33,226 A:middle
So in order to solve this
problem you can use a

509
00:25:33,226 --> 00:25:37,236 A:middle
deterministic algorithm
that will on both sides come

510
00:25:37,236 --> 00:25:40,816 A:middle
to the same result so that
only one peer will be the one

511
00:25:40,816 --> 00:25:41,986 A:middle
to send an invitation.

512
00:25:42,926 --> 00:25:46,736 A:middle
Now there are many ways you
can do that, and one of them is

513
00:25:46,736 --> 00:25:51,076 A:middle
to use peer ID hash
values or hash value

514
00:25:51,076 --> 00:25:52,286 A:middle
of the peer ID object.

515
00:25:52,986 --> 00:25:57,136 A:middle
Since both sides have access to
the same two peer ID objects,

516
00:25:57,576 --> 00:25:59,826 A:middle
they will come to the
same determination as to

517
00:25:59,826 --> 00:26:01,546 A:middle
who has the higher hash value,

518

519
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

520
00:25:59,826 --> 00:26:01,546 A:middle
who has the higher hash value,

521
00:26:02,086 --> 00:26:04,396 A:middle
and only one invitation
will be sent out.

522
00:26:05,876 --> 00:26:09,866 A:middle
Next I want to talk about
discovery info a little bit.

523
00:26:10,636 --> 00:26:14,206 A:middle
Multipeer Connectivity
uses Bonjour underneath

524
00:26:14,366 --> 00:26:19,166 A:middle
for discovery, and you have the
option to set additional data

525
00:26:19,606 --> 00:26:23,496 A:middle
for advertisers when
you instantiate them.

526
00:26:23,886 --> 00:26:27,106 A:middle
Now this additional data
is passed to the framework

527
00:26:27,106 --> 00:26:30,976 A:middle
in the form of an NSDictionary
that we call discoveryInfo,

528
00:26:32,076 --> 00:26:36,096 A:middle
and discoveryInfo is very useful
because it is made available

529
00:26:36,096 --> 00:26:39,396 A:middle
to the browsers when they
discover an advertiser.

530
00:26:40,106 --> 00:26:44,506 A:middle
So first thing I want to advise
is to keep discoveryInfo small,

531
00:26:45,266 --> 00:26:47,936 A:middle
this will make the discovery
experience much better

532
00:26:47,936 --> 00:26:48,816 A:middle
for your users.

533
00:26:50,976 --> 00:26:54,396 A:middle
Next both keys and values

534
00:26:54,486 --> 00:26:57,726 A:middle
in discoveryInfo must
be of type NSString.

535
00:26:58,656 --> 00:27:04,036 A:middle
If any key or any value in the
discoveryInfo dictionary is not

536

537
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

538
00:26:58,656 --> 00:27:04,036 A:middle
If any key or any value in the
discoveryInfo dictionary is not

539
00:27:04,036 --> 00:27:07,816 A:middle
of type NSString, the
framework will complain

540
00:27:07,896 --> 00:27:08,946 A:middle
and throw an exception.

541
00:27:11,406 --> 00:27:14,516 A:middle
Also, you should know
that each key value pair

542
00:27:14,516 --> 00:27:18,856 A:middle
in the discoveryInfo dictionary
underneath gets formatted

543
00:27:19,146 --> 00:27:21,316 A:middle
in a Bonjour text record entry,

544
00:27:22,696 --> 00:27:26,506 A:middle
and each Bonjour text record
entry has a specific format,

545
00:27:26,576 --> 00:27:27,916 A:middle
which is shown in this slide.

546
00:27:28,416 --> 00:27:33,486 A:middle
First the key, followed by an
equal sign, and then the value.

547
00:27:34,846 --> 00:27:40,046 A:middle
Note that each text record
entry is limited to 256 bytes,

548
00:27:40,986 --> 00:27:43,846 A:middle
and if any key-value
pair when formatted

549
00:27:43,846 --> 00:27:47,946 A:middle
as a text record
exceeds 256 bytes,

550
00:27:48,516 --> 00:27:51,216 A:middle
the framework will complain
again and throw an exception.

551
00:27:52,646 --> 00:27:55,276 A:middle
For more details
on Discovery Info

552
00:27:55,276 --> 00:27:58,136 A:middle
and Bonjour text records
I'd like to refer you

553
00:27:58,136 --> 00:28:02,386 A:middle
to the Bonjour RFC, which can
be obtained at the link quoted

554

555
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

556
00:27:58,136 --> 00:28:02,386 A:middle
to the Bonjour RFC, which can
be obtained at the link quoted

557
00:28:02,386 --> 00:28:03,626 A:middle
at the bottom of this slide.

558
00:28:06,266 --> 00:28:09,776 A:middle
Okay, so now we're ready to
tackle on some advanced topics,

559
00:28:10,006 --> 00:28:12,206 A:middle
and I'd like to start
with custom discovery.

560
00:28:12,636 --> 00:28:15,336 A:middle
We've covered two approaches
to discovery so far.

561
00:28:16,096 --> 00:28:19,226 A:middle
The first one was UI-based,
and it's really simple.

562
00:28:19,736 --> 00:28:22,996 A:middle
All you have to do is
instantiate an advertiser,

563
00:28:23,466 --> 00:28:24,856 A:middle
instantiate a browser,

564
00:28:25,206 --> 00:28:28,626 A:middle
and everything else is
entirely user-driven.

565
00:28:29,566 --> 00:28:32,226 A:middle
Now this approach is
very simple to implement,

566
00:28:32,616 --> 00:28:35,356 A:middle
but the framework
gives you the UI,

567
00:28:35,356 --> 00:28:37,546 A:middle
so you don't have much
flexibility there.

568
00:28:38,306 --> 00:28:40,806 A:middle
If you want to design
your own framework,

569
00:28:41,216 --> 00:28:42,976 A:middle
you can use the programmatic
approach.

570
00:28:43,756 --> 00:28:45,956 A:middle
Now the programmatic
approach requires you

571
00:28:45,956 --> 00:28:47,346 A:middle
to do a little bit more work,

572
00:28:47,846 --> 00:28:50,336 A:middle
but you have much more
flexibility in terms

573
00:28:50,336 --> 00:28:52,606 A:middle
of how you define
the user experience.

574
00:28:54,956 --> 00:28:57,386 A:middle
So even given that we
have these two approaches,

575
00:28:57,536 --> 00:29:00,746 A:middle
we realize that there may be
some of you who have the need

576

577
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

578
00:28:57,536 --> 00:29:00,746 A:middle
we realize that there may be
some of you who have the need

579
00:29:00,906 --> 00:29:05,746 A:middle
to have or to define the
discovery experience even more

580
00:29:05,746 --> 00:29:08,366 A:middle
or to customize it even more.

581
00:29:09,586 --> 00:29:12,316 A:middle
And for those, we
offer a third way,

582
00:29:12,686 --> 00:29:14,636 A:middle
which we call the
custom approach.

583
00:29:15,466 --> 00:29:19,306 A:middle
Now the custom approach might
be useful for those users

584
00:29:19,306 --> 00:29:22,266 A:middle
that operate in environments
that is not Bonjour friendly,

585
00:29:22,266 --> 00:29:25,556 A:middle
for instance, or you
may have the need

586
00:29:25,636 --> 00:29:29,196 A:middle
to exchange large amounts of
data during the discovery phase

587
00:29:29,666 --> 00:29:33,306 A:middle
and that data cannot fit in
the discoveryInfo dictionary.

588
00:29:34,696 --> 00:29:39,216 A:middle
So if you fit into one of those
categories you might find custom

589
00:29:39,296 --> 00:29:39,996 A:middle
discovery useful.

590
00:29:39,996 --> 00:29:42,976 A:middle
So let's go over custom
discovery in this section.

591
00:29:43,226 --> 00:29:48,926 A:middle
First, let me say that for
custom discovery you are

592
00:29:48,926 --> 00:29:52,836 A:middle
in full control of the discovery
process, so we will assume

593
00:29:53,076 --> 00:29:55,806 A:middle
that you will implement
a mechanism to discover

594
00:29:55,806 --> 00:30:00,556 A:middle
who is nearby and you will also
establish a one-to-one data link

595

596
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

597
00:29:55,806 --> 00:30:00,556 A:middle
who is nearby and you will also
establish a one-to-one data link

598
00:30:00,616 --> 00:30:01,956 A:middle
between nearby peers.

599
00:30:02,346 --> 00:30:03,626 A:middle
So this will be your job.

600
00:30:05,156 --> 00:30:08,726 A:middle
Now the goal for nearby
peers will be to connect

601
00:30:08,726 --> 00:30:11,836 A:middle
into a Multipeer session
where they can exchange data

602
00:30:11,836 --> 00:30:14,606 A:middle
with other peers on
a many-to-many basis.

603
00:30:15,776 --> 00:30:19,246 A:middle
So let's see how
they can do that.

604
00:30:19,696 --> 00:30:23,006 A:middle
Assuming that we've
discovered nearby peers

605
00:30:23,006 --> 00:30:25,066 A:middle
and we've established
a one-to-one data link

606
00:30:25,066 --> 00:30:28,846 A:middle
between them, let's see
what you have to do in order

607
00:30:28,846 --> 00:30:30,466 A:middle
to connect them into a session.

608
00:30:31,106 --> 00:30:35,416 A:middle
First, each peer will need to
instantiate a peerID object

609
00:30:35,996 --> 00:30:40,196 A:middle
and a session object, and then
it will have to-they will both

610
00:30:40,196 --> 00:30:42,476 A:middle
have to complete a
two-step process.

611
00:30:43,046 --> 00:30:47,376 A:middle
First, they will have to
exchange their peerID objects

612
00:30:47,376 --> 00:30:48,846 A:middle
over the one-to-one data link.

613
00:30:49,306 --> 00:30:51,706 A:middle
So, in order to do that,
they will first have

614
00:30:51,746 --> 00:30:55,056 A:middle
to serialize their peerID
object and pass them

615
00:30:55,056 --> 00:30:57,026 A:middle
over to the other peer.

616
00:30:57,736 --> 00:31:01,236 A:middle
Once the serialized ID object
is available they'll have

617

618
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

619
00:30:57,736 --> 00:31:01,236 A:middle
Once the serialized ID object
is available they'll have

620
00:31:01,276 --> 00:31:02,916 A:middle
to de-serialize it, and at

621
00:31:02,916 --> 00:31:08,086 A:middle
that moment they'll have the
peerID object of the other peer.

622
00:31:08,696 --> 00:31:11,836 A:middle
Once the peerID object
is available they'll have

623
00:31:11,886 --> 00:31:14,156 A:middle
to generate nearby
connection data

624
00:31:15,056 --> 00:31:17,646 A:middle
by calling
nearbyConnectionDataForPeer

625
00:31:17,646 --> 00:31:18,036 A:middle
method.

626
00:31:19,236 --> 00:31:23,106 A:middle
When nearby connection data
becomes available they will have

627
00:31:23,106 --> 00:31:26,846 A:middle
to exchange that object much
like before with the other peer,

628
00:31:27,706 --> 00:31:31,646 A:middle
so this is the second step
of the process, and when both

629
00:31:31,646 --> 00:31:33,156 A:middle
of these objects are available

630
00:31:33,156 --> 00:31:35,486 A:middle
on the other side
you can connect them

631
00:31:35,486 --> 00:31:40,526 A:middle
into a session using
connectPeer:withConnectionData

632
00:31:40,526 --> 00:31:40,936 A:middle
method.

633
00:31:41,396 --> 00:31:43,736 A:middle
When they are done
connecting, much like before,

634
00:31:44,076 --> 00:31:46,746 A:middle
you will be notified
with a delegate method,

635
00:31:46,906 --> 00:31:50,836 A:middle
peer:didChangeState, and
the state will be specified

636
00:31:51,176 --> 00:31:51,876 A:middle
as connected.

637
00:31:52,436 --> 00:31:56,866 A:middle
Okay, so let's see how
we can do this in code.

638
00:31:57,596 --> 00:31:58,736 A:middle
Now serializing

639
00:31:58,736 --> 00:32:01,156 A:middle
and de-serializing can
be accomplished much

640

641
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

642
00:31:58,736 --> 00:32:01,156 A:middle
and de-serializing can
be accomplished much

643
00:32:01,156 --> 00:32:04,606 A:middle
like we've described before
in the best practices section.

644
00:32:04,936 --> 00:32:09,746 A:middle
You can use, for serializing you
can use NSKeyedArchiver APIs,

645
00:32:10,436 --> 00:32:17,326 A:middle
and for de-serializing you can
use NSKeyedUnarchiver APIs.

646
00:32:18,256 --> 00:32:21,986 A:middle
So now that we've exchanged
the peerID objects we have

647
00:32:21,986 --> 00:32:23,376 A:middle
to generate connection data,

648
00:32:24,216 --> 00:32:27,426 A:middle
and to generate nearby
connection data you can use

649
00:32:27,426 --> 00:32:30,256 A:middle
nearbyConnectionData
withCompletionHandler method.

650
00:32:30,956 --> 00:32:32,456 A:middle
The framework, when it's done,

651
00:32:32,896 --> 00:32:36,356 A:middle
will call the completion
handler, where it will pass

652
00:32:36,486 --> 00:32:39,896 A:middle
to you the object that
contains nearby connection data.

653
00:32:40,966 --> 00:32:44,126 A:middle
Then you will have to send that
object over to the other side

654
00:32:47,196 --> 00:32:53,786 A:middle
and when all peers have both
objects for the peer they want

655
00:32:53,786 --> 00:32:55,546 A:middle
to connect with they can do

656
00:32:55,546 --> 00:32:59,956 A:middle
so by calling connectPeer
withNearbyConnectionData.

657

658
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

659
00:33:01,036 --> 00:33:04,916 A:middle
In this method you also have the
opportunity to specify a timeout

660
00:33:04,916 --> 00:33:08,856 A:middle
in seconds, and this timeout
will let the framework know how

661
00:33:08,856 --> 00:33:10,076 A:middle
long you're willing to wait

662
00:33:10,376 --> 00:33:14,906 A:middle
until the peers successfully
connect in a session.

663
00:33:15,216 --> 00:33:18,206 A:middle
If for some reason you change
your mind during the connection

664
00:33:18,206 --> 00:33:19,986 A:middle
process you can cancel it

665
00:33:20,296 --> 00:33:22,636 A:middle
by calling cancelConnectPeer
method.

666
00:33:23,336 --> 00:33:28,146 A:middle
So in summary we've described
a fully customized discovery,

667
00:33:28,486 --> 00:33:32,126 A:middle
which you can use if you
can't use the UI-based

668
00:33:32,126 --> 00:33:34,086 A:middle
or the programmatic
approach for your needs.

669
00:33:34,836 --> 00:33:36,926 A:middle
It consists of a
two-step process.

670
00:33:37,506 --> 00:33:42,166 A:middle
First, you need to exchange the
peerID object, then you need

671
00:33:42,166 --> 00:33:45,716 A:middle
to exchange nearby connection
object, and when both

672
00:33:45,716 --> 00:33:47,266 A:middle
of these objects are available

673
00:33:47,266 --> 00:33:54,216 A:middle
for the other peer you can
connect it into a session.

674
00:33:54,906 --> 00:33:56,986 A:middle
Next up is authentication.

675
00:33:57,876 --> 00:34:02,106 A:middle
So some apps, for
instance, those that deal

676

677
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

678
00:33:57,876 --> 00:34:02,106 A:middle
So some apps, for
instance, those that deal

679
00:34:02,106 --> 00:34:06,776 A:middle
with money transactions think
an app that enables people

680
00:34:06,776 --> 00:34:11,856 A:middle
to split a taxi cab
bill will have to rely

681
00:34:11,856 --> 00:34:15,735 A:middle
on properly implemented
security to provide safe

682
00:34:16,036 --> 00:34:18,806 A:middle
and trustworthy experience
to their users.

683
00:34:21,835 --> 00:34:25,206 A:middle
Multipeer Connectivity
gives you the option

684
00:34:25,206 --> 00:34:28,025 A:middle
of enabling encryption
and authentication

685
00:34:28,025 --> 00:34:30,166 A:middle
for providing security
to your users.

686
00:34:30,896 --> 00:34:33,646 A:middle
Now enabling encryption is
pretty easy, all you have

687
00:34:33,646 --> 00:34:36,176 A:middle
to do is set the flag when
you instantiate the session,

688
00:34:36,996 --> 00:34:39,755 A:middle
but in authentication it is
a little bit more involved.

689
00:34:40,146 --> 00:34:42,306 A:middle
So let's take a look
at how you can deal

690
00:34:42,306 --> 00:34:44,386 A:middle
with authentication
in this section.

691
00:34:45,976 --> 00:34:48,485 A:middle
If you want to provide
authentication

692
00:34:48,485 --> 00:34:52,775 A:middle
to your users you will have
to make sure that each one

693
00:34:52,775 --> 00:34:55,606 A:middle
of your users has
a digital identity,

694
00:34:56,235 --> 00:34:58,716 A:middle
and a digital identity consists

695
00:34:58,716 --> 00:35:01,456 A:middle
of a private key
and a certificate.

696

697
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

698
00:34:58,716 --> 00:35:01,456 A:middle
of a private key
and a certificate.

699
00:35:02,126 --> 00:35:07,056 A:middle
The users will use the private
key to sign their messages

700
00:35:08,246 --> 00:35:11,096 A:middle
and they will make their
certificate available

701
00:35:11,096 --> 00:35:15,216 A:middle
to other users so they can
verify if the signature is valid

702
00:35:15,756 --> 00:35:18,896 A:middle
and if they can trust
the sender.

703
00:35:20,566 --> 00:35:24,106 A:middle
In code, a digital
identity is represented

704
00:35:24,106 --> 00:35:26,276 A:middle
by a SecIdentityRef object.

705
00:35:27,136 --> 00:35:31,666 A:middle
The private key is represented
by a SecKeyRef object.

706
00:35:32,656 --> 00:35:34,666 A:middle
And the certificate
is represented

707
00:35:34,666 --> 00:35:36,756 A:middle
by a SecCertificateRef object.

708
00:35:39,166 --> 00:35:42,546 A:middle
There are multiple ways how
you can distribute digital

709
00:35:42,546 --> 00:35:44,086 A:middle
identities to your users.

710
00:35:44,706 --> 00:35:49,046 A:middle
Perhaps the best way is to
make identities available

711
00:35:49,046 --> 00:35:53,326 A:middle
on a trusted web server so that
the users can download them

712
00:35:53,326 --> 00:35:57,466 A:middle
from that trusted web
server from within the app.

713
00:35:57,466 --> 00:35:59,756 A:middle
Other ways include
e-mail attachments

714

715
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

716
00:36:00,216 --> 00:36:02,786 A:middle
or via a mobile device
management server.

717
00:36:04,026 --> 00:36:06,766 A:middle
For more detailed
information on this topic,

718
00:36:06,766 --> 00:36:11,176 A:middle
I'd like to refer you to the
Tech QA 1745, and the link

719
00:36:11,176 --> 00:36:14,216 A:middle
for this is also provided
at the bottom of this slide.

720
00:36:16,466 --> 00:36:19,996 A:middle
Now let's see how you can import
a digital identity in your code.

721
00:36:21,776 --> 00:36:27,256 A:middle
Usually the digital identity is
stored in a PKCS#12 data file,

722
00:36:27,636 --> 00:36:29,826 A:middle
and these files are
password-protected.

723
00:36:30,826 --> 00:36:33,716 A:middle
So the first thing you'll
need to do is get the password

724
00:36:33,716 --> 00:36:38,436 A:middle
for the file and store
it in a dictionary.

725
00:36:38,436 --> 00:36:41,616 A:middle
Next you will have to get
access to bytes in that file

726
00:36:41,786 --> 00:36:44,456 A:middle
by using dataWithContentsOfURL
method,

727
00:36:45,036 --> 00:36:50,246 A:middle
and once bytes are available you
can import the digital identity

728
00:36:50,246 --> 00:36:54,576 A:middle
by using SecPKCS12Import method.

729
00:36:55,446 --> 00:37:00,556 A:middle
This method will import the
digital identity from the bytes

730

731
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

732
00:36:55,446 --> 00:37:00,556 A:middle
This method will import the
digital identity from the bytes

733
00:37:00,556 --> 00:37:04,076 A:middle
that we have from the file
and store it in an array.

734
00:37:05,126 --> 00:37:07,416 A:middle
So now you know what
a digital identity is,

735
00:37:07,966 --> 00:37:10,096 A:middle
how to distribute
it to your users,

736
00:37:10,776 --> 00:37:14,646 A:middle
and how to import
it in your apps.

737
00:37:15,146 --> 00:37:17,406 A:middle
Note that only certificate part

738
00:37:17,406 --> 00:37:21,616 A:middle
of your digital identity is
made available to other users,

739
00:37:22,496 --> 00:37:26,066 A:middle
and the other users can use
that certificate to verify

740
00:37:26,316 --> 00:37:28,026 A:middle
if you are really who
you claim you are,

741
00:37:28,416 --> 00:37:31,356 A:middle
and they can make a decision
if they want to trust you.

742
00:37:31,926 --> 00:37:34,516 A:middle
So let's look at how
they can verify this.

743
00:37:34,816 --> 00:37:40,646 A:middle
An end-user certificate
can be issued

744
00:37:40,646 --> 00:37:46,376 A:middle
by a trusted root certificate
authority or it can be issued

745
00:37:46,376 --> 00:37:50,486 A:middle
by an untrusted intermediate
certificate authority whose

746
00:37:50,486 --> 00:37:54,476 A:middle
certificate was issued by a
trusted certificate authority.

747
00:37:55,936 --> 00:37:59,886 A:middle
This hierarchy of
certificates that starts

748
00:37:59,886 --> 00:38:03,426 A:middle
with the end-user certificate
on the left and ends

749

750
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

751
00:37:59,886 --> 00:38:03,426 A:middle
with the end-user certificate
on the left and ends

752
00:38:03,426 --> 00:38:05,386 A:middle
with the trusted
root certificate

753
00:38:05,386 --> 00:38:11,786 A:middle
on the right is often referred
to as the chain of trust.

754
00:38:12,356 --> 00:38:16,486 A:middle
Roughly speaking, when we
evaluate the chain of trust,

755
00:38:17,086 --> 00:38:22,396 A:middle
the following step-wise
procedure happens.

756
00:38:22,776 --> 00:38:25,546 A:middle
First, we inspect the
end user's certificate

757
00:38:25,796 --> 00:38:27,066 A:middle
and check if it's valid.

758
00:38:28,536 --> 00:38:32,086 A:middle
Let's assume it is, next,

759
00:38:32,426 --> 00:38:34,626 A:middle
we inspect the intermediate
certificate

760
00:38:34,626 --> 00:38:35,646 A:middle
and check if it's valid.

761
00:38:36,576 --> 00:38:40,886 A:middle
We also check if the end
user certificate was, indeed,

762
00:38:40,886 --> 00:38:43,946 A:middle
issued by the intermediate
certificate authority.

763
00:38:45,326 --> 00:38:48,836 A:middle
Say that checks out,
as well, finally,

764
00:38:49,546 --> 00:38:51,646 A:middle
we have to inspect
the root certificate,

765
00:38:52,996 --> 00:38:54,686 A:middle
and we check if it's valid.

766
00:38:55,576 --> 00:39:01,506 A:middle
We also check if the
intermediate certificate was,

767

768
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

769
00:38:55,576 --> 00:39:01,506 A:middle
We also check if the
intermediate certificate was,

770
00:39:01,506 --> 00:39:05,376 A:middle
indeed, issued by the
trusted certificate authority,

771
00:39:05,956 --> 00:39:09,176 A:middle
and if that checks out, as well,

772
00:39:09,596 --> 00:39:12,516 A:middle
then the chain of
trust is valid.

773
00:39:13,026 --> 00:39:16,706 A:middle
So in code when you
evaluate the chain of trust,

774
00:39:17,036 --> 00:39:20,826 A:middle
the first thing you'll have to
do is create a policy object.

775
00:39:21,866 --> 00:39:25,136 A:middle
This policy object will
govern how the chain

776
00:39:25,136 --> 00:39:26,966 A:middle
of trust is evaluated.

777
00:39:28,886 --> 00:39:31,596 A:middle
Then you will have to
create the chain of trust,

778
00:39:32,606 --> 00:39:33,586 A:middle
and once you have the chain

779
00:39:33,586 --> 00:39:36,336 A:middle
of trust you will
have to evaluate it.

780
00:39:37,086 --> 00:39:39,296 A:middle
So let's see how you
can do this in code.

781
00:39:40,496 --> 00:39:42,386 A:middle
First, we need to
create the policy,

782
00:39:43,026 --> 00:39:48,706 A:middle
and for our purposes we can use
SecPolicyCreateBasicX509 API,

783
00:39:49,446 --> 00:39:53,716 A:middle
which will create a
policy, an X509 policy

784
00:39:53,716 --> 00:39:58,926 A:middle
because we're dealing with
X509-type certificates.

785
00:39:59,236 --> 00:40:01,236 A:middle
Next, we have to
create the trust object

786

787
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

788
00:39:59,236 --> 00:40:01,236 A:middle
Next, we have to
create the trust object

789
00:40:01,656 --> 00:40:05,586 A:middle
by using
SecTrustCreateWithCertificates

790
00:40:05,586 --> 00:40:11,036 A:middle
API, and we also have to
set anchor certificates.

791
00:40:11,696 --> 00:40:14,646 A:middle
By anchor certificates we
mean the root certificates

792
00:40:14,846 --> 00:40:16,516 A:middle
that can be trusted
by the system,

793
00:40:17,006 --> 00:40:20,346 A:middle
so we have to let the system
know which certificates can be

794
00:40:20,346 --> 00:40:23,716 A:middle
at the end of the
chain of trust.

795
00:40:23,946 --> 00:40:27,586 A:middle
Once that is established, we
can evaluate the chain of trust

796
00:40:27,996 --> 00:40:30,636 A:middle
by calling the SecTrustEvaluate
method,

797
00:40:31,736 --> 00:40:34,476 A:middle
and the result will be stored
in the second parameter.

798
00:40:35,706 --> 00:40:40,066 A:middle
Now if the result equals
kSecTrustUnspecified,

799
00:40:40,786 --> 00:40:44,086 A:middle
that means that the
chain of trust is valid.

800
00:40:44,926 --> 00:40:49,436 A:middle
So, with that, let's see how
you can set up authentication

801
00:40:49,736 --> 00:40:51,676 A:middle
in a Multipeer Connectivity
session.

802
00:40:52,186 --> 00:40:57,846 A:middle
You'll have to use the session
initializer initWithPeer

803
00:40:58,186 --> 00:41:01,346 A:middle
securityIdentity
encryption preference method.

804

805
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

806
00:40:58,186 --> 00:41:01,346 A:middle
securityIdentity
encryption preference method.

807
00:41:02,476 --> 00:41:05,876 A:middle
And for the second parameter
securityIdentity you'll have

808
00:41:05,906 --> 00:41:10,846 A:middle
to pass an array, which
contains your digital identity

809
00:41:10,846 --> 00:41:14,736 A:middle
as the first parameter and
a chain of certificates

810
00:41:15,036 --> 00:41:19,836 A:middle
that validate your
identity as next elements.

811
00:41:20,386 --> 00:41:25,506 A:middle
When somebody tries to connect
to you, you will be notified

812
00:41:25,536 --> 00:41:28,266 A:middle
with the delegate method,
didReceiveCertificate,

813
00:41:28,636 --> 00:41:31,376 A:middle
where you will be passed
the chain of certificates

814
00:41:31,626 --> 00:41:33,106 A:middle
that represent the other peer.

815
00:41:34,016 --> 00:41:38,006 A:middle
At that time you will have to
decide whether you want to trust

816
00:41:38,006 --> 00:41:41,176 A:middle
that peer or whether you trust
that peer and whether you want

817
00:41:41,176 --> 00:41:44,336 A:middle
to proceed connecting to it.

818
00:41:44,976 --> 00:41:48,056 A:middle
At this moment you can use the
method for evaluating the chain

819
00:41:48,056 --> 00:41:50,866 A:middle
of trust that we discussed
a couple of slides ago.

820
00:41:51,546 --> 00:41:55,406 A:middle
And if you decide that the
chain of trust can be trusted,

821
00:41:55,406 --> 00:41:59,066 A:middle
is valid and can be trusted,
you can let the framework know

822
00:41:59,316 --> 00:42:01,276 A:middle
by calling the certificate
handler

823

824
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

825
00:41:59,316 --> 00:42:01,276 A:middle
by calling the certificate
handler

826
00:42:01,566 --> 00:42:04,926 A:middle
and passing it a Boolean,
so in this case a yes.

827
00:42:05,876 --> 00:42:08,466 A:middle
If you don't trust it
you can just pass it a no

828
00:42:08,676 --> 00:42:10,496 A:middle
and the framework will
reject the connection.

829
00:42:10,836 --> 00:42:13,546 A:middle
In summary, we've looked
at a bit more detail

830
00:42:13,826 --> 00:42:16,696 A:middle
about how you can
set up authentication

831
00:42:16,746 --> 00:42:18,866 A:middle
in your Multipeer
Connectivity apps.

832
00:42:19,496 --> 00:42:21,466 A:middle
We've looked at digital
identities

833
00:42:22,006 --> 00:42:24,736 A:middle
and we've described how
you can make them available

834
00:42:24,736 --> 00:42:28,986 A:middle
to your users and how you
can import them in your apps.

835
00:42:29,166 --> 00:42:32,546 A:middle
We've also looked at chains
of trust and how you can go

836
00:42:32,546 --> 00:42:34,046 A:middle
about evaluating them.

837
00:42:34,586 --> 00:42:37,506 A:middle
For more information, I
would like to refer you

838
00:42:37,506 --> 00:42:41,746 A:middle
to our Evangelist, Paul
Danbold, and you can check

839
00:42:41,746 --> 00:42:43,256 A:middle
out our documentation,

840
00:42:43,326 --> 00:42:45,906 A:middle
"Multipeer Connectivity
Framework Reference" guide.

841
00:42:46,686 --> 00:42:49,096 A:middle
And, as Eric mentioned,
we have some sample code

842
00:42:49,096 --> 00:42:51,946 A:middle
that you guys should check
out called MultipeerGroupChat.

843
00:42:52,826 --> 00:42:55,066 A:middle
We'll be available to
answer questions and hear

844
00:42:55,066 --> 00:42:58,676 A:middle
about your comments at
devforums.apple.com, as well.

845
00:42:59,176 --> 00:43:03,366 A:middle
There are a few related sessions
that I would like to call out.

846

847
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

848
00:42:59,176 --> 00:43:03,366 A:middle
There are a few related sessions
that I would like to call out.

849
00:43:03,716 --> 00:43:05,946 A:middle
One is "What's New in
Foundation Networking",

850
00:43:06,386 --> 00:43:08,816 A:middle
and the other one is
"Storyboards and Controllers"

851
00:43:08,816 --> 00:43:11,966 A:middle
on OS X, where you can
hear more about what's new

852
00:43:12,196 --> 00:43:14,166 A:middle
with NSViewControllers
in Yosemite.

853
00:43:14,976 --> 00:43:15,976 A:middle
Thank you very much, everyone.

854
00:43:16,516 --> 00:43:19,500 A:middle
[ Applause ]

855
