X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:11,516 --> 00:00:14,546 A:middle
[ Applause ]

2
00:00:15,046 --> 00:00:15,356 A:middle
>> Good afternoon.

3
00:00:15,356 --> 00:00:15,716 A:middle
Welcome.

4
00:00:16,186 --> 00:00:17,566 A:middle
Welcome to Intermediate Swift.

5
00:00:18,656 --> 00:00:20,666 A:middle
My name is Brian Lanier.

6
00:00:20,666 --> 00:00:22,606 A:middle
I'm an engineer in
Developer Publications.

7
00:00:22,866 --> 00:00:25,596 A:middle
Later I'll be joined on stage
by my colleague, Joe Groff,

8
00:00:25,966 --> 00:00:27,836 A:middle
who is an engineer on
the Swift compiler team.

9
00:00:28,266 --> 00:00:31,786 A:middle
We're both really excited to be
here today to talk with you more

10
00:00:32,156 --> 00:00:34,316 A:middle
in depth about the Swift
programming language.

11
00:00:34,976 --> 00:00:36,676 A:middle
I've been in the labs
the last couple of days

12
00:00:36,676 --> 00:00:38,496 A:middle
and I've been very
impressed already

13
00:00:38,496 --> 00:00:40,506 A:middle
with what you've been
able to do with Swift,

14
00:00:41,156 --> 00:00:44,026 A:middle
and I think that to go
into some more detail

15
00:00:44,026 --> 00:00:46,426 A:middle
on some really key features
of Swift, you'll be able

16
00:00:46,426 --> 00:00:48,736 A:middle
to take advantage of
those features even more

17
00:00:48,736 --> 00:00:52,716 A:middle
so in your code.

18
00:00:52,866 --> 00:00:56,306 A:middle
So, in particular, we're
going to look at some features

19
00:00:56,306 --> 00:00:59,066 A:middle
in some more detail
including optionals

20
00:00:59,246 --> 00:01:02,206 A:middle
and how you can use them
to make your code safer.

21

22
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

23
00:00:59,246 --> 00:01:02,206 A:middle
and how you can use them
to make your code safer.

24
00:01:02,826 --> 00:01:05,245 A:middle
We're going to talk to you
about memory management in Swift

25
00:01:05,245 --> 00:01:06,856 A:middle
and how it's largely automatic.

26
00:01:07,966 --> 00:01:09,916 A:middle
We're also going to talk
about initialization

27
00:01:10,486 --> 00:01:13,386 A:middle
and how you can take advantage
of the power of closures

28
00:01:13,686 --> 00:01:15,226 A:middle
and pattern matching
in your code.

29
00:01:15,516 --> 00:01:19,406 A:middle
So, I want to begin
by looking at one

30
00:01:19,406 --> 00:01:22,666 A:middle
of Swift's most powerful
features, optionals,

31
00:01:24,096 --> 00:01:25,566 A:middle
but first I want to take a look

32
00:01:25,566 --> 00:01:27,986 A:middle
at why we might need
optionals in the first place.

33
00:01:29,686 --> 00:01:32,206 A:middle
Say you need to work with
input data from a user.

34
00:01:32,676 --> 00:01:34,586 A:middle
Here we're asking
for the user's age.

35
00:01:35,356 --> 00:01:38,406 A:middle
The response comes in as
a string but say we need

36
00:01:38,406 --> 00:01:39,546 A:middle
to convert that string

37
00:01:39,546 --> 00:01:43,876 A:middle
to an integer using
this toInt method here.

38
00:01:44,096 --> 00:01:47,126 A:middle
Now when the enter
users a string

39
00:01:47,126 --> 00:01:48,416 A:middle
that represents a valid integer,

40
00:01:48,806 --> 00:01:53,066 A:middle
the toInt method returns the
correct result but, however,

41
00:01:53,066 --> 00:01:56,726 A:middle
because you're not in control
of the user's response you have

42
00:01:57,276 --> 00:01:59,696 A:middle
to deal with cases or situations

43
00:01:59,696 --> 00:02:02,376 A:middle
where there's not an
obvious value to return.

44

45
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

46
00:01:59,696 --> 00:02:02,376 A:middle
where there's not an
obvious value to return.

47
00:02:03,346 --> 00:02:05,656 A:middle
The user has full control
over what they're entering in.

48
00:02:05,706 --> 00:02:09,936 A:middle
So, if they try to
get cute or snippy,

49
00:02:11,566 --> 00:02:15,426 A:middle
we don't really have a clear
value to return in this case.

50
00:02:15,856 --> 00:02:19,086 A:middle
So, what do we do?

51
00:02:19,086 --> 00:02:20,346 A:middle
What value do we return?

52
00:02:20,346 --> 00:02:23,686 A:middle
Well, we have lots
of options, right?

53
00:02:25,086 --> 00:02:29,766 A:middle
Well, as you're probably aware,
various sentinels have been used

54
00:02:30,306 --> 00:02:32,636 A:middle
in various different
languages to model these kinds

55
00:02:32,636 --> 00:02:35,506 A:middle
of problems, but
having so many sentinels

56
00:02:35,506 --> 00:02:37,326 A:middle
around isn't very good.

57
00:02:37,436 --> 00:02:38,636 A:middle
It's not very safe.

58
00:02:38,976 --> 00:02:41,346 A:middle
It's a common source of bugs
and problems in your code.

59
00:02:41,826 --> 00:02:42,826 A:middle
For one you have to know

60
00:02:42,826 --> 00:02:45,396 A:middle
which of these possible
sentinels was chosen

61
00:02:45,396 --> 00:02:48,766 A:middle
by the author of the API and
then you have to remember

62
00:02:48,766 --> 00:02:51,036 A:middle
which one to check against it.

63
00:02:52,456 --> 00:02:53,866 A:middle
So this isn't a very
good pattern.

64
00:02:54,126 --> 00:02:56,066 A:middle
So really how should
we model this?

65
00:02:57,256 --> 00:03:00,006 A:middle
Well, in Swift, we
model problems

66

67
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

68
00:02:57,256 --> 00:03:00,006 A:middle
Well, in Swift, we
model problems

69
00:03:00,006 --> 00:03:02,606 A:middle
like these using
the optional type.

70
00:03:03,436 --> 00:03:07,446 A:middle
The optional type represents
possibly missing values

71
00:03:07,736 --> 00:03:09,506 A:middle
of any type whatsoever.

72
00:03:10,816 --> 00:03:17,366 A:middle
The optional type has 2 discrete
states; a default, nil state,

73
00:03:18,176 --> 00:03:23,296 A:middle
which represents literally the
absence of any value whatsoever

74
00:03:23,786 --> 00:03:25,376 A:middle
and optionals are
defaulted to nil.

75
00:03:25,836 --> 00:03:27,796 A:middle
You've probably seen a couple
of examples and options.

76
00:03:27,796 --> 00:03:30,646 A:middle
If you've seen the introduction
to Swift Talk, you write them

77
00:03:30,646 --> 00:03:33,496 A:middle
by writing the base height
followed by a question mark

78
00:03:33,546 --> 00:03:34,866 A:middle
to indicate their optionality.

79
00:03:36,116 --> 00:03:41,226 A:middle
Now, in Swift, nil is not
like Swift in Objective-C

80
00:03:41,516 --> 00:03:44,196 A:middle
where in Objective-C Swift is
an object pointer to nothing

81
00:03:44,456 --> 00:03:46,356 A:middle
and it only works for
the reference types.

82
00:03:47,226 --> 00:03:49,886 A:middle
In Swift, nil is a
true sentinel value.

83
00:03:50,156 --> 00:03:52,076 A:middle
It works with any
type whatsoever.

84
00:03:52,116 --> 00:03:54,836 A:middle
It literally just means
there's no value present.

85
00:03:56,266 --> 00:03:58,706 A:middle
The other state of an
option includes a presence

86
00:03:58,706 --> 00:04:01,226 A:middle
of a value that's been
wrapped up in the optional.

87

88
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

89
00:03:58,706 --> 00:04:01,226 A:middle
of a value that's been
wrapped up in the optional.

90
00:04:01,226 --> 00:04:04,056 A:middle
Think of optionals as this
wrapper container that wraps

91
00:04:04,056 --> 00:04:06,776 A:middle
up values when there
are values present.

92
00:04:06,776 --> 00:04:09,316 A:middle
So here we're setting the
value of optional number to 6

93
00:04:09,316 --> 00:04:12,346 A:middle
and the value is wrapped
up in the optional.

94
00:04:12,866 --> 00:04:15,366 A:middle
We'll see how to unwrap
this value and access it

95
00:04:15,886 --> 00:04:16,766 A:middle
in just a little while.

96
00:04:18,495 --> 00:04:24,706 A:middle
So, now that we have a single
sentinel value that works

97
00:04:24,706 --> 00:04:26,826 A:middle
with any type at
all even integers,

98
00:04:27,506 --> 00:04:29,566 A:middle
it's clear what this
method should return.

99
00:04:29,566 --> 00:04:33,446 A:middle
It's clear that whenever we
have a value that's not valid,

100
00:04:33,536 --> 00:04:35,166 A:middle
we should just return an
optional and, in fact,

101
00:04:35,696 --> 00:04:37,916 A:middle
the toInt method is defined
in the standard library

102
00:04:37,986 --> 00:04:41,196 A:middle
under string type and it does
just that it returns nil.

103
00:04:42,066 --> 00:04:44,596 A:middle
Now because we have optionals,

104
00:04:45,066 --> 00:04:47,276 A:middle
we also have non-optional
types as well.

105
00:04:47,276 --> 00:04:49,166 A:middle
So what are non-optional types?

106
00:04:49,306 --> 00:04:51,846 A:middle
Well, they're just ordinary
types you would think they are.

107
00:04:52,146 --> 00:04:55,036 A:middle
Integers, strings, even
your custom objects.

108
00:04:55,396 --> 00:05:00,016 A:middle
And the great thing about
non-optional types is

109

110
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

111
00:04:55,396 --> 00:05:00,016 A:middle
And the great thing about
non-optional types is

112
00:05:00,016 --> 00:05:01,706 A:middle
that they can't be nil.

113
00:05:01,706 --> 00:05:04,126 A:middle
And we think this is pretty cool

114
00:05:04,126 --> 00:05:06,606 A:middle
because this makes your
code safe and predictable.

115
00:05:06,606 --> 00:05:08,306 A:middle
When you declare a value

116
00:05:08,306 --> 00:05:11,796 A:middle
of a non-optional
type, it can't be nil.

117
00:05:11,796 --> 00:05:13,776 A:middle
You can be sure that it's
there when you need it

118
00:05:14,416 --> 00:05:15,506 A:middle
and you can't be surprised

119
00:05:15,506 --> 00:05:18,496 A:middle
by unexpected nil values
propagating throughout

120
00:05:19,146 --> 00:05:21,026 A:middle
your code.

121
00:05:21,216 --> 00:05:22,996 A:middle
So, now that we know
what optional types are

122
00:05:22,996 --> 00:05:25,056 A:middle
and what they represent
let's see how we can use them

123
00:05:25,056 --> 00:05:27,856 A:middle
in our code, for example,
to write a function

124
00:05:28,596 --> 00:05:30,206 A:middle
that returns an optional type.

125
00:05:31,016 --> 00:05:33,496 A:middle
So here we're going to write a
function that looks for a string

126
00:05:34,286 --> 00:05:35,496 A:middle
in an array of strings and if

127
00:05:35,496 --> 00:05:38,196 A:middle
that string has found the array
it simply returns the index,

128
00:05:39,176 --> 00:05:41,416 A:middle
but as you might guess,
this is a case in which

129
00:05:42,436 --> 00:05:45,216 A:middle
if the string isn't found we
need some value to indicate

130
00:05:45,216 --> 00:05:48,156 A:middle
that failure and because
we have nil and optionals

131
00:05:48,156 --> 00:05:51,346 A:middle
at our disposal, let's go ahead
and change return pipe here

132
00:05:51,466 --> 00:05:54,336 A:middle
to an optional by adding the
question mark at the end.

133
00:05:55,326 --> 00:05:56,956 A:middle
So, let's implement
the function.

134
00:05:56,956 --> 00:05:58,856 A:middle
The first thing we need
to is enumerate the array

135
00:05:58,856 --> 00:06:00,626 A:middle
and here we're using
the enumerate method

136

137
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

138
00:05:58,856 --> 00:06:00,626 A:middle
and here we're using
the enumerate method

139
00:06:00,626 --> 00:06:03,136 A:middle
to find the standard library
which actually enumerates

140
00:06:03,136 --> 00:06:07,586 A:middle
to an array and returns as
tuple, the index and the value

141
00:06:07,586 --> 00:06:09,546 A:middle
of each value in the array.

142
00:06:09,546 --> 00:06:14,086 A:middle
We can use that in the 4N
statement here and check to see

143
00:06:14,086 --> 00:06:16,626 A:middle
if the string that we're looking
for matches the value and if

144
00:06:16,626 --> 00:06:18,246 A:middle
so simply return the integer.

145
00:06:18,696 --> 00:06:21,746 A:middle
Now, we're returning an integer
here but then it gets wrapped

146
00:06:21,746 --> 00:06:24,226 A:middle
up as we said in the
optional return type

147
00:06:24,486 --> 00:06:27,756 A:middle
and because we have nil at our
disposal, we know exactly what

148
00:06:27,756 --> 00:06:30,786 A:middle
to do when we don't
have a valid result.

149
00:06:30,916 --> 00:06:31,946 A:middle
We just simply return nil.

150
00:06:32,586 --> 00:06:36,296 A:middle
Now, as I said, we need
to unwrap optionals.

151
00:06:36,666 --> 00:06:41,986 A:middle
So, let's use this function here
to look through an array and try

152
00:06:41,986 --> 00:06:43,456 A:middle
to find a name in this array.

153
00:06:44,086 --> 00:06:47,326 A:middle
Here you can clearly see that
the string that we're looking

154
00:06:47,326 --> 00:06:50,306 A:middle
for is in the array so we
have a valid result to return.

155
00:06:51,176 --> 00:06:52,316 A:middle
Then we can check though.

156
00:06:52,406 --> 00:06:55,166 A:middle
We always want to make
sure the value is present

157
00:06:55,166 --> 00:06:58,346 A:middle
so we can simply ask if the
index value isn't nil here

158
00:06:59,076 --> 00:07:01,846 A:middle
and notice that I don't, I'm not
checking explicitly against nil

159

160
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

161
00:06:59,076 --> 00:07:01,846 A:middle
and notice that I don't, I'm not
checking explicitly against nil

162
00:07:02,236 --> 00:07:05,146 A:middle
and that's because optionals
can be used in Boolean context.

163
00:07:05,636 --> 00:07:08,126 A:middle
That means that you can check
them directly very naturally

164
00:07:08,126 --> 00:07:08,896 A:middle
like I've done here.

165
00:07:09,846 --> 00:07:13,346 A:middle
So if the value is present,
which it is, we can simply try

166
00:07:13,346 --> 00:07:16,356 A:middle
to use that value in the
subscript of the array,

167
00:07:16,626 --> 00:07:19,236 A:middle
but if we've done it like
this we have a problem

168
00:07:20,056 --> 00:07:23,936 A:middle
because the array is expecting
a non-optional integer,

169
00:07:23,936 --> 00:07:27,206 A:middle
but we've said that the function
returns an optional integer.

170
00:07:27,826 --> 00:07:29,176 A:middle
So the types don't match here

171
00:07:29,176 --> 00:07:30,406 A:middle
and the compiler
will let us know

172
00:07:30,406 --> 00:07:33,476 A:middle
that first before we use it we
need to unwrap the optionals.

173
00:07:34,146 --> 00:07:35,846 A:middle
One way we can unwrap optionals,

174
00:07:36,206 --> 00:07:39,236 A:middle
is using the force unwrapping
operator which simply consists

175
00:07:39,236 --> 00:07:40,306 A:middle
of an exclamation mark.

176
00:07:41,106 --> 00:07:43,886 A:middle
You write the exclamation
mark after the optional value

177
00:07:43,886 --> 00:07:44,656 A:middle
that you wish to unwrap.

178
00:07:46,176 --> 00:07:50,396 A:middle
And here because our search
returned a valid response,

179
00:07:51,066 --> 00:07:53,536 A:middle
we can simply print out
the result, but you have

180
00:07:53,536 --> 00:07:55,326 A:middle
to be careful as I
said we should check

181
00:07:55,436 --> 00:07:57,756 A:middle
to make sure the value is nil
first before we unwrap it.

182
00:07:58,206 --> 00:08:00,576 A:middle
So if we try to use the forced
unwrapping operator here

183

184
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

185
00:07:58,206 --> 00:08:00,576 A:middle
So if we try to use the forced
unwrapping operator here

186
00:08:01,056 --> 00:08:04,186 A:middle
without checking, we would
actually get a runtime

187
00:08:04,186 --> 00:08:06,606 A:middle
assertion, a runtime
error because we need

188
00:08:06,606 --> 00:08:08,866 A:middle
to make sure the value
is there and we're trying

189
00:08:08,866 --> 00:08:11,486 A:middle
to force it when it's not.

190
00:08:11,756 --> 00:08:14,316 A:middle
So instead in Swift we have
a better way of doing this

191
00:08:14,636 --> 00:08:16,766 A:middle
where we can actually
test and unwrap

192
00:08:17,756 --> 00:08:20,506 A:middle
at the same time using what
we call optional binding.

193
00:08:21,126 --> 00:08:22,426 A:middle
Optional binding uses this

194
00:08:22,426 --> 00:08:24,896 A:middle
if let syntax you
may have seen earlier

195
00:08:24,896 --> 00:08:26,086 A:middle
in the Introduction
to Swift Talk.

196
00:08:27,476 --> 00:08:29,366 A:middle
So, the if let statement,
how does it work?

197
00:08:29,536 --> 00:08:33,096 A:middle
Well, first as I said
it tests so it tests

198
00:08:33,096 --> 00:08:36,616 A:middle
to see the optional type here
to see if it's actually present

199
00:08:36,616 --> 00:08:40,696 A:middle
or if its value is nil, and
if it's not nil, it assigns,

200
00:08:40,696 --> 00:08:43,265 A:middle
unwraps and assigns
a non-optional type

201
00:08:43,936 --> 00:08:47,006 A:middle
to the index value here,
this temporary constant,

202
00:08:47,226 --> 00:08:49,486 A:middle
and you can use a temporary
constant because it's unwrapped

203
00:08:50,396 --> 00:08:53,466 A:middle
as the index, as a
subscript to this array

204
00:08:54,426 --> 00:08:55,746 A:middle
and everything should
work just fine,

205
00:08:56,926 --> 00:08:58,666 A:middle
but we can actually
combine these together.

206
00:08:58,666 --> 00:09:01,416 A:middle
There's no need to actually
include a temporary variable.

207

208
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

209
00:08:58,666 --> 00:09:01,416 A:middle
There's no need to actually
include a temporary variable.

210
00:09:01,656 --> 00:09:06,596 A:middle
We can simply evaluate the
result of the function directly

211
00:09:06,596 --> 00:09:08,796 A:middle
in line and then assign
that after it's unwrapped

212
00:09:08,796 --> 00:09:12,126 A:middle
to the index here, which now
index is a non-optional Int,

213
00:09:12,226 --> 00:09:14,966 A:middle
just regular old Int.

214
00:09:15,866 --> 00:09:19,286 A:middle
But that's what optional bind
looks like in a simple case.

215
00:09:19,286 --> 00:09:20,406 A:middle
Let's look at how it might look

216
00:09:20,406 --> 00:09:22,506 A:middle
if we did something a
little bit more complex.

217
00:09:23,306 --> 00:09:26,296 A:middle
So, to do that, let's set
up a couple of classes.

218
00:09:26,296 --> 00:09:29,136 A:middle
Say we have a person class
that has an optional residence

219
00:09:30,266 --> 00:09:32,106 A:middle
and a residence which
has an optional address.

220
00:09:33,066 --> 00:09:34,636 A:middle
Finally, we have
an address class

221
00:09:34,636 --> 00:09:37,466 A:middle
that has 3 optional
properties; the building number,

222
00:09:37,466 --> 00:09:39,696 A:middle
a street name and
apartment number all

223
00:09:39,696 --> 00:09:40,446 A:middle
of which are optional.

224
00:09:41,376 --> 00:09:43,386 A:middle
Let's do a little
bit more bookkeeping.

225
00:09:43,386 --> 00:09:45,646 A:middle
Let's go ahead and create
a person instance, Paul,

226
00:09:45,646 --> 00:09:48,806 A:middle
here and let's give
Paul a residence

227
00:09:49,716 --> 00:09:52,946 A:middle
and let's also give
Paul's residence an address

228
00:09:53,126 --> 00:09:54,186 A:middle
so he can receive his mail.

229
00:09:54,426 --> 00:09:58,436 A:middle
Now because Paul doesn't live
in an apartment we're not going

230
00:09:58,436 --> 00:10:00,006 A:middle
to set the apartment
number but we're going

231

232
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

233
00:09:58,436 --> 00:10:00,006 A:middle
to set the apartment
number but we're going

234
00:10:00,006 --> 00:10:02,586 A:middle
to set the building
number to the string 243

235
00:10:02,586 --> 00:10:04,256 A:middle
and the street name
to Main Street.

236
00:10:05,416 --> 00:10:09,516 A:middle
Now let's say that we wanted
to get at the address number

237
00:10:09,796 --> 00:10:12,076 A:middle
as an integer not as a string.

238
00:10:12,076 --> 00:10:16,336 A:middle
Well we could use if let binding
to drill down through all

239
00:10:16,336 --> 00:10:17,726 A:middle
of these properties
and sub properties

240
00:10:17,726 --> 00:10:19,076 A:middle
of the classes we've defined.

241
00:10:19,246 --> 00:10:21,576 A:middle
So first we can test to see
if Paul has a residence.

242
00:10:21,576 --> 00:10:23,626 A:middle
If so, unwrap it,
assign it to home.

243
00:10:24,286 --> 00:10:28,286 A:middle
We can do the same with the
address and finally we can drill

244
00:10:28,286 --> 00:10:31,386 A:middle
down and use the toInt
method to convert that string

245
00:10:31,716 --> 00:10:36,386 A:middle
into a number and assign
it to the address variable,

246
00:10:37,556 --> 00:10:39,826 A:middle
but this is really
cumbersome as you can tell.

247
00:10:40,106 --> 00:10:43,606 A:middle
This does not lead to pretty
code and it's kind of hard

248
00:10:43,606 --> 00:10:46,826 A:middle
to follow all of the nested if
let syntax and statements here.

249
00:10:47,516 --> 00:10:51,796 A:middle
So in Swift we can actually
use optional chaining as a way

250
00:10:51,796 --> 00:10:53,086 A:middle
of accomplishing the same thing.

251
00:10:53,706 --> 00:10:55,586 A:middle
Optional chaining lets
you work with optionals

252
00:10:55,636 --> 00:10:57,406 A:middle
to conditionally
perform operations.

253
00:10:57,766 --> 00:11:01,086 A:middle
It's like messaging nil in
Objective-C but in such a way

254

255
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

256
00:10:57,766 --> 00:11:01,086 A:middle
It's like messaging nil in
Objective-C but in such a way

257
00:11:01,086 --> 00:11:03,036 A:middle
that it works with
any type whatsoever.

258
00:11:04,286 --> 00:11:07,876 A:middle
Optional chaining provides
a clean and succinct syntax

259
00:11:07,996 --> 00:11:09,456 A:middle
for doing these kinds
of operations

260
00:11:09,886 --> 00:11:12,316 A:middle
so what we're doing here is
we're evaluating each point

261
00:11:12,316 --> 00:11:15,726 A:middle
using the question mark operator
or the chaining operator to see

262
00:11:15,726 --> 00:11:19,106 A:middle
if the thing to its left which
is an optional type if it's nil

263
00:11:19,356 --> 00:11:22,216 A:middle
or if it's present before we
proceed to the next expression.

264
00:11:22,886 --> 00:11:23,876 A:middle
So to see how this works

265
00:11:23,876 --> 00:11:26,586 A:middle
in a little bit more detail
let's look at this example

266
00:11:26,586 --> 00:11:27,646 A:middle
and see how it's evaluated.

267
00:11:27,796 --> 00:11:29,186 A:middle
You could think of
the evaluation

268
00:11:29,736 --> 00:11:31,356 A:middle
of an optional chaining
expression

269
00:11:32,016 --> 00:11:34,946 A:middle
like 2 parallel railroad
tracks that end

270
00:11:34,946 --> 00:11:36,916 A:middle
in two different
destinations or two stations.

271
00:11:37,196 --> 00:11:40,576 A:middle
The first station being the
optional value that's wrapped

272
00:11:40,576 --> 00:11:43,876 A:middle
up here so in this case an Int
that's wrapped in an optional

273
00:11:44,416 --> 00:11:46,156 A:middle
or simply nil when
there's no value present.

274
00:11:47,036 --> 00:11:48,906 A:middle
So let's see what this
looks like as we go

275
00:11:48,906 --> 00:11:49,666 A:middle
through the expression.

276
00:11:50,136 --> 00:11:51,966 A:middle
Well, Paul is non-optional
so that's obvious.

277
00:11:51,966 --> 00:11:53,356 A:middle
We've set him, he's
a valid instance.

278
00:11:54,116 --> 00:11:55,786 A:middle
We can go to the
first optional here

279
00:11:55,966 --> 00:11:57,836 A:middle
in the chain expression
residence.

280
00:11:57,836 --> 00:11:59,686 A:middle
Well, we know that we've
set it as a residence

281
00:11:59,946 --> 00:12:03,226 A:middle
but if it were nil, we would
actually just take the nil track

282

283
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

284
00:11:59,946 --> 00:12:03,226 A:middle
but if it were nil, we would
actually just take the nil track

285
00:12:03,646 --> 00:12:05,936 A:middle
and the entire expression
would return nil.

286
00:12:05,936 --> 00:12:08,636 A:middle
It's still an optional type
but it simply returns nil

287
00:12:08,636 --> 00:12:12,996 A:middle
and the rest of the expression
is ignored, but of course,

288
00:12:12,996 --> 00:12:13,976 A:middle
we did set a residence

289
00:12:13,976 --> 00:12:16,206 A:middle
and we can do the same
here along the path

290
00:12:16,926 --> 00:12:20,576 A:middle
and we can check every single
optional in a chained expression

291
00:12:20,576 --> 00:12:21,866 A:middle
to see whether or
not it's valid.

292
00:12:22,486 --> 00:12:24,466 A:middle
In this case, we've
set an address

293
00:12:24,466 --> 00:12:28,606 A:middle
and we've set a building
number and finally we come

294
00:12:28,606 --> 00:12:32,586 A:middle
to the last method call
after we've checked all

295
00:12:32,586 --> 00:12:33,556 A:middle
of the rest of the optionals.

296
00:12:33,946 --> 00:12:34,916 A:middle
Now the toInt method

297
00:12:34,916 --> 00:12:37,116 A:middle
as you recall returns
an optional type itself

298
00:12:37,486 --> 00:12:39,656 A:middle
so there's actually one more
path we need to consider.

299
00:12:39,906 --> 00:12:42,496 A:middle
It could, in fact, return nil
if it can't convert the value,

300
00:12:43,926 --> 00:12:47,826 A:middle
but we've set it, of course, to
a valid string representation

301
00:12:47,826 --> 00:12:50,406 A:middle
of an integer and so
toInt method has a result

302
00:12:50,406 --> 00:12:54,786 A:middle
to return 243 and the entire
expression is completely

303
00:12:54,786 --> 00:12:57,676 A:middle
evaluated it's wrapped
back up in an optional

304
00:12:58,096 --> 00:13:00,526 A:middle
so that the address
number is now an optional

305

306
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

307
00:12:58,096 --> 00:13:00,526 A:middle
so that the address
number is now an optional

308
00:13:00,796 --> 00:13:02,996 A:middle
with an underlying value of 243,

309
00:13:03,756 --> 00:13:06,276 A:middle
but because it's an optional
value if I need to use it

310
00:13:07,246 --> 00:13:09,986 A:middle
as a real integer, I
need to unwrap it still.

311
00:13:10,466 --> 00:13:12,856 A:middle
Actually we can combine
these operations together,

312
00:13:12,856 --> 00:13:17,206 A:middle
optional chaining, and if let
syntax are optional binding,

313
00:13:17,576 --> 00:13:20,226 A:middle
to test and unwrap it
at the same time again.

314
00:13:20,566 --> 00:13:23,116 A:middle
So here we can take the entire
optional chained expression

315
00:13:23,386 --> 00:13:27,766 A:middle
and evaluate it, see if it isn't
nil, unwrap it and assign it

316
00:13:27,766 --> 00:13:28,596 A:middle
to the address variable.

317
00:13:28,876 --> 00:13:30,996 A:middle
We can use it like an
ordinary non-optional type.

318
00:13:31,446 --> 00:13:32,846 A:middle
For example, to add
it to a database.

319
00:13:34,236 --> 00:13:35,686 A:middle
So that's how optionals work.

320
00:13:36,516 --> 00:13:39,546 A:middle
[ Applause ]

321
00:13:40,046 --> 00:13:40,766 A:middle
It's pretty cool.

322
00:13:41,166 --> 00:13:42,476 A:middle
So that's how optionals works.

323
00:13:42,476 --> 00:13:43,816 A:middle
It's how optional
chaining works,

324
00:13:43,816 --> 00:13:46,316 A:middle
how optional binding works,
I want to take a step back

325
00:13:46,806 --> 00:13:48,866 A:middle
and show you what optionals
look like under the hood.

326
00:13:49,376 --> 00:13:51,366 A:middle
I don't want to spend a lot
of time here but I do want

327
00:13:51,366 --> 00:13:52,946 A:middle
to show you how powerful

328
00:13:52,946 --> 00:13:54,916 A:middle
and expressive the Swift
programming language is

329
00:13:55,226 --> 00:13:57,566 A:middle
that we can actually model
something so fundamental

330
00:13:57,566 --> 00:14:01,046 A:middle
to the language like optionals
in the language itself.

331

332
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

333
00:13:57,566 --> 00:14:01,046 A:middle
to the language like optionals
in the language itself.

334
00:14:01,626 --> 00:14:04,636 A:middle
So optionals are really
just a simple enumeration,

335
00:14:05,286 --> 00:14:07,566 A:middle
a generic enumeration
at that, of any type.

336
00:14:07,876 --> 00:14:10,596 A:middle
You can see the sum type
here represents the case

337
00:14:10,596 --> 00:14:13,686 A:middle
in which I said there is a
value present that's wrapped up.

338
00:14:13,906 --> 00:14:15,516 A:middle
You can see that
wrapping here going on

339
00:14:15,896 --> 00:14:19,376 A:middle
and the None case just simply is
a default value which we've said

340
00:14:19,376 --> 00:14:20,796 A:middle
that you can indicate using nil.

341
00:14:22,126 --> 00:14:24,466 A:middle
We haven't talked too much about
generics and we're not going

342
00:14:24,466 --> 00:14:27,176 A:middle
to go into generics in much
detail here, but I encourage you

343
00:14:27,176 --> 00:14:29,756 A:middle
to watch the Advanced Swift talk
where you can see the full power

344
00:14:29,756 --> 00:14:32,476 A:middle
of generics in action.

345
00:14:32,656 --> 00:14:33,636 A:middle
So that's optionals.

346
00:14:34,316 --> 00:14:37,186 A:middle
You use optionals to
work safely in your code

347
00:14:37,186 --> 00:14:38,756 A:middle
with possibly missing values.

348
00:14:39,706 --> 00:14:40,896 A:middle
Missing values are nil

349
00:14:40,896 --> 00:14:43,766 A:middle
and present values are
wrapped up in the optionals.

350
00:14:44,256 --> 00:14:46,576 A:middle
You can then unwrap the
optionals in two ways;

351
00:14:46,576 --> 00:14:49,196 A:middle
either with a forced-unwrapping
operator but only do

352
00:14:49,196 --> 00:14:51,466 A:middle
that if you're sure there's a
value there and it's not nil,

353
00:14:52,186 --> 00:14:55,376 A:middle
and you can also use if let
syntax or optional binding

354
00:14:55,376 --> 00:14:58,276 A:middle
to unwrap and test at the
same time in a very safe way.

355
00:14:59,026 --> 00:15:02,226 A:middle
And finally, you can use
optional chaining to work

356

357
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

358
00:14:59,026 --> 00:15:02,226 A:middle
And finally, you can use
optional chaining to work

359
00:15:02,226 --> 00:15:03,836 A:middle
in a very succinct
and eloquent way

360
00:15:04,196 --> 00:15:06,616 A:middle
with multiple optional
expressions chained together

361
00:15:06,616 --> 00:15:08,336 A:middle
and that's optionals.

362
00:15:08,696 --> 00:15:11,096 A:middle
So, I'd like to invite Joe back
on the stage to talk to you

363
00:15:11,096 --> 00:15:12,386 A:middle
about memory management
in Swift.

364
00:15:13,516 --> 00:15:15,546 A:middle
[ Applause ]

365
00:15:16,046 --> 00:15:18,246 A:middle
>> My name is Joe Groff, I
work on the Swift compiler,

366
00:15:18,356 --> 00:15:21,666 A:middle
and I'm really excited because
managing memory is my favorite

367
00:15:21,666 --> 00:15:24,116 A:middle
thing to do when I program.

368
00:15:24,976 --> 00:15:26,266 A:middle
No, it's not.

369
00:15:26,956 --> 00:15:29,226 A:middle
Thankfully Swift is built

370
00:15:29,226 --> 00:15:32,076 A:middle
on automatic reference
counting the same model we used

371
00:15:32,076 --> 00:15:33,586 A:middle
in Objective-C or ARC.

372
00:15:35,216 --> 00:15:39,496 A:middle
We don't make you use pointer
syntax, we don't make you spell

373
00:15:39,496 --> 00:15:42,426 A:middle
out Alec, but still we need
a clear class like this

374
00:15:42,716 --> 00:15:47,166 A:middle
and a constructed class you get
a memory allocation implicitly

375
00:15:47,316 --> 00:15:50,926 A:middle
and a reference to that is what
gets stored in a local variable

376
00:15:50,926 --> 00:15:54,006 A:middle
and it's these references
that keep that memory alive.

377
00:15:55,426 --> 00:15:57,986 A:middle
Now we can juggle a couple
of these bowling pins here

378
00:15:57,986 --> 00:16:01,306 A:middle
and when the last reference
to a class goes away,

379

380
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

381
00:15:57,986 --> 00:16:01,306 A:middle
and when the last reference
to a class goes away,

382
00:16:01,306 --> 00:16:05,716 A:middle
an object goes away, the object
automatically gets deallocated.

383
00:16:06,386 --> 00:16:08,006 A:middle
ARC is a horrible
juggler but it's great

384
00:16:08,006 --> 00:16:09,606 A:middle
at reclaiming unused memory.

385
00:16:10,166 --> 00:16:13,636 A:middle
When a reference
goes out of scope,

386
00:16:13,636 --> 00:16:15,706 A:middle
it's automatically
released but as long

387
00:16:15,706 --> 00:16:18,206 A:middle
as you have some reference to
the object, it's kept alive

388
00:16:19,296 --> 00:16:22,386 A:middle
and only when the final
reference is released is the

389
00:16:22,386 --> 00:16:23,576 A:middle
object deallocated.

390
00:16:23,946 --> 00:16:27,586 A:middle
It's safe, it's predictable,
it just works.

391
00:16:28,616 --> 00:16:31,036 A:middle
Except for those cycles.

392
00:16:31,916 --> 00:16:35,146 A:middle
Sometimes it doesn't make sense
for an object to be owned.

393
00:16:35,666 --> 00:16:39,766 A:middle
For instance, apartments
literally aren't owned

394
00:16:39,766 --> 00:16:42,206 A:middle
by their tenants but
they also will have

395
00:16:42,206 --> 00:16:43,666 A:middle
like multiple people
living in them

396
00:16:43,666 --> 00:16:45,236 A:middle
over the lifetime
of the building.

397
00:16:46,506 --> 00:16:48,806 A:middle
On the other hand, a person
will move from apartment

398
00:16:48,806 --> 00:16:50,046 A:middle
to apartment over their life.

399
00:16:50,496 --> 00:16:54,646 A:middle
Even if you move a
person into an apartment,

400
00:16:56,516 --> 00:16:59,696 A:middle
this relationship isn't
really an owning relationship.

401
00:16:59,696 --> 00:17:04,036 A:middle
And there's a problem if
we try to model it as such.

402

403
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

404
00:16:59,696 --> 00:17:04,036 A:middle
And there's a problem if
we try to model it as such.

405
00:17:04,566 --> 00:17:08,715 A:middle
Let's set up a dictionary
of our renters

406
00:17:08,715 --> 00:17:10,576 A:middle
and our apartments
say we're a landlord.

407
00:17:11,516 --> 00:17:14,675 A:middle
Let's move one of tenants,
Elsvette, into her apartment.

408
00:17:15,486 --> 00:17:16,536 A:middle
Now there's a problem.

409
00:17:17,286 --> 00:17:20,236 A:middle
If she tries to move
out, she's trapped.

410
00:17:21,336 --> 00:17:24,376 A:middle
The reference to the apartment
keeps her object alive

411
00:17:24,376 --> 00:17:27,945 A:middle
and even worse if we try to sell
off the property we're stuck

412
00:17:27,945 --> 00:17:28,626 A:middle
with the deed.

413
00:17:29,546 --> 00:17:33,476 A:middle
Both objects keep each other
alive in a reference cycle.

414
00:17:35,296 --> 00:17:38,556 A:middle
So like Objective-C,
we have weak references

415
00:17:38,966 --> 00:17:42,026 A:middle
and these tell Swift that
this object isn't responsible

416
00:17:42,026 --> 00:17:44,116 A:middle
for keeping the object
on the other end alive.

417
00:17:44,686 --> 00:17:49,736 A:middle
Now, when we work through the
example again, a weak reference

418
00:17:49,736 --> 00:17:54,366 A:middle
between these two
objects Elsvette can move

419
00:17:54,366 --> 00:17:59,566 A:middle
out of her apartment and make a
clean break with her landlord.

420

421
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

422
00:18:00,146 --> 00:18:03,266 A:middle
And the reference
automatically gets reset to nil.

423
00:18:04,266 --> 00:18:07,306 A:middle
There's no dangling reference
to the allocated object.

424
00:18:08,516 --> 00:18:11,116 A:middle
Now of course, when we sell off
the property, both objects end

425
00:18:11,116 --> 00:18:12,786 A:middle
up deallocated and
there's no leak.

426
00:18:13,226 --> 00:18:19,296 A:middle
And weak references in Swift
are modeled as optional values.

427
00:18:19,296 --> 00:18:20,946 A:middle
You can use all the
optional operations

428
00:18:20,946 --> 00:18:23,036 A:middle
that Brian just showed
you to work with them

429
00:18:23,036 --> 00:18:26,426 A:middle
and when you take an
optional weak value

430
00:18:26,516 --> 00:18:29,466 A:middle
and you bind the
non-optional part

431
00:18:29,466 --> 00:18:33,496 A:middle
out of it you get a
strong non-optional value

432
00:18:33,496 --> 00:18:35,186 A:middle
and you can safely
work with that just

433
00:18:35,186 --> 00:18:36,426 A:middle
like any other reference.

434
00:18:37,516 --> 00:18:39,556 A:middle
If you're applying a
single method or looking

435
00:18:39,556 --> 00:18:41,376 A:middle
at the single property
conditionally

436
00:18:41,376 --> 00:18:42,716 A:middle
on a weak reference object,

437
00:18:42,716 --> 00:18:45,796 A:middle
you can also use the chaining
operator as a nice shorthand.

438
00:18:46,336 --> 00:18:50,646 A:middle
Some things to be aware
of are that the test

439
00:18:50,646 --> 00:18:53,506 A:middle
and unwrap pattern does not
work very well with weak.

440
00:18:54,386 --> 00:18:56,716 A:middle
You could go to cash your
tenant's rent check and find

441
00:18:56,716 --> 00:18:59,636 A:middle
out it bounced and evict
them before you have a chance

442
00:18:59,636 --> 00:19:00,956 A:middle
to even greet them and end

443

444
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

445
00:18:59,636 --> 00:19:00,956 A:middle
to even greet them and end

446
00:19:00,956 --> 00:19:05,596 A:middle
up with a runtime error
you didn't expect.

447
00:19:05,716 --> 00:19:08,886 A:middle
Chaining also doesn't preserve
a strong reference if you use it

448
00:19:08,886 --> 00:19:11,806 A:middle
to try to apply multiple
methods to the same object.

449
00:19:12,296 --> 00:19:17,656 A:middle
Here cashRentCheck could again
cause the tenant to get released

450
00:19:17,656 --> 00:19:22,026 A:middle
and then we'd end up getting a
nil object and then, in fact,

451
00:19:22,096 --> 00:19:23,576 A:middle
not calling greet at all.

452
00:19:27,456 --> 00:19:29,746 A:middle
Weak references are
great for breaking cycles

453
00:19:29,846 --> 00:19:31,696 A:middle
but they aren't always ideal.

454
00:19:32,266 --> 00:19:35,476 A:middle
Let's say we're a
modern landlord

455
00:19:35,476 --> 00:19:37,546 A:middle
and we accept credit card
payments from our tenants.

456
00:19:37,836 --> 00:19:40,136 A:middle
A dream I know but bear with me.

457
00:19:40,866 --> 00:19:44,376 A:middle
Now a credit card
should only ever be owned

458
00:19:44,376 --> 00:19:45,826 A:middle
by one person, right?

459
00:19:46,416 --> 00:19:48,846 A:middle
So we really want this to
be an immutable binding,

460
00:19:48,846 --> 00:19:51,766 A:middle
an immutable property
of the credit card.

461
00:19:52,766 --> 00:19:56,016 A:middle
We also don't even really
want to track a credit card

462
00:19:56,016 --> 00:19:57,666 A:middle
if it isn't owned by a person.

463
00:19:58,106 --> 00:19:59,766 A:middle
It shouldn't be an
optional property.

464

465
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

466
00:20:01,616 --> 00:20:04,686 A:middle
There's obviously a cycle here
and we could break that cycle

467
00:20:04,686 --> 00:20:07,096 A:middle
with weak references
but that forces us

468
00:20:07,096 --> 00:20:09,866 A:middle
into some unfortunate
loosening of the model here.

469
00:20:10,776 --> 00:20:13,196 A:middle
First of all weak
references have to be optional

470
00:20:14,056 --> 00:20:17,136 A:middle
because they have to
be resettable to nil.

471
00:20:17,356 --> 00:20:19,706 A:middle
Second of all they
have to be mutable

472
00:20:20,026 --> 00:20:23,406 A:middle
because they could be
reset to nil at any time

473
00:20:24,086 --> 00:20:26,866 A:middle
and we don't really want this.

474
00:20:27,636 --> 00:20:30,376 A:middle
We could end up accidently
reassigning a credit card

475
00:20:30,776 --> 00:20:34,706 A:middle
or ending up with an
orphan credit card just

476
00:20:34,706 --> 00:20:36,876 A:middle
to deal with memory leaks.

477
00:20:37,086 --> 00:20:38,366 A:middle
That would suck.

478
00:20:39,196 --> 00:20:40,676 A:middle
So, instead, we have
another kind

479
00:20:40,676 --> 00:20:42,366 A:middle
of weak reference the
unowned reference.

480
00:20:42,846 --> 00:20:45,246 A:middle
What this tells Swift is

481
00:20:45,246 --> 00:20:48,216 A:middle
that although I don't have an
owning stake in the object,

482
00:20:48,576 --> 00:20:49,806 A:middle
my life depends on it.

483
00:20:51,036 --> 00:20:54,846 A:middle
I cannot live without my
owner, my card holder.

484
00:20:58,776 --> 00:21:00,756 A:middle
So we can go back to
our renter's table,

485

486
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

487
00:20:58,776 --> 00:21:00,756 A:middle
So we can go back to
our renter's table,

488
00:21:01,216 --> 00:21:03,686 A:middle
we can save our tenant's
credit card information

489
00:21:03,686 --> 00:21:07,286 A:middle
and you can see here that the
credit card is uniquely owned

490
00:21:07,556 --> 00:21:11,076 A:middle
by the person record so that

491
00:21:11,076 --> 00:21:14,876 A:middle
when her record is reallocated
the entire object graph

492
00:21:14,876 --> 00:21:15,806 A:middle
gets allocated.

493
00:21:16,116 --> 00:21:21,046 A:middle
There's no need to observe
the credit card independent

494
00:21:21,046 --> 00:21:21,886 A:middle
of the person.

495
00:21:22,426 --> 00:21:25,446 A:middle
And because there's
this assumption

496
00:21:25,446 --> 00:21:28,936 A:middle
that the program is not
correct without the object

497
00:21:28,936 --> 00:21:31,546 A:middle
on the other side, you can
use unknown references just

498
00:21:31,546 --> 00:21:32,636 A:middle
like strong references.

499
00:21:32,636 --> 00:21:34,636 A:middle
You can assign them
into a local variable

500
00:21:35,066 --> 00:21:36,876 A:middle
or you can call methods
on them directly.

501
00:21:37,686 --> 00:21:39,996 A:middle
It's a bit like unsafe,
unretained in C

502
00:21:40,106 --> 00:21:42,476 A:middle
or Objective-C but
it's still safe.

503
00:21:42,476 --> 00:21:45,616 A:middle
We still assert that the object
is still allocated every time

504
00:21:45,616 --> 00:21:47,366 A:middle
you access it through
an unowned reference.

505
00:21:47,806 --> 00:21:52,006 A:middle
So let's look at three kinds
of references in Swift.

506
00:21:53,386 --> 00:21:55,646 A:middle
Strong references are
the default and that's

507
00:21:55,646 --> 00:21:57,356 A:middle
because they're what you
should use most of the time.

508
00:21:57,496 --> 00:21:59,416 A:middle
Most of the time you
have an ownership stake

509
00:21:59,416 --> 00:22:03,686 A:middle
in an object you want to use.

510

511
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

512
00:21:59,416 --> 00:22:03,686 A:middle
in an object you want to use.

513
00:22:03,686 --> 00:22:05,736 A:middle
However, if you have
independent objects,

514
00:22:05,736 --> 00:22:08,426 A:middle
objects with independent
lifetimes, sort of a, you know,

515
00:22:08,426 --> 00:22:10,896 A:middle
a casual relationship
going on where you can move

516
00:22:10,896 --> 00:22:14,046 A:middle
on if they went away,
weak references are great

517
00:22:14,046 --> 00:22:15,476 A:middle
for modeling that sort of thing.

518
00:22:16,006 --> 00:22:18,296 A:middle
If part of your program
ends up deallocated due

519
00:22:18,296 --> 00:22:21,796 A:middle
to maybe low memory, the rest
of your program marches on

520
00:22:22,026 --> 00:22:23,666 A:middle
and optionals are a
great way of dealing

521
00:22:23,926 --> 00:22:25,966 A:middle
with weak referenced
objects going away.

522
00:22:26,536 --> 00:22:30,916 A:middle
And unowned references are
great for back references

523
00:22:30,916 --> 00:22:33,426 A:middle
from dependent objects
backed up to their owners.

524
00:22:34,516 --> 00:22:36,166 A:middle
If part of the object
graph goes away,

525
00:22:36,166 --> 00:22:37,996 A:middle
the entire object
graph goes away

526
00:22:37,996 --> 00:22:39,976 A:middle
and there's no need
to deal with nil.

527
00:22:41,176 --> 00:22:42,846 A:middle
And that's memory
management with Swift.

528
00:22:43,436 --> 00:22:46,796 A:middle
It's automatic, it's automatic
reference counting, it's safe

529
00:22:47,326 --> 00:22:50,126 A:middle
and it lets you think
about the relationships

530
00:22:50,126 --> 00:22:53,096 A:middle
between your objects rather
than the raw mechanics

531
00:22:53,096 --> 00:22:55,086 A:middle
of memory management
making strong,

532
00:22:55,086 --> 00:22:58,846 A:middle
weak and unknown references
to model those relationships

533
00:22:59,426 --> 00:23:02,076 A:middle
and provides a nice, safe
foundation for Swift.

534

535
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

536
00:22:59,426 --> 00:23:02,076 A:middle
and provides a nice, safe
foundation for Swift.

537
00:23:02,076 --> 00:23:05,406 A:middle
To talk a little bit more
about that foundation I'm going

538
00:23:05,406 --> 00:23:08,046 A:middle
to bring it back to Brian to
talk about initialization.

539
00:23:09,516 --> 00:23:11,556 A:middle
[ Applause ]

540
00:23:12,056 --> 00:23:13,946 A:middle
>> Thank you, Joe,
thank you, Joe.

541
00:23:14,116 --> 00:23:16,506 A:middle
So I want to talk to you
about initialization in Swift.

542
00:23:17,426 --> 00:23:22,776 A:middle
Initialization in Swift follows
one very simple rule and that's

543
00:23:22,806 --> 00:23:25,726 A:middle
that every value must be
initialized before it's used.

544
00:23:27,066 --> 00:23:29,996 A:middle
This one simple rule is
enforced by the compiler

545
00:23:29,996 --> 00:23:32,956 A:middle
and it ensures memory
safety in your code.

546
00:23:34,356 --> 00:23:37,666 A:middle
It ensures that you never
read from uninitialized memory

547
00:23:38,066 --> 00:23:38,626 A:middle
and it, therefore,

548
00:23:38,626 --> 00:23:40,536 A:middle
helps eliminate an
entire class of bugs.

549
00:23:42,146 --> 00:23:44,756 A:middle
Let's look at how this rule
applies throughout the language.

550
00:23:44,756 --> 00:23:48,546 A:middle
So let's start with
the simple variables.

551
00:23:49,176 --> 00:23:51,896 A:middle
Swift doesn't default
initialized variables,

552
00:23:52,366 --> 00:23:56,966 A:middle
constants, or properties because
there often isn't a natural

553
00:23:56,966 --> 00:23:58,566 A:middle
and correct value
for everything.

554
00:23:59,056 --> 00:24:02,296 A:middle
The only exception to this is
optionals where we saw earlier

555

556
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

557
00:23:59,056 --> 00:24:02,296 A:middle
The only exception to this is
optionals where we saw earlier

558
00:24:02,296 --> 00:24:05,296 A:middle
that optionals have a very
natural default value of nil.

559
00:24:06,186 --> 00:24:09,466 A:middle
This means that you need to
set these values explicitly

560
00:24:09,466 --> 00:24:11,976 A:middle
in your code, but it
doesn't mean that you need

561
00:24:11,976 --> 00:24:14,426 A:middle
to declare these
values at the point

562
00:24:14,476 --> 00:24:17,176 A:middle
that you declare your variable
as constants or properties.

563
00:24:17,516 --> 00:24:20,276 A:middle
It just means that you must
do so before you try to read

564
00:24:20,276 --> 00:24:21,526 A:middle
from them or access them.

565
00:24:22,756 --> 00:24:26,556 A:middle
For example, say we
wanted to set message here

566
00:24:27,226 --> 00:24:30,076 A:middle
to an appropriate value
depending on whether

567
00:24:30,076 --> 00:24:33,406 A:middle
or not a condition was true and
then print that message out.

568
00:24:34,126 --> 00:24:36,566 A:middle
Even though the condition is
true in this case, I mean we're

569
00:24:36,566 --> 00:24:37,916 A:middle
in the middle of the
session after all,

570
00:24:38,626 --> 00:24:40,046 A:middle
we'd get a compiler error

571
00:24:40,546 --> 00:24:45,576 A:middle
because we haven't considered
every possible branch

572
00:24:45,626 --> 00:24:46,436 A:middle
in our code.

573
00:24:47,116 --> 00:24:49,556 A:middle
We haven't said what
the value of messages

574
00:24:49,846 --> 00:24:51,256 A:middle
when the condition is false.

575
00:24:52,546 --> 00:24:56,506 A:middle
So let's add an else
clause to do just that.

576
00:24:56,676 --> 00:24:59,206 A:middle
Now when we read for message
to print it out we can be sure

577
00:24:59,206 --> 00:25:02,396 A:middle
that it has an explicit value
for every single condition

578

579
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

580
00:24:59,206 --> 00:25:02,396 A:middle
that it has an explicit value
for every single condition

581
00:25:02,616 --> 00:25:07,346 A:middle
in our code, but now as I'm sure
you're all aware it's quite easy

582
00:25:07,346 --> 00:25:09,896 A:middle
to forget to check all of
the conditions in your code.

583
00:25:10,546 --> 00:25:15,206 A:middle
So rather than surprising you
by unexpected and hard to track

584
00:25:15,206 --> 00:25:19,096 A:middle
down behavior, the Swift
compiler catches these kinds

585
00:25:19,096 --> 00:25:21,786 A:middle
of mistakes for you and
ensures that you're explicit

586
00:25:21,786 --> 00:25:24,056 A:middle
about the values you want
to set for every branch

587
00:25:24,056 --> 00:25:25,796 A:middle
and under every condition
in your code.

588
00:25:26,506 --> 00:25:28,066 A:middle
This is great for memory safety.

589
00:25:28,706 --> 00:25:31,966 A:middle
Now that we've seen
how this rule applies

590
00:25:31,966 --> 00:25:34,356 A:middle
to simple variables,
let's see how it applies

591
00:25:34,806 --> 00:25:38,486 A:middle
when you're defining your
own classes like, classes

592
00:25:38,486 --> 00:25:41,736 A:middle
or structures, your own types.

593
00:25:41,916 --> 00:25:45,786 A:middle
So, inside of the structure are
class declaration initializers

594
00:25:45,786 --> 00:25:47,116 A:middle
handle this responsibility.

595
00:25:47,336 --> 00:25:49,416 A:middle
They handle the responsibility
of satisfying the rule

596
00:25:49,416 --> 00:25:52,826 A:middle
that everything is
set before it's used.

597
00:25:53,906 --> 00:25:56,876 A:middle
Now, you've seen some
initializers in some

598
00:25:56,876 --> 00:25:59,406 A:middle
of Joe's examples and memory
management just a while ago

599
00:25:59,406 --> 00:26:02,106 A:middle
and they're declared
using the key word in it

600

601
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

602
00:25:59,406 --> 00:26:02,106 A:middle
and they're declared
using the key word in it

603
00:26:03,166 --> 00:26:05,896 A:middle
and they're invoked
at object creation

604
00:26:06,096 --> 00:26:11,736 A:middle
or instance creation here
using this initializer syntax.

605
00:26:11,736 --> 00:26:14,466 A:middle
Now initializers can have any
number of labeled arguments

606
00:26:14,466 --> 00:26:18,756 A:middle
or parameters and when
they do you need to call,

607
00:26:18,756 --> 00:26:21,236 A:middle
you need to call it using
these label parameters.

608
00:26:21,236 --> 00:26:23,226 A:middle
They're required
at the call site.

609
00:26:24,356 --> 00:26:27,606 A:middle
Before we look at initialization
in classes, let's take a look

610
00:26:27,606 --> 00:26:30,416 A:middle
at initialization and how
it works in structures.

611
00:26:31,216 --> 00:26:32,766 A:middle
Let's define a simple
color structure

612
00:26:33,156 --> 00:26:35,986 A:middle
that has three properties,
red, green and blue

613
00:26:35,986 --> 00:26:38,806 A:middle
to represent the color
components and we'll deal

614
00:26:38,806 --> 00:26:42,626 A:middle
with alpha later, now let's say
that we want to create colors

615
00:26:42,626 --> 00:26:43,736 A:middle
in different shades of gray.

616
00:26:44,696 --> 00:26:47,936 A:middle
Well to do so we can define a
single initializer here a very

617
00:26:47,936 --> 00:26:50,016 A:middle
simple one that simply has,

618
00:26:50,486 --> 00:26:55,336 A:middle
takes a single gray scale
double value and sets all

619
00:26:55,336 --> 00:26:58,576 A:middle
of the stored properties of the
structure to that same value.

620
00:26:58,776 --> 00:27:01,846 A:middle
Now, if we had forgotten to set
the red property, for example,

621

622
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

623
00:26:58,776 --> 00:27:01,846 A:middle
Now, if we had forgotten to set
the red property, for example,

624
00:27:02,496 --> 00:27:03,726 A:middle
we'd get a compiler error

625
00:27:03,996 --> 00:27:05,626 A:middle
because we haven't
satisfied the rule

626
00:27:05,626 --> 00:27:08,496 A:middle
that every value must be
initialized before it's used.

627
00:27:09,566 --> 00:27:11,736 A:middle
The same is true
for calling a method

628
00:27:12,316 --> 00:27:15,006 A:middle
in your initializer before you
set all of your properties.

629
00:27:16,256 --> 00:27:19,076 A:middle
For example, say we want to
validate, we want a method

630
00:27:19,076 --> 00:27:21,646 A:middle
that validates the color
components to make sure they're

631
00:27:21,646 --> 00:27:26,046 A:middle
within a valid range
of values say 0 to 1.0.

632
00:27:27,166 --> 00:27:29,826 A:middle
If we then call this
method here inside

633
00:27:29,826 --> 00:27:32,596 A:middle
of the initializer before we
set all of our properties,

634
00:27:33,296 --> 00:27:36,356 A:middle
we'd again get a compiler
error because we're trying

635
00:27:36,356 --> 00:27:38,646 A:middle
to call a method on
self on the instance,

636
00:27:39,436 --> 00:27:41,606 A:middle
but before self has
been fully initialized.

637
00:27:42,556 --> 00:27:46,126 A:middle
So if you need to access self
just customize any property

638
00:27:46,126 --> 00:27:48,926 A:middle
values or to call on the
methods in your initializer,

639
00:27:49,526 --> 00:27:52,316 A:middle
always do so after you've set
all of your stored properties

640
00:27:52,316 --> 00:27:53,336 A:middle
to appropriate values.

641
00:27:55,156 --> 00:27:57,726 A:middle
Now in structures, if
you don't define any

642
00:27:57,726 --> 00:28:00,526 A:middle
of your own initializers,
Swift provides you

643

644
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

645
00:27:57,726 --> 00:28:00,526 A:middle
of your own initializers,
Swift provides you

646
00:28:00,526 --> 00:28:03,656 A:middle
with a memberwise
initializer automatically.

647
00:28:05,116 --> 00:28:08,276 A:middle
The memberwise initializer
has arguments that correspond

648
00:28:08,276 --> 00:28:11,556 A:middle
to each of that instances
store, each of that classes

649
00:28:11,556 --> 00:28:12,746 A:middle
or structures stored property.

650
00:28:13,636 --> 00:28:16,886 A:middle
You can also provide default
values in line directly

651
00:28:17,156 --> 00:28:19,526 A:middle
for your stored properties
and when you've set all

652
00:28:19,526 --> 00:28:21,986 A:middle
of your stored properties
and you haven't defined any

653
00:28:21,986 --> 00:28:23,526 A:middle
of your own custom initializers,

654
00:28:24,606 --> 00:28:27,436 A:middle
Swift provides a default
initializer for you to use

655
00:28:27,626 --> 00:28:30,666 A:middle
that takes no parameters
and creates an instance

656
00:28:30,666 --> 00:28:33,516 A:middle
with the properties you
set as default values

657
00:28:34,116 --> 00:28:35,286 A:middle
when you declare your structure.

658
00:28:37,106 --> 00:28:39,376 A:middle
So that's how initialization
works in structures.

659
00:28:40,576 --> 00:28:43,936 A:middle
Now let's take a look at
how it works in classes.

660
00:28:44,106 --> 00:28:45,166 A:middle
Really it's no different.

661
00:28:46,786 --> 00:28:48,616 A:middle
So let's start with a
simple car class here

662
00:28:49,686 --> 00:28:51,996 A:middle
that has a single
property, a paint color,

663
00:28:52,326 --> 00:28:55,056 A:middle
and a single initializer that
just sets that paint color

664
00:28:55,326 --> 00:28:56,306 A:middle
to an appropriate value.

665
00:28:56,306 --> 00:28:58,876 A:middle
Now, in practice, classes

666
00:28:59,056 --> 00:29:01,336 A:middle
and often subclass
inherit from other classes.

667

668
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

669
00:28:59,056 --> 00:29:01,336 A:middle
and often subclass
inherit from other classes.

670
00:29:01,636 --> 00:29:04,316 A:middle
So we need to deal with
how initialization works

671
00:29:04,316 --> 00:29:05,496 A:middle
with subclasses as well.

672
00:29:07,036 --> 00:29:09,506 A:middle
So let's define a
subclass called RaceCar

673
00:29:09,546 --> 00:29:12,516 A:middle
and it has one extra property
and its own initializer.

674
00:29:13,586 --> 00:29:15,416 A:middle
When the RaceCar's
initializer is called,

675
00:29:16,206 --> 00:29:18,146 A:middle
it first sets its own properties

676
00:29:19,046 --> 00:29:21,606 A:middle
and then it called the
super class initializer.

677
00:29:22,206 --> 00:29:26,326 A:middle
And the super class
initializer, of course,

678
00:29:26,326 --> 00:29:28,946 A:middle
sets its own properties to
an appropriate value as well

679
00:29:29,866 --> 00:29:32,686 A:middle
and only after the super class
and all the super classes

680
00:29:32,686 --> 00:29:35,746 A:middle
in the class hierarchy
have had a chance

681
00:29:35,746 --> 00:29:39,356 A:middle
to set their own values is
a class fully initialized

682
00:29:39,356 --> 00:29:40,326 A:middle
and ready to use.

683
00:29:41,466 --> 00:29:43,406 A:middle
Now if you're coming from
an Objective-C background,

684
00:29:44,326 --> 00:29:46,976 A:middle
you probably noticed that
this is opposite or different

685
00:29:47,346 --> 00:29:50,156 A:middle
than what you've noticed than
what you do in Objective-C

686
00:29:50,376 --> 00:29:53,746 A:middle
where you always call
your super class first

687
00:29:53,746 --> 00:29:55,366 A:middle
and then you set
your own properties.

688
00:29:58,806 --> 00:30:00,776 A:middle
So in Swift if we
were to do this,

689

690
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

691
00:29:58,806 --> 00:30:00,776 A:middle
So in Swift if we
were to do this,

692
00:30:00,776 --> 00:30:02,936 A:middle
if we were to call our super
class initializer first

693
00:30:03,206 --> 00:30:04,586 A:middle
and then set our own properties,

694
00:30:05,816 --> 00:30:07,346 A:middle
we would actually
get a compiler error

695
00:30:07,346 --> 00:30:10,236 A:middle
because it's not always
safe to do so in this order

696
00:30:11,086 --> 00:30:13,846 A:middle
and the reason Swift's
initialization follows this

697
00:30:13,846 --> 00:30:18,236 A:middle
order is that it ensures memory
safety so that you don't try

698
00:30:18,356 --> 00:30:20,556 A:middle
to access memory before it's
been completely initialized.

699
00:30:20,556 --> 00:30:24,056 A:middle
Now it may not be obvious where
you might run into problems

700
00:30:24,096 --> 00:30:26,756 A:middle
by doing things in this order so
let's take a look at an example

701
00:30:26,756 --> 00:30:29,846 A:middle
where calling your super class
initializer first is unsafe.

702
00:30:31,446 --> 00:30:33,886 A:middle
Let's say, for example, that
we want to define a function

703
00:30:33,976 --> 00:30:37,146 A:middle
or method on our car class
that fills up the gas tank

704
00:30:37,146 --> 00:30:39,766 A:middle
and we want to call that
function inside the initializer

705
00:30:39,766 --> 00:30:41,836 A:middle
so that every time we
get a new car it comes

706
00:30:41,836 --> 00:30:45,296 A:middle
with a full gas tank and because
race cars use a different kind

707
00:30:45,296 --> 00:30:46,566 A:middle
of gas than regular cars,

708
00:30:46,946 --> 00:30:49,256 A:middle
we've overridden this
method in our subclass.

709
00:30:50,396 --> 00:30:52,886 A:middle
So, when we create
a new race car

710
00:30:53,536 --> 00:30:55,066 A:middle
and its initializer is called,

711
00:30:55,806 --> 00:30:57,896 A:middle
it's first called
super class initializer

712
00:30:58,756 --> 00:31:00,756 A:middle
which then sets its
paint color properties

713

714
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

715
00:30:58,756 --> 00:31:00,756 A:middle
which then sets its
paint color properties

716
00:31:01,306 --> 00:31:03,476 A:middle
and finally calls its
fillGasTank method,

717
00:31:04,356 --> 00:31:07,306 A:middle
but because we've overridden
our subclass it gets dynamically

718
00:31:07,306 --> 00:31:11,806 A:middle
dispatched to the subclass's
version of that same method

719
00:31:12,516 --> 00:31:13,876 A:middle
and that's where
we have a problem.

720
00:31:15,366 --> 00:31:17,306 A:middle
And our problem is that
we haven't got a chance

721
00:31:17,306 --> 00:31:20,356 A:middle
in our own initializer
to set our own properties

722
00:31:20,586 --> 00:31:22,886 A:middle
and so we're trying to
call a method on self.

723
00:31:23,196 --> 00:31:25,516 A:middle
We're trying to access this
object or this instance

724
00:31:25,746 --> 00:31:28,486 A:middle
that hasn't been fully
initialized and that's not safe.

725
00:31:29,926 --> 00:31:34,286 A:middle
So in Swift, we always make sure
we set our own properties before

726
00:31:34,286 --> 00:31:36,446 A:middle
we call our super
class's initializer

727
00:31:36,946 --> 00:31:38,156 A:middle
to have a chance to do the same.

728
00:31:39,846 --> 00:31:43,126 A:middle
So far we've just seen
examples of a single initializer

729
00:31:43,126 --> 00:31:46,156 A:middle
in a class, but you can
have multiple initializers

730
00:31:46,156 --> 00:31:48,036 A:middle
in your class just like
you can in Objective-C.

731
00:31:48,036 --> 00:31:52,356 A:middle
In fact, you can have designated
initializers what we've seen

732
00:31:52,356 --> 00:31:55,846 A:middle
so far designated initializers
which you may be familiar

733
00:31:55,846 --> 00:31:58,986 A:middle
with coming from Objective-C
have the sole responsibility

734
00:31:58,986 --> 00:32:01,436 A:middle
of creating an object and
setting all of its properties

735

736
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

737
00:31:58,986 --> 00:32:01,436 A:middle
of creating an object and
setting all of its properties

738
00:32:01,926 --> 00:32:04,926 A:middle
and it has a job of calling
the super class's initializer

739
00:32:05,196 --> 00:32:06,386 A:middle
and delegating up.

740
00:32:06,626 --> 00:32:08,176 A:middle
Like you can think of
them as funnel points

741
00:32:08,176 --> 00:32:10,946 A:middle
that funnel the initialization
process all the way to the class

742
00:32:11,496 --> 00:32:12,906 A:middle
to the base class and hierarchy,

743
00:32:13,116 --> 00:32:15,456 A:middle
but you can also have
convenience initializers.

744
00:32:15,776 --> 00:32:18,966 A:middle
Convenience initializers are
sort of secondary initializers

745
00:32:19,266 --> 00:32:24,316 A:middle
that provide an alternative
implementation initialization

746
00:32:24,316 --> 00:32:28,676 A:middle
interface that allows you
to say pass default values

747
00:32:28,916 --> 00:32:30,556 A:middle
and make it easier for
your clients to use.

748
00:32:30,796 --> 00:32:32,686 A:middle
They can only call across.

749
00:32:32,786 --> 00:32:36,836 A:middle
They can only delegate side
to side in a particular class.

750
00:32:36,866 --> 00:32:37,966 A:middle
They never call up.

751
00:32:38,156 --> 00:32:40,616 A:middle
So they can call designated
initializers in the same class

752
00:32:40,956 --> 00:32:42,656 A:middle
or other convenience
initializers

753
00:32:43,046 --> 00:32:45,086 A:middle
but ultimately these
convenience initializers need

754
00:32:45,086 --> 00:32:47,716 A:middle
to call a designated to
actually do the heavy lifting

755
00:32:47,716 --> 00:32:48,786 A:middle
of setting the properties.

756
00:32:49,816 --> 00:32:52,176 A:middle
So let's see how you might
write a convenience initializer

757
00:32:52,406 --> 00:32:53,176 A:middle
in your own code.

758
00:32:53,726 --> 00:32:55,776 A:middle
Say we have RaceCar
again and we want

759
00:32:55,776 --> 00:32:57,206 A:middle
to create a convenience
initializer

760
00:32:57,206 --> 00:32:59,376 A:middle
that lets it just
pass in a color

761
00:32:59,376 --> 00:33:03,006 A:middle
and it sets the turbo
property to true and it does

762

763
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

764
00:32:59,376 --> 00:33:03,006 A:middle
and it sets the turbo
property to true and it does

765
00:33:03,006 --> 00:33:04,446 A:middle
so by delegating this task

766
00:33:05,116 --> 00:33:07,356 A:middle
to the designated
initializer in the same class.

767
00:33:08,676 --> 00:33:10,846 A:middle
Now when we do this
kind of thing in Swift,

768
00:33:10,936 --> 00:33:12,756 A:middle
when we define a
convenience initializer,

769
00:33:13,026 --> 00:33:14,446 A:middle
we need to let the
Swift compiler know

770
00:33:14,746 --> 00:33:16,676 A:middle
by including the
convenience key word

771
00:33:16,946 --> 00:33:18,116 A:middle
in front of the declaration.

772
00:33:19,236 --> 00:33:22,146 A:middle
We can even provide more than
one convenience initializer

773
00:33:22,706 --> 00:33:25,826 A:middle
so we can even provide a
convenience initializer

774
00:33:25,826 --> 00:33:28,656 A:middle
that lets us create a RaceCar
providing no parameters at all

775
00:33:28,866 --> 00:33:32,976 A:middle
and then delegates this task
here providing a default gray

776
00:33:32,976 --> 00:33:36,556 A:middle
value and it calls the other
convenience initializer we've

777
00:33:36,556 --> 00:33:38,766 A:middle
just declared and that
in turn, of course,

778
00:33:39,066 --> 00:33:40,796 A:middle
has to call the designated
initializer

779
00:33:40,796 --> 00:33:43,806 A:middle
to actually set the values and
because we have a super class

780
00:33:43,806 --> 00:33:45,776 A:middle
to deal with here,
that initializer needs

781
00:33:45,776 --> 00:33:46,556 A:middle
to call its super class.

782
00:33:47,866 --> 00:33:50,406 A:middle
And how are initializers
inherited in Swift?

783
00:33:51,186 --> 00:33:53,466 A:middle
Well, they're not
inherited by default

784
00:33:54,256 --> 00:33:55,946 A:middle
because doing so
isn't always safe.

785
00:33:57,526 --> 00:34:00,966 A:middle
However, when your class
provides no initializers at all

786

787
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

788
00:33:57,526 --> 00:34:00,966 A:middle
However, when your class
provides no initializers at all

789
00:34:01,476 --> 00:34:04,386 A:middle
and you set default values for
all of its stored properties

790
00:34:04,386 --> 00:34:06,336 A:middle
as we've done here with
the FormulaOne RaceCar

791
00:34:06,336 --> 00:34:08,266 A:middle
where we've set a
single stored property

792
00:34:08,266 --> 00:34:11,045 A:middle
to a minimum regulation
weight and since we know

793
00:34:11,045 --> 00:34:12,476 A:middle
that weight we can
set it directly.

794
00:34:12,476 --> 00:34:16,606 A:middle
Now when we do this, we actually
inherit automatically all

795
00:34:16,606 --> 00:34:18,025 A:middle
of the initializers
of the super class

796
00:34:18,025 --> 00:34:19,996 A:middle
that includes designated
initializers

797
00:34:20,266 --> 00:34:22,136 A:middle
and the convenience initializers
that we've declared.

798
00:34:22,896 --> 00:34:24,815 A:middle
Now, if we did this in
this particular case,

799
00:34:24,815 --> 00:34:26,835 A:middle
we'd have a problem because one

800
00:34:26,835 --> 00:34:29,735 A:middle
of the convenience initializers
we've inherited sets the wrong

801
00:34:29,735 --> 00:34:30,656 A:middle
value for turbo.

802
00:34:31,226 --> 00:34:34,056 A:middle
Formula One race cars aren't
allowed to have a turbo

803
00:34:34,226 --> 00:34:36,266 A:middle
by regulation and so this
wouldn't be appropriate

804
00:34:36,266 --> 00:34:36,896 A:middle
in this case.

805
00:34:37,516 --> 00:34:39,826 A:middle
So instead we'll define
our own initializer here

806
00:34:39,906 --> 00:34:41,916 A:middle
and now it's a designated
initializer

807
00:34:41,916 --> 00:34:44,966 A:middle
because it calls super and
passes that turbo value of false

808
00:34:46,206 --> 00:34:47,886 A:middle
and because we've done
this we've provided our own

809
00:34:47,886 --> 00:34:51,436 A:middle
initializer, we actually don't
inherit those other convenience

810
00:34:51,436 --> 00:34:53,666 A:middle
initializers or the other
designated initializer.

811
00:34:54,786 --> 00:34:58,846 A:middle
So that's how you would use
initializers to set properties

812
00:34:58,846 --> 00:35:01,396 A:middle
and how you can set
properties in line directly,

813

814
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

815
00:34:58,846 --> 00:35:01,396 A:middle
and how you can set
properties in line directly,

816
00:35:02,196 --> 00:35:04,336 A:middle
but I haven't told you about a
pattern and you may be familiar

817
00:35:04,336 --> 00:35:07,886 A:middle
with from Objective-C sometimes
called lazy instantiation

818
00:35:07,886 --> 00:35:12,056 A:middle
or lazy initialization where
you want to delay the evaluation

819
00:35:12,296 --> 00:35:16,156 A:middle
of a property in setting
it because, for example,

820
00:35:16,156 --> 00:35:18,786 A:middle
maybe doing so is
computationally expensive.

821
00:35:19,706 --> 00:35:23,616 A:middle
So we have the same concept
in Swift using lazy properties

822
00:35:24,296 --> 00:35:27,336 A:middle
and let's take a
look at an example

823
00:35:27,336 --> 00:35:29,466 A:middle
of where you might use one,
where it might be appropriate.

824
00:35:29,466 --> 00:35:32,276 A:middle
Say we have a game class and
the game can either be a single

825
00:35:32,276 --> 00:35:33,896 A:middle
player game or a
multi-player game.

826
00:35:34,606 --> 00:35:38,636 A:middle
Now, the multiplayerManager
let's just suppose

827
00:35:38,966 --> 00:35:41,326 A:middle
that it does a bunch of
expensive computation

828
00:35:41,646 --> 00:35:43,206 A:middle
and so we don't want
to create it

829
00:35:43,956 --> 00:35:45,716 A:middle
if there's only ever
a single player.

830
00:35:46,766 --> 00:35:48,816 A:middle
We only want to create it
when there's multiple players.

831
00:35:49,476 --> 00:35:51,536 A:middle
So we want to delay
that initialization

832
00:35:51,536 --> 00:35:52,646 A:middle
until it's appropriate.

833
00:35:53,246 --> 00:35:59,356 A:middle
So we can do this in Swift by
including the @lazy attribute

834
00:35:59,356 --> 00:36:00,786 A:middle
in front of the declaration here

835

836
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

837
00:35:59,356 --> 00:36:00,786 A:middle
in front of the declaration here

838
00:36:01,376 --> 00:36:05,086 A:middle
and when we do this it will
only be evaluated the time it's

839
00:36:05,086 --> 00:36:08,086 A:middle
accessed and only when it's
accessed and only that one time.

840
00:36:08,636 --> 00:36:10,226 A:middle
Now just as we have
initialization

841
00:36:10,226 --> 00:36:10,966 A:middle
in Swift, we also have --

842
00:36:11,516 --> 00:36:16,716 A:middle
[ Applause ]

843
00:36:17,216 --> 00:36:18,476 A:middle
Just as we have initialization

844
00:36:18,476 --> 00:36:20,116 A:middle
in Swift we have
deinitialization.

845
00:36:20,116 --> 00:36:22,426 A:middle
Deinitialization is responsible
for tearing down the object.

846
00:36:22,796 --> 00:36:25,916 A:middle
Now as Joe has already
told you, memory management

847
00:36:25,916 --> 00:36:28,846 A:middle
in Swift is automatic so most
of the time you don't even need

848
00:36:28,906 --> 00:36:31,196 A:middle
to think about the
initialization it just works,

849
00:36:31,196 --> 00:36:32,226 A:middle
it just happens for you.

850
00:36:33,446 --> 00:36:36,566 A:middle
But for cases where you
do need it, for example,

851
00:36:36,566 --> 00:36:39,756 A:middle
to unregister yourself as
an observer or, for example,

852
00:36:39,756 --> 00:36:41,686 A:middle
to close a file that
you may have opened,

853
00:36:42,306 --> 00:36:45,236 A:middle
we want to have a chance to
close that file and clean

854
00:36:45,236 --> 00:36:46,836 A:middle
up those non-memory resources.

855
00:36:47,296 --> 00:36:50,566 A:middle
So for that we use
a deinitializer

856
00:36:50,926 --> 00:36:53,756 A:middle
and deinitializers are just
declared using the deinit

857
00:36:53,806 --> 00:36:54,166 A:middle
key word.

858
00:36:54,456 --> 00:36:56,876 A:middle
So, for example, here we have
a class that when we open

859
00:36:56,876 --> 00:36:59,706 A:middle
up a file if this class gets
deallocated before we have a

860
00:36:59,706 --> 00:37:03,816 A:middle
chance to close the file,
that's not good so think of this

861

862
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

863
00:36:59,706 --> 00:37:03,816 A:middle
chance to close the file,
that's not good so think of this

864
00:37:03,816 --> 00:37:06,496 A:middle
as the last resort, the last
chance you have to clean

865
00:37:06,496 --> 00:37:10,176 A:middle
up non-memory resources before
your object is deallocated.

866
00:37:11,106 --> 00:37:13,016 A:middle
Again most of the time you
probably won't need them.

867
00:37:13,656 --> 00:37:15,076 A:middle
So that's initialization
in Swift.

868
00:37:15,316 --> 00:37:15,876 A:middle
It's safe.

869
00:37:16,696 --> 00:37:19,386 A:middle
You initialize all of your
values before you use them

870
00:37:19,386 --> 00:37:22,216 A:middle
and set your stored
property values first

871
00:37:22,806 --> 00:37:25,086 A:middle
and then call your super
class initializer always

872
00:37:25,086 --> 00:37:25,626 A:middle
in that order.

873
00:37:26,416 --> 00:37:28,536 A:middle
Designated initializers
only delegate up

874
00:37:28,976 --> 00:37:31,896 A:middle
and convenience initializers
only delegate across.

875
00:37:32,816 --> 00:37:35,916 A:middle
And finally, we have the
initializers if you need them,

876
00:37:36,296 --> 00:37:37,386 A:middle
but most of the time you won't.

877
00:37:37,386 --> 00:37:39,456 A:middle
So that's initialization.

878
00:37:39,456 --> 00:37:41,586 A:middle
I'd like to invite Joe back
on the stage to talk to you

879
00:37:41,586 --> 00:37:42,576 A:middle
about closures in Swift.

880
00:37:43,516 --> 00:37:50,826 A:middle
[ Applause ]

881
00:37:51,326 --> 00:37:54,366 A:middle
>> Now, there are a lot
of ways to sort an array

882
00:37:54,366 --> 00:37:57,686 A:middle
and we could keep our standard
library writers busy writing a

883
00:37:57,686 --> 00:38:01,356 A:middle
million different sort methods
on array, but we'd rather not.

884

885
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

886
00:37:57,686 --> 00:38:01,356 A:middle
million different sort methods
on array, but we'd rather not.

887
00:38:01,676 --> 00:38:04,566 A:middle
So instead we have a single sort
method that takes a closure.

888
00:38:04,646 --> 00:38:06,656 A:middle
You've probably seen a bit
of this in the intro talk

889
00:38:06,656 --> 00:38:07,776 A:middle
or even in the keynotes.

890
00:38:08,766 --> 00:38:13,096 A:middle
A closure in Swift is
spelled inside curly braces.

891
00:38:13,976 --> 00:38:15,466 A:middle
You follow it with a signature.

892
00:38:15,466 --> 00:38:18,696 A:middle
In the case of sort,
it takes two arguments

893
00:38:18,696 --> 00:38:20,666 A:middle
of the element type of the
array, in this case String,

894
00:38:20,666 --> 00:38:23,396 A:middle
and in terms of Boolean telling
us whether the elements are

895
00:38:23,396 --> 00:38:24,546 A:middle
sorted in the right order.

896
00:38:25,606 --> 00:38:26,886 A:middle
Default with the in key word,

897
00:38:26,886 --> 00:38:30,466 A:middle
you're binding these arguments
inside the body of the closure

898
00:38:30,926 --> 00:38:34,786 A:middle
and then you follow it with
the body of the function.

899
00:38:35,346 --> 00:38:40,406 A:middle
And now we have a single sort
method that can sort an array

900
00:38:40,406 --> 00:38:41,736 A:middle
in a number of different ways.

901
00:38:42,366 --> 00:38:45,976 A:middle
We can sort A to Z ascending
using the lesson operator.

902
00:38:46,736 --> 00:38:49,776 A:middle
We can sort descending using
the greater than operator.

903
00:38:50,336 --> 00:38:54,916 A:middle
We can even do something like
sort from shortest to longest

904
00:38:54,916 --> 00:38:56,876 A:middle
by counting the number of
characters in each string.

905
00:38:57,566 --> 00:39:00,656 A:middle
Now this is a great interface.

906

907
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

908
00:38:57,566 --> 00:39:00,656 A:middle
Now this is a great interface.

909
00:39:01,076 --> 00:39:04,866 A:middle
It's also a lot of
typing and closures

910
00:39:04,866 --> 00:39:07,286 A:middle
in this form are a little
awkward to work with

911
00:39:07,796 --> 00:39:11,776 A:middle
and the actual interesting
part gets lost

912
00:39:11,776 --> 00:39:13,486 A:middle
in a lot of syntactic noise.

913
00:39:14,686 --> 00:39:16,976 A:middle
Thankfully we have type
inference to help us here.

914
00:39:17,286 --> 00:39:18,926 A:middle
Let's open a definition
of sorts.

915
00:39:20,216 --> 00:39:22,936 A:middle
Sort, of course, already knows
what kind of closure it takes.

916
00:39:22,936 --> 00:39:25,736 A:middle
In this case, we're working
with an array of strings

917
00:39:25,736 --> 00:39:28,056 A:middle
so it takes two strings
and returns a Bool.

918
00:39:28,056 --> 00:39:32,336 A:middle
Let's look at the
call side again

919
00:39:32,336 --> 00:39:36,026 A:middle
and that's really offensive,

920
00:39:36,026 --> 00:39:38,306 A:middle
that's really burning
my eyes here and I want

921
00:39:39,396 --> 00:39:42,526 A:middle
to do something about that.

922
00:39:42,746 --> 00:39:43,456 A:middle
Much better.

923
00:39:44,446 --> 00:39:47,066 A:middle
We can infer the
argument and return types

924
00:39:47,376 --> 00:39:49,416 A:middle
from the signature
of the function.

925
00:39:49,966 --> 00:39:53,746 A:middle
That's a great improvement
but we don't stop there.

926
00:39:54,176 --> 00:39:56,496 A:middle
If a closure consists of
a single return statement

927
00:39:56,496 --> 00:39:59,336 A:middle
like this, we don't
need to specify return.

928
00:39:59,746 --> 00:40:03,766 A:middle
A single expression closure
implicitly returns its results.

929

930
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

931
00:39:59,746 --> 00:40:03,766 A:middle
A single expression closure
implicitly returns its results.

932
00:40:04,516 --> 00:40:07,576 A:middle
[ Applause ]

933
00:40:08,076 --> 00:40:08,456 A:middle
Thank you.

934
00:40:10,116 --> 00:40:12,996 A:middle
At this point even the
argument list is starting

935
00:40:12,996 --> 00:40:14,056 A:middle
to look a little heavy.

936
00:40:14,466 --> 00:40:15,656 A:middle
Let's get rid of
that too [laughter].

937
00:40:17,306 --> 00:40:21,836 A:middle
There are implicit argument
names, $0, $1, $ a million,

938
00:40:22,136 --> 00:40:24,416 A:middle
they may need a little taste
in some cases but they're there

939
00:40:24,416 --> 00:40:26,846 A:middle
if you need them and they
make closures really succinct

940
00:40:26,846 --> 00:40:29,236 A:middle
and easy to use.

941
00:40:29,406 --> 00:40:31,786 A:middle
We've also seen that we have
trailing closure syntax.

942
00:40:32,156 --> 00:40:34,106 A:middle
When you have a single
argument like this,

943
00:40:35,216 --> 00:40:37,966 A:middle
you can move it outside and when
it's the only argument you can

944
00:40:37,966 --> 00:40:39,356 A:middle
drop the parens all together.

945
00:40:40,426 --> 00:40:42,136 A:middle
And this makes functional
programming

946
00:40:42,136 --> 00:40:44,526 A:middle
in Swift really expressive
and fun to do

947
00:40:44,526 --> 00:40:49,336 A:middle
and we've added methods to the
array class, to the array struct

948
00:40:49,376 --> 00:40:51,366 A:middle
to make this possible.

949
00:40:52,116 --> 00:40:53,836 A:middle
I'll start with a
list of all the words

950
00:40:53,836 --> 00:40:56,726 A:middle
in the English language that we
got from the dictionary service.

951
00:40:57,086 --> 00:41:03,006 A:middle
Now we can pick out words
that share some common traits,

952

953
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

954
00:40:57,086 --> 00:41:03,006 A:middle
Now we can pick out words
that share some common traits,

955
00:41:03,006 --> 00:41:04,806 A:middle
say the ones that end
in G-R-Y and it turns

956
00:41:04,806 --> 00:41:07,496 A:middle
out there's only two and we
can use the filter method

957
00:41:07,956 --> 00:41:12,476 A:middle
which selects out, which applies
a closure to each element

958
00:41:12,476 --> 00:41:16,956 A:middle
of the array and for the one it
returns true returns a new array

959
00:41:16,956 --> 00:41:17,936 A:middle
containing those.

960
00:41:18,336 --> 00:41:23,326 A:middle
We can then transform
these with the map method,

961
00:41:23,656 --> 00:41:25,246 A:middle
which applies closure
to each element

962
00:41:25,246 --> 00:41:27,646 A:middle
and collects the results
into another array.

963
00:41:28,166 --> 00:41:31,016 A:middle
And then we can use
the reduced method

964
00:41:31,296 --> 00:41:34,246 A:middle
to fold these into
a single string.

965
00:41:37,136 --> 00:41:40,406 A:middle
Now each of these is
chaining another method call

966
00:41:40,406 --> 00:41:42,456 A:middle
onto the result of the
previous expression.

967
00:41:42,926 --> 00:41:45,686 A:middle
Even if we're using trailing
closure syntax we can just chain

968
00:41:45,686 --> 00:41:48,216 A:middle
method invocations
using dot like this.

969
00:41:49,196 --> 00:41:53,236 A:middle
Because it's a single expression
we can even include it in a

970
00:41:53,236 --> 00:41:58,276 A:middle
yet larger expression and
include a lot of complex logic

971
00:41:58,276 --> 00:42:00,296 A:middle
into a very small
amount of code.

972

973
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

974
00:41:58,276 --> 00:42:00,296 A:middle
into a very small
amount of code.

975
00:42:00,976 --> 00:42:06,376 A:middle
It's an extremely expressive
way to build up your logic even

976
00:42:06,446 --> 00:42:08,806 A:middle
for a code that doesn't
involve Hulk.

977
00:42:09,516 --> 00:42:15,916 A:middle
[ Applause ]

978
00:42:16,416 --> 00:42:18,366 A:middle
Closures can also
capture local states.

979
00:42:18,936 --> 00:42:23,516 A:middle
We could sum up all the elements
in array using a for loop

980
00:42:23,516 --> 00:42:27,406 A:middle
or reduce but we can
actually abuse math to do it.

981
00:42:27,676 --> 00:42:30,196 A:middle
Inside of closure we can
refer to local variables

982
00:42:30,196 --> 00:42:31,466 A:middle
and we can even mutate them.

983
00:42:31,466 --> 00:42:35,636 A:middle
There's never need to mark
them under block or in any way.

984
00:42:35,636 --> 00:42:36,526 A:middle
It just works.

985
00:42:37,676 --> 00:42:43,796 A:middle
And then we can return
that result.

986
00:42:43,796 --> 00:42:47,226 A:middle
Closures are really just
literal functions in Swift just

987
00:42:47,226 --> 00:42:48,996 A:middle
like you can pass
a literal integer

988
00:42:48,996 --> 00:42:51,746 A:middle
or a named integer constant
as an integer parameter,

989
00:42:51,746 --> 00:42:54,666 A:middle
you can pass a closure
or, indeed,

990
00:42:54,666 --> 00:42:57,076 A:middle
a named function
as a closure value.

991
00:42:57,336 --> 00:43:00,296 A:middle
We don't have to wrap up print
line in a closure like this.

992

993
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

994
00:42:57,336 --> 00:43:00,296 A:middle
We don't have to wrap up print
line in a closure like this.

995
00:43:01,196 --> 00:43:02,426 A:middle
We can just pass print line.

996
00:43:02,426 --> 00:43:04,516 A:middle
There's only one kind of
function type in Swift.

997
00:43:05,056 --> 00:43:09,136 A:middle
We can even do this with
bound methods instead

998
00:43:09,136 --> 00:43:12,516 A:middle
of packing an index set
like this wrapping a call

999
00:43:12,516 --> 00:43:16,126 A:middle
to the method in a closure we
can just pass the bound method

1000
00:43:16,126 --> 00:43:17,626 A:middle
directly as a function value.

1001
00:43:20,836 --> 00:43:23,206 A:middle
Closures in Swift
are just ARC objects.

1002
00:43:23,206 --> 00:43:25,766 A:middle
They follow the same memory
management rules as classes.

1003
00:43:25,766 --> 00:43:29,486 A:middle
So if we wanted to
have a global variable

1004
00:43:29,486 --> 00:43:33,786 A:middle
that we can install a call
back on and write a function

1005
00:43:34,326 --> 00:43:41,836 A:middle
that installs a call back using
local state of that function,

1006
00:43:41,936 --> 00:43:44,476 A:middle
that reference will keep
that closure and all

1007
00:43:44,476 --> 00:43:45,656 A:middle
of its local state alive.

1008
00:43:45,656 --> 00:43:47,806 A:middle
There's never a need to
explicitly copy a closure

1009
00:43:47,806 --> 00:43:50,586 A:middle
or to worry about dangling
references to its environment

1010
00:43:51,106 --> 00:43:53,976 A:middle
and just like closures
of functions,

1011
00:43:54,036 --> 00:43:55,356 A:middle
functions are also closures.

1012
00:43:55,356 --> 00:43:58,616 A:middle
We can nest functions inside
other functions and refer

1013
00:43:58,616 --> 00:44:00,576 A:middle
to the local state of
the outer function.

1014

1015
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1016
00:43:58,616 --> 00:44:00,576 A:middle
to the local state of
the outer function.

1017
00:44:01,116 --> 00:44:03,306 A:middle
If we look at these in the
debugger or instruments,

1018
00:44:03,306 --> 00:44:04,756 A:middle
they show up with their names.

1019
00:44:05,326 --> 00:44:10,936 A:middle
So when we store a reference
to this in a global variable,

1020
00:44:11,596 --> 00:44:13,586 A:middle
even when the local
function goes out of scope

1021
00:44:14,206 --> 00:44:16,466 A:middle
that reference keeps the
local function alive just

1022
00:44:16,466 --> 00:44:17,196 A:middle
like the closure.

1023
00:44:17,806 --> 00:44:23,326 A:middle
Now because closures are ARC
objects they have the same

1024
00:44:23,326 --> 00:44:26,836 A:middle
ownership and reference cycle
problems as classes can have.

1025
00:44:27,426 --> 00:44:29,956 A:middle
If we did something
as seemingly innocent

1026
00:44:29,956 --> 00:44:33,716 A:middle
as taking this call back and
putting it into the property

1027
00:44:33,826 --> 00:44:37,026 A:middle
of a class, we'll
have a problem.

1028
00:44:38,406 --> 00:44:41,306 A:middle
When we go to set up
these objects, of course,

1029
00:44:41,476 --> 00:44:43,606 A:middle
what we're really doing
is we're capturing self

1030
00:44:43,606 --> 00:44:46,106 A:middle
and we're capturing it as
a strong reference and then

1031
00:44:46,106 --> 00:44:48,826 A:middle
when we store reference to
the closure inside the class,

1032
00:44:49,546 --> 00:44:53,706 A:middle
we end up with the reference
cycle and a memory leak.

1033
00:44:54,666 --> 00:44:59,156 A:middle
The compiler actually won't let
you implicitly reference self

1034
00:44:59,156 --> 00:45:01,136 A:middle
inside of closure
because of this problem.

1035

1036
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1037
00:44:59,156 --> 00:45:01,136 A:middle
inside of closure
because of this problem.

1038
00:45:01,396 --> 00:45:04,816 A:middle
Yeah, it's pretty nice.

1039
00:45:05,526 --> 00:45:08,346 A:middle
Now in a past life, you may
have solved this using unknown

1040
00:45:08,346 --> 00:45:11,946 A:middle
reference, using a local
variable with weak ownership.

1041
00:45:12,886 --> 00:45:15,696 A:middle
In Swift, we can use
unowned ownership instead,

1042
00:45:16,666 --> 00:45:18,976 A:middle
but this is problematic.

1043
00:45:18,976 --> 00:45:21,536 A:middle
Even if we did this if
someone cut and pasted code

1044
00:45:21,536 --> 00:45:23,426 A:middle
into this closure, it
would still be capturing

1045
00:45:23,426 --> 00:45:24,366 A:middle
self strongly.

1046
00:45:24,686 --> 00:45:26,356 A:middle
So we have a better
way to do it in Swift.

1047
00:45:27,136 --> 00:45:29,676 A:middle
You can specify directly
inside the closure how

1048
00:45:29,676 --> 00:45:31,176 A:middle
to capture its local states.

1049
00:45:32,516 --> 00:45:37,006 A:middle
[ Applause ]

1050
00:45:37,506 --> 00:45:39,086 A:middle
And now when we set
up the object graph,

1051
00:45:39,136 --> 00:45:41,326 A:middle
there's no longer a cycle
and there's no leak.

1052
00:45:41,946 --> 00:45:44,716 A:middle
So that's closures in Swift.

1053
00:45:44,716 --> 00:45:47,656 A:middle
They have an incredibly
expressive syntax

1054
00:45:48,966 --> 00:45:51,456 A:middle
and a much simplified memory
model from Objective-C

1055
00:45:51,456 --> 00:45:53,406 A:middle
and they make functional
programming

1056
00:45:53,406 --> 00:45:55,346 A:middle
in Swift really awesome
and powerful.

1057
00:45:55,346 --> 00:45:59,326 A:middle
Now I'd like to talk about
another powerful feature

1058
00:45:59,326 --> 00:46:01,116 A:middle
of Swift, pattern matching.

1059

1060
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1061
00:45:59,326 --> 00:46:01,116 A:middle
of Swift, pattern matching.

1062
00:46:01,716 --> 00:46:08,136 A:middle
You may have seen in the intro
talk that Switch not only works

1063
00:46:08,136 --> 00:46:11,496 A:middle
with integers it also works
with strings or, indeed,

1064
00:46:11,496 --> 00:46:15,826 A:middle
values of any type and also
works with ranges of values

1065
00:46:15,896 --> 00:46:18,006 A:middle
but that's just the
tip of the iceberg.

1066
00:46:19,156 --> 00:46:21,326 A:middle
You may also remember
that enumerations

1067
00:46:21,326 --> 00:46:24,606 A:middle
in Swift can carry associated
data and we can tell not only

1068
00:46:24,606 --> 00:46:27,076 A:middle
that a train is delayed
we can say by how much

1069
00:46:27,296 --> 00:46:29,366 A:middle
with an integer value
that only makes sense

1070
00:46:30,526 --> 00:46:31,896 A:middle
when the train is delayed.

1071
00:46:33,276 --> 00:46:37,516 A:middle
Because this associated data is
tied to that case of the enum,

1072
00:46:38,626 --> 00:46:40,536 A:middle
we access it through
a case statement.

1073
00:46:41,776 --> 00:46:43,796 A:middle
We combine it to a
variable and then use

1074
00:46:43,796 --> 00:46:45,966 A:middle
that variable inside
that case statement.

1075
00:46:46,246 --> 00:46:48,886 A:middle
It's electrically
scoped to that case.

1076
00:46:49,406 --> 00:46:52,476 A:middle
Cases are electrical
scopes by default in Swift

1077
00:46:52,476 --> 00:46:54,316 A:middle
and we can't access
it anywhere else.

1078
00:46:54,316 --> 00:46:57,276 A:middle
It's much safer and easier
than using an enum with a union

1079
00:46:57,276 --> 00:46:59,076 A:middle
or struct like you
may have in C.

1080
00:46:59,566 --> 00:47:03,326 A:middle
Now this is a simple
case of a pattern.

1081

1082
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1083
00:46:59,566 --> 00:47:03,326 A:middle
Now this is a simple
case of a pattern.

1084
00:47:04,126 --> 00:47:08,906 A:middle
This outer construct
Delayed only matches values

1085
00:47:08,906 --> 00:47:11,486 A:middle
of the delayed state
inside the enum.

1086
00:47:12,966 --> 00:47:16,196 A:middle
If it is at the delayed state,
it unwraps the associated data

1087
00:47:16,196 --> 00:47:17,996 A:middle
and passes it down
to a sub pattern.

1088
00:47:18,196 --> 00:47:21,106 A:middle
In this case, the let pattern
binds it to a variable.

1089
00:47:21,586 --> 00:47:25,446 A:middle
This is actually a
completely independent

1090
00:47:25,446 --> 00:47:26,666 A:middle
and fully powerful pattern.

1091
00:47:26,666 --> 00:47:29,226 A:middle
Anything we do at the
top level of a switch

1092
00:47:29,226 --> 00:47:31,746 A:middle
with an int we can do
to its associated value.

1093
00:47:32,806 --> 00:47:35,456 A:middle
So we can match it against a
specific value say we're delayed

1094
00:47:35,456 --> 00:47:36,256 A:middle
by 1 minute.

1095
00:47:36,856 --> 00:47:37,946 A:middle
We can match it against a range

1096
00:47:37,946 --> 00:47:40,166 A:middle
of values say we're delayed
from 2 to 10 minutes.

1097
00:47:41,046 --> 00:47:42,876 A:middle
We can also ignore the
value all together,

1098
00:47:42,876 --> 00:47:45,796 A:middle
match any Delay using
the underscore,

1099
00:47:45,796 --> 00:47:47,946 A:middle
which is the wild card pattern.

1100
00:47:48,516 --> 00:47:54,646 A:middle
[ Applause ]

1101
00:47:55,146 --> 00:47:58,266 A:middle
You can also use enums as
associated data of other enums.

1102
00:47:58,796 --> 00:48:02,296 A:middle
We can track not only the status

1103

1104
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1105
00:47:58,796 --> 00:48:02,296 A:middle
We can track not only the status

1106
00:48:02,296 --> 00:48:05,246 A:middle
of our train while we're
traveling we can track the

1107
00:48:05,246 --> 00:48:07,526 A:middle
entire state of our
vacation and when we do so,

1108
00:48:07,526 --> 00:48:08,706 A:middle
we can tell our friends

1109
00:48:08,706 --> 00:48:10,526 A:middle
on social media based
on that state.

1110
00:48:11,246 --> 00:48:13,056 A:middle
We can match a simple
case of the enum,

1111
00:48:13,736 --> 00:48:17,196 A:middle
we can match a nested associated
value two levels deep.

1112
00:48:17,296 --> 00:48:20,346 A:middle
If we're 15 minutes in, we might
be able to, 15 minutes delayed,

1113
00:48:20,346 --> 00:48:22,896 A:middle
we might be a little
snarky, but still composed.

1114
00:48:23,596 --> 00:48:24,756 A:middle
If we're delayed
any more than that,

1115
00:48:24,756 --> 00:48:26,826 A:middle
we might get a little upset.

1116
00:48:30,296 --> 00:48:31,816 A:middle
Pattern matching
doesn't just work

1117
00:48:31,816 --> 00:48:33,206 A:middle
with enumerations it also works

1118
00:48:33,206 --> 00:48:35,656 A:middle
with the dynamic
types of classes.

1119
00:48:36,166 --> 00:48:40,106 A:middle
Let's say we're going to tune up
a car and it's an arbitrary car.

1120
00:48:40,766 --> 00:48:44,046 A:middle
If someone brings a Formula
One car into our mechanics,

1121
00:48:44,046 --> 00:48:48,296 A:middle
to our mechanic, he's probably
going to be a little confused.

1122
00:48:48,296 --> 00:48:49,886 A:middle
He might want to take
it to a specialist.

1123
00:48:50,786 --> 00:48:52,716 A:middle
We can do this using
the as pattern.

1124
00:48:53,276 --> 00:48:56,136 A:middle
This will both check that
the value is of a type and if

1125
00:48:56,136 --> 00:48:59,516 A:middle
so cast it and pass it
into the sub pattern,

1126
00:48:59,516 --> 00:49:02,906 A:middle
which we can then use to bind a
variable and then we can pass it

1127

1128
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1129
00:48:59,516 --> 00:49:02,906 A:middle
which we can then use to bind a
variable and then we can pass it

1130
00:49:02,906 --> 00:49:06,416 A:middle
on to a pit crew who will then
tune up that Formula One car.

1131
00:49:07,516 --> 00:49:11,396 A:middle
For a more mundane car, we
can pattern match it and then

1132
00:49:11,396 --> 00:49:14,406 A:middle
if it has a turbo tune up
the turbo before following

1133
00:49:14,456 --> 00:49:17,996 A:middle
through using the fall through
statement into the default case

1134
00:49:18,196 --> 00:49:22,986 A:middle
that does the normal
tune up for a car.

1135
00:49:23,186 --> 00:49:26,096 A:middle
We can also pattern match
multiple values simultaneously

1136
00:49:26,096 --> 00:49:27,036 A:middle
using tuples.

1137
00:49:27,446 --> 00:49:30,006 A:middle
Tuples are a great way of
returning multiple values

1138
00:49:30,006 --> 00:49:33,846 A:middle
from a function or for
combining related values

1139
00:49:33,846 --> 00:49:39,236 A:middle
like the components of a color
and when we do so, each element

1140
00:49:39,236 --> 00:49:41,566 A:middle
of this tuple pattern is
an independent pattern.

1141
00:49:42,346 --> 00:49:46,506 A:middle
We can match red against a
single value, we can match green

1142
00:49:46,506 --> 00:49:49,876 A:middle
against a range of values,
bind blue to a variable

1143
00:49:50,206 --> 00:49:54,826 A:middle
and ignore the alpha component
all in a single pattern.

1144
00:49:55,516 --> 00:49:59,726 A:middle
[ Applause ]

1145

1146
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1147
00:50:00,226 --> 00:50:02,366 A:middle
We can also match
multiple values

1148
00:50:02,366 --> 00:50:03,866 A:middle
and test additional conditions

1149
00:50:03,866 --> 00:50:05,706 A:middle
with those values
using a where clause.

1150
00:50:06,626 --> 00:50:08,376 A:middle
Here we're testing that
they're all equal to see

1151
00:50:08,376 --> 00:50:09,606 A:middle
if it's a grey scale value.

1152
00:50:10,186 --> 00:50:13,956 A:middle
So these are some
neat parlor tricks.

1153
00:50:14,166 --> 00:50:16,086 A:middle
Let's try something
a little more real.

1154
00:50:16,086 --> 00:50:21,186 A:middle
Let's validate a property list,
a dictionary of arbitrary values

1155
00:50:21,186 --> 00:50:24,976 A:middle
of unknown type and
given a valid one we want

1156
00:50:24,976 --> 00:50:27,386 A:middle
to return a well-typed struct.

1157
00:50:30,756 --> 00:50:35,236 A:middle
Given a property list with
a name key that's a string,

1158
00:50:35,306 --> 00:50:36,796 A:middle
a population that's a number

1159
00:50:37,056 --> 00:50:39,026 A:middle
and a two-letter
postal abbreviation,

1160
00:50:39,026 --> 00:50:42,056 A:middle
we want to get a
record like this.

1161
00:50:42,266 --> 00:50:44,756 A:middle
However, if one of the
fields is of the wrong type

1162
00:50:44,756 --> 00:50:50,256 A:middle
or if the postal abbreviation is
too long, we want to return nil.

1163
00:50:51,126 --> 00:50:52,766 A:middle
Let's see how we can do
this with pattern matching.

1164
00:50:53,436 --> 00:50:59,466 A:middle
We'll start with a single
key of the property list

1165
00:50:59,806 --> 00:51:05,466 A:middle
and you may remember that
optional is just an enumeration

1166

1167
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1168
00:50:59,806 --> 00:51:05,466 A:middle
and you may remember that
optional is just an enumeration

1169
00:51:05,466 --> 00:51:07,246 A:middle
so we can use an
enumeration pattern

1170
00:51:07,246 --> 00:51:09,936 A:middle
to both reject property
lists that don't have the key

1171
00:51:10,166 --> 00:51:14,476 A:middle
and unwrap the value
for ones that do.

1172
00:51:14,726 --> 00:51:17,906 A:middle
Inside that pattern we
can use a type pattern

1173
00:51:17,906 --> 00:51:20,916 A:middle
to both reject property lists
that don't have a string name

1174
00:51:21,356 --> 00:51:23,796 A:middle
and get the string value
out for those that do.

1175
00:51:24,896 --> 00:51:27,856 A:middle
Then we can use a let pattern
to bind to that string value

1176
00:51:28,446 --> 00:51:29,726 A:middle
and store it to a variable

1177
00:51:30,296 --> 00:51:34,616 A:middle
with a single default clause
handle all invalid names.

1178
00:51:35,056 --> 00:51:38,726 A:middle
Now we can repeat this for
each element that we care

1179
00:51:38,726 --> 00:51:41,736 A:middle
about inside the dictionary
but there's a better way.

1180
00:51:42,226 --> 00:51:43,816 A:middle
Remember we can use
tuple patterns

1181
00:51:43,886 --> 00:51:48,396 A:middle
to match these simultaneously
and repeat this pattern

1182
00:51:48,746 --> 00:51:52,236 A:middle
for each key of the property
list that we're interested in.

1183
00:51:52,766 --> 00:51:55,316 A:middle
We can see that the
name is a string,

1184
00:51:55,316 --> 00:51:56,566 A:middle
the population is a number

1185
00:51:56,566 --> 00:52:00,196 A:middle
and the abbreviation is a string
all simultaneously and with the

1186

1187
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1188
00:51:56,566 --> 00:52:00,196 A:middle
and the abbreviation is a string
all simultaneously and with the

1189
00:52:00,196 --> 00:52:02,216 A:middle
where clause even
check the abbreviations

1190
00:52:02,216 --> 00:52:06,596 A:middle
of the appropriate
length and we're done.

1191
00:52:06,816 --> 00:52:09,886 A:middle
With a single default clause
we handle all invalid property

1192
00:52:09,886 --> 00:52:12,496 A:middle
lists and it all fits
nicely on a single slide.

1193
00:52:13,746 --> 00:52:14,926 A:middle
That's the power of
pattern matching.

1194
00:52:15,516 --> 00:52:19,566 A:middle
[ Applause ]

1195
00:52:20,066 --> 00:52:22,336 A:middle
It's an incredible way to
test the structure of values

1196
00:52:22,746 --> 00:52:24,536 A:middle
and really improve
the readability

1197
00:52:24,626 --> 00:52:25,926 A:middle
and safety of your code.

1198
00:52:26,486 --> 00:52:31,846 A:middle
So we still just scratched the
surface of what Swift can do.

1199
00:52:33,146 --> 00:52:36,746 A:middle
We've looked at how optionals
allow you to write safe code,

1200
00:52:37,196 --> 00:52:39,956 A:middle
we looked at the
foundations of Swift

1201
00:52:39,956 --> 00:52:42,006 A:middle
in memory management
and initialization.

1202
00:52:43,546 --> 00:52:45,476 A:middle
We looked at how
powerful closure is

1203
00:52:45,476 --> 00:52:46,616 A:middle
and pattern matching are.

1204
00:52:47,976 --> 00:52:49,796 A:middle
There's a ton more
information online.

1205
00:52:50,116 --> 00:52:52,096 A:middle
There's the book that you
probably already downloaded

1206
00:52:52,096 --> 00:52:52,946 A:middle
and read by now.

1207
00:52:53,026 --> 00:52:56,036 A:middle
There's also some additional
material on the developer's site

1208
00:52:56,036 --> 00:52:57,386 A:middle
about Interop with Cocoa.

1209
00:52:58,166 --> 00:53:01,746 A:middle
If you're following along from
home, talk to Dave he's great

1210

1211
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1212
00:52:58,166 --> 00:53:01,746 A:middle
If you're following along from
home, talk to Dave he's great

1213
00:53:02,016 --> 00:53:02,996 A:middle
and there's our forums.

1214
00:53:03,656 --> 00:53:07,036 A:middle
You also might want to
save your seat here.

1215
00:53:07,036 --> 00:53:09,216 A:middle
We've got a lot of other great
Swift sessions right here

1216
00:53:09,216 --> 00:53:09,916 A:middle
in Presidio.

1217
00:53:10,816 --> 00:53:11,476 A:middle
Thank you.

1218
