X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:00,506 --> 00:00:11,516 A:middle
[ Silence ]

2
00:00:12,016 --> 00:00:16,000 A:middle
[ Applause ]

3
00:00:16,516 --> 00:00:16,986 A:middle
>> Welcome.

4
00:00:18,216 --> 00:00:19,176 A:middle
So I'm Doug Gregor.

5
00:00:19,416 --> 00:00:22,656 A:middle
I'm an engineer on the Swift
Compiler Team, and we're here

6
00:00:22,656 --> 00:00:24,976 A:middle
to talk about Swift
Interoperabiity.

7
00:00:28,626 --> 00:00:30,416 A:middle
We're going to talk about a
couple of different things here.

8
00:00:31,166 --> 00:00:33,986 A:middle
So, of course, Swift is
a new language for Cocoa

9
00:00:33,986 --> 00:00:35,526 A:middle
and Cocoa Touch development.

10
00:00:36,856 --> 00:00:38,746 A:middle
Now, Cocoa's not
written in Swift.

11
00:00:38,746 --> 00:00:41,286 A:middle
It's written in Objective-C,
a language you've been using

12
00:00:41,286 --> 00:00:43,526 A:middle
for years and that all of
your apps are written in.

13
00:00:44,276 --> 00:00:47,036 A:middle
So, interoperability between
these two very different

14
00:00:47,036 --> 00:00:49,626 A:middle
programming languages
is absolutely critical.

15
00:00:50,106 --> 00:00:52,636 A:middle
So we're going to talk about
how that interoperating works

16
00:00:53,076 --> 00:00:54,576 A:middle
at the language level.

17
00:00:55,116 --> 00:00:58,786 A:middle
We're going to hit a number
of different topics today.

18
00:00:59,426 --> 00:01:01,336 A:middle
We're going to talk
about working with Cocoa,

19

20
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

21
00:00:59,426 --> 00:01:01,336 A:middle
We're going to talk
about working with Cocoa,

22
00:01:01,436 --> 00:01:06,816 A:middle
seeing how the Cocoa APIs or
Objective-C APIs look and feel

23
00:01:06,816 --> 00:01:09,916 A:middle
in Swift and how to work
with them, as well as working

24
00:01:09,916 --> 00:01:13,786 A:middle
with some more Swift concepts
like dealing with AnyObject

25
00:01:13,786 --> 00:01:17,046 A:middle
and doing dynamic
checks on your types.

26
00:01:18,106 --> 00:01:20,206 A:middle
Then we're going to
talk about bridging

27
00:01:20,526 --> 00:01:24,216 A:middle
of the core Cocoa datatypes
and NSArray, NSDictionary,

28
00:01:24,366 --> 00:01:27,386 A:middle
NSString into their
Swift-native equivalents.

29
00:01:28,616 --> 00:01:30,796 A:middle
Then we'll move on
to subclassing,

30
00:01:30,946 --> 00:01:33,946 A:middle
so writing Swift classes that
subclass from Objective-C

31
00:01:34,186 --> 00:01:36,576 A:middle
and how they're mapped
back into Objective-C

32
00:01:36,856 --> 00:01:38,926 A:middle
so that you can use these
two languages together.

33
00:01:40,156 --> 00:01:42,526 A:middle
And, finally, we're going to
talk about Core Foundation

34
00:01:42,526 --> 00:01:44,316 A:middle
and Core Graphics, and
this general notion

35
00:01:44,316 --> 00:01:48,276 A:middle
of CF Interoperability within
the Swift programming language.

36
00:01:48,806 --> 00:01:53,366 A:middle
Let's get started talking
about working with Cocoa.

37
00:01:55,466 --> 00:01:59,616 A:middle
So Swift provides seamless
access to Objective-C APIs

38
00:01:59,916 --> 00:02:03,166 A:middle
through the Objective-C Module
System we introduced last year.

39

40
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

41
00:01:59,916 --> 00:02:03,166 A:middle
through the Objective-C Module
System we introduced last year.

42
00:02:03,796 --> 00:02:06,986 A:middle
So you can pull your Objective-C
APIs whether they be from Cocoa

43
00:02:06,986 --> 00:02:09,826 A:middle
or your own into
Swift and use them.

44
00:02:10,556 --> 00:02:13,206 A:middle
And then Swift maps
those Objective-C APIs

45
00:02:13,306 --> 00:02:15,126 A:middle
into the Swift syntax.

46
00:02:15,836 --> 00:02:19,186 A:middle
This covers both the objective
parts of Objective-C -

47
00:02:19,306 --> 00:02:21,656 A:middle
the classes, protocols,
methods, and so on,

48
00:02:22,116 --> 00:02:24,856 A:middle
as well as the lower level
C things like functions,

49
00:02:24,856 --> 00:02:26,956 A:middle
enumerations, structs, pointers.

50
00:02:27,456 --> 00:02:29,966 A:middle
So you have access to all
of your Objective-C APIs.

51
00:02:31,456 --> 00:02:33,926 A:middle
Now when you look at one of
these Objective-C APIs in Swift,

52
00:02:34,486 --> 00:02:36,366 A:middle
it's going to be
different from Objective-C.

53
00:02:37,316 --> 00:02:39,286 A:middle
There are inherent
syntactic differences

54
00:02:39,336 --> 00:02:41,346 A:middle
between these two
language, of course.

55
00:02:42,426 --> 00:02:46,506 A:middle
Swift also has some
modern features that we use

56
00:02:46,506 --> 00:02:49,266 A:middle
when expressing those
Objective-C APIs in Swift

57
00:02:49,266 --> 00:02:51,196 A:middle
that will make it look
a little bit different,

58
00:02:51,516 --> 00:02:54,066 A:middle
as well as the bridging
of core Cocoa types

59
00:02:54,316 --> 00:02:55,306 A:middle
that I mentioned earlier.

60
00:02:55,926 --> 00:02:59,486 A:middle
Now, despite all of these
differences that you see

61
00:02:59,486 --> 00:03:02,396 A:middle
when looking at the
APIs, it's still Cocoa,

62

63
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

64
00:02:59,486 --> 00:03:02,396 A:middle
when looking at the
APIs, it's still Cocoa,

65
00:03:02,586 --> 00:03:04,006 A:middle
it's still Cocoa Touch.

66
00:03:04,236 --> 00:03:07,366 A:middle
And the same conventions
and idioms still apply,

67
00:03:07,766 --> 00:03:10,166 A:middle
so what you know of
Cocoa works in Swift.

68
00:03:10,206 --> 00:03:11,676 A:middle
It's just a different
programming language

69
00:03:11,766 --> 00:03:14,646 A:middle
for the same great platform,
the same great frameworks.

70
00:03:16,136 --> 00:03:19,356 A:middle
So we're going to walk through
part of something we know

71
00:03:19,356 --> 00:03:22,336 A:middle
and love, and that's
the UIDocument class.

72
00:03:23,736 --> 00:03:26,456 A:middle
Here's a tiny slice
of it in Objective-C.

73
00:03:26,846 --> 00:03:30,706 A:middle
We're going to walk through how
and why that maps into Swift.

74
00:03:31,546 --> 00:03:35,656 A:middle
First thing, something simple, a
property: fileModificationDate.

75
00:03:35,656 --> 00:03:36,596 A:middle
It is an NSDate!.

76
00:03:37,826 --> 00:03:40,756 A:middle
This comes into Swift
as a property.

77
00:03:40,986 --> 00:03:41,956 A:middle
It's the var keyword.

78
00:03:42,536 --> 00:03:45,536 A:middle
The NSDate class, of course
just comes into Swift.

79
00:03:45,536 --> 00:03:47,346 A:middle
Nothing interesting there except

80
00:03:47,346 --> 00:03:50,396 A:middle
for this little exclamation
point that you may have noticed.

81
00:03:50,896 --> 00:03:55,966 A:middle
Now that exclamation point is an
Implicitly Unwrapped Optional.

82
00:03:56,486 --> 00:03:58,846 A:middle
What does that mean?

83
00:03:59,156 --> 00:04:01,456 A:middle
Well, let's look at
Swift in Objective-C.

84

85
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

86
00:03:59,156 --> 00:04:01,456 A:middle
Well, let's look at
Swift in Objective-C.

87
00:04:01,456 --> 00:04:03,946 A:middle
They're different languages with
some different ideas in them.

88
00:04:04,456 --> 00:04:06,616 A:middle
So in Swift, when
you have a value

89
00:04:06,616 --> 00:04:09,366 A:middle
of class type, so
I have an NSDate!

90
00:04:09,866 --> 00:04:11,746 A:middle
That can never be nil.

91
00:04:12,466 --> 00:04:13,826 A:middle
So a very strong constraint.

92
00:04:14,566 --> 00:04:16,616 A:middle
And it makes life a bit
simpler when you know

93
00:04:16,616 --> 00:04:17,565 A:middle
that thing is not nil.

94
00:04:19,036 --> 00:04:21,646 A:middle
Now, when you want to deal
with nil, you have an NSDate!

95
00:04:21,646 --> 00:04:25,056 A:middle
that could be nil, you
use an optional type,

96
00:04:25,236 --> 00:04:27,526 A:middle
and optional types are
covered extensively in the

97
00:04:27,526 --> 00:04:29,506 A:middle
"Intermediate Swift" talk.

98
00:04:30,046 --> 00:04:31,526 A:middle
We're going to cover them
a little bit more now.

99
00:04:32,976 --> 00:04:34,546 A:middle
That's the Swift side of things.

100
00:04:34,986 --> 00:04:36,226 A:middle
What about Objective-C?

101
00:04:36,656 --> 00:04:39,756 A:middle
Well, it does not have
the notion of a never

102
00:04:39,756 --> 00:04:42,816 A:middle
"never-nil" pointer
like we have in Swift.

103
00:04:43,356 --> 00:04:45,876 A:middle
And so we have a little
impedance mismatch here.

104
00:04:45,876 --> 00:04:50,256 A:middle
The Objective-C APIs don't have
the notion of this is not nil,

105
00:04:50,256 --> 00:04:52,146 A:middle
but we need to bring
them into Swift.

106
00:04:52,796 --> 00:04:56,066 A:middle
And so, we have the
implicitly unwrapped optional

107
00:04:56,146 --> 00:04:57,486 A:middle
with the exclamation point here.

108
00:04:57,486 --> 00:04:59,916 A:middle
And this gives us
a nice balance.

109
00:04:59,916 --> 00:05:02,336 A:middle
It means that we can
express the notion of nil

110

111
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

112
00:04:59,916 --> 00:05:02,336 A:middle
It means that we can
express the notion of nil

113
00:05:03,006 --> 00:05:05,686 A:middle
and you can test it against
nil to do those checks.

114
00:05:06,426 --> 00:05:09,656 A:middle
However, you can also just
directly access properties

115
00:05:09,656 --> 00:05:12,346 A:middle
or directly call a method
on it, or you can convert it

116
00:05:12,346 --> 00:05:14,786 A:middle
down to NSNil, and we'll unwrap

117
00:05:14,936 --> 00:05:17,116 A:middle
that optional object
automatically

118
00:05:17,116 --> 00:05:17,976 A:middle
for you doing the checking.

119
00:05:18,046 --> 00:05:21,976 A:middle
So it's a fairly syntactically
lightweight way of dealing

120
00:05:21,976 --> 00:05:26,786 A:middle
with nil in a language where nil
is a much more explicit entity

121
00:05:27,376 --> 00:05:28,006 A:middle
like in Swift.

122
00:05:29,406 --> 00:05:32,976 A:middle
Let's look at another property.

123
00:05:33,096 --> 00:05:35,396 A:middle
So here we have the fileType
property that's in NSString.

124
00:05:36,676 --> 00:05:42,456 A:middle
This is going to come into
Swift as a native Swift string.

125
00:05:43,196 --> 00:05:45,636 A:middle
Now, again, we have the
implicitly unwrapped optional

126
00:05:45,636 --> 00:05:47,876 A:middle
here so that nil can be passed

127
00:05:47,876 --> 00:05:50,866 A:middle
through since NSString doesn't
have a notion of nil inside it.

128
00:05:52,446 --> 00:05:55,106 A:middle
And there's a number
of Objective-C types

129
00:05:55,286 --> 00:05:58,056 A:middle
that get mapped slightly
differently into Swift.

130
00:05:58,776 --> 00:06:01,846 A:middle
So there's some very, very
fundamental types like BOOL

131

132
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

133
00:05:58,776 --> 00:06:01,846 A:middle
So there's some very, very
fundamental types like BOOL

134
00:06:01,896 --> 00:06:07,036 A:middle
and NSInteger that map into the
Bool and Int types within Swift.

135
00:06:07,256 --> 00:06:08,846 A:middle
So we're working with
all the Swift types.

136
00:06:09,636 --> 00:06:11,606 A:middle
There's id and Class,

137
00:06:11,606 --> 00:06:14,396 A:middle
which we're very familiar
with in Objective-C.

138
00:06:14,676 --> 00:06:16,496 A:middle
These map over to AnyObject!

139
00:06:16,496 --> 00:06:18,396 A:middle
and AnyClass!, something
we're going to talk

140
00:06:18,396 --> 00:06:19,346 A:middle
about in a couple of minutes.

141
00:06:20,366 --> 00:06:22,746 A:middle
And we also have the core
Cocoa types that are bridged,

142
00:06:22,746 --> 00:06:24,066 A:middle
like NSString and NSArray,

143
00:06:24,326 --> 00:06:26,586 A:middle
mapping to their
Swift-native equivalents.

144
00:06:26,776 --> 00:06:28,616 A:middle
Again, we'll talk about
that later in this talk.

145
00:06:29,956 --> 00:06:31,106 A:middle
Let's take a look at methods.

146
00:06:32,346 --> 00:06:34,706 A:middle
There's an Objective-C method
fileNameExtensionForType,

147
00:06:34,776 --> 00:06:35,796 A:middle
saveOperation.

148
00:06:36,356 --> 00:06:39,796 A:middle
It comes into Swift here
as, again, a method.

149
00:06:40,906 --> 00:06:43,946 A:middle
Now, one important thing
to know here is that all

150
00:06:43,946 --> 00:06:47,596 A:middle
of the selector pieces from
the Objective-C method are here

151
00:06:47,666 --> 00:06:49,926 A:middle
in the method's signature
in Swift.

152
00:06:50,556 --> 00:06:53,236 A:middle
The first selector piece has
become the so-called base name

153
00:06:53,236 --> 00:06:53,846 A:middle
of the method.

154
00:06:54,436 --> 00:06:56,816 A:middle
The second selector
piece, SaveOperation,

155
00:06:57,226 --> 00:07:00,576 A:middle
has become a label on
the second argument.

156

157
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

158
00:06:57,226 --> 00:07:00,576 A:middle
has become a label on
the second argument.

159
00:07:01,966 --> 00:07:05,046 A:middle
A really important thing
here is that these labels

160
00:07:05,306 --> 00:07:08,846 A:middle
and their order are
enforced at the call site.

161
00:07:09,656 --> 00:07:13,026 A:middle
So, you must call it as
fileNameExtensionForType,

162
00:07:13,266 --> 00:07:15,746 A:middle
saveOperation, just
like you do in Cocoa

163
00:07:16,036 --> 00:07:18,236 A:middle
with the exact same
ordering, so to preserve

164
00:07:18,506 --> 00:07:21,416 A:middle
that nice readability from
Cocoa that we all know and love.

165
00:07:23,466 --> 00:07:26,516 A:middle
Now the other thing to note
here is the consistency here

166
00:07:26,516 --> 00:07:27,296 A:middle
on the Swift side.

167
00:07:28,496 --> 00:07:31,106 A:middle
All of the names and the
colons and the parentheses

168
00:07:31,106 --> 00:07:33,586 A:middle
and the commas are in
exactly the same places

169
00:07:34,166 --> 00:07:37,206 A:middle
in the declaration of
the method in the middle

170
00:07:37,676 --> 00:07:39,946 A:middle
and in the call site of
the method at the bottom.

171
00:07:39,946 --> 00:07:41,846 A:middle
So the kind of consistency
we like out

172
00:07:41,846 --> 00:07:43,196 A:middle
of building a new language.

173
00:07:43,196 --> 00:07:47,296 A:middle
Let's look at a little bit
more complicated method here

174
00:07:47,296 --> 00:07:48,646 A:middle
where we have some
blocks going on,

175
00:07:48,646 --> 00:07:51,506 A:middle
some more interesting things,
and map that into Swift.

176
00:07:52,326 --> 00:07:54,556 A:middle
And here there are two different
things I want to talk about.

177
00:07:54,596 --> 00:07:58,496 A:middle
The first thing I want to
talk about is the naming

178
00:07:58,586 --> 00:08:02,096 A:middle
of these argument labels and
the internal parameter names.

179

180
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

181
00:07:58,586 --> 00:08:02,096 A:middle
of these argument labels and
the internal parameter names.

182
00:08:02,676 --> 00:08:05,816 A:middle
So here in Objective-C you
always have a selector piece,

183
00:08:06,556 --> 00:08:07,586 A:middle
goes before the colon.

184
00:08:07,976 --> 00:08:10,666 A:middle
And then you have the name of
the - at the internal parameter

185
00:08:10,956 --> 00:08:13,016 A:middle
that you use when you're
defining the method

186
00:08:13,016 --> 00:08:14,196 A:middle
in your .m file.

187
00:08:14,406 --> 00:08:17,416 A:middle
In Objective-C you always
have to write both of these,

188
00:08:17,416 --> 00:08:19,536 A:middle
of course, and many
times they're the same.

189
00:08:19,536 --> 00:08:20,696 A:middle
So you have some redundancy.

190
00:08:21,316 --> 00:08:24,566 A:middle
We do a little bit of syntax
optimization here in Swift,

191
00:08:24,566 --> 00:08:25,866 A:middle
so you just write the name once.

192
00:08:26,236 --> 00:08:28,996 A:middle
It serves both as the label
and the internal name.

193
00:08:29,906 --> 00:08:32,525 A:middle
If you want those names
to be different, fine,

194
00:08:32,525 --> 00:08:33,576 A:middle
we can handle that, too.

195
00:08:33,706 --> 00:08:35,416 A:middle
You just write the two
names next to each other.

196
00:08:35,626 --> 00:08:37,816 A:middle
The first one is the label
because that's what's important

197
00:08:37,816 --> 00:08:38,996 A:middle
for the caller to use.

198
00:08:39,616 --> 00:08:42,376 A:middle
And then the second one is the
internal name that you're going

199
00:08:42,376 --> 00:08:44,896 A:middle
to use within the
implementation of your method.

200
00:08:46,366 --> 00:08:50,106 A:middle
The next thing I want to
point out here is the Block.

201
00:08:51,436 --> 00:08:54,596 A:middle
So here we have a method
that takes a Block,

202
00:08:55,126 --> 00:08:59,716 A:middle
and Blocks in Objective-C get
mapped into Closures in Swift.

203

204
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

205
00:09:00,566 --> 00:09:03,316 A:middle
You see, again, this is an
implicitly unwrapped optional

206
00:09:03,536 --> 00:09:05,936 A:middle
so that you can pass
a nil Block in here.

207
00:09:07,486 --> 00:09:08,806 A:middle
Now the really great thing

208
00:09:09,076 --> 00:09:13,036 A:middle
about getting Objective-C Blocks
mapped into Swift Closures is

209
00:09:13,036 --> 00:09:16,316 A:middle
that we get all of the great
closure syntax that is provided

210
00:09:16,316 --> 00:09:18,766 A:middle
by Swift, including
trailing closures

211
00:09:18,986 --> 00:09:20,826 A:middle
when your block is
the last parameter.

212
00:09:21,356 --> 00:09:23,816 A:middle
So all of your block-based
APIs that you've written,

213
00:09:23,886 --> 00:09:26,526 A:middle
all the ones from Cocoa, when
they're following the convention

214
00:09:26,526 --> 00:09:30,736 A:middle
of putting the block last get
this nice trailing closure

215
00:09:30,736 --> 00:09:31,736 A:middle
syntax in Swift.

216
00:09:32,166 --> 00:09:37,026 A:middle
Let's talk a little
bit about Initializers.

217
00:09:38,626 --> 00:09:41,796 A:middle
So in Objective-C
we have init methods

218
00:09:42,576 --> 00:09:46,506 A:middle
and init methods have a lot of
conventions built around them.

219
00:09:47,036 --> 00:09:48,376 A:middle
They start with the word "init."

220
00:09:49,046 --> 00:09:51,016 A:middle
They should be returning
instance type,

221
00:09:51,546 --> 00:09:52,966 A:middle
although that's a
fairly new invention.

222
00:09:52,966 --> 00:09:54,746 A:middle
So sometimes they're
still returning ID.

223
00:09:56,206 --> 00:09:58,036 A:middle
And when you're implementing
these things,

224
00:09:58,036 --> 00:09:59,356 A:middle
you have a lot of requirements.

225
00:09:59,356 --> 00:09:59,966 A:middle
You need to call "super init."

226

227
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

228
00:10:00,046 --> 00:10:01,896 A:middle
You need to reassign "self."

229
00:10:01,896 --> 00:10:03,996 A:middle
You need to check "self,"
you need to return "self."

230
00:10:05,926 --> 00:10:09,666 A:middle
So all of this screams, we
need something formalized

231
00:10:09,696 --> 00:10:10,506 A:middle
in the language.

232
00:10:10,536 --> 00:10:13,476 A:middle
And so Swift has this
notion of Initializers.

233
00:10:13,906 --> 00:10:18,236 A:middle
And we import Objective-C init
methods as Swift Initializers.

234
00:10:19,206 --> 00:10:21,696 A:middle
How do we get from the
top Objective-C code

235
00:10:21,696 --> 00:10:23,016 A:middle
to the Swift code in the bottom?

236
00:10:23,526 --> 00:10:27,436 A:middle
Well, we find the init,
so we match the init name

237
00:10:27,436 --> 00:10:28,916 A:middle
and the camel-case string here.

238
00:10:28,916 --> 00:10:31,586 A:middle
We actually look forward
a little bit to see

239
00:10:31,586 --> 00:10:34,546 A:middle
if it's really initWith
because that's extremely common.

240
00:10:34,986 --> 00:10:37,756 A:middle
And then we take the
rest of that Selector,

241
00:10:37,846 --> 00:10:39,826 A:middle
and lowercase the
first character in it,

242
00:10:40,146 --> 00:10:43,666 A:middle
and turn that into an argument
label for the Swift Initializer.

243
00:10:44,976 --> 00:10:45,866 A:middle
Now, why do we do this?

244
00:10:45,866 --> 00:10:47,736 A:middle
Well, let's look at
how we build objects

245
00:10:47,736 --> 00:10:49,996 A:middle
in Objective-C versus in Swift.

246
00:10:50,566 --> 00:10:54,196 A:middle
So in Objective-C you do
an alloc on your class

247
00:10:54,386 --> 00:10:58,256 A:middle
and then you immediately
send it an init message

248
00:10:58,386 --> 00:10:59,556 A:middle
to initialize the Object.

249
00:10:59,846 --> 00:11:02,246 A:middle
These two steps are
almost never separated.

250

251
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

252
00:10:59,846 --> 00:11:02,246 A:middle
These two steps are
almost never separated.

253
00:11:02,866 --> 00:11:07,376 A:middle
Now in Swift we have
our Initializers

254
00:11:07,856 --> 00:11:11,116 A:middle
and we use this Unified
Object Construction syntax

255
00:11:11,386 --> 00:11:13,176 A:middle
where we write the
name of the Class

256
00:11:13,536 --> 00:11:16,346 A:middle
and then we pass arguments
directly to the Initializer.

257
00:11:16,916 --> 00:11:20,626 A:middle
And notice here, we're using the
argument label of fileURL to say

258
00:11:20,626 --> 00:11:22,786 A:middle
which Initializer
we're actually using

259
00:11:23,146 --> 00:11:24,316 A:middle
and then give it the argument.

260
00:11:25,046 --> 00:11:27,556 A:middle
And, of course, we folded the
alloc and the init together

261
00:11:27,556 --> 00:11:29,906 A:middle
in this one nice syntax
that also happens to work

262
00:11:29,906 --> 00:11:32,216 A:middle
for all other types of in
Swift whether they be structs

263
00:11:32,216 --> 00:11:32,786 A:middle
or enums.

264
00:11:33,336 --> 00:11:38,186 A:middle
Okay. So let's talk
about factory methods

265
00:11:38,226 --> 00:11:40,026 A:middle
because this is the other way

266
00:11:40,176 --> 00:11:42,376 A:middle
that we build Objects
in Objective-C.

267
00:11:42,816 --> 00:11:44,746 A:middle
So here we have something
from UIColor.

268
00:11:44,746 --> 00:11:46,106 A:middle
I've stepped away
from UIDocument.

269
00:11:46,106 --> 00:11:48,316 A:middle
And they have colorWithRed
blue green alpha.

270
00:11:48,726 --> 00:11:50,366 A:middle
And, of course, we
can go and construct

271
00:11:50,366 --> 00:11:55,366 A:middle
that by calling UIColor
colorWithRed green blue alpha.

272
00:11:55,616 --> 00:11:58,206 A:middle
All of this can be
directly imported in Swift.

273
00:11:58,646 --> 00:12:01,496 A:middle
It would just be a class
method, colorwithRed,

274

275
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

276
00:11:58,646 --> 00:12:01,496 A:middle
It would just be a class
method, colorwithRed,

277
00:12:01,496 --> 00:12:04,406 A:middle
and green blue alpha
as argument labels,

278
00:12:04,846 --> 00:12:07,456 A:middle
and we could just
call it on the class.

279
00:12:08,396 --> 00:12:09,286 A:middle
This would be fine.

280
00:12:09,286 --> 00:12:10,876 A:middle
However, we don't really love

281
00:12:10,876 --> 00:12:12,626 A:middle
that they're two
completely different kinds

282
00:12:12,626 --> 00:12:13,626 A:middle
of initialization.

283
00:12:14,916 --> 00:12:19,496 A:middle
So we recognize the
common patterns

284
00:12:19,496 --> 00:12:22,066 A:middle
in how factory methods are
described in Objective-C,

285
00:12:22,236 --> 00:12:24,786 A:middle
and bring them in as
Swift Initializers.

286
00:12:25,976 --> 00:12:27,906 A:middle
And the really great
thing here is we get

287
00:12:27,906 --> 00:12:31,416 A:middle
that common Initialization
syntax for all

288
00:12:31,416 --> 00:12:32,816 A:middle
of these Objective-C APIs.

289
00:12:33,266 --> 00:12:35,396 A:middle
You don't have to think, "Is
there an init method for this?

290
00:12:35,396 --> 00:12:38,156 A:middle
Or is there a class
method for this?"

291
00:12:39,046 --> 00:12:40,486 A:middle
It's there as an Initializer.

292
00:12:43,176 --> 00:12:43,956 A:middle
Do you like that?

293
00:12:44,516 --> 00:12:49,026 A:middle
[ Applause ]

294
00:12:49,526 --> 00:12:51,166 A:middle
Let's go a little
bit down the stack

295
00:12:51,586 --> 00:12:52,856 A:middle
and let's talk about Enums.

296
00:12:54,006 --> 00:12:56,826 A:middle
So here's the
UIDocumentSaveOperation enum

297
00:12:57,186 --> 00:12:58,556 A:middle
as defined in Objective-C.

298
00:12:59,646 --> 00:13:02,666 A:middle
And if we look at this we see
a whole lot of redundancy.

299

300
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

301
00:12:59,646 --> 00:13:02,666 A:middle
And if we look at this we see
a whole lot of redundancy.

302
00:13:03,416 --> 00:13:06,646 A:middle
This UIDocumentSave
prefix is used for the enum

303
00:13:06,916 --> 00:13:09,136 A:middle
and for both of its enum values.

304
00:13:10,066 --> 00:13:10,986 A:middle
Why is this?

305
00:13:10,986 --> 00:13:12,436 A:middle
Well, this is C.

306
00:13:13,236 --> 00:13:16,896 A:middle
The enum values in C are
in a global namespace.

307
00:13:17,276 --> 00:13:20,386 A:middle
We can't call these enum
values just ForCreating

308
00:13:20,386 --> 00:13:22,456 A:middle
and ForOverwriting because
that's going to stomp

309
00:13:22,456 --> 00:13:25,016 A:middle
on some other completely
different enumeration somewhere

310
00:13:25,016 --> 00:13:27,546 A:middle
else in the system
and cause havoc.

311
00:13:28,396 --> 00:13:31,456 A:middle
So we do this common
prefix by convention.

312
00:13:31,496 --> 00:13:33,506 A:middle
It helps code completion
find the right thing.

313
00:13:33,506 --> 00:13:37,196 A:middle
But when we're talking about
Swift, it's also a great cue

314
00:13:37,196 --> 00:13:38,776 A:middle
for us that we can do better.

315
00:13:39,376 --> 00:13:42,036 A:middle
And so we can import
this NS-ENUM

316
00:13:42,506 --> 00:13:46,876 A:middle
as a Swift enum chopping off
all of those common prefixes

317
00:13:47,116 --> 00:13:49,396 A:middle
to get us nice short
names for the cases.

318
00:13:50,886 --> 00:13:54,126 A:middle
Now the reason we can do this
is because the enum cases

319
00:13:54,126 --> 00:13:57,446 A:middle
in Swift are scoped within
the enum type itself.

320
00:13:58,016 --> 00:14:02,026 A:middle
How does this play
out in actual code?

321

322
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

323
00:13:58,016 --> 00:14:02,026 A:middle
How does this play
out in actual code?

324
00:14:02,596 --> 00:14:04,656 A:middle
Well, okay, if we call
fileNameExtensionForType

325
00:14:04,656 --> 00:14:08,606 A:middle
saveOperation, we can
refer to, say ForCreating,

326
00:14:09,306 --> 00:14:12,216 A:middle
with its fully dotted
name - class name.enum,

327
00:14:12,216 --> 00:14:13,996 A:middle
the same dotted syntax we use

328
00:14:14,146 --> 00:14:16,686 A:middle
for a number of anything
in Swift.

329
00:14:17,896 --> 00:14:19,626 A:middle
But Swift has type inference.

330
00:14:20,496 --> 00:14:23,426 A:middle
We know that this method takes
the UIDocumentSaveOperation,

331
00:14:23,536 --> 00:14:25,446 A:middle
so there's absolutely
no reason to write that.

332
00:14:25,756 --> 00:14:27,626 A:middle
You can just pass .ForCreating

333
00:14:27,626 --> 00:14:30,546 A:middle
and we will infer the
enum type from that.

334
00:14:36,046 --> 00:14:38,426 A:middle
I'd also like to
talk about NSError.

335
00:14:39,276 --> 00:14:43,086 A:middle
So this is our pattern in
Cocoa for dealing with errors.

336
00:14:43,676 --> 00:14:45,846 A:middle
And so there are many
methods throughout Cocoa

337
00:14:45,846 --> 00:14:48,896 A:middle
and throughout your own
apps that take an NSError ,

338
00:14:49,106 --> 00:14:53,266 A:middle
and that's a C pointer
to an NSError object.

339
00:14:53,896 --> 00:14:57,076 A:middle
We bring this in with a
special type in Swift.

340
00:14:57,166 --> 00:14:58,216 A:middle
In fact, if you type alias

341
00:14:58,216 --> 00:15:01,896 A:middle
for a much longer type
name call NSErrorPointer.

342

343
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

344
00:14:58,216 --> 00:15:01,896 A:middle
for a much longer type
name call NSErrorPointer.

345
00:15:03,026 --> 00:15:03,356 A:middle
We're going

346
00:15:03,356 --> 00:15:05,976 A:middle
to see NSErrorPointer
twice in this talk.

347
00:15:06,826 --> 00:15:08,846 A:middle
For now we're going to
talk about how to use it

348
00:15:09,356 --> 00:15:11,326 A:middle
when we're calling into the API.

349
00:15:13,036 --> 00:15:15,646 A:middle
And it's not actually all that
much different from Objective-C.

350
00:15:16,506 --> 00:15:20,506 A:middle
So, if we bring this up, we
declare a local variable.

351
00:15:20,936 --> 00:15:22,026 A:middle
It's called error.

352
00:15:22,096 --> 00:15:24,036 A:middle
It's a type NSError optional.

353
00:15:24,996 --> 00:15:27,566 A:middle
And we pass its address
in when we're calling

354
00:15:27,566 --> 00:15:28,766 A:middle
contentsForType error.

355
00:15:30,076 --> 00:15:32,816 A:middle
And so in this code we check
whether we're getting back some

356
00:15:32,816 --> 00:15:33,826 A:middle
contents from this.

357
00:15:34,726 --> 00:15:36,106 A:middle
Then we can deal
with those contents.

358
00:15:36,736 --> 00:15:39,446 A:middle
If we fail to find any contents
well, we probably have an error.

359
00:15:39,446 --> 00:15:42,056 A:middle
So we can go unwrap
that optional error

360
00:15:42,356 --> 00:15:43,726 A:middle
and present it to the user.

361
00:15:44,126 --> 00:15:46,626 A:middle
And if we fall through the
else here, now we're in trouble

362
00:15:46,626 --> 00:15:49,256 A:middle
because something failed and we
have nothing we can do about it.

363
00:15:49,906 --> 00:15:52,476 A:middle
We hope that doesn't happen.

364
00:15:52,686 --> 00:15:55,456 A:middle
But this is the pattern
you'll be using when dealing

365
00:15:55,456 --> 00:15:57,026 A:middle
with NSError in Swift.

366
00:15:57,296 --> 00:15:59,036 A:middle
If you truly don't
care about the error,

367
00:15:59,176 --> 00:16:00,176 A:middle
you can also pass nil.

368

369
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

370
00:15:59,176 --> 00:16:00,176 A:middle
you can also pass nil.

371
00:16:01,656 --> 00:16:04,916 A:middle
So we've walked through
a lot of little pieces

372
00:16:05,356 --> 00:16:08,446 A:middle
of the Objective-C
mapping into Swift.

373
00:16:08,446 --> 00:16:11,306 A:middle
And there are a lot of
rules that we've talked

374
00:16:11,306 --> 00:16:13,016 A:middle
about that you're certainly
not going to remember.

375
00:16:14,166 --> 00:16:15,196 A:middle
That's perfectly fine.

376
00:16:15,366 --> 00:16:16,506 A:middle
Xcode has your back here.

377
00:16:17,226 --> 00:16:18,466 A:middle
Use the tools to help you.

378
00:16:19,026 --> 00:16:21,346 A:middle
So if you're in Xcode,
you're in some Swift Code,

379
00:16:21,346 --> 00:16:23,636 A:middle
you can Command+Click
on a class name.

380
00:16:23,886 --> 00:16:25,956 A:middle
And we'll show you
the Swift projection

381
00:16:26,276 --> 00:16:28,096 A:middle
of the underlying
Objective-C class.

382
00:16:28,896 --> 00:16:31,046 A:middle
So take your favorite
Cocoa class and look

383
00:16:31,046 --> 00:16:33,176 A:middle
at how it maps into Swift.

384
00:16:33,566 --> 00:16:35,616 A:middle
Get a feel for the
language, an intuitive feel

385
00:16:35,616 --> 00:16:38,806 A:middle
for how these languages
work together and you'll get

386
00:16:38,806 --> 00:16:40,336 A:middle
into Swift really fast.

387
00:16:41,126 --> 00:16:43,956 A:middle
And the great thing
is, all of these tools,

388
00:16:44,166 --> 00:16:47,016 A:middle
all the rules I've talked
about, apply equally

389
00:16:47,016 --> 00:16:50,976 A:middle
to any Objective-C API
when it comes into Swift.

390
00:16:51,416 --> 00:16:52,636 A:middle
It doesn't matter if it's Cocoa.

391
00:16:52,636 --> 00:16:53,776 A:middle
It doesn't matter if
it's your own API.

392
00:16:54,256 --> 00:16:58,876 A:middle
The same rules apply, and you
can view your own Objective-C

393
00:16:58,956 --> 00:17:01,186 A:middle
APIs in Swift to get
to know them better.

394

395
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

396
00:16:58,956 --> 00:17:01,186 A:middle
APIs in Swift to get
to know them better.

397
00:17:02,246 --> 00:17:05,146 A:middle
Now this works best
when you're following

398
00:17:05,175 --> 00:17:07,136 A:middle
"modern" Objective-C practices.

399
00:17:07,705 --> 00:17:11,935 A:middle
So these are using features
like Properties, instancetype,

400
00:17:12,726 --> 00:17:15,915 A:middle
marking your enumerations
with NS-ENUM or NS-OPTIONS

401
00:17:15,965 --> 00:17:17,866 A:middle
to describe more
semantic information

402
00:17:17,866 --> 00:17:20,366 A:middle
about what these enums
actually mean in C.

403
00:17:21,616 --> 00:17:24,306 A:middle
We've also introduced
NS-DESIGNATED-INITIALIZER this

404
00:17:24,306 --> 00:17:27,086 A:middle
year to mark your
designated Initializers

405
00:17:27,606 --> 00:17:29,546 A:middle
and formalize a Designated
Initializer pattern,

406
00:17:29,546 --> 00:17:31,676 A:middle
both in Objective-C
through additional warnings,

407
00:17:32,306 --> 00:17:35,486 A:middle
and as the initialization
model for Swift.

408
00:17:36,736 --> 00:17:39,176 A:middle
So, of course, we want
you to follow all of these

409
00:17:39,176 --> 00:17:42,496 A:middle
"modern" Objective-C
practices but we don't want you

410
00:17:42,496 --> 00:17:43,296 A:middle
to have to go it alone.

411
00:17:44,046 --> 00:17:47,316 A:middle
And so this year we introduced
the Objective-C Modernizer

412
00:17:47,776 --> 00:17:50,296 A:middle
that helps find these
cases in your code

413
00:17:50,596 --> 00:17:53,376 A:middle
where we could possibly
modernize them to work

414
00:17:53,376 --> 00:17:55,496 A:middle
with all these "modern"
Objective-C features

415
00:17:55,786 --> 00:17:57,876 A:middle
and give you a better
projection into Swift.

416
00:17:58,426 --> 00:18:00,696 A:middle
And that Modernizer is
discussed in the "What's New

417

418
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

419
00:17:58,426 --> 00:18:00,696 A:middle
And that Modernizer is
discussed in the "What's New

420
00:18:00,696 --> 00:18:02,666 A:middle
in LLVM" talk earlier today.

421
00:18:03,296 --> 00:18:05,686 A:middle
Highly recommend you catch
it on video if you missed it.

422
00:18:08,096 --> 00:18:12,056 A:middle
With that, let's talk about id.

423
00:18:13,766 --> 00:18:15,176 A:middle
What is id in Objective-C?

424
00:18:15,736 --> 00:18:19,576 A:middle
It's kind of a placeholder
in some sense.

425
00:18:19,766 --> 00:18:21,596 A:middle
It means, I have a value.

426
00:18:22,016 --> 00:18:25,066 A:middle
I know it's an object
but I don't know

427
00:18:25,066 --> 00:18:28,686 A:middle
or I don't care what the
static type of that object is.

428
00:18:29,096 --> 00:18:30,996 A:middle
It's going to vary at
runtime most likely.

429
00:18:31,766 --> 00:18:34,026 A:middle
And there's a couple
of core operations

430
00:18:34,026 --> 00:18:35,316 A:middle
that you can perform on id.

431
00:18:35,316 --> 00:18:38,216 A:middle
You can do upcasting on it.

432
00:18:38,296 --> 00:18:41,996 A:middle
So, if I have this
variable object of type id,

433
00:18:42,366 --> 00:18:44,416 A:middle
I can put an NSURL into it.

434
00:18:45,406 --> 00:18:48,326 A:middle
Later I can go reassign it
and I can put a UIView on it.

435
00:18:48,736 --> 00:18:49,646 A:middle
That's perfectly fine.

436
00:18:49,806 --> 00:18:52,626 A:middle
They can both be upcasted
essentially to id.

437
00:18:52,806 --> 00:18:53,596 A:middle
They're both objects.

438
00:18:54,536 --> 00:18:57,796 A:middle
I can do Message sends
to id just directly

439
00:18:57,796 --> 00:18:58,816 A:middle
by doing a Message Send.

440
00:18:59,206 --> 00:19:02,786 A:middle
I can subscript an id
if I really feel like.

441

442
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

443
00:18:59,206 --> 00:19:02,786 A:middle
I can subscript an id
if I really feel like.

444
00:19:03,516 --> 00:19:08,546 A:middle
In Swift, any object is
the equivalent to id.

445
00:19:08,546 --> 00:19:13,376 A:middle
And it provides these same
core operations - Upcasting,

446
00:19:13,796 --> 00:19:15,576 A:middle
Message Sends, Subscripting -

447
00:19:15,876 --> 00:19:17,736 A:middle
that you can do on
id in Objective-C.

448
00:19:17,736 --> 00:19:23,316 A:middle
Now one of the things we know
from using id in Objective-C is

449
00:19:23,316 --> 00:19:25,636 A:middle
that you sometimes have
to be a little bit careful

450
00:19:26,906 --> 00:19:28,816 A:middle
because if you send a
message to an object

451
00:19:29,386 --> 00:19:31,256 A:middle
that doesn't have a
corresponding method,

452
00:19:31,446 --> 00:19:33,036 A:middle
you're going to get
a runtime failure

453
00:19:33,036 --> 00:19:34,866 A:middle
that this is an unrecognized
selector.

454
00:19:35,916 --> 00:19:37,976 A:middle
Now in Objective-C we
have an answer for this.

455
00:19:38,456 --> 00:19:40,476 A:middle
Using this respondsToSelector
idiom.

456
00:19:40,966 --> 00:19:44,186 A:middle
Do an if. Check whether it
respondsToSelector, then do it.

457
00:19:45,356 --> 00:19:47,556 A:middle
In Swift we like to do
a little bit better.

458
00:19:48,556 --> 00:19:49,916 A:middle
So let's take the same call

459
00:19:49,916 --> 00:19:52,466 A:middle
and let's do a
removeFromSuperview() call

460
00:19:52,466 --> 00:19:53,076 A:middle
on this object.

461
00:19:54,506 --> 00:19:59,216 A:middle
And the thing to note here
is that removeFromSuperview()

462
00:19:59,836 --> 00:20:02,576 A:middle
on an object of unknown type,

463

464
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

465
00:19:59,836 --> 00:20:02,576 A:middle
on an object of unknown type,

466
00:20:02,946 --> 00:20:04,976 A:middle
it may be there, it
may not be there.

467
00:20:06,226 --> 00:20:07,876 A:middle
Well, how do we deal with
this notion in Swift?

468
00:20:08,246 --> 00:20:11,406 A:middle
We use an "optional" that says
there may be a value there;

469
00:20:11,496 --> 00:20:12,226 A:middle
there may not be.

470
00:20:12,566 --> 00:20:14,726 A:middle
And so the reference to
removeFromSuperview()

471
00:20:14,726 --> 00:20:17,086 A:middle
on object is in effect,
optional.

472
00:20:17,506 --> 00:20:20,936 A:middle
That means we can use the
optional Chaining Operator here

473
00:20:21,886 --> 00:20:22,026 A:middle
to -

474
00:20:23,516 --> 00:20:29,066 A:middle
[ Applause ]

475
00:20:29,566 --> 00:20:30,616 A:middle
What we're doing, of course,

476
00:20:30,806 --> 00:20:33,266 A:middle
is we're folding the
respondsToSelector check in,

477
00:20:33,696 --> 00:20:36,566 A:middle
so we do the reference, go
look for RemoveFromSuperview.

478
00:20:36,976 --> 00:20:39,126 A:middle
If it's there, go on, call it.

479
00:20:39,886 --> 00:20:42,176 A:middle
If it's not there, stop
evaluating this expression.

480
00:20:42,176 --> 00:20:42,536 A:middle
We're done.

481
00:20:44,276 --> 00:20:47,156 A:middle
Now, something that id does

482
00:20:47,156 --> 00:20:50,496 A:middle
that AnyObject does not
do is implicitly downcast.

483
00:20:50,816 --> 00:20:54,316 A:middle
So I have Object, which is a
type AnyObject, and I'm trying

484
00:20:54,316 --> 00:20:56,486 A:middle
to assign it into a UIView.

485
00:20:57,506 --> 00:20:59,166 A:middle
This is going to
produce a compiler error

486
00:20:59,166 --> 00:21:01,786 A:middle
because this is a
unsafe downcast.

487

488
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

489
00:20:59,166 --> 00:21:01,786 A:middle
because this is a
unsafe downcast.

490
00:21:02,276 --> 00:21:05,146 A:middle
How do we deal with this?

491
00:21:05,236 --> 00:21:06,666 A:middle
Well, there's really
two cases here that need

492
00:21:06,666 --> 00:21:07,866 A:middle
that you need to think about.

493
00:21:08,536 --> 00:21:12,796 A:middle
One case is, I know it's a
UIView but for some reason

494
00:21:12,796 --> 00:21:15,496 A:middle
that strong type information
got lost when going

495
00:21:15,496 --> 00:21:16,626 A:middle
through some API somewhere.

496
00:21:17,226 --> 00:21:19,126 A:middle
If I know for sure
it's a UIView,

497
00:21:19,456 --> 00:21:23,086 A:middle
I can use the cast
operator, "as", to say,

498
00:21:23,086 --> 00:21:25,066 A:middle
"Treat this object as a UIView."

499
00:21:26,466 --> 00:21:29,326 A:middle
We're going to do these kind
of class check at runtime

500
00:21:29,326 --> 00:21:31,196 A:middle
to make sure that's
absolutely true.

501
00:21:31,836 --> 00:21:36,336 A:middle
But the type system will
believe you at this point.

502
00:21:36,516 --> 00:21:40,976 A:middle
Now if you don't know whether
this object is a UIView

503
00:21:40,976 --> 00:21:42,906 A:middle
or not, you can use the "as?"

504
00:21:43,036 --> 00:21:45,976 A:middle
to perform a conditional
downcast.

505
00:21:46,516 --> 00:21:52,606 A:middle
[ Applause ]

506
00:21:53,106 --> 00:21:54,286 A:middle
Think you guys have
figured it out?

507
00:21:54,286 --> 00:21:57,476 A:middle
But just to be sure, this is
doing "is kind of" class check.

508
00:21:57,476 --> 00:22:00,936 A:middle
And it's wrapping the result
in an optional UIView.

509

510
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

511
00:21:57,476 --> 00:22:00,936 A:middle
And it's wrapping the result
in an optional UIView.

512
00:22:01,756 --> 00:22:03,336 A:middle
It's nil if the check failed.

513
00:22:03,636 --> 00:22:06,426 A:middle
It has the UIView if
the check succeeded.

514
00:22:06,826 --> 00:22:08,256 A:middle
We can do an if-let here

515
00:22:08,676 --> 00:22:10,986 A:middle
to completely do this
entire thing safely,

516
00:22:11,336 --> 00:22:13,896 A:middle
and view in here is the
UIView we were looking for.

517
00:22:15,276 --> 00:22:17,886 A:middle
So let's take a little
bit of detour and talk

518
00:22:17,886 --> 00:22:19,366 A:middle
about tiny bit of protocols.

519
00:22:19,836 --> 00:22:24,026 A:middle
Here's an Objective-C Protocol
for a UITableViewDataSource

520
00:22:24,536 --> 00:22:27,426 A:middle
and its Swift equivalent.

521
00:22:27,786 --> 00:22:31,496 A:middle
Not a whole lot new here.

522
00:22:31,706 --> 00:22:33,866 A:middle
But there are two things that
I do I want to point out.

523
00:22:33,926 --> 00:22:38,076 A:middle
The first thing I want to point
out is optional and required.

524
00:22:38,546 --> 00:22:39,856 A:middle
So in Objective-C optional

525
00:22:39,856 --> 00:22:42,406 A:middle
and required are essentially
modes in the protocol.

526
00:22:42,916 --> 00:22:44,826 A:middle
You say @optional,
and everything

527
00:22:44,826 --> 00:22:47,636 A:middle
that follows is optional
up until the point

528
00:22:47,636 --> 00:22:50,066 A:middle
where you hit an @required and
then everything is required.

529
00:22:50,836 --> 00:22:54,426 A:middle
And we're not totally thrilled
with this decision now.

530
00:22:54,976 --> 00:22:56,996 A:middle
And the basic reason is
that you can't just look

531
00:22:56,996 --> 00:22:59,126 A:middle
at one single declaration
in the protocol

532
00:22:59,126 --> 00:23:00,846 A:middle
and know whether it's
optional or required.

533

534
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

535
00:22:59,126 --> 00:23:00,846 A:middle
and know whether it's
optional or required.

536
00:23:00,846 --> 00:23:03,636 A:middle
You have to go scan up
your protocol to find it.

537
00:23:04,006 --> 00:23:06,056 A:middle
And so we did something a
little bit different in Swift

538
00:23:06,756 --> 00:23:10,876 A:middle
in that requirements in
protocol are required

539
00:23:10,876 --> 00:23:12,506 A:middle
by default in Swift.

540
00:23:12,806 --> 00:23:15,326 A:middle
If you want to make them
optional, then tag them

541
00:23:15,326 --> 00:23:17,596 A:middle
with the optional attribute
to make them optional.

542
00:23:18,936 --> 00:23:20,696 A:middle
The other thing I want
to point out here.

543
00:23:21,016 --> 00:23:23,216 A:middle
We're doing a little bit
of Protocol Inheritance

544
00:23:23,916 --> 00:23:26,416 A:middle
and we're inheriting
from NSObjectProtocol.

545
00:23:28,196 --> 00:23:31,946 A:middle
So in Objective-C we will
have NSObject the class

546
00:23:32,116 --> 00:23:34,046 A:middle
and NSObject the protocol.

547
00:23:35,216 --> 00:23:38,716 A:middle
And they have the same name so
we have to add the "the class"

548
00:23:38,716 --> 00:23:40,746 A:middle
or "the protocol" at the
end when we talk about it.

549
00:23:41,106 --> 00:23:45,296 A:middle
The language keeps these in
syntactically distinct points

550
00:23:45,736 --> 00:23:47,456 A:middle
so the language isn't confused.

551
00:23:48,086 --> 00:23:50,606 A:middle
But in Swift we wanted
to bring all these things

552
00:23:50,606 --> 00:23:53,476 A:middle
into the same namespace because
that's far more convenient

553
00:23:53,476 --> 00:23:54,476 A:middle
for the general case.

554
00:23:54,876 --> 00:23:56,436 A:middle
And so we needed to
rename something.

555
00:23:57,056 --> 00:23:59,376 A:middle
And essentially when there's a
conflict between a class name

556
00:23:59,376 --> 00:24:01,336 A:middle
and a protocol name,
we'll append protocol

557

558
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

559
00:23:59,376 --> 00:24:01,336 A:middle
and a protocol name,
we'll append protocol

560
00:24:01,336 --> 00:24:03,286 A:middle
to the name of the protocol.

561
00:24:03,846 --> 00:24:06,286 A:middle
Why did we do this?

562
00:24:06,286 --> 00:24:10,766 A:middle
Well, let's take a look at
another use of id that we see

563
00:24:10,846 --> 00:24:14,086 A:middle
in Objective-C, and that's
protocol-qualified id.

564
00:24:15,086 --> 00:24:19,426 A:middle
So this dataSource here is an
object of some unknown type.

565
00:24:20,626 --> 00:24:22,336 A:middle
But we know that
the type conforms

566
00:24:22,336 --> 00:24:24,346 A:middle
to the UITableViewDataSource
protocol.

567
00:24:25,526 --> 00:24:27,416 A:middle
We describe that a
little bit more directly

568
00:24:27,416 --> 00:24:30,056 A:middle
in the Swift language by
just saying the dataSource is

569
00:24:30,056 --> 00:24:31,486 A:middle
a UITableViewDataSource!.

570
00:24:32,146 --> 00:24:33,026 A:middle
That's it.

571
00:24:33,716 --> 00:24:38,006 A:middle
Now some of you here noticed
with protocol-qualified id,

572
00:24:38,256 --> 00:24:40,766 A:middle
you can have many different
protocols if you want.

573
00:24:41,346 --> 00:24:44,836 A:middle
We can use the protocol
keyword with angle brackets

574
00:24:44,996 --> 00:24:46,396 A:middle
to describe more
than one protocol.

575
00:24:46,396 --> 00:24:49,456 A:middle
Now, one of the things we do

576
00:24:49,456 --> 00:24:52,116 A:middle
with Protocol Conformance is we
have an object of unknown type

577
00:24:52,116 --> 00:24:55,266 A:middle
and we want to determine, does
it conform to the protocol?

578
00:24:55,456 --> 00:24:57,606 A:middle
This is the "conforms
to protocol check"

579
00:24:57,606 --> 00:25:00,236 A:middle
in the Objective-C runtime.

580

581
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

582
00:24:57,606 --> 00:25:00,236 A:middle
in the Objective-C runtime.

583
00:25:00,356 --> 00:25:02,506 A:middle
In Swift, we do this same thing

584
00:25:03,056 --> 00:25:05,276 A:middle
with the conditional
downcast operator.

585
00:25:05,836 --> 00:25:09,106 A:middle
So we can just ask, is my object
the UITableViewDataSource"

586
00:25:09,686 --> 00:25:11,916 A:middle
conforms to protocol check,
happens in the runtime,

587
00:25:12,196 --> 00:25:13,826 A:middle
captures the results
in an optional.

588
00:25:14,216 --> 00:25:17,026 A:middle
Here we can go easily do
that, call one of the methods

589
00:25:17,026 --> 00:25:19,926 A:middle
and compute the number of
rows in the first section

590
00:25:19,976 --> 00:25:21,406 A:middle
of this TableViewDataSource.

591
00:25:21,916 --> 00:25:25,146 A:middle
Let's make our example a
little bit more interesting.

592
00:25:25,766 --> 00:25:28,446 A:middle
Let's compute the number of
rows in the last section.

593
00:25:29,716 --> 00:25:32,446 A:middle
So here we need to compute the
number of sections that exist

594
00:25:32,446 --> 00:25:36,936 A:middle
in the TableView, subtract one
off of it, and then we can ask

595
00:25:36,936 --> 00:25:38,576 A:middle
for the number of
rows in that section.

596
00:25:39,076 --> 00:25:41,506 A:middle
Now there's a problem
with this code.

597
00:25:42,566 --> 00:25:45,226 A:middle
And the problem is the number
of sections in TableView,

598
00:25:45,266 --> 00:25:48,186 A:middle
as you might remember,
is an optional method.

599
00:25:48,766 --> 00:25:50,196 A:middle
It might not be there
at runtime.

600
00:25:50,886 --> 00:25:53,876 A:middle
So we're going to need to
compile error out of this

601
00:25:53,876 --> 00:25:55,706 A:middle
because we need to deal
with the optionality

602
00:25:55,706 --> 00:25:57,006 A:middle
of this protocol method.

603
00:25:57,836 --> 00:25:59,796 A:middle
And we deal with this
the same way we deal

604
00:25:59,796 --> 00:26:02,736 A:middle
with optionality everywhere
else in the Swift language,

605

606
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

607
00:25:59,796 --> 00:26:02,736 A:middle
with optionality everywhere
else in the Swift language,

608
00:26:03,576 --> 00:26:05,166 A:middle
using the mechanisms we have.

609
00:26:05,166 --> 00:26:07,836 A:middle
So here we're going to
use the chaining "?"

610
00:26:07,836 --> 00:26:11,916 A:middle
operator. We're checking, does
my DataSource have a number

611
00:26:11,916 --> 00:26:13,626 A:middle
of sections in TableView method?

612
00:26:14,066 --> 00:26:16,606 A:middle
If so, call it, given
the TableView,

613
00:26:16,956 --> 00:26:19,156 A:middle
and then we capture the
result in numSections

614
00:26:19,456 --> 00:26:21,226 A:middle
so we can compute the
last section number

615
00:26:21,696 --> 00:26:23,926 A:middle
and get the number of rows

616
00:26:24,026 --> 00:26:28,766 A:middle
in the last section
of our TableView.

617
00:26:29,046 --> 00:26:30,996 A:middle
That's about all we're going to
talk about with Protocols here.

618
00:26:31,716 --> 00:26:33,776 A:middle
If you're interested
in Protocols and some

619
00:26:33,776 --> 00:26:35,196 A:middle
of the amazing things
they can do,

620
00:26:35,586 --> 00:26:37,996 A:middle
there's an "Advanced Swift"
talk tomorrow morning.

621
00:26:38,556 --> 00:26:41,756 A:middle
It goes into more depth on
those and their interaction

622
00:26:42,296 --> 00:26:46,196 A:middle
with the generic system.

623
00:26:46,196 --> 00:26:51,646 A:middle
So, wrapping up here, AnyObject
is Swift's equivalent to id.

624
00:26:52,346 --> 00:26:53,856 A:middle
The functionality is similar.

625
00:26:53,856 --> 00:26:56,386 A:middle
The ideas are similar
and the uses are similar.

626
00:26:56,746 --> 00:26:58,706 A:middle
However, it's more
safe by default.

627
00:26:59,756 --> 00:27:02,826 A:middle
Now we didn't talk about it,
but there's also AnyClass,

628

629
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

630
00:26:59,756 --> 00:27:02,826 A:middle
Now we didn't talk about it,
but there's also AnyClass,

631
00:27:02,956 --> 00:27:06,706 A:middle
which is Swift's equivalent
to class and has most

632
00:27:06,706 --> 00:27:07,876 A:middle
of the same behaviors.

633
00:27:08,446 --> 00:27:12,256 A:middle
Now the other thing that we've
seen is how Optionals are used

634
00:27:12,336 --> 00:27:15,656 A:middle
throughout the language to
represent dynamic checks.

635
00:27:16,276 --> 00:27:18,456 A:middle
We've taken "is kind
of" class checks,

636
00:27:18,826 --> 00:27:22,416 A:middle
conforms to protocol checks,
responds to selector checks,

637
00:27:22,706 --> 00:27:25,616 A:middle
and folded them all into
the notion of Optionals

638
00:27:25,616 --> 00:27:28,706 A:middle
within the language with
their optimized syntax

639
00:27:28,746 --> 00:27:31,976 A:middle
to make them easy to use and
easy to do the right thing.

640
00:27:32,526 --> 00:27:38,336 A:middle
With that, let's switch
gears a little bit and talk

641
00:27:38,336 --> 00:27:40,546 A:middle
about Bridging of
Cocoa data types.

642
00:27:41,106 --> 00:27:44,516 A:middle
Now first, let's talk a little
bit about the native Strings,

643
00:27:44,516 --> 00:27:46,736 A:middle
Arrays, and the Dictionaries
within Swift.

644
00:27:47,586 --> 00:27:50,006 A:middle
The goal of Swift
is to have one set

645
00:27:50,006 --> 00:27:53,296 A:middle
of general-purpose native
value types that you use

646
00:27:53,296 --> 00:27:54,456 A:middle
for nearly everything.

647
00:27:55,396 --> 00:27:57,066 A:middle
These need to be
safe by default.

648
00:27:57,066 --> 00:27:58,846 A:middle
This means bounds
restricting for arrays,

649
00:27:58,846 --> 00:28:00,796 A:middle
automatic memory
management, and so on.

650

651
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

652
00:27:58,846 --> 00:28:00,796 A:middle
automatic memory
management, and so on.

653
00:28:01,926 --> 00:28:04,636 A:middle
They need to have predictable
performance so that you can look

654
00:28:04,636 --> 00:28:07,176 A:middle
at code and have a sense
of how it's going to behave

655
00:28:07,176 --> 00:28:09,356 A:middle
with no surprises, how
it's going to perform.

656
00:28:10,746 --> 00:28:13,116 A:middle
And, of course, we want
arrays and dictionaries

657
00:28:13,616 --> 00:28:16,956 A:middle
to be collections and they need
to be strongly typed collections

658
00:28:16,956 --> 00:28:17,946 A:middle
that work with any type.

659
00:28:18,056 --> 00:28:19,886 A:middle
We can't limit them
just to objects

660
00:28:19,926 --> 00:28:22,486 A:middle
because sometimes you need
an array of strings or ints.

661
00:28:23,576 --> 00:28:26,746 A:middle
And we don't have a seed to
fall back to for the cases

662
00:28:26,746 --> 00:28:27,976 A:middle
where the other tools
don't work.

663
00:28:28,416 --> 00:28:31,206 A:middle
This is it.

664
00:28:31,476 --> 00:28:34,776 A:middle
Now, to support having
this one notion of one set

665
00:28:34,776 --> 00:28:37,656 A:middle
of general purpose native value
types, we're going to bridge

666
00:28:37,656 --> 00:28:40,446 A:middle
from Cocoa's NSString,
NSArray, NSDictionary,

667
00:28:40,816 --> 00:28:42,496 A:middle
into the Swift-native
equivalents.

668
00:28:44,616 --> 00:28:46,836 A:middle
So let's first talk a little bit

669
00:28:46,986 --> 00:28:49,226 A:middle
about the native
string type itself.

670
00:28:50,326 --> 00:28:54,146 A:middle
So, String is an efficient,
Unicode-compliant string type.

671
00:28:55,556 --> 00:28:59,356 A:middle
Core string type of Swift
has Unicode built in through

672
00:28:59,356 --> 00:29:01,056 A:middle
and through so it makes
it easy to work with.

673

674
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

675
00:28:59,356 --> 00:29:01,056 A:middle
and through so it makes
it easy to work with.

676
00:29:01,626 --> 00:29:02,706 A:middle
We provide flexible

677
00:29:02,706 --> 00:29:06,226 A:middle
and efficient high-level
APIs to work with strings.

678
00:29:06,226 --> 00:29:08,696 A:middle
You can easily do
concatenation, searches,

679
00:29:08,816 --> 00:29:11,076 A:middle
prefix matches, sub-strings.

680
00:29:11,516 --> 00:29:14,106 A:middle
And the strings provide
value semantics,

681
00:29:14,206 --> 00:29:15,716 A:middle
which makes them
easier to work with.

682
00:29:16,416 --> 00:29:21,286 A:middle
And value semantics is generally
a fairly simple notion of,

683
00:29:21,606 --> 00:29:23,476 A:middle
you know, if I have two
variables of string type,

684
00:29:24,106 --> 00:29:27,706 A:middle
modifying one of them doesn't
affect the other one, all right.

685
00:29:27,796 --> 00:29:30,436 A:middle
This is very nice for a
fundamental data type.

686
00:29:32,716 --> 00:29:34,976 A:middle
Now, of course, you can also
think of strings as a unit,

687
00:29:34,976 --> 00:29:37,026 A:middle
but you can also think
of them as being composed

688
00:29:37,026 --> 00:29:39,496 A:middle
of characters which,
in fact, they are.

689
00:29:40,476 --> 00:29:44,576 A:middle
And so we can go walk over a
string and using the for loop,

690
00:29:44,816 --> 00:29:47,196 A:middle
and get all of the
characters out of the string.

691
00:29:47,506 --> 00:29:49,596 A:middle
And you get the answer
that you would expect.

692
00:29:49,646 --> 00:29:52,806 A:middle
There are five characters here
even though there's no emoji

693
00:29:53,596 --> 00:29:55,516 A:middle
at the end.

694
00:29:55,516 --> 00:30:01,016 A:middle
So I want to talk a little bit
about characters and code points

695

696
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

697
00:29:55,516 --> 00:30:01,016 A:middle
So I want to talk a little bit
about characters and code points

698
00:30:02,106 --> 00:30:03,856 A:middle
because the character
that you're getting

699
00:30:03,856 --> 00:30:04,976 A:middle
out of here is a full
Unicode character.

700
00:30:05,236 --> 00:30:09,166 A:middle
It's not a UTF-8 code
point or UTF-16 code point

701
00:30:09,166 --> 00:30:09,936 A:middle
that you have to deal with.

702
00:30:10,376 --> 00:30:12,226 A:middle
It is a Unicode character.

703
00:30:13,386 --> 00:30:16,706 A:middle
And now, one of the challenges
with the Unicode characters is,

704
00:30:16,706 --> 00:30:20,866 A:middle
you really can't encode
them efficiently in a way

705
00:30:20,866 --> 00:30:24,866 A:middle
that treats a string as
just an array of characters.

706
00:30:25,586 --> 00:30:26,456 A:middle
It would be too large.

707
00:30:27,096 --> 00:30:28,946 A:middle
And so what you generally see is

708
00:30:28,946 --> 00:30:33,346 A:middle
that a string is encoded
as, say, UTF-8 or UTF-16.

709
00:30:34,376 --> 00:30:37,446 A:middle
But working with those
UTF-8 or UTF-16 code points,

710
00:30:37,736 --> 00:30:40,556 A:middle
that requires Unicode expertise
to get right all the time.

711
00:30:42,246 --> 00:30:44,126 A:middle
And so we made a really
interesting decision here.

712
00:30:45,336 --> 00:30:49,066 A:middle
We decided not to provide the
super low-level operations

713
00:30:49,066 --> 00:30:52,856 A:middle
like length and characterAtIndex
to let you poke directly

714
00:30:52,856 --> 00:30:55,796 A:middle
at the UTF-16 or UTF-8 code
points, or whatever is stored

715
00:30:55,796 --> 00:30:59,786 A:middle
in the string because doing
so causes big problems.

716
00:30:59,886 --> 00:31:03,876 A:middle
Instead we want you to
use the high-level APIs

717

718
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

719
00:30:59,886 --> 00:31:03,876 A:middle
Instead we want you to
use the high-level APIs

720
00:31:04,186 --> 00:31:06,726 A:middle
and let the library do
the hard work of dealing

721
00:31:06,726 --> 00:31:08,516 A:middle
with all the intricacies
of Unicode.

722
00:31:09,086 --> 00:31:13,056 A:middle
Of course, there's still common
operations you want to use.

723
00:31:13,546 --> 00:31:16,836 A:middle
You may want to count the number
of characters in a string,

724
00:31:17,526 --> 00:31:19,946 A:middle
so there's this countElements
algorithm.

725
00:31:19,946 --> 00:31:23,296 A:middle
It works on any sequence
and allows you to, well,

726
00:31:23,366 --> 00:31:25,176 A:middle
just count the number of
characters in a string,

727
00:31:25,546 --> 00:31:27,146 A:middle
and this produces
the right answer,

728
00:31:27,146 --> 00:31:29,566 A:middle
which is there are five
characters in this string.

729
00:31:30,426 --> 00:31:32,846 A:middle
Some of you will want to
work with code points, right.

730
00:31:33,336 --> 00:31:36,006 A:middle
You may be Unicode experts
and that's wonderful.

731
00:31:36,396 --> 00:31:38,206 A:middle
You can get access
to the code points.

732
00:31:38,356 --> 00:31:42,996 A:middle
There's a property UTF-16 that
gives you a lazily computed view

733
00:31:42,996 --> 00:31:46,976 A:middle
on the string producing
the UTF-16 code points

734
00:31:46,976 --> 00:31:47,746 A:middle
in that string.

735
00:31:49,316 --> 00:31:53,216 A:middle
And we can go walk over
the 16-bit unsigned integer

736
00:31:53,546 --> 00:31:54,656 A:middle
code points.

737
00:31:55,096 --> 00:31:58,536 A:middle
We can print out the number of
code points here and, of course,

738
00:31:58,536 --> 00:32:00,836 A:middle
you'll get the answer "6"

739

740
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

741
00:31:58,536 --> 00:32:00,836 A:middle
you'll get the answer "6"

742
00:32:01,306 --> 00:32:04,966 A:middle
because there are six UTF-16
code points in this string.

743
00:32:06,056 --> 00:32:06,956 A:middle
The last thing I want to talk

744
00:32:06,956 --> 00:32:09,376 A:middle
about with strings
is the relationship

745
00:32:09,376 --> 00:32:11,466 A:middle
between string and NSSring.

746
00:32:12,726 --> 00:32:14,686 A:middle
So NSString has a wealth

747
00:32:14,926 --> 00:32:17,586 A:middle
of really great text
processing APIs

748
00:32:17,916 --> 00:32:19,856 A:middle
that you've probably
been using for years.

749
00:32:20,376 --> 00:32:23,886 A:middle
So we've made all those
Foundation APIs directly

750
00:32:23,886 --> 00:32:26,846 A:middle
available on the string
type, so the APIs you know

751
00:32:26,846 --> 00:32:29,506 A:middle
and love are there,
and you can use them.

752
00:32:30,716 --> 00:32:33,706 A:middle
Now in doing so, we've made
them a little bit more Swift.

753
00:32:33,706 --> 00:32:35,976 A:middle
We've tightened up the
type signatures so that

754
00:32:35,976 --> 00:32:38,996 A:middle
if you're going to split a
string into its components,

755
00:32:38,996 --> 00:32:41,826 A:middle
well, you're getting it back
an array of strings rather

756
00:32:41,826 --> 00:32:43,726 A:middle
than just an array
of somethings.

757
00:32:45,596 --> 00:32:49,316 A:middle
Now you may have developed
your own categories on NSString

758
00:32:49,566 --> 00:32:51,426 A:middle
with additional functionality
that you use

759
00:32:51,426 --> 00:32:52,896 A:middle
within your own applications.

760
00:32:53,896 --> 00:32:55,946 A:middle
You can get to those
with a simple Cast.

761
00:32:56,086 --> 00:32:59,626 A:middle
So you can take a Swift string,
turn it into an NSString,

762
00:32:59,796 --> 00:33:00,926 A:middle
so this is just a conversion,

763

764
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

765
00:32:59,796 --> 00:33:00,926 A:middle
so this is just a conversion,

766
00:33:01,986 --> 00:33:04,426 A:middle
and then call your
NSStringMethod.

767
00:33:05,636 --> 00:33:07,996 A:middle
If you find yourselves
doing this a lot,

768
00:33:08,696 --> 00:33:10,646 A:middle
feel free to just go ahead

769
00:33:10,646 --> 00:33:12,656 A:middle
and extend the underlying
string type.

770
00:33:12,966 --> 00:33:15,196 A:middle
Add your StringMethod,
make it a little more Swift

771
00:33:15,196 --> 00:33:17,486 A:middle
with strong type signatures,
closures if you'd like.

772
00:33:18,766 --> 00:33:22,146 A:middle
But this should help you feel
at home in Swift fairly quickly

773
00:33:22,376 --> 00:33:24,166 A:middle
and use the String type.

774
00:33:25,476 --> 00:33:29,306 A:middle
Now let's move from
String to a container.

775
00:33:29,566 --> 00:33:31,486 A:middle
Let's talk about Arrays.

776
00:33:32,376 --> 00:33:36,396 A:middle
So here we have toolbar
items that is in an NSArray.

777
00:33:37,036 --> 00:33:43,386 A:middle
That's going to come into
Swift as an array of AnyObject.

778
00:33:44,386 --> 00:33:46,656 A:middle
Now these two types
are fairly similar.

779
00:33:47,346 --> 00:33:49,826 A:middle
You can iterate over them
and what you're going to get

780
00:33:49,826 --> 00:33:52,396 A:middle
out of it are values
of type AnyObject.

781
00:33:52,466 --> 00:33:54,646 A:middle
They're objects but you don't
know what kind of object it is.

782
00:33:55,356 --> 00:33:57,486 A:middle
You can subscript into
them and, of course,

783
00:33:57,486 --> 00:33:58,786 A:middle
you will get an AnyObject.

784

785
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

786
00:34:00,256 --> 00:34:04,976 A:middle
Now, in Swift, you tend to deal
in typed arrays more often.

787
00:34:05,446 --> 00:34:07,906 A:middle
And so there are
some other operations

788
00:34:07,906 --> 00:34:09,846 A:middle
that the core language
needs to provide

789
00:34:09,846 --> 00:34:11,315 A:middle
for you to make this clean.

790
00:34:12,085 --> 00:34:16,696 A:middle
So maybe I'm composing my
toolbar items into a Swift array

791
00:34:17,176 --> 00:34:20,406 A:middle
and that Swift array is going
to contain UIBarButtonItems.

792
00:34:20,926 --> 00:34:24,716 A:middle
That's what actually goes into
the toolbar items property.

793
00:34:25,706 --> 00:34:29,636 A:middle
I can work with that Swift
Array and then I can assign it

794
00:34:29,636 --> 00:34:31,335 A:middle
into the AnyObject array.

795
00:34:31,335 --> 00:34:35,065 A:middle
So this is essentially doing
a safe upcast of any array

796
00:34:35,065 --> 00:34:37,636 A:middle
of ToolbarItems to any
array of AnyObjects.

797
00:34:38,456 --> 00:34:40,906 A:middle
It also happens to be
calling into Objective-C,

798
00:34:41,085 --> 00:34:43,916 A:middle
which we'll get to in a minute.

799
00:34:44,076 --> 00:34:48,025 A:middle
Now we also see the flip side
of this where we want to, say,

800
00:34:48,025 --> 00:34:49,636 A:middle
iterate over all
the ToolbarItems

801
00:34:50,735 --> 00:34:56,295 A:middle
in this particular view
controller and here we're going

802
00:34:56,295 --> 00:34:59,476 A:middle
to get AnyObject values and,
we talked about cast earlier,

803
00:34:59,476 --> 00:35:01,226 A:middle
so we can downcast each of them.

804

805
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

806
00:34:59,476 --> 00:35:01,226 A:middle
so we can downcast each of them.

807
00:35:01,756 --> 00:35:04,406 A:middle
This is fine but it's a little
bit on the tedious side.

808
00:35:04,766 --> 00:35:07,076 A:middle
And so we have specialized
syntax here

809
00:35:07,296 --> 00:35:12,836 A:middle
to downcast an entire
array at a time doing the

810
00:35:12,836 --> 00:35:14,656 A:middle
"is kind of" class
checks necessary

811
00:35:14,656 --> 00:35:17,436 A:middle
to make this safe
lazily behind the scenes.

812
00:35:18,596 --> 00:35:19,966 A:middle
And then you can walk
over all with them.

813
00:35:20,516 --> 00:35:26,086 A:middle
[ Applause ]

814
00:35:26,586 --> 00:35:29,646 A:middle
Now, we've seen NSArrays
in the Objective-C side,

815
00:35:30,176 --> 00:35:32,506 A:middle
Swift arrays on the Swift side.

816
00:35:32,946 --> 00:35:35,116 A:middle
Let's take a little bit
of a peek under the hood

817
00:35:35,296 --> 00:35:38,226 A:middle
at how this actually
works because you're going

818
00:35:38,226 --> 00:35:41,526 A:middle
to be writing a lot of Swift
code that interacts with a lot

819
00:35:41,526 --> 00:35:43,626 A:middle
of Objective-C code and we
want this to perform well.

820
00:35:45,456 --> 00:35:48,496 A:middle
So there's a Swift array.

821
00:35:48,536 --> 00:35:52,896 A:middle
And the Swift array actually has
two internal representations.

822
00:35:53,826 --> 00:35:56,726 A:middle
Its first representation is
probably what you'd expect

823
00:35:56,726 --> 00:35:57,286 A:middle
out of Swift.

824
00:35:57,756 --> 00:35:59,206 A:middle
It's a native representation.

825
00:35:59,596 --> 00:36:02,166 A:middle
It has a length, which is the
number of elements in the array.

826

827
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

828
00:35:59,596 --> 00:36:02,166 A:middle
It has a length, which is the
number of elements in the array.

829
00:36:02,166 --> 00:36:04,316 A:middle
It has a capacity that's used

830
00:36:04,316 --> 00:36:07,026 A:middle
so we can algorithmically
efficiently add things

831
00:36:07,026 --> 00:36:07,556 A:middle
to the array.

832
00:36:09,126 --> 00:36:12,926 A:middle
And then it has the buffer of
elements that are in the array.

833
00:36:14,416 --> 00:36:17,916 A:middle
And, of course, those buffered
elements, whatever kind

834
00:36:17,916 --> 00:36:19,736 A:middle
of array it is, that's how
much storage they take.

835
00:36:19,736 --> 00:36:21,906 A:middle
If we have an array
of 32-bit integers,

836
00:36:21,906 --> 00:36:24,156 A:middle
each element takes
32 bits of storage.

837
00:36:24,156 --> 00:36:25,966 A:middle
There's not extra
boxing going on here,

838
00:36:26,666 --> 00:36:27,776 A:middle
no extra performance loss.

839
00:36:27,946 --> 00:36:30,986 A:middle
It's just a native buffer.

840
00:36:31,166 --> 00:36:33,906 A:middle
Now we also have this
second representation

841
00:36:34,526 --> 00:36:37,446 A:middle
and we do a couple of pointer
tricks so that we can fit it

842
00:36:37,446 --> 00:36:39,546 A:middle
into just a tiny
amount of memory.

843
00:36:40,116 --> 00:36:42,076 A:middle
And that's the Cocoa
representation.

844
00:36:43,236 --> 00:36:49,096 A:middle
So any Swift array can actually
be an NSArray underneath

845
00:36:49,256 --> 00:36:50,346 A:middle
as representation.

846
00:36:50,966 --> 00:36:54,476 A:middle
And all the operations
on an array handle both

847
00:36:54,476 --> 00:36:55,996 A:middle
of these representations.

848
00:36:56,486 --> 00:37:00,386 A:middle
So if I subscript my array and
it happens to be an NSArray,

849

850
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

851
00:36:56,486 --> 00:37:00,386 A:middle
So if I subscript my array and
it happens to be an NSArray,

852
00:37:00,916 --> 00:37:02,886 A:middle
we'll use object and
index behind the scenes.

853
00:37:03,666 --> 00:37:04,926 A:middle
So you get the result
that you want.

854
00:37:05,916 --> 00:37:07,606 A:middle
If we do append to
such an array, well,

855
00:37:07,636 --> 00:37:10,196 A:middle
we can flip the representation
quickly and give you

856
00:37:10,196 --> 00:37:11,566 A:middle
that efficient append operation.

857
00:37:12,166 --> 00:37:16,176 A:middle
So given these two
representations,

858
00:37:16,356 --> 00:37:20,066 A:middle
we can talk about the notion
of bridging, of converting

859
00:37:20,666 --> 00:37:23,746 A:middle
between an NSArray, as
Objective-C would see,

860
00:37:24,786 --> 00:37:26,936 A:middle
and a Swift array that
you use within Swift.

861
00:37:28,256 --> 00:37:29,216 A:middle
There's two directions here:

862
00:37:29,696 --> 00:37:31,686 A:middle
going to Objective-C
and coming back.

863
00:37:32,986 --> 00:37:36,416 A:middle
So first, let's talk
about coming back.

864
00:37:37,196 --> 00:37:39,036 A:middle
So we have an Objective-C
method.

865
00:37:39,036 --> 00:37:41,336 A:middle
In this case, it's the
getter for toolbar items.

866
00:37:41,766 --> 00:37:43,686 A:middle
In Objective-C, that
returns NSArray.

867
00:37:44,406 --> 00:37:47,576 A:middle
In Swift, that's going to come
back as an array of AnyObject.

868
00:37:48,236 --> 00:37:49,136 A:middle
How do we do this?

869
00:37:49,586 --> 00:37:51,406 A:middle
Well, given our two
representations,

870
00:37:51,956 --> 00:37:53,386 A:middle
it's extremely efficient
to do it

871
00:37:53,386 --> 00:37:54,976 A:middle
because we have our
representation

872
00:37:55,266 --> 00:37:57,846 A:middle
that can just take
that NSArray directly.

873
00:37:58,426 --> 00:38:00,616 A:middle
All we need to do is
one copy operation

874

875
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

876
00:37:58,426 --> 00:38:00,616 A:middle
All we need to do is
one copy operation

877
00:38:00,946 --> 00:38:03,256 A:middle
to make sure the contents
don't change underneath us

878
00:38:03,256 --> 00:38:04,616 A:middle
if it's a mutable array.

879
00:38:05,746 --> 00:38:08,206 A:middle
But the common case here is
that it's not a mutable array.

880
00:38:08,336 --> 00:38:12,436 A:middle
It's an immutable NSArray and so
this copy operation is trivial.

881
00:38:12,436 --> 00:38:14,966 A:middle
It's a message send, it's
a retain, and that's it.

882
00:38:15,366 --> 00:38:16,926 A:middle
So its conversion
is extremely fast.

883
00:38:17,746 --> 00:38:20,646 A:middle
Let's talk about
the other direction,

884
00:38:21,576 --> 00:38:23,656 A:middle
going from a Swift
array to an NSArray.

885
00:38:24,146 --> 00:38:27,556 A:middle
So this would happen when we
take, say, our ToolbarItems.

886
00:38:27,556 --> 00:38:28,436 A:middle
It's a Swift array.

887
00:38:28,946 --> 00:38:31,036 A:middle
And we call the Objective-C
setter,

888
00:38:31,446 --> 00:38:32,886 A:middle
which expects an NSArray.

889
00:38:33,586 --> 00:38:36,036 A:middle
Well, now we have an
interesting question

890
00:38:36,906 --> 00:38:38,686 A:middle
because there's two possible
representations here.

891
00:38:39,176 --> 00:38:40,496 A:middle
There's the really easy answer.

892
00:38:41,036 --> 00:38:43,186 A:middle
It's already in the
Cocoa representation

893
00:38:43,386 --> 00:38:46,246 A:middle
and we can just hand off
the NSArray, no work at all.

894
00:38:47,696 --> 00:38:50,546 A:middle
But the native one, that a
different question entirely.

895
00:38:51,406 --> 00:38:55,906 A:middle
We could copy the whole buffer
but that would be awful.

896
00:38:55,906 --> 00:38:59,016 A:middle
We could possibly go
allocate a little shim object.

897
00:38:59,016 --> 00:39:00,636 A:middle
That's also possible.

898

899
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

900
00:38:59,016 --> 00:39:00,636 A:middle
That's also possible.

901
00:39:01,346 --> 00:39:05,096 A:middle
Instead, we decided to make
our native representation

902
00:39:06,016 --> 00:39:08,866 A:middle
into a little bit of an
Objective-C object [laughter].

903
00:39:09,526 --> 00:39:12,376 A:middle
It's already an NSArray.

904
00:39:13,516 --> 00:39:15,986 A:middle
And we've optimized
the allocation here

905
00:39:16,406 --> 00:39:18,656 A:middle
so we can build these
objects super fast

906
00:39:19,476 --> 00:39:21,776 A:middle
and just pass off our
native representation

907
00:39:21,956 --> 00:39:24,826 A:middle
as if it were an NSArray
and it works beautifully

908
00:39:24,826 --> 00:39:26,466 A:middle
on the Objective-C side.

909
00:39:29,516 --> 00:39:33,856 A:middle
[ Applause ]

910
00:39:34,356 --> 00:39:37,216 A:middle
I think that's enough
of Bridging.

911
00:39:37,696 --> 00:39:39,106 A:middle
Let's talk about subclassing.

912
00:39:41,206 --> 00:39:52,556 A:middle
Okay. So, Swift objects are
all Objective-C objects.

913
00:39:53,776 --> 00:39:56,546 A:middle
Now what this means is that,
if you define a class in Swift,

914
00:39:57,456 --> 00:39:59,976 A:middle
it has basic Objective-C
interoperability built in.

915

916
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

917
00:40:00,226 --> 00:40:05,136 A:middle
We use the same layout as an
Objective-C class so there's an

918
00:40:05,136 --> 00:40:06,346 A:middle
"isa" pointer in there.

919
00:40:06,346 --> 00:40:09,366 A:middle
The "isa" pointer points
out to Objective-C metadata.

920
00:40:10,166 --> 00:40:12,306 A:middle
There's the same
underlying infrastructure,

921
00:40:12,306 --> 00:40:15,836 A:middle
the thing that makes "arch" work
and the basic frameworks work

922
00:40:15,836 --> 00:40:16,906 A:middle
with retain and release.

923
00:40:17,116 --> 00:40:18,296 A:middle
You can expect a class.

924
00:40:19,136 --> 00:40:19,786 A:middle
That sort of thing.

925
00:40:20,086 --> 00:40:20,896 A:middle
They're all available.

926
00:40:22,416 --> 00:40:25,376 A:middle
Now, if you really want to
make use of your classes

927
00:40:25,486 --> 00:40:29,386 A:middle
from within your
Objective-C code, well,

928
00:40:29,386 --> 00:40:32,246 A:middle
then you should inherit
from an Objective-C class,

929
00:40:32,616 --> 00:40:35,106 A:middle
whether it's NSObject
or some other class.

930
00:40:35,596 --> 00:40:38,926 A:middle
And this is going to expose your
class to the Objective-C world

931
00:40:38,926 --> 00:40:42,516 A:middle
and make all the things you
write in Swift available also

932
00:40:42,516 --> 00:40:43,606 A:middle
to your Objective-C code.

933
00:40:44,746 --> 00:40:47,226 A:middle
So we're going to continue
with our UIDocument example

934
00:40:47,226 --> 00:40:50,636 A:middle
from earlier and we're going to
create a little MyDocument class

935
00:40:50,676 --> 00:40:52,766 A:middle
that inherits from UIDocument.

936
00:40:53,266 --> 00:40:57,046 A:middle
And we're going to
talk about a couple

937
00:40:57,046 --> 00:40:58,666 A:middle
of the things that
subclasses do.

938
00:40:59,076 --> 00:41:00,266 A:middle
They override methods.

939

940
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

941
00:40:59,076 --> 00:41:00,266 A:middle
They override methods.

942
00:41:01,276 --> 00:41:03,546 A:middle
So here we're going to
override the handleError,

943
00:41:03,546 --> 00:41:05,566 A:middle
userInteractionPermitted method.

944
00:41:06,636 --> 00:41:09,486 A:middle
And you do this exactly
the same way as you'd do it

945
00:41:09,486 --> 00:41:11,156 A:middle
if you were overriding
a Swift method.

946
00:41:11,426 --> 00:41:12,196 A:middle
It doesn't matter.

947
00:41:12,196 --> 00:41:13,486 A:middle
The syntax is the same.

948
00:41:13,636 --> 00:41:15,856 A:middle
The fact that the super class
is written in Objective-C?

949
00:41:16,116 --> 00:41:18,596 A:middle
Completely irrelevant to
the syntax of the language

950
00:41:18,896 --> 00:41:19,796 A:middle
and how you work with it.

951
00:41:21,856 --> 00:41:23,916 A:middle
Now one thing to note
in Swift is that the

952
00:41:23,916 --> 00:41:26,726 A:middle
"override" keyword is mandatory.

953
00:41:28,146 --> 00:41:28,976 A:middle
Why do we do that?

954
00:41:29,296 --> 00:41:30,656 A:middle
There's a couple of
reasons for doing that.

955
00:41:31,346 --> 00:41:35,136 A:middle
One of the reasons is because
when you look at a method,

956
00:41:35,726 --> 00:41:38,306 A:middle
you probably want to know
if the intention here is

957
00:41:38,306 --> 00:41:41,046 A:middle
to override your
super class's behavior

958
00:41:41,046 --> 00:41:43,906 A:middle
because that's a really
important part of your API.

959
00:41:44,136 --> 00:41:45,136 A:middle
It's a really part

960
00:41:45,136 --> 00:41:48,166 A:middle
of understanding what this
method is supposed to do.

961
00:41:48,766 --> 00:41:54,236 A:middle
Now the other thing it does is
it helps overriding accidents.

962
00:41:55,236 --> 00:41:58,496 A:middle
For example, I meant to override
something from my super class,

963
00:41:59,056 --> 00:42:01,046 A:middle
but I typed part of
the selector wrong

964

965
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

966
00:41:59,056 --> 00:42:01,046 A:middle
but I typed part of
the selector wrong

967
00:42:01,796 --> 00:42:04,006 A:middle
and the method name
no longer overrides.

968
00:42:04,286 --> 00:42:06,896 A:middle
My code isn't running
and I have no idea why.

969
00:42:06,896 --> 00:42:09,696 A:middle
Well, with mandatory
override, we catch that.

970
00:42:09,946 --> 00:42:12,286 A:middle
If you didn't override something
and you thought you did,

971
00:42:12,986 --> 00:42:13,826 A:middle
compiler will complain.

972
00:42:15,456 --> 00:42:19,196 A:middle
There's also the real
surprise which is

973
00:42:19,256 --> 00:42:21,916 A:middle
when you override something
from your super class

974
00:42:21,966 --> 00:42:23,786 A:middle
that you didn't even
know existed.

975
00:42:24,386 --> 00:42:30,046 A:middle
And this is the case where you
just wrote a method and maybe

976
00:42:30,046 --> 00:42:32,266 A:middle
in this release that
method happens to exist

977
00:42:32,266 --> 00:42:34,276 A:middle
or maybe it doesn't
exist in this release,

978
00:42:34,736 --> 00:42:37,516 A:middle
but some joker added it to the
next release in the frameworks

979
00:42:37,516 --> 00:42:39,696 A:middle
that you use and now
you're overriding something

980
00:42:39,696 --> 00:42:41,166 A:middle
that you didn't know
existed at the time.

981
00:42:41,996 --> 00:42:44,886 A:middle
We can catch that by
requiring override throughout

982
00:42:45,356 --> 00:42:45,926 A:middle
the language.

983
00:42:46,516 --> 00:42:51,686 A:middle
We could also talk a little bit
about overriding properties.

984
00:42:53,436 --> 00:42:57,406 A:middle
So, in Swift, you don't
override the getter

985
00:42:57,586 --> 00:42:58,926 A:middle
or the setter separately.

986
00:42:59,146 --> 00:43:01,796 A:middle
Instead you override
the property itself

987

988
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

989
00:42:59,146 --> 00:43:01,796 A:middle
Instead you override
the property itself

990
00:43:02,396 --> 00:43:06,116 A:middle
and then you provide a getter
or a setter as appropriate.

991
00:43:06,716 --> 00:43:08,276 A:middle
So here we're doing
something very simple.

992
00:43:08,276 --> 00:43:10,476 A:middle
We're overriding the
description property

993
00:43:11,046 --> 00:43:12,616 A:middle
and providing a new
getter for it.

994
00:43:13,806 --> 00:43:16,176 A:middle
Now what this means to
the Objective-C runtime,

995
00:43:16,416 --> 00:43:17,636 A:middle
to your Objective-C code,

996
00:43:17,636 --> 00:43:19,326 A:middle
is that you've overridden
the getter.

997
00:43:20,546 --> 00:43:23,276 A:middle
But the semantic model
in Swift is different.

998
00:43:23,276 --> 00:43:26,386 A:middle
It's based on overriding the
actual thing that was declared.

999
00:43:26,386 --> 00:43:27,646 A:middle
In this case, the property.

1000
00:43:28,216 --> 00:43:32,636 A:middle
As I mentioned before,
NSError is going to come back.

1001
00:43:33,446 --> 00:43:35,966 A:middle
So we have contentsForType
error we're going

1002
00:43:35,966 --> 00:43:37,346 A:middle
to override in our subclass.

1003
00:43:37,766 --> 00:43:40,576 A:middle
And remember that the
Objective-C method took NSError,

1004
00:43:42,226 --> 00:43:45,806 A:middle
a C pointer to an NSError
which could be nil.

1005
00:43:47,346 --> 00:43:49,986 A:middle
The way we work with
these in Swift is

1006
00:43:49,986 --> 00:43:53,646 A:middle
that the NSErrorPointer class
provides a couple of operations

1007
00:43:53,646 --> 00:43:55,336 A:middle
that you would expect
out of a pointer.

1008
00:43:55,736 --> 00:43:58,966 A:middle
You can test it for nil, as
we do in the if check here,

1009
00:43:59,396 --> 00:44:02,116 A:middle
to see whether we were actually
given a valid point error

1010

1011
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1012
00:43:59,396 --> 00:44:02,116 A:middle
to see whether we were actually
given a valid point error

1013
00:44:02,116 --> 00:44:04,216 A:middle
where it's being given
nil by our caller.

1014
00:44:05,426 --> 00:44:07,596 A:middle
Now, if it's not
nil, we can point

1015
00:44:07,596 --> 00:44:10,006 A:middle
at the memory location
associated with that pointer

1016
00:44:10,556 --> 00:44:14,756 A:middle
by referring to it as
error.memory and we can read

1017
00:44:14,756 --> 00:44:16,846 A:middle
from that memory or
write to that memory

1018
00:44:16,846 --> 00:44:18,356 A:middle
by just reading or
signing to it.

1019
00:44:19,566 --> 00:44:21,426 A:middle
Now, and this error pointer
is going to take care

1020
00:44:21,426 --> 00:44:24,726 A:middle
of the nitty-gritty details
of making this auto-releasing

1021
00:44:24,866 --> 00:44:27,146 A:middle
to fit in with the
code conventions

1022
00:44:27,146 --> 00:44:29,316 A:middle
of Cocoa NSError handling.

1023
00:44:29,316 --> 00:44:33,146 A:middle
So it's actually fairly easy
to deal with the C pointer

1024
00:44:33,346 --> 00:44:34,516 A:middle
from within the Swift world.

1025
00:44:35,266 --> 00:44:36,626 A:middle
Now let's take a look
at the Swift class

1026
00:44:36,626 --> 00:44:37,856 A:middle
that we've been building here.

1027
00:44:38,436 --> 00:44:42,266 A:middle
We have MyDocument.

1028
00:44:42,266 --> 00:44:43,796 A:middle
It inherits from UIDocument.

1029
00:44:44,356 --> 00:44:45,556 A:middle
It has a property in it.

1030
00:44:45,556 --> 00:44:47,226 A:middle
It has some method overrides.

1031
00:44:47,986 --> 00:44:50,106 A:middle
It's just a Swift class
through and through.

1032
00:44:51,256 --> 00:44:54,316 A:middle
But all of this is
accessible directly

1033
00:44:54,316 --> 00:44:56,096 A:middle
in your Objective-C code.

1034
00:44:57,386 --> 00:44:59,326 A:middle
So if you project
this into Objective-C,

1035
00:44:59,886 --> 00:45:01,656 A:middle
it would look like this.

1036

1037
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1038
00:44:59,886 --> 00:45:01,656 A:middle
it would look like this.

1039
00:45:01,656 --> 00:45:04,406 A:middle
All the same elements are there.

1040
00:45:04,406 --> 00:45:05,306 A:middle
We have properties.

1041
00:45:05,306 --> 00:45:06,166 A:middle
We have methods.

1042
00:45:06,686 --> 00:45:08,636 A:middle
Now there's some interesting
things to point out.

1043
00:45:09,216 --> 00:45:12,596 A:middle
Well, for one, we have
this item's property

1044
00:45:12,596 --> 00:45:13,776 A:middle
that is in an NSArray.

1045
00:45:14,866 --> 00:45:16,596 A:middle
Remember, we talked
about bridging here.

1046
00:45:17,836 --> 00:45:21,046 A:middle
The original Swift code
had an array of strings.

1047
00:45:22,496 --> 00:45:25,416 A:middle
We bridged that seamlessly
over to an NSArray

1048
00:45:25,446 --> 00:45:27,666 A:middle
that contains NSString objects

1049
00:45:27,866 --> 00:45:29,626 A:middle
for your Objective-C
code to use.

1050
00:45:30,146 --> 00:45:35,166 A:middle
So you can use strong typing
in the Swift world and it maps

1051
00:45:35,166 --> 00:45:38,606 A:middle
over to the natural thing
within the Objective-C world.

1052
00:45:39,746 --> 00:45:43,486 A:middle
The other thing I want to point
out is this really ugly name

1053
00:45:43,486 --> 00:45:44,436 A:middle
up top you've noticed.

1054
00:45:45,346 --> 00:45:46,466 A:middle
So this is a mangled name.

1055
00:45:47,386 --> 00:45:50,986 A:middle
Usually you're going to see
this as MyApp.MyDocument,

1056
00:45:51,996 --> 00:45:53,716 A:middle
unless you're poking at
the internal somewhere.

1057
00:45:54,306 --> 00:46:00,126 A:middle
And the purpose of this mangled
name is to put everything

1058

1059
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1060
00:45:54,306 --> 00:46:00,126 A:middle
And the purpose of this mangled
name is to put everything

1061
00:46:00,126 --> 00:46:02,566 A:middle
in a namespace of some
sort so you don't have

1062
00:46:02,566 --> 00:46:04,756 A:middle
to prefix all of
your class names.

1063
00:46:05,616 --> 00:46:09,436 A:middle
Instead, what Swift does
is it puts the module name,

1064
00:46:09,496 --> 00:46:11,786 A:middle
which is your target, your
framework, or your app -

1065
00:46:12,886 --> 00:46:16,186 A:middle
that name into the names
of the classes it creates

1066
00:46:16,386 --> 00:46:18,956 A:middle
so you can use the
simple names that you want

1067
00:46:18,956 --> 00:46:21,486 A:middle
to use throughout your
application and not worry

1068
00:46:21,486 --> 00:46:24,246 A:middle
about a conflict with something
else in the system somewhere.

1069
00:46:26,516 --> 00:46:32,286 A:middle
[ Applause ]

1070
00:46:32,786 --> 00:46:34,106 A:middle
When you're writing
your Swift Classes,

1071
00:46:34,326 --> 00:46:36,436 A:middle
you do need to be a
little bit cognizant

1072
00:46:37,006 --> 00:46:38,886 A:middle
of the limits of Objective-C.

1073
00:46:39,906 --> 00:46:42,286 A:middle
Swift has a lot of cool
features; you might want

1074
00:46:42,286 --> 00:46:45,336 A:middle
to use them -Tuples,
Generics and so on.

1075
00:46:45,876 --> 00:46:48,426 A:middle
And if you go crazy
in your classes

1076
00:46:48,426 --> 00:46:51,526 A:middle
and you use these features,
you might be a little surprised

1077
00:46:51,526 --> 00:46:55,966 A:middle
that this generic method that
returns a tuple doesn't show

1078
00:46:55,966 --> 00:46:58,576 A:middle
up in your Objective-C code
because Objective-C has no way

1079
00:46:58,576 --> 00:46:59,766 A:middle
to express that signature.

1080

1081
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1082
00:47:00,306 --> 00:47:01,076 A:middle
There's nothing we can do.

1083
00:47:01,076 --> 00:47:02,386 A:middle
We don't have tuples
in Objective-C.

1084
00:47:04,216 --> 00:47:07,186 A:middle
So if this happens to you
and you're surprised by it,

1085
00:47:08,176 --> 00:47:10,046 A:middle
there's an attribute you
can add to your method.

1086
00:47:10,716 --> 00:47:12,046 A:middle
It's the objc attribute.

1087
00:47:12,596 --> 00:47:16,656 A:middle
And what this does is it
asks the compiler to check

1088
00:47:17,166 --> 00:47:22,326 A:middle
and make sure that this method
or property or initializer

1089
00:47:22,326 --> 00:47:26,636 A:middle
or whatever is expressible in
Objective-C so it can be used

1090
00:47:26,636 --> 00:47:27,856 A:middle
from your Objective-C code.

1091
00:47:28,566 --> 00:47:31,566 A:middle
And if it's not expressible in
Objective-C for some reason,

1092
00:47:31,896 --> 00:47:33,696 A:middle
the compiler will
give you a hard error

1093
00:47:33,696 --> 00:47:36,536 A:middle
to tell you this is not
something you can use

1094
00:47:36,536 --> 00:47:37,246 A:middle
from Objective-C.

1095
00:47:39,006 --> 00:47:42,676 A:middle
Now the objc attribute
actually has a second purpose.

1096
00:47:42,866 --> 00:47:45,626 A:middle
And that's controlling
the names that you see

1097
00:47:45,626 --> 00:47:47,386 A:middle
in the Objective-C
side of things.

1098
00:47:48,456 --> 00:47:50,096 A:middle
So, here's a property enabled.

1099
00:47:50,286 --> 00:47:51,046 A:middle
It has a getter.

1100
00:47:51,046 --> 00:47:51,806 A:middle
It has a setter.

1101
00:47:53,486 --> 00:47:56,336 A:middle
In Objective-C this is going to
come through as a property named

1102
00:47:56,336 --> 00:48:00,216 A:middle
"enabled," a getter named
"enabled," and a setter named

1103

1104
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1105
00:47:56,336 --> 00:48:00,216 A:middle
"enabled," a getter named
"enabled," and a setter named

1106
00:48:00,216 --> 00:48:04,436 A:middle
"setEnabled:" That's
not Cocoa convention.

1107
00:48:04,596 --> 00:48:07,346 A:middle
You'd really rather the call,
the getter, "isEnabled".

1108
00:48:08,726 --> 00:48:11,186 A:middle
And so to do that we just
use the objc attribute,

1109
00:48:11,946 --> 00:48:13,976 A:middle
provide it with the
selector "isEnabled"

1110
00:48:14,346 --> 00:48:17,136 A:middle
so we can control
the mapping ourselves

1111
00:48:17,136 --> 00:48:18,746 A:middle
between these two languages.

1112
00:48:19,476 --> 00:48:21,206 A:middle
I don't expect you
to do this often,

1113
00:48:21,856 --> 00:48:24,866 A:middle
but it's there if you need it.

1114
00:48:25,136 --> 00:48:29,746 A:middle
You can also do this
for the name of a class.

1115
00:48:29,916 --> 00:48:32,106 A:middle
And what we have here
in the parentheses,

1116
00:48:32,326 --> 00:48:36,806 A:middle
in the objc attribute, is the
non-named space name of a class.

1117
00:48:37,406 --> 00:48:38,706 A:middle
So why would you do this?

1118
00:48:39,206 --> 00:48:42,556 A:middle
Well, perhaps you're porting
part of your application

1119
00:48:42,556 --> 00:48:44,496 A:middle
from Objective-C to
Swift for some reason.

1120
00:48:45,036 --> 00:48:46,906 A:middle
And so you had ABCMyDocument.

1121
00:48:47,226 --> 00:48:48,816 A:middle
Now you just want to
call it MyDocument

1122
00:48:48,816 --> 00:48:50,316 A:middle
because you're sick
of typing ABC.

1123
00:48:51,346 --> 00:48:53,876 A:middle
However, you have some
archives that you still want

1124
00:48:53,876 --> 00:48:55,446 A:middle
to have work, because
this is going

1125
00:48:55,446 --> 00:48:57,466 A:middle
to be a drop-in compatible
implementation.

1126
00:48:58,316 --> 00:49:00,116 A:middle
In Swift, for your
Objective-C class,

1127

1128
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1129
00:48:58,316 --> 00:49:00,116 A:middle
In Swift, for your
Objective-C class,

1130
00:49:00,476 --> 00:49:01,976 A:middle
you can use the objc attribute

1131
00:49:02,116 --> 00:49:06,676 A:middle
to give this class the
runtime name of ABCMyDocument

1132
00:49:06,926 --> 00:49:08,526 A:middle
and keep all of your
archives working.

1133
00:49:08,526 --> 00:49:11,836 A:middle
One last thing I
promised to talk about,

1134
00:49:12,276 --> 00:49:14,246 A:middle
and that's CF Interoperability.

1135
00:49:15,286 --> 00:49:20,216 A:middle
So by CF we're referring
to all of the C-like APIs

1136
00:49:20,296 --> 00:49:22,686 A:middle
that work with the C objects.

1137
00:49:22,966 --> 00:49:24,476 A:middle
So, this is Core Foundation.

1138
00:49:24,476 --> 00:49:27,706 A:middle
This is Core Graphics
and other frameworks,

1139
00:49:27,706 --> 00:49:29,056 A:middle
maybe some of your
own frameworks.

1140
00:49:29,866 --> 00:49:32,976 A:middle
And let's take a
little look at using CF,

1141
00:49:33,196 --> 00:49:35,906 A:middle
particularly Core
Graphics in Objective-C.

1142
00:49:36,256 --> 00:49:38,426 A:middle
I'm going to do something
really simple here.

1143
00:49:38,496 --> 00:49:42,806 A:middle
I'm going to draw a gradient in
a rectangle using Core Graphics.

1144
00:49:43,276 --> 00:49:46,686 A:middle
Here's my start.

1145
00:49:47,096 --> 00:49:48,916 A:middle
I need to go build
up the ColorSpace

1146
00:49:49,006 --> 00:49:49,986 A:middle
and build up the Gradient.

1147
00:49:50,036 --> 00:49:54,496 A:middle
Now there's a couple of things
of here that I find non-optimal.

1148
00:49:55,236 --> 00:49:56,956 A:middle
So the one thing
is bridge casts.

1149
00:49:57,916 --> 00:49:58,726 A:middle
So we're in ARC.

1150

1151
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1152
00:50:00,056 --> 00:50:00,666 A:middle
It's partly great.

1153
00:50:00,666 --> 00:50:02,366 A:middle
It's handling our
NSArray for us.

1154
00:50:02,366 --> 00:50:04,596 A:middle
We're using the nice
array literal syntax.

1155
00:50:04,846 --> 00:50:09,136 A:middle
But now we need to do bridge
casts between CGColorRef and id

1156
00:50:09,136 --> 00:50:11,296 A:middle
so we can put things
into the NSArray.

1157
00:50:12,866 --> 00:50:15,536 A:middle
And we have this
CFArray cast sort

1158
00:50:15,536 --> 00:50:16,836 A:middle
of doing toll-free
bridging there

1159
00:50:16,996 --> 00:50:19,296 A:middle
between the NSArray
and the CFArray.

1160
00:50:20,666 --> 00:50:24,076 A:middle
And there's also this
semi-amusing thing

1161
00:50:24,076 --> 00:50:26,656 A:middle
that we're using three
different kinds of arrays

1162
00:50:27,186 --> 00:50:28,356 A:middle
in four lines of code.

1163
00:50:28,796 --> 00:50:34,246 A:middle
And you can write this - you
can try to write this better.

1164
00:50:34,246 --> 00:50:37,546 A:middle
I couldn't, actually, find a way
to make it cleaner than this.

1165
00:50:38,216 --> 00:50:40,186 A:middle
And it's really unfortunate

1166
00:50:40,416 --> 00:50:43,236 A:middle
because the NSArray gives
us some useful behavior.

1167
00:50:43,236 --> 00:50:45,056 A:middle
ARC is managing its
lifetime for us.

1168
00:50:45,056 --> 00:50:45,686 A:middle
That's great.

1169
00:50:46,086 --> 00:50:49,676 A:middle
We need the C Array because
we need to put CGFloats in it,

1170
00:50:50,246 --> 00:50:52,166 A:middle
and we can't do that
within NSArray.

1171
00:50:53,596 --> 00:50:56,256 A:middle
And finally, we need to
do the toll-free bridging

1172
00:50:56,256 --> 00:51:00,846 A:middle
over to CFArrayRef
because that's what we use

1173

1174
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1175
00:50:56,256 --> 00:51:00,846 A:middle
over to CFArrayRef
because that's what we use

1176
00:51:00,846 --> 00:51:04,846 A:middle
with Core Graphics APIs.

1177
00:51:05,056 --> 00:51:07,066 A:middle
Now, moving along, we
can create some points

1178
00:51:07,066 --> 00:51:10,696 A:middle
with CGPointMake and, of course,
even though you're under ARC

1179
00:51:10,986 --> 00:51:12,996 A:middle
where memory management
is automatic,

1180
00:51:13,366 --> 00:51:15,556 A:middle
it's not automated
for CF things.

1181
00:51:15,556 --> 00:51:17,796 A:middle
So we have to remember
to release the ColorSpace

1182
00:51:17,896 --> 00:51:18,906 A:middle
and release the Gradient.

1183
00:51:19,636 --> 00:51:21,046 A:middle
We feel like we can
do a little bit better

1184
00:51:21,046 --> 00:51:21,816 A:middle
in the world of Swift.

1185
00:51:23,106 --> 00:51:26,686 A:middle
So let's start again,
this time in Swift.

1186
00:51:27,126 --> 00:51:29,296 A:middle
And first, let's
build our colorSpace.

1187
00:51:30,256 --> 00:51:33,156 A:middle
So here we're just calling
CGColorSpaceCreateDeviceRGB().

1188
00:51:34,746 --> 00:51:35,996 A:middle
Nothing different about that.

1189
00:51:36,856 --> 00:51:39,236 A:middle
However, the type that we infer

1190
00:51:39,236 --> 00:51:43,106 A:middle
for this ColorSpace
variable is CGColorSpace.

1191
00:51:44,016 --> 00:51:46,406 A:middle
Note the lack of a ref
at the end of this.

1192
00:51:46,986 --> 00:51:49,006 A:middle
This isn't some opaque pointer.

1193
00:51:49,686 --> 00:51:54,386 A:middle
This is the CGColorSpace
class that we've created.

1194
00:51:55,866 --> 00:51:57,676 A:middle
What's the nice thing
about being a class?

1195
00:51:57,996 --> 00:52:00,226 A:middle
Well, that means we're in
the ARC model and we're going

1196

1197
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1198
00:51:57,996 --> 00:52:00,226 A:middle
Well, that means we're in
the ARC model and we're going

1199
00:52:00,226 --> 00:52:02,606 A:middle
to automatically manage
the memory for you.

1200
00:52:04,516 --> 00:52:09,946 A:middle
[ Applause ]

1201
00:52:10,446 --> 00:52:13,166 A:middle
Let's go a little
further and create

1202
00:52:13,166 --> 00:52:14,446 A:middle
that Gradient we talked about.

1203
00:52:15,896 --> 00:52:18,936 A:middle
So here, remember, we need to
pass a couple of arrays through.

1204
00:52:19,816 --> 00:52:23,426 A:middle
We can use this nice
Swift array literal syntax

1205
00:52:23,906 --> 00:52:26,456 A:middle
to form an array containing
startColor and Color.

1206
00:52:27,296 --> 00:52:30,166 A:middle
We're doing all of the bridging
automatically here for you.

1207
00:52:30,426 --> 00:52:32,186 A:middle
So we've created
the NSArray we need.

1208
00:52:32,516 --> 00:52:36,386 A:middle
We've toll-free bridged it to
the CFArray behind the scenes

1209
00:52:36,536 --> 00:52:38,616 A:middle
so you don't have to deal
with the fact that there are

1210
00:52:38,616 --> 00:52:40,106 A:middle
so many array types
running around.

1211
00:52:40,606 --> 00:52:44,606 A:middle
Did the exact same
thing for the C parts.

1212
00:52:45,226 --> 00:52:48,936 A:middle
So here we just have an array
of floating point values.

1213
00:52:49,366 --> 00:52:52,756 A:middle
So it's treated as a native
Swift array of CGFloats

1214
00:52:53,866 --> 00:52:57,516 A:middle
that we bridged seamlessly
to the underlying C array

1215
00:52:57,776 --> 00:52:59,436 A:middle
that this C function expects.

1216
00:52:59,926 --> 00:53:03,136 A:middle
Let's keep going with
our example here.

1217

1218
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1219
00:52:59,926 --> 00:53:03,136 A:middle
Let's keep going with
our example here.

1220
00:53:04,976 --> 00:53:08,716 A:middle
CGPoint. You can use
CGPointMake if you want.

1221
00:53:09,086 --> 00:53:10,106 A:middle
It's perfectly fine.

1222
00:53:10,106 --> 00:53:13,126 A:middle
It works exactly the same way
as it does in Objective-C.

1223
00:53:14,256 --> 00:53:16,556 A:middle
However, whenever
we import a struct,

1224
00:53:16,726 --> 00:53:20,346 A:middle
like CGPoint is a struct, we
provide it with initializers

1225
00:53:21,126 --> 00:53:22,626 A:middle
that have labeled arguments.

1226
00:53:23,056 --> 00:53:26,256 A:middle
And so a better way to
build CGPoints in Swift is

1227
00:53:26,496 --> 00:53:29,706 A:middle
to just construct a
CGPoint value using

1228
00:53:29,706 --> 00:53:32,046 A:middle
that same construction
syntax we've been talking

1229
00:53:32,046 --> 00:53:33,266 A:middle
about throughout this talk.

1230
00:53:34,726 --> 00:53:37,506 A:middle
And then use the
argument labels x and y

1231
00:53:37,806 --> 00:53:39,926 A:middle
to make it absolutely
clear what you're doing.

1232
00:53:39,926 --> 00:53:42,996 A:middle
And this brings a
little bit of a flavor

1233
00:53:43,146 --> 00:53:46,646 A:middle
of that nice Cocoa readability
using argument labels

1234
00:53:47,036 --> 00:53:48,646 A:middle
into the underlying CF APIs.

1235
00:53:48,646 --> 00:53:52,366 A:middle
And that's it for
our example in Swift.

1236
00:53:52,846 --> 00:53:53,626 A:middle
It's smaller.

1237
00:53:53,626 --> 00:53:54,416 A:middle
It's easier.

1238
00:53:54,416 --> 00:53:56,746 A:middle
There's far fewer concepts
that you have to deal

1239
00:53:56,746 --> 00:53:58,976 A:middle
with because we've automatically
taken over the management.

1240
00:53:59,516 --> 00:54:06,356 A:middle
[ Applause ]

1241

1242
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1243
00:53:59,516 --> 00:54:06,356 A:middle
[ Applause ]

1244
00:54:06,856 --> 00:54:09,086 A:middle
Now you may have some of
your own APIs that we refer

1245
00:54:09,086 --> 00:54:11,066 A:middle
to as explicitly bridged.

1246
00:54:11,726 --> 00:54:14,046 A:middle
So these are CF-like APIs

1247
00:54:14,526 --> 00:54:17,136 A:middle
where we're not quite sure
whether you're following all the

1248
00:54:17,136 --> 00:54:22,066 A:middle
CF memory conventions because,
unlike the world of Cocoa

1249
00:54:22,066 --> 00:54:25,126 A:middle
which is fairly tame, and we've
been following conventions

1250
00:54:25,126 --> 00:54:28,016 A:middle
fairly well for many years,
we haven't been following them

1251
00:54:28,016 --> 00:54:30,056 A:middle
so well in C as a community.

1252
00:54:30,746 --> 00:54:34,356 A:middle
And so we may have this
function GetRandomColor,

1253
00:54:34,696 --> 00:54:35,886 A:middle
produces some random color.

1254
00:54:36,976 --> 00:54:40,836 A:middle
When we pull this in, the Swift
compiler doesn't know whether we

1255
00:54:40,836 --> 00:54:43,886 A:middle
can really trust that this
returns plus zero or not.

1256
00:54:43,956 --> 00:54:46,186 A:middle
It has get in the name
but we're not sure.

1257
00:54:46,686 --> 00:54:49,126 A:middle
And so we do the safe
thing and we import it

1258
00:54:49,126 --> 00:54:51,356 A:middle
as an Unmanaged<CGColor>

1259
00:54:52,546 --> 00:54:55,326 A:middle
which means we can't directly
manage the memory here

1260
00:54:55,326 --> 00:54:57,076 A:middle
because we don't know
what the conventions are.

1261
00:54:58,656 --> 00:55:00,536 A:middle
So what is this Unmanaged thing?

1262

1263
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1264
00:54:58,656 --> 00:55:00,536 A:middle
So what is this Unmanaged thing?

1265
00:55:00,966 --> 00:55:03,886 A:middle
So Unmanaged is actually
a generic struct

1266
00:55:04,856 --> 00:55:05,916 A:middle
over an arbitrary T.

1267
00:55:06,836 --> 00:55:09,316 A:middle
Now the details of generic
structs we don't need

1268
00:55:09,316 --> 00:55:10,216 A:middle
to go into now.

1269
00:55:10,326 --> 00:55:12,916 A:middle
They're covered in the Advanced
talk which I highly recommend.

1270
00:55:13,536 --> 00:55:15,926 A:middle
What we want to look at right
now is just the simple API

1271
00:55:16,526 --> 00:55:17,626 A:middle
of this Unmanaged type.

1272
00:55:18,156 --> 00:55:21,706 A:middle
We have two core operations
- takeUnretainedValue,

1273
00:55:21,876 --> 00:55:25,226 A:middle
which you use for +0
returns, and takeRetainedValue

1274
00:55:25,226 --> 00:55:27,216 A:middle
which you use for +1 returns.

1275
00:55:27,746 --> 00:55:32,116 A:middle
Now, when we call our
CGColorGetRandomColor,

1276
00:55:32,766 --> 00:55:35,396 A:middle
we want to immediately use
one of these two functions.

1277
00:55:35,536 --> 00:55:39,166 A:middle
So we know that GetRandomColor
returns a plus zero,

1278
00:55:39,456 --> 00:55:41,306 A:middle
so we're going to do a
takeUnretainedValue of it.

1279
00:55:42,126 --> 00:55:43,706 A:middle
Now the reason to
do this immediately

1280
00:55:43,706 --> 00:55:47,286 A:middle
after the call is
this gets us a CGColor

1281
00:55:47,486 --> 00:55:48,486 A:middle
which takes us right back

1282
00:55:48,606 --> 00:55:51,186 A:middle
into automatically
managing memory for you.

1283
00:55:52,286 --> 00:55:54,756 A:middle
So the window in which
you have to do something

1284
00:55:54,926 --> 00:55:57,476 A:middle
with manual memory
management is tiny.

1285
00:55:57,476 --> 00:55:59,256 A:middle
It's just this one
little line of code

1286
00:55:59,556 --> 00:56:01,306 A:middle
where you establish
what the convention is

1287

1288
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1289
00:55:59,556 --> 00:56:01,306 A:middle
where you establish
what the convention is

1290
00:56:01,596 --> 00:56:03,776 A:middle
for CGColorGetRandomColor.

1291
00:56:04,366 --> 00:56:12,706 A:middle
Now, if you own
CGColorGetRandomColor,

1292
00:56:13,526 --> 00:56:17,036 A:middle
you can audit your APIs to
make sure they follow the Core

1293
00:56:17,036 --> 00:56:20,046 A:middle
Foundation naming conventions
for memory management.

1294
00:56:21,276 --> 00:56:24,226 A:middle
And when they do, you can
use these annotations here

1295
00:56:24,226 --> 00:56:25,106 A:middle
in core foundation -

1296
00:56:25,266 --> 00:56:27,586 A:middle
CF-IMPLICIT-BRIDGING-ENABLED
and DISABLED.

1297
00:56:28,066 --> 00:56:31,616 A:middle
Put this over a whole header
once you've audited all the

1298
00:56:31,616 --> 00:56:32,596 A:middle
methods in that header.

1299
00:56:33,626 --> 00:56:38,046 A:middle
And when you do that, well,
now your function when you use

1300
00:56:38,046 --> 00:56:42,056 A:middle
from Swift, gets you right back
into the managed world directly.

1301
00:56:43,176 --> 00:56:46,016 A:middle
So you have the great
automatic memory management

1302
00:56:46,386 --> 00:56:48,426 A:middle
that Swift can provide for CF.

1303
00:56:49,816 --> 00:56:50,836 A:middle
So let's wrap up here.

1304
00:56:50,836 --> 00:56:53,346 A:middle
We've talked about a
lot of different topics.

1305
00:56:54,516 --> 00:56:55,896 A:middle
We've talked about
interoperability

1306
00:56:55,896 --> 00:56:57,256 A:middle
between Swift and Objective-C.

1307
00:56:57,616 --> 00:57:00,166 A:middle
We've talked about a whole lot
of rules about how that works.

1308

1309
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1310
00:56:57,616 --> 00:57:00,166 A:middle
We've talked about a whole lot
of rules about how that works.

1311
00:57:00,476 --> 00:57:02,746 A:middle
But let the tools and
documentation help you.

1312
00:57:03,046 --> 00:57:05,896 A:middle
They can show you Swift and
Objective-C side-by-side

1313
00:57:05,986 --> 00:57:09,576 A:middle
so you can get a feel for how
your Objective-C APIs work

1314
00:57:09,576 --> 00:57:10,086 A:middle
in Swift.

1315
00:57:11,126 --> 00:57:12,626 A:middle
We've talked about
some of the details

1316
00:57:12,626 --> 00:57:14,846 A:middle
of bridging Core
Cocoa data types

1317
00:57:14,916 --> 00:57:17,226 A:middle
and using Swift's native types.

1318
00:57:18,326 --> 00:57:22,166 A:middle
And we talked about automated
CF memory management available

1319
00:57:23,136 --> 00:57:24,046 A:middle
in Swift.

1320
00:57:24,206 --> 00:57:26,376 A:middle
For more information,
check out the

1321
00:57:26,376 --> 00:57:30,086 A:middle
"Swift Programming Language
Book," and also the "Using Swift

1322
00:57:30,086 --> 00:57:32,126 A:middle
with Cocoa and Objective-C"
guide that goes

1323
00:57:32,126 --> 00:57:34,286 A:middle
into more details
on the interplay

1324
00:57:34,286 --> 00:57:38,716 A:middle
between these two
programming languages.

1325
00:57:39,136 --> 00:57:39,906 A:middle
Thank you.

1326
00:57:40,516 --> 00:57:55,880 A:middle
[ Applause ]

1327
