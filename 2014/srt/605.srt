X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:13,216 --> 00:00:15,566 A:middle
>> Hello. Welcome to
the Advanced Session

2
00:00:15,566 --> 00:00:16,566 A:middle
on Working with Metal.

3
00:00:17,126 --> 00:00:18,616 A:middle
My name is Gokhan Avkarogullari.

4
00:00:18,996 --> 00:00:20,826 A:middle
My colleagues, Aaftab
Munshi and Serhat Tekin,

5
00:00:20,826 --> 00:00:22,236 A:middle
and I will be presenting
this session.

6
00:00:23,456 --> 00:00:26,186 A:middle
This is the third session that
we have about Metal today.

7
00:00:26,746 --> 00:00:28,916 A:middle
In the first session, Jeremy
introduced Metal to us.

8
00:00:29,256 --> 00:00:32,625 A:middle
He talked about the motivation
behind Metal, the structures

9
00:00:32,625 --> 00:00:35,866 A:middle
that we build the Metal on,
and concluded it with a demo

10
00:00:36,056 --> 00:00:39,316 A:middle
from a Crytek on collectibles
with thousands of draw calls.

11
00:00:39,906 --> 00:00:42,066 A:middle
We followed-up with the
second session where we talked

12
00:00:42,066 --> 00:00:44,056 A:middle
about Fundamentals of Metal.

13
00:00:44,786 --> 00:00:47,846 A:middle
We talked about creating your
first application with Metal,

14
00:00:48,366 --> 00:00:51,296 A:middle
drawing an animated triangle
on the screen, and followed it

15
00:00:51,296 --> 00:00:54,206 A:middle
up with the details about
the shading language.

16
00:00:55,116 --> 00:00:57,606 A:middle
In this session, we're going
to do a more deeper dive

17
00:00:57,906 --> 00:01:00,976 A:middle
into creating a full blown
graphics application with Metal.

18

19
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

20
00:00:57,906 --> 00:01:00,976 A:middle
into creating a full blown
graphics application with Metal.

21
00:01:01,456 --> 00:01:03,656 A:middle
We'll follow it up with
data-parallel computing

22
00:01:03,656 --> 00:01:06,996 A:middle
on the GPU using Metal and
finally, we'll have a demo

23
00:01:07,526 --> 00:01:10,026 A:middle
of the developer tools
that we build from Metal.

24
00:01:11,326 --> 00:01:15,706 A:middle
Ok, so let's talk about
why multi-pass applications

25
00:01:15,706 --> 00:01:16,276 A:middle
are relevant.

26
00:01:16,976 --> 00:01:19,736 A:middle
The modern graphics applications
are very complicated pieces

27
00:01:19,736 --> 00:01:20,326 A:middle
of software.

28
00:01:20,966 --> 00:01:23,716 A:middle
They're built on using
many, many advanced graphics

29
00:01:23,716 --> 00:01:27,606 A:middle
and computer algorithms and they
do them in a piecewise manner.

30
00:01:27,706 --> 00:01:30,716 A:middle
Basically they're built on many,
many hundreds of texture passes

31
00:01:30,716 --> 00:01:32,396 A:middle
and compute passes
and blip passes

32
00:01:32,746 --> 00:01:35,546 A:middle
to generate a final great
looking image on the screen.

33
00:01:36,476 --> 00:01:38,116 A:middle
So we're going to go and
talk about a little bit how

34
00:01:38,116 --> 00:01:39,146 A:middle
to do that using Metal.

35
00:01:40,146 --> 00:01:43,326 A:middle
We will talk about multiple
framebuffer configurations,

36
00:01:43,826 --> 00:01:48,116 A:middle
rendering to off-screen and
on-screen textures, using meshes

37
00:01:48,116 --> 00:01:50,026 A:middle
and different things
with different states

38
00:01:50,026 --> 00:01:51,856 A:middle
and in different configurations,

39
00:01:52,296 --> 00:01:54,086 A:middle
and how to set up
multiple encoders.

40
00:01:55,416 --> 00:01:58,536 A:middle
We'll use a deferred lighting
with a shadow map example

41
00:01:59,096 --> 00:02:01,046 A:middle
to basically walk through
these code examples.

42

43
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

44
00:01:59,096 --> 00:02:01,046 A:middle
to basically walk through
these code examples.

45
00:02:01,096 --> 00:02:04,546 A:middle
This is a 2 pass
application that we built

46
00:02:04,686 --> 00:02:06,386 A:middle
for this particular
presentation.

47
00:02:06,886 --> 00:02:08,985 A:middle
In the first pass, we
have a shadow map pass

48
00:02:08,985 --> 00:02:11,476 A:middle
where we rendered the
scene from the perspective

49
00:02:11,476 --> 00:02:13,606 A:middle
of the directional
light to a depth buffer.

50
00:02:13,936 --> 00:02:17,456 A:middle
And in the second pass we set
up a G-buffer, fat G-buffer,

51
00:02:17,606 --> 00:02:18,976 A:middle
through multiple render targets.

52
00:02:19,486 --> 00:02:21,276 A:middle
We generate attributes
in that G-buffer

53
00:02:21,756 --> 00:02:24,716 A:middle
and we apply the point light
volumes onto that G-buffer

54
00:02:24,716 --> 00:02:26,366 A:middle
to find out which
pixels are affected.

55
00:02:26,786 --> 00:02:28,936 A:middle
And finally using the
framebuffer fetch,

56
00:02:29,616 --> 00:02:31,876 A:middle
create light accumulation
information and then merge

57
00:02:31,876 --> 00:02:34,136 A:middle
with the [inaudible] textures
to generate a final image.

58
00:02:34,946 --> 00:02:37,616 A:middle
Having said that, we're
not really interested

59
00:02:37,616 --> 00:02:40,706 A:middle
in describing the example in
here; it's just a vehicle for us

60
00:02:40,706 --> 00:02:42,036 A:middle
to basically talk
about the APIs.

61
00:02:42,036 --> 00:02:45,416 A:middle
On top of that, the example
is actually published

62
00:02:45,416 --> 00:02:48,446 A:middle
as a sample code on
the developer website

63
00:02:48,446 --> 00:02:50,426 A:middle
so you can go ahead and
download it and take a look

64
00:02:50,426 --> 00:02:53,576 A:middle
at it later if you
would like to.

65
00:02:53,776 --> 00:02:56,846 A:middle
The way the example is
structured that it has 2 passes.

66
00:02:57,266 --> 00:02:59,786 A:middle
Both of them are
RenderCommandEncoder passes.

67

68
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

69
00:03:00,226 --> 00:03:01,636 A:middle
The first 1 is for shadow map

70
00:03:01,636 --> 00:03:04,066 A:middle
and the second 1 is afforded
the deferred lighting pass.

71
00:03:04,636 --> 00:03:06,576 A:middle
They're all encoded into
a single command buffer

72
00:03:06,576 --> 00:03:09,446 A:middle
which is...and the
single command buffer goes

73
00:03:09,446 --> 00:03:10,406 A:middle
into a command queue.

74
00:03:10,736 --> 00:03:13,676 A:middle
So this is kind of what most
applications will look like;

75
00:03:14,016 --> 00:03:15,756 A:middle
multiple render to
texture passes going

76
00:03:15,756 --> 00:03:16,666 A:middle
into a command encoder

77
00:03:16,666 --> 00:03:19,006 A:middle
on a frame boundary that's
sent to the command queue.

78
00:03:19,946 --> 00:03:22,096 A:middle
I did a demo of the application.

79
00:03:23,516 --> 00:03:27,576 A:middle
[ Pause ]

80
00:03:28,076 --> 00:03:31,556 A:middle
Ok, I have it here.

81
00:03:31,766 --> 00:03:33,836 A:middle
So this is the upload
of the first pass

82
00:03:33,836 --> 00:03:36,096 A:middle
where we are rendering
basically through that buffer

83
00:03:36,096 --> 00:03:38,566 A:middle
from the perspective of
the directional light.

84
00:03:39,956 --> 00:03:42,566 A:middle
And this is how our
G-buffer is laid out.

85
00:03:42,566 --> 00:03:44,506 A:middle
On the top left we
normally have RB to texture,

86
00:03:44,506 --> 00:03:47,336 A:middle
but we're showing basically the
combined image that is going

87
00:03:47,336 --> 00:03:49,886 A:middle
to go to the screen
when we're actually done

88
00:03:49,886 --> 00:03:50,846 A:middle
with our entire rendering.

89
00:03:51,266 --> 00:03:53,046 A:middle
And there's a normal
buffer, and a depth buffer,

90
00:03:53,046 --> 00:03:54,326 A:middle
and a light accumulation buffer,

91
00:03:54,716 --> 00:03:58,346 A:middle
4 color buffers basically
attached to a framebuffer

92
00:03:58,706 --> 00:04:00,356 A:middle
and depth and stencil
buffers as well.

93

94
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

95
00:03:58,706 --> 00:04:00,356 A:middle
and depth and stencil
buffers as well.

96
00:04:01,376 --> 00:04:02,386 A:middle
This is the light accumulation;

97
00:04:02,386 --> 00:04:04,436 A:middle
there's also the light
accumulation pass.

98
00:04:04,986 --> 00:04:06,396 A:middle
And these are the visualization

99
00:04:06,396 --> 00:04:08,926 A:middle
of the lights basically
using light voluminous.

100
00:04:09,116 --> 00:04:10,566 A:middle
They're mapped onto the screen.

101
00:04:11,816 --> 00:04:15,176 A:middle
And finally this is the final
image that goes to the display.

102
00:04:15,176 --> 00:04:17,745 A:middle
It looks a lot better on the
device than on the presentation.

103
00:04:18,046 --> 00:04:23,296 A:middle
Ok, let's go back
to our presentation.

104
00:04:24,816 --> 00:04:29,306 A:middle
Ok, so how do we setup
an application like this

105
00:04:29,306 --> 00:04:31,516 A:middle
or more complicated
ones that you have seen

106
00:04:31,846 --> 00:04:35,036 A:middle
in the demos using Metal?

107
00:04:35,616 --> 00:04:37,576 A:middle
Just like Jeremy talked about
in the first session and looked

108
00:04:37,576 --> 00:04:40,226 A:middle
at the things that...at what
frequency things are done

109
00:04:40,226 --> 00:04:42,156 A:middle
and moved the most heavy ones

110
00:04:42,156 --> 00:04:44,496 A:middle
to the least frequently
done stages.

111
00:04:44,886 --> 00:04:47,916 A:middle
An application has a lot of
things that are done once

112
00:04:48,366 --> 00:04:50,296 A:middle
and there are things that
are done at low level times

113
00:04:50,296 --> 00:04:53,576 A:middle
or streaming time, and there
are things done every frame

114
00:04:53,716 --> 00:04:55,496 A:middle
and in an application
there are also things

115
00:04:55,496 --> 00:04:56,606 A:middle
that are render to textures.

116
00:04:56,606 --> 00:04:58,996 A:middle
So we're going to look at
each category and figure

117
00:04:58,996 --> 00:05:01,556 A:middle
out what is done in these
categories and figure out how

118

119
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

120
00:04:58,996 --> 00:05:01,556 A:middle
out what is done in these
categories and figure out how

121
00:05:01,556 --> 00:05:02,416 A:middle
to do those with Metal.

122
00:05:03,706 --> 00:05:05,446 A:middle
Let's start with the
things that are done once.

123
00:05:05,896 --> 00:05:06,816 A:middle
Creating a device.

124
00:05:06,816 --> 00:05:09,426 A:middle
They are the only ones you queue
on the system so you're going

125
00:05:09,426 --> 00:05:12,616 A:middle
to get a GPU and are
handled through the GPU,

126
00:05:12,966 --> 00:05:15,636 A:middle
and creating a command queue
on the GPU is only done once

127
00:05:16,076 --> 00:05:17,686 A:middle
in most of the applications.

128
00:05:18,086 --> 00:05:20,176 A:middle
And Richard told you something
about this; I'm not going

129
00:05:20,176 --> 00:05:22,076 A:middle
to talk about that
in this session.

130
00:05:23,076 --> 00:05:24,596 A:middle
There are things
we do as needed.

131
00:05:25,086 --> 00:05:27,096 A:middle
For example; we know
up front in all

132
00:05:27,196 --> 00:05:29,286 A:middle
of our applications
what our render

133
00:05:29,286 --> 00:05:30,696 A:middle
to texture stages will be.

134
00:05:30,696 --> 00:05:33,826 A:middle
There are usually a set of
render to texture passes,

135
00:05:33,826 --> 00:05:36,166 A:middle
that are known up front for
like an indoor environment

136
00:05:36,466 --> 00:05:38,576 A:middle
or an outdoor environment and
they might change if there's

137
00:05:38,576 --> 00:05:41,146 A:middle
like [inaudible] included
or something like that

138
00:05:41,146 --> 00:05:42,776 A:middle
but most of them are up front.

139
00:05:42,776 --> 00:05:45,466 A:middle
You know as an application
developer what your render

140
00:05:45,466 --> 00:05:47,896 A:middle
to texture passes will be,
in what order they're going

141
00:05:47,896 --> 00:05:50,236 A:middle
to be done, and what kind of
framebuffers that are going

142
00:05:50,236 --> 00:05:50,756 A:middle
to be used with those.

143
00:05:50,756 --> 00:05:53,456 A:middle
So we can actually
define...create the framebuffer

144
00:05:53,456 --> 00:05:54,796 A:middle
textures for those passes

145
00:05:54,796 --> 00:05:56,456 A:middle
and define what those
textures are going to look

146
00:05:56,456 --> 00:05:58,216 A:middle
like up front at once.

147
00:05:58,786 --> 00:06:02,446 A:middle
And at level load time we can
download our assets including

148

149
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

150
00:05:58,786 --> 00:06:02,446 A:middle
And at level load time we can
download our assets including

151
00:06:02,446 --> 00:06:06,346 A:middle
our meshes, textures and
then basically our shaders

152
00:06:06,346 --> 00:06:07,616 A:middle
and associated with
those shaders

153
00:06:07,616 --> 00:06:10,016 A:middle
to create pipeline objects,
and the pipeline objects.

154
00:06:10,496 --> 00:06:13,506 A:middle
And of course we can
create our uniform buffers

155
00:06:13,506 --> 00:06:14,376 A:middle
up front as well.

156
00:06:15,476 --> 00:06:17,966 A:middle
These are the things that we
do either at level load time

157
00:06:18,456 --> 00:06:21,676 A:middle
at once or depending on if we're
going to stream load or not,

158
00:06:22,116 --> 00:06:24,406 A:middle
at other times as well
but only as needed.

159
00:06:24,956 --> 00:06:28,866 A:middle
In our example, we're using
a single command buffer

160
00:06:28,866 --> 00:06:31,256 A:middle
to submit a set of
render to texture passes

161
00:06:31,486 --> 00:06:34,366 A:middle
to basically have the results
of our render to texture passes

162
00:06:34,366 --> 00:06:35,476 A:middle
to show up on the screen

163
00:06:35,476 --> 00:06:38,616 A:middle
so that's basically a
frame boundary operation.

164
00:06:38,616 --> 00:06:41,036 A:middle
Every time you want to have
something to go to the screen,

165
00:06:41,036 --> 00:06:43,096 A:middle
we're going to basically create
a command buffer and use it

166
00:06:43,096 --> 00:06:44,866 A:middle
to encode our render
to texture passes

167
00:06:44,866 --> 00:06:46,906 A:middle
so this is something
we do every frame.

168
00:06:47,436 --> 00:06:50,016 A:middle
Of course there are uniform
buffers that need to be updated

169
00:06:50,016 --> 00:06:52,386 A:middle
on frame boundaries; that's
where you do it as well.

170
00:06:52,976 --> 00:06:57,126 A:middle
And finally the things we do
every render to texture pass

171
00:06:57,126 --> 00:07:00,576 A:middle
such as encoding the command
so that GPU can understand.

172

173
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

174
00:06:57,126 --> 00:07:00,576 A:middle
such as encoding the command
so that GPU can understand.

175
00:07:00,926 --> 00:07:02,576 A:middle
Setting up the states
and resources,

176
00:07:02,576 --> 00:07:03,856 A:middle
and initiating draw calls.

177
00:07:03,916 --> 00:07:06,236 A:middle
And then finally
finishing the encoding

178
00:07:06,236 --> 00:07:07,576 A:middle
so you can go to
the next encoder.

179
00:07:08,796 --> 00:07:10,846 A:middle
So these are the things we do
every render to texture pass

180
00:07:10,846 --> 00:07:12,956 A:middle
and we're going to basically
look at each one of them

181
00:07:12,956 --> 00:07:15,966 A:middle
and understand how Metal is
used to do these operations.

182
00:07:18,446 --> 00:07:23,236 A:middle
Ok, let's start with the
things that we do as needed

183
00:07:23,606 --> 00:07:27,296 A:middle
and understand how we can setup
information for our render

184
00:07:27,296 --> 00:07:29,176 A:middle
to texture passes
up front so that

185
00:07:29,176 --> 00:07:31,106 A:middle
when we create our
encoders; all the information

186
00:07:31,106 --> 00:07:33,456 A:middle
that is necessary for
that encoding is ready.

187
00:07:34,626 --> 00:07:37,026 A:middle
But before we go there, I'd
like to speak a little bit

188
00:07:37,026 --> 00:07:39,616 A:middle
about descriptors because all
of the code examples have lots

189
00:07:39,616 --> 00:07:42,356 A:middle
of descriptors and I'd
like to establish that all

190
00:07:42,356 --> 00:07:44,236 A:middle
of the descriptor...that all

191
00:07:44,236 --> 00:07:47,076 A:middle
of the descriptor are
defining how an object is going

192
00:07:47,076 --> 00:07:47,716 A:middle
to be created.

193
00:07:47,716 --> 00:07:49,826 A:middle
It's like the blueprint and just

194
00:07:49,826 --> 00:07:52,336 A:middle
like the blueprints
you basically use

195
00:07:52,336 --> 00:07:55,266 A:middle
to build a house from,
once a house is built,

196
00:07:55,266 --> 00:07:57,236 A:middle
you don't have actually
a connection back

197
00:07:57,236 --> 00:07:57,946 A:middle
to the blueprint.

198
00:07:57,946 --> 00:08:00,706 A:middle
You cannot change the blueprint
and see in fact a change

199

200
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

201
00:07:57,946 --> 00:08:00,706 A:middle
You cannot change the blueprint
and see in fact a change

202
00:08:00,996 --> 00:08:02,126 A:middle
on an already built house.

203
00:08:02,536 --> 00:08:05,036 A:middle
You cannot change a
descriptor and expect a change

204
00:08:05,066 --> 00:08:06,756 A:middle
to the built object
from that descriptor.

205
00:08:06,756 --> 00:08:10,136 A:middle
Descriptors are there to define
what objects are going to be

206
00:08:10,136 --> 00:08:12,136 A:middle
but once they're created,
the connection is lost.

207
00:08:12,936 --> 00:08:15,826 A:middle
But just like a blueprint as
well, a descriptor can be used

208
00:08:15,826 --> 00:08:18,916 A:middle
to create more instances
of the same kind of object

209
00:08:19,356 --> 00:08:21,926 A:middle
or they can modify it a little
bit to create a different kind

210
00:08:21,926 --> 00:08:25,726 A:middle
of object that shares
some of the personality

211
00:08:25,726 --> 00:08:26,926 A:middle
of the previous object.

212
00:08:28,256 --> 00:08:32,346 A:middle
And as Jeremy pointed out
before, everything except

213
00:08:32,346 --> 00:08:33,916 A:middle
for a few states
that you can set

214
00:08:33,916 --> 00:08:35,986 A:middle
on the render encoders
are actually built

215
00:08:36,306 --> 00:08:39,866 A:middle
into the state objects and the
resources and they are immutable

216
00:08:40,076 --> 00:08:42,015 A:middle
which gives us the
opportunity acutely

217
00:08:42,346 --> 00:08:44,155 A:middle
to avoid the state
revelation [assumed spelling]

218
00:08:44,536 --> 00:08:45,486 A:middle
at the draw time.

219
00:08:46,016 --> 00:08:49,116 A:middle
So a descriptor built an
object and pretty much

220
00:08:49,116 --> 00:08:51,416 A:middle
that object is immutable
after that point.

221
00:08:51,796 --> 00:08:54,356 A:middle
That basically makes the
Metal a lower head API

222
00:08:54,416 --> 00:08:57,686 A:middle
by avoiding all the state
tracking, all the state changes,

223
00:08:57,956 --> 00:08:59,406 A:middle
and reflecting them
at the draw time.

224

225
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

226
00:09:00,046 --> 00:09:00,976 A:middle
Ok, let's go back

227
00:09:00,976 --> 00:09:04,496 A:middle
to our framebuffer
configuration,

228
00:09:04,496 --> 00:09:05,316 A:middle
how we setup that.

229
00:09:06,806 --> 00:09:09,366 A:middle
Ok, so for
RenderCommandEncoders,

230
00:09:09,366 --> 00:09:12,006 A:middle
we need to know about the
nature of the framebuffer

231
00:09:12,256 --> 00:09:14,366 A:middle
like how many color
detections there are,

232
00:09:14,366 --> 00:09:16,436 A:middle
what kind of pixel types
there are, the depth

233
00:09:16,436 --> 00:09:18,516 A:middle
and stencil attachment;
things of that sort.

234
00:09:18,996 --> 00:09:21,656 A:middle
And those are defined through
a RenderPassDescriptor.

235
00:09:22,156 --> 00:09:25,396 A:middle
We are allowed up to 4 color
attachments that are allowed

236
00:09:25,396 --> 00:09:27,676 A:middle
on Metal and we can
attach a depth

237
00:09:27,676 --> 00:09:29,266 A:middle
and stencil buffer as well.

238
00:09:29,776 --> 00:09:32,056 A:middle
And the attachments
themselves are also described

239
00:09:32,056 --> 00:09:34,136 A:middle
to in other descriptor
that's embedded

240
00:09:34,136 --> 00:09:35,526 A:middle
into the RenderPassDescriptor

241
00:09:35,526 --> 00:09:38,656 A:middle
which is
RenderPassAttachmentDescriptor.

242
00:09:38,936 --> 00:09:42,526 A:middle
In this descriptor we basically
define what kind of load

243
00:09:42,526 --> 00:09:45,956 A:middle
and store actions clear
values and what kind of slice

244
00:09:46,056 --> 00:09:48,686 A:middle
or mid-level that we're
going to render into;

245
00:09:48,936 --> 00:09:50,806 A:middle
all of these are
basically defined here.

246
00:09:51,876 --> 00:09:55,166 A:middle
And it also points to the
texture that we're going

247
00:09:55,166 --> 00:09:56,376 A:middle
to use to render into.

248
00:09:57,036 --> 00:09:59,636 A:middle
So this pass descriptor
basically has all

249
00:09:59,636 --> 00:09:59,976 A:middle
the information

250

251
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

252
00:10:00,136 --> 00:10:00,716 A:middle
necessary

253
00:10:00,716 --> 00:10:03,036 A:middle
for a RenderCommandEncoder
to get going.

254
00:10:03,036 --> 00:10:06,316 A:middle
And we're going to look at
the 2 passes that we have;

255
00:10:06,746 --> 00:10:10,266 A:middle
the shadow pass and the deferred
lighting pass in our example

256
00:10:10,266 --> 00:10:12,826 A:middle
and build render pass
descriptors for those.

257
00:10:13,486 --> 00:10:15,326 A:middle
So let's start with
the shadowRenderPass.

258
00:10:15,986 --> 00:10:18,306 A:middle
In this case we only
have a depth buffer;

259
00:10:18,576 --> 00:10:21,296 A:middle
we don't have any color buffers
attached because all we want is

260
00:10:21,296 --> 00:10:23,916 A:middle
to create a shadow map
buffer that we can use later

261
00:10:24,086 --> 00:10:27,476 A:middle
to basically see if a
pixel is all clear or not.

262
00:10:28,736 --> 00:10:31,816 A:middle
So we're going to start with
creating the texture for that

263
00:10:31,816 --> 00:10:36,016 A:middle
and what we have in here is
basically a 1k by 1k texture

264
00:10:36,016 --> 00:10:40,826 A:middle
with no mitmapping,
a depth 432 texture.

265
00:10:41,436 --> 00:10:46,286 A:middle
It is created on the device as
we talked extensively before.

266
00:10:46,286 --> 00:10:51,136 A:middle
There's no concept of context or
shared groups like GL on Metal.

267
00:10:52,176 --> 00:10:54,936 A:middle
Every resource is created on
the device, they are visible

268
00:10:54,936 --> 00:10:58,796 A:middle
by the GPU, and also you can
independently modify them,

269
00:10:59,426 --> 00:11:02,596 A:middle
not the objects themselves,
but like the texture data

270

271
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

272
00:10:59,426 --> 00:11:02,596 A:middle
not the objects themselves,
but like the texture data

273
00:11:02,596 --> 00:11:06,726 A:middle
or the buffer data, read that in
a requirement of bind to modify.

274
00:11:07,236 --> 00:11:10,496 A:middle
You can modify them any time you
want as long as you're careful

275
00:11:10,496 --> 00:11:12,916 A:middle
that they are not modified
while the GPU is accessing them

276
00:11:13,336 --> 00:11:15,346 A:middle
and as long as you make sure
that memory coincident rules

277
00:11:15,346 --> 00:11:17,406 A:middle
at the command buffer
boundaries is followed.

278
00:11:17,516 --> 00:11:21,626 A:middle
After we have our texture,

279
00:11:21,896 --> 00:11:23,626 A:middle
we can create our
render pass descriptor.

280
00:11:24,196 --> 00:11:28,176 A:middle
We're going to assign this
texture to the depth detector

281
00:11:28,176 --> 00:11:29,406 A:middle
of render pass descriptor

282
00:11:29,406 --> 00:11:31,326 A:middle
because it has only
a single attachment.

283
00:11:32,496 --> 00:11:35,696 A:middle
And then define the properties
such as the clear value,

284
00:11:35,696 --> 00:11:36,976 A:middle
load, and store actions.

285
00:11:37,286 --> 00:11:39,586 A:middle
We talked extensively about
load and store actions before.

286
00:11:39,906 --> 00:11:41,786 A:middle
They're very important
in terms of performance

287
00:11:42,106 --> 00:11:43,206 A:middle
so you should really
pay attention

288
00:11:43,206 --> 00:11:45,226 A:middle
to setting them correctly
and most

289
00:11:45,226 --> 00:11:47,656 A:middle
of the time the default values
are the most sensible values.

290
00:11:47,976 --> 00:11:52,676 A:middle
Ok, let's go to our second pass.

291
00:11:52,676 --> 00:11:55,886 A:middle
We need to also create a
descriptor for our second pass;

292
00:11:55,886 --> 00:11:58,126 A:middle
we're going to actually do the
second render command encoding.

293
00:11:58,506 --> 00:12:00,256 A:middle
That information will
be available up front.

294

295
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

296
00:11:58,506 --> 00:12:00,256 A:middle
That information will
be available up front.

297
00:12:00,516 --> 00:12:02,326 A:middle
Those textures are created
up front so we don't have

298
00:12:02,326 --> 00:12:05,206 A:middle
to pay the penalty of doing
those at the draw time.

299
00:12:05,976 --> 00:12:09,936 A:middle
In this example we
have 4 color buffers,

300
00:12:09,936 --> 00:12:11,226 A:middle
one of them is actually
interesting;

301
00:12:11,226 --> 00:12:12,226 A:middle
the one on the top left.

302
00:12:12,716 --> 00:12:15,596 A:middle
It is a buffer that we're going
to render into and then go

303
00:12:15,596 --> 00:12:16,706 A:middle
and send it to the display.

304
00:12:17,136 --> 00:12:20,456 A:middle
So that texture we cannot create
up front; we need to get it

305
00:12:20,456 --> 00:12:22,006 A:middle
from the Metal layer,
the CAMetal layer.

306
00:12:22,286 --> 00:12:24,396 A:middle
And we talked extensively about
this in the second session.

307
00:12:24,396 --> 00:12:27,756 A:middle
Richard basically had a sample
code showing how we can get

308
00:12:27,756 --> 00:12:28,966 A:middle
that texture from
the Metal layer.

309
00:12:29,776 --> 00:12:32,066 A:middle
The other 3 color textures
though and the depth

310
00:12:32,066 --> 00:12:34,656 A:middle
and stencil texture are
things that we know up front.

311
00:12:34,656 --> 00:12:36,716 A:middle
They are structures and we
can create them up front

312
00:12:36,986 --> 00:12:38,186 A:middle
and we don't have
to do them later

313
00:12:39,006 --> 00:12:40,276 A:middle
so let's go ahead and do that.

314
00:12:40,876 --> 00:12:44,926 A:middle
Ok, we're going to start again
with a texture descriptor

315
00:12:44,926 --> 00:12:46,896 A:middle
to define how our texture
is going to look like.

316
00:12:47,206 --> 00:12:49,296 A:middle
In this example I'm
going to create only 2

317
00:12:49,296 --> 00:12:51,456 A:middle
of the color textures
and then the rest

318
00:12:51,456 --> 00:12:52,466 A:middle
of them are very similar.

319
00:12:53,636 --> 00:12:56,686 A:middle
So we basically need to create
something that has a width

320
00:12:56,686 --> 00:12:59,196 A:middle
and height of the
displayable surface

321
00:12:59,696 --> 00:13:02,166 A:middle
and there is no mapping
required.

322

323
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

324
00:12:59,696 --> 00:13:02,166 A:middle
and there is no mapping
required.

325
00:13:02,166 --> 00:13:04,726 A:middle
So we create our first
texture using this descriptor,

326
00:13:04,726 --> 00:13:05,636 A:middle
texture descriptor.

327
00:13:06,106 --> 00:13:08,186 A:middle
Now as I said before,
the descriptors are kind

328
00:13:08,186 --> 00:13:11,306 A:middle
of blueprints so we can
actually use the same descriptor

329
00:13:11,926 --> 00:13:14,546 A:middle
and create the second
texture out of that as well.

330
00:13:14,876 --> 00:13:16,506 A:middle
This is what we're going
to do as well in here.

331
00:13:16,946 --> 00:13:18,926 A:middle
Basically we modify
the descriptor

332
00:13:19,286 --> 00:13:21,786 A:middle
to change the pixel format and
everything like width, height,

333
00:13:22,096 --> 00:13:24,166 A:middle
the mitmapping properties were
the same so we didn't have

334
00:13:24,166 --> 00:13:27,396 A:middle
to modify those, and then create
the second texture with that.

335
00:13:27,396 --> 00:13:30,746 A:middle
So you can see that we basically
have 1 descriptor creating 2

336
00:13:30,746 --> 00:13:31,616 A:middle
different textures.

337
00:13:32,546 --> 00:13:34,436 A:middle
So now that...and
we're going to do this

338
00:13:34,436 --> 00:13:37,006 A:middle
for the third color
attachment, depth and stencil.

339
00:13:37,006 --> 00:13:39,116 A:middle
Now that we have done all
of those, we can go ahead

340
00:13:39,116 --> 00:13:40,726 A:middle
and create our
RenderPassDescriptor

341
00:13:41,026 --> 00:13:43,566 A:middle
so that we can use it later to
create our RenderCommandEncoder.

342
00:13:44,946 --> 00:13:46,206 A:middle
We first create it.

343
00:13:47,306 --> 00:13:49,436 A:middle
What is interesting in
here as I explained before;

344
00:13:49,826 --> 00:13:53,366 A:middle
the first color attachment we
actually don't have a texture

345
00:13:53,366 --> 00:13:54,486 A:middle
up front ready for it.

346
00:13:54,666 --> 00:13:57,466 A:middle
We'll have it when we actually
start setting up our frame.

347
00:13:58,136 --> 00:14:02,146 A:middle
So it's set to "no" initially
and eventually we'll get it

348

349
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

350
00:13:58,136 --> 00:14:02,146 A:middle
So it's set to "no" initially
and eventually we'll get it

351
00:14:02,146 --> 00:14:04,786 A:middle
from the drawable when we
create our RenderCommandEncoder.

352
00:14:05,456 --> 00:14:09,266 A:middle
But despite not having
a texture,

353
00:14:09,716 --> 00:14:11,836 A:middle
we know actually
the actions up front

354
00:14:11,836 --> 00:14:14,766 A:middle
so we can define the clear
value, load and store actions

355
00:14:14,766 --> 00:14:16,466 A:middle
on the attachment
descriptor up front.

356
00:14:17,396 --> 00:14:20,276 A:middle
And we can go ahead and do it
for the second color attachment.

357
00:14:20,676 --> 00:14:24,276 A:middle
As you can see in this one, I
used the texture that we created

358
00:14:24,276 --> 00:14:26,336 A:middle
in the previous slide
as an attachment.

359
00:14:26,976 --> 00:14:30,116 A:middle
And we can also define
the clear value,

360
00:14:30,116 --> 00:14:31,976 A:middle
load and store actions
up front over here.

361
00:14:33,246 --> 00:14:35,266 A:middle
I'd like to point
out the difference

362
00:14:35,266 --> 00:14:37,226 A:middle
between the store
actions between these 2;

363
00:14:37,626 --> 00:14:40,576 A:middle
for the first buffer
attachment, we'd like it to end

364
00:14:40,576 --> 00:14:43,856 A:middle
up on the screen so we'd like
it to be stored into the memory.

365
00:14:44,426 --> 00:14:46,716 A:middle
But the second, third, and
fourth, color attachments depth

366
00:14:46,716 --> 00:14:49,236 A:middle
and stencil buffers,
they can be discarded;

367
00:14:49,236 --> 00:14:51,266 A:middle
they're just intermediate
values that we used

368
00:14:51,266 --> 00:14:53,436 A:middle
to generate the first
attachment's values.

369
00:14:53,826 --> 00:14:56,476 A:middle
So we don't really need to store
them into memory; we don't want

370
00:14:56,476 --> 00:14:58,556 A:middle
to lose memory bandwidth
and GP cycles

371
00:14:58,556 --> 00:15:01,446 A:middle
for that expensive operation
so we set them as "don't care"

372

373
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

374
00:14:58,556 --> 00:15:01,446 A:middle
for that expensive operation
so we set them as "don't care"

375
00:15:01,446 --> 00:15:04,406 A:middle
and let the driver figure out
the best kind of operation

376
00:15:04,406 --> 00:15:06,116 A:middle
for the particular GP
that you're working on.

377
00:15:07,476 --> 00:15:11,316 A:middle
Ok, so that covers how we
create render pass descriptors

378
00:15:11,626 --> 00:15:14,166 A:middle
that we want and the textures
associated with the framebuffers

379
00:15:14,166 --> 00:15:15,656 A:middle
that we are going to use later

380
00:15:15,656 --> 00:15:17,376 A:middle
for creating render
command encoders

381
00:15:17,696 --> 00:15:19,276 A:middle
when we do render
to texture passes.

382
00:15:20,726 --> 00:15:23,736 A:middle
Let's look at now the textures,
buffers, and state objects,

383
00:15:23,736 --> 00:15:27,396 A:middle
and specifically the pipeline
state objects that we're going

384
00:15:27,396 --> 00:15:30,126 A:middle
to create at level load
time so that we don't have

385
00:15:30,126 --> 00:15:31,276 A:middle
to basically deal
with them later.

386
00:15:33,196 --> 00:15:35,046 A:middle
We've already seen
how to create textures

387
00:15:35,046 --> 00:15:36,706 A:middle
from texture descriptors;
I am not going

388
00:15:36,706 --> 00:15:37,806 A:middle
to go into details of that.

389
00:15:37,806 --> 00:15:40,486 A:middle
I just want to point out
that there are multiple ways

390
00:15:40,486 --> 00:15:41,936 A:middle
to upload data into
your texture.

391
00:15:42,536 --> 00:15:45,076 A:middle
This is one of them;
basically a CPU copy.

392
00:15:45,706 --> 00:15:47,616 A:middle
And you can also use
booth command encoder

393
00:15:47,616 --> 00:15:50,936 A:middle
to upload data inline through
the GPU to do that as well.

394
00:15:52,956 --> 00:15:54,676 A:middle
We talked about buffers before.

395
00:15:55,176 --> 00:15:56,236 A:middle
We don't have a concept

396
00:15:56,236 --> 00:15:58,836 A:middle
of a vertex buffer
or a uniform buffer.

397
00:15:59,126 --> 00:16:00,766 A:middle
Buffers are buffers;
they are raw data.

398

399
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

400
00:15:59,126 --> 00:16:00,766 A:middle
Buffers are buffers;
they are raw data.

401
00:16:01,106 --> 00:16:02,906 A:middle
You can create them
for anything you want

402
00:16:02,906 --> 00:16:05,896 A:middle
and then reach them...you
know access them through a GPU

403
00:16:06,446 --> 00:16:10,386 A:middle
in your shaders when you
specify them as inputs.

404
00:16:10,846 --> 00:16:14,216 A:middle
All we're doing here is creating
one with the information

405
00:16:14,216 --> 00:16:16,556 A:middle
about you now the
size and the options.

406
00:16:17,606 --> 00:16:22,066 A:middle
And as I said before, you can
modify these really easily while

407
00:16:22,726 --> 00:16:26,216 A:middle
your GPU is working on,
for example another section

408
00:16:26,216 --> 00:16:28,296 A:middle
of your buffer, you can
modify this section of buffer.

409
00:16:28,506 --> 00:16:31,506 A:middle
You need to take care of the
synchronization and you need

410
00:16:31,506 --> 00:16:34,286 A:middle
to follow the memory coincident
rules, but you don't have

411
00:16:34,286 --> 00:16:37,126 A:middle
to do anything like locking the
buffer or getting the pointer

412
00:16:37,126 --> 00:16:38,976 A:middle
to do...both pointers are
always available to you.

413
00:16:38,976 --> 00:16:41,676 A:middle
You have the freedom to modify
however you want whenever you

414
00:16:41,676 --> 00:16:45,486 A:middle
want and as long as you
basically pay attention to GP

415
00:16:45,486 --> 00:16:48,336 A:middle
and CP synchronization
issues, it will work correctly.

416
00:16:48,896 --> 00:16:53,386 A:middle
And finally one other example
of a depth stencil state,

417
00:16:53,866 --> 00:16:56,916 A:middle
I showed this one; I don't have
much to say about it except

418
00:16:56,916 --> 00:16:58,286 A:middle
that it is an interesting one

419
00:16:58,446 --> 00:17:01,896 A:middle
that it has an embedded
descriptor, internal descriptor.

420

421
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

422
00:16:58,446 --> 00:17:01,896 A:middle
that it has an embedded
descriptor, internal descriptor.

423
00:17:01,896 --> 00:17:04,146 A:middle
Basically that stencil
descriptor has a stencil

424
00:17:04,146 --> 00:17:05,425 A:middle
descriptor defined within it.

425
00:17:05,896 --> 00:17:10,715 A:middle
But you can create all of your
depth stencil states up front

426
00:17:10,715 --> 00:17:12,935 A:middle
because just like you know
your render to texture state,

427
00:17:13,286 --> 00:17:15,276 A:middle
you actually know how
your objects are going

428
00:17:15,276 --> 00:17:17,185 A:middle
to be rendered into
those textures.

429
00:17:17,536 --> 00:17:21,086 A:middle
You know that, for example
in the shadow map pass,

430
00:17:21,476 --> 00:17:23,915 A:middle
you don't really need to
write into stencil buffer,

431
00:17:23,915 --> 00:17:26,836 A:middle
so you can basically say
that information here

432
00:17:26,836 --> 00:17:27,685 A:middle
or you don't use that.

433
00:17:28,016 --> 00:17:30,176 A:middle
Or when you have
something that is opaque,

434
00:17:30,556 --> 00:17:31,986 A:middle
you can basically
update the depth buffer,

435
00:17:31,986 --> 00:17:34,686 A:middle
but if you're going to do
something that is blended

436
00:17:34,686 --> 00:17:37,576 A:middle
for example, you might choose
to not update the depth buffer

437
00:17:37,576 --> 00:17:40,436 A:middle
and then you can actually...if
you know all the sates up front,

438
00:17:40,436 --> 00:17:41,356 A:middle
you can actually
create them up front

439
00:17:41,356 --> 00:17:44,016 A:middle
and don't pay the penalty
during the draw time.

440
00:17:44,646 --> 00:17:45,856 A:middle
Ok so we're going to talk

441
00:17:45,856 --> 00:17:48,786 A:middle
about next the render
pipeline state objects

442
00:17:48,786 --> 00:17:52,496 A:middle
but before we go there, I'd
like to revisit the...kind

443
00:17:53,226 --> 00:17:57,936 A:middle
of the open GL view of the GPU.

444
00:17:58,526 --> 00:18:01,676 A:middle
And then go and basically talk
about what's the motivation

445

446
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

447
00:17:58,526 --> 00:18:01,676 A:middle
And then go and basically talk
about what's the motivation

448
00:18:01,676 --> 00:18:04,676 A:middle
of RenderPipelineState objects
and what is included in them.

449
00:18:05,296 --> 00:18:08,716 A:middle
So this is kind of how it looks
to basically in general open GL,

450
00:18:08,716 --> 00:18:11,036 A:middle
but there's actually a
separate vertex shader state

451
00:18:11,416 --> 00:18:14,106 A:middle
and a fragment shader state
and all the other operations

452
00:18:14,106 --> 00:18:15,166 A:middle
that are all that looks

453
00:18:15,166 --> 00:18:17,316 A:middle
like fixed function
hardware controlled

454
00:18:17,316 --> 00:18:20,156 A:middle
through basically
state changing APIs.

455
00:18:20,666 --> 00:18:23,126 A:middle
Unfortunately the modern
hardware doesn't really work

456
00:18:23,126 --> 00:18:23,516 A:middle
that way.

457
00:18:24,236 --> 00:18:26,066 A:middle
If you think about
it, for example,

458
00:18:26,276 --> 00:18:28,956 A:middle
when your vertex layout
doesn't match your vertex shader

459
00:18:28,956 --> 00:18:29,826 A:middle
because they're separate,

460
00:18:29,826 --> 00:18:32,256 A:middle
the meshes are all
altered separately

461
00:18:32,256 --> 00:18:33,476 A:middle
than your vertex shaders,

462
00:18:33,806 --> 00:18:35,676 A:middle
there has to be some
code running somewhere;

463
00:18:36,106 --> 00:18:39,596 A:middle
either a deimaging code or
a vertex fetch shader code

464
00:18:39,866 --> 00:18:41,056 A:middle
that needs to bridge that gap

465
00:18:41,056 --> 00:18:43,096 A:middle
between these 2 layout
differences.

466
00:18:43,706 --> 00:18:47,896 A:middle
Or in some GPUs we have tile
based deferred render so most

467
00:18:47,896 --> 00:18:50,506 A:middle
of the frame buffer actually is
on the GPU while you're working

468
00:18:50,506 --> 00:18:53,176 A:middle
on it so the blending or write
mask is basically a read,

469
00:18:53,176 --> 00:18:56,476 A:middle
modify, write operation
I the tile and we do

470
00:18:56,476 --> 00:18:58,686 A:middle
that by creating actually
a shader code running

471
00:18:58,686 --> 00:19:01,036 A:middle
on the shader core;
it's not really a state.

472

473
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

474
00:18:58,686 --> 00:19:01,036 A:middle
on the shader core;
it's not really a state.

475
00:19:01,036 --> 00:19:04,226 A:middle
So when you actually make a
draw call with one blending mode

476
00:19:04,626 --> 00:19:07,886 A:middle
for compiled shaders and
then change your blend state

477
00:19:07,956 --> 00:19:11,176 A:middle
and make another draw call
with the same compiled shaders.

478
00:19:11,416 --> 00:19:12,856 A:middle
Well we find out
that we actually have

479
00:19:12,856 --> 00:19:15,576 A:middle
to generate new code for this
new framebuffer configuration

480
00:19:15,606 --> 00:19:18,456 A:middle
because we have never seen
it before and we're going

481
00:19:18,456 --> 00:19:21,006 A:middle
to do this fixed-function
looking-like operation

482
00:19:21,006 --> 00:19:22,556 A:middle
in the shader core and we end

483
00:19:22,556 --> 00:19:24,476 A:middle
up recompiling your
shader causing a hitch

484
00:19:24,746 --> 00:19:25,696 A:middle
in your application.

485
00:19:26,256 --> 00:19:29,666 A:middle
So recognizing the differences
between how the API looks

486
00:19:29,666 --> 00:19:32,466 A:middle
on a PGL and how
actually a GP behaves,

487
00:19:32,466 --> 00:19:35,596 A:middle
we decided to basically
put everything in the GPU

488
00:19:35,596 --> 00:19:39,296 A:middle
that closes shader code and has
an impact on the shader code

489
00:19:39,296 --> 00:19:42,276 A:middle
in one place that's called
"render pipeline state object."

490
00:19:42,986 --> 00:19:44,316 A:middle
So let's look at
what we have in it.

491
00:19:44,896 --> 00:19:47,616 A:middle
We basically have the vertex
fetch basically information

492
00:19:47,616 --> 00:19:50,396 A:middle
about your vertex layout
that we talked about before.

493
00:19:50,396 --> 00:19:51,906 A:middle
I actually gave a
good example of it.

494
00:19:51,906 --> 00:19:54,326 A:middle
Aaftab gave a good example of
it in his talk about language.

495
00:19:55,436 --> 00:19:59,056 A:middle
Obviously we have the
shaders included in it.

496
00:19:59,236 --> 00:19:59,776 A:middle
We have

497

498
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

499
00:20:00,316 --> 00:20:03,836 A:middle
framebuffer configurations like
number of the rendered targets,

500
00:20:03,836 --> 00:20:06,036 A:middle
the pixel format,
sample count, write mask,

501
00:20:06,036 --> 00:20:11,276 A:middle
blend information actually,
and depth and stencil state.

502
00:20:12,246 --> 00:20:15,396 A:middle
Now we didn't go all the
way to including everything

503
00:20:15,456 --> 00:20:18,136 A:middle
in the GPU state in the
render pipeline state object

504
00:20:18,136 --> 00:20:21,106 A:middle
because if we had done that,
you would be creating millions

505
00:20:21,106 --> 00:20:21,876 A:middle
and millions of them

506
00:20:21,876 --> 00:20:24,456 A:middle
and actually there would
be only a few unique ones

507
00:20:24,456 --> 00:20:25,256 A:middle
of these around.

508
00:20:25,476 --> 00:20:29,486 A:middle
So basically anything that
is...that can easily be updated

509
00:20:29,736 --> 00:20:32,326 A:middle
or that's really truly fix
function hardware is not

510
00:20:32,326 --> 00:20:36,726 A:middle
in the render pipeline state
object such as the inputs.

511
00:20:37,046 --> 00:20:39,166 A:middle
We need to know the layout
of the buffer for example,

512
00:20:39,466 --> 00:20:40,566 A:middle
but we don't really need to know

513
00:20:40,566 --> 00:20:41,936 A:middle
which particular
buffer you're using.

514
00:20:41,936 --> 00:20:43,706 A:middle
It's really easy to
update the pointer pointing

515
00:20:43,706 --> 00:20:45,466 A:middle
to the buffer and the hardware.

516
00:20:46,696 --> 00:20:48,846 A:middle
The same goes true
for buffers as outputs

517
00:20:48,846 --> 00:20:50,566 A:middle
or the framebuffer textures.

518
00:20:50,996 --> 00:20:53,246 A:middle
We need to know how they're
configured, but we don't need

519
00:20:53,246 --> 00:20:55,516 A:middle
to know specifically which
ones are used at any time.

520
00:20:55,596 --> 00:20:59,316 A:middle
Or the primitive setup
states like the cull mode,

521
00:20:59,436 --> 00:21:03,136 A:middle
facing orientation, or
information like viewport

522

523
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

524
00:20:59,436 --> 00:21:03,136 A:middle
facing orientation, or
information like viewport

525
00:21:03,136 --> 00:21:05,806 A:middle
and scissor information; depth
bias and clamp and slope.

526
00:21:06,346 --> 00:21:07,476 A:middle
So those are not included

527
00:21:07,476 --> 00:21:09,536 A:middle
in your render pipeline
state objects, but everything

528
00:21:09,536 --> 00:21:11,296 A:middle
that affects your
cost is included

529
00:21:11,296 --> 00:21:12,776 A:middle
in your pipeline state object

530
00:21:13,076 --> 00:21:14,826 A:middle
so everything you
create is explicit

531
00:21:15,296 --> 00:21:18,026 A:middle
and everything you create is
basically you pay the cost

532
00:21:18,026 --> 00:21:18,446 A:middle
up front.

533
00:21:18,446 --> 00:21:19,706 A:middle
There are no hidden codes

534
00:21:19,706 --> 00:21:21,866 A:middle
that are not deferred
state validation,

535
00:21:21,866 --> 00:21:23,826 A:middle
no later compilation in Metal.

536
00:21:23,826 --> 00:21:26,486 A:middle
So what you do, you know
you do it, you're doing it,

537
00:21:26,766 --> 00:21:29,186 A:middle
why you're doing it, and
the cost is paid up front

538
00:21:29,186 --> 00:21:30,176 A:middle
when you are actually doing it.

539
00:21:31,336 --> 00:21:32,836 A:middle
So let's go and create
a few of those.

540
00:21:33,616 --> 00:21:36,216 A:middle
Basically there's a render
pipeline sate object associated

541
00:21:36,216 --> 00:21:37,206 A:middle
with every draw call.

542
00:21:37,516 --> 00:21:40,576 A:middle
And in our example, for example
under rendering the mesh,

543
00:21:40,576 --> 00:21:43,346 A:middle
the mesh for the [inaudible],
we're going to render it twice;

544
00:21:43,346 --> 00:21:45,346 A:middle
1 we're creating the depth
buffer for the shadowMap

545
00:21:45,686 --> 00:21:47,506 A:middle
and then one; we are
basically doing light

546
00:21:47,506 --> 00:21:49,126 A:middle
accumulation...deferred
lighting pass.

547
00:21:49,506 --> 00:21:51,576 A:middle
So we're going to create 2 of
them; I'm going to give examples

548
00:21:51,576 --> 00:21:53,156 A:middle
of how to create them.

549
00:21:53,796 --> 00:21:55,566 A:middle
We create a new one,
a descriptor.

550
00:21:55,676 --> 00:21:57,416 A:middle
As we talked before,

551
00:21:57,676 --> 00:22:00,676 A:middle
you hopefully basically
compiled your shaders on Xcode

552

553
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

554
00:21:57,676 --> 00:22:00,676 A:middle
you hopefully basically
compiled your shaders on Xcode

555
00:22:00,676 --> 00:22:02,656 A:middle
on the [inaudible] or in
a library so we can go

556
00:22:02,656 --> 00:22:05,106 A:middle
and get your vertex
shader from the library.

557
00:22:05,786 --> 00:22:10,116 A:middle
And now I'm basically setting
the rest of the sates here;

558
00:22:10,116 --> 00:22:11,716 A:middle
basically we're setting
the vertex function,

559
00:22:12,066 --> 00:22:14,176 A:middle
we're setting depth
write enabled to "true"

560
00:22:14,176 --> 00:22:16,036 A:middle
because you actually want
to update that buffer.

561
00:22:16,966 --> 00:22:19,306 A:middle
Interestingly since there's
no color buffer attached,

562
00:22:19,746 --> 00:22:21,426 A:middle
you can set your
fragment shader to "no."

563
00:22:21,496 --> 00:22:22,286 A:middle
There is not really going

564
00:22:22,286 --> 00:22:23,846 A:middle
to be a fragment
shader operation going

565
00:22:23,846 --> 00:22:26,846 A:middle
on for this configuration
for this drawing.

566
00:22:27,386 --> 00:22:30,816 A:middle
And once you have
that information,

567
00:22:30,816 --> 00:22:32,316 A:middle
you can use that descriptor

568
00:22:32,316 --> 00:22:35,676 A:middle
to create our render pipeline
state object for our temple mesh

569
00:22:35,806 --> 00:22:37,196 A:middle
for our shadowMap pass.

570
00:22:38,236 --> 00:22:40,686 A:middle
Let's do the same thing for
the deferred lighting pass.

571
00:22:41,226 --> 00:22:43,856 A:middle
Well the deferred lighting
pass is a little bit more rich

572
00:22:43,856 --> 00:22:46,966 A:middle
in terms of the stream buffer
configuration and terms

573
00:22:46,966 --> 00:22:48,496 A:middle
of the actions that
are taking place.

574
00:22:48,806 --> 00:22:51,316 A:middle
So we're going to have both
the vertex and fragment shader

575
00:22:51,826 --> 00:22:53,876 A:middle
and we're going to
define the pixel formats

576
00:22:54,226 --> 00:22:55,656 A:middle
for all attachments.

577
00:22:56,426 --> 00:23:01,876 A:middle
So we have now basically defined
our render pass descriptors;

578

579
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

580
00:22:56,426 --> 00:23:01,876 A:middle
So we have now basically defined
our render pass descriptors;

581
00:23:02,276 --> 00:23:05,866 A:middle
we created our buffers
for meshes, for uniforms;

582
00:23:06,146 --> 00:23:09,096 A:middle
we created our textures
and uploaded them;

583
00:23:09,346 --> 00:23:11,636 A:middle
we created our render
pipeline state objects;

584
00:23:12,056 --> 00:23:13,996 A:middle
well I think we can now
get into the business

585
00:23:13,996 --> 00:23:15,286 A:middle
of drawing things on the screen.

586
00:23:16,216 --> 00:23:19,166 A:middle
So...well Richard
did a great job

587
00:23:19,166 --> 00:23:22,436 A:middle
in explaining how the command
buffers are formed and used

588
00:23:22,436 --> 00:23:27,626 A:middle
so I'm going you know visit it
for just a bit to remind you.

589
00:23:27,836 --> 00:23:31,286 A:middle
So we have a single command
queue that is our channel

590
00:23:31,286 --> 00:23:34,736 A:middle
to the GPU and we get a command
buffer from the command queue

591
00:23:35,256 --> 00:23:38,096 A:middle
and that's how we do it;
ask the command queue

592
00:23:38,096 --> 00:23:39,216 A:middle
to give us a new command buffer.

593
00:23:39,286 --> 00:23:42,976 A:middle
And then once we basically go
ahead and encode all our render

594
00:23:42,976 --> 00:23:45,586 A:middle
to texture passes, we're
going to be ready to send it

595
00:23:45,586 --> 00:23:49,286 A:middle
to the GPU so that's how we do
it, by issuing a commit call.

596
00:23:49,286 --> 00:23:52,706 A:middle
And then finally, command
buffers are not reused.

597
00:23:52,916 --> 00:23:55,856 A:middle
Once they're used, we get rid
of them and then the next step,

598
00:23:56,016 --> 00:23:58,446 A:middle
next frame, we're going to get
a new one so we set it to "new"

599
00:23:58,446 --> 00:23:59,496 A:middle
and that takes care of it.

600

601
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

602
00:24:00,476 --> 00:24:02,326 A:middle
One thing I like to point
out just as Richard did

603
00:24:02,326 --> 00:24:05,266 A:middle
in the previous session; if
you like to get the results

604
00:24:05,266 --> 00:24:07,946 A:middle
of your command buffer's
operations to show

605
00:24:07,946 --> 00:24:09,436 A:middle
up on the screen, you need

606
00:24:09,436 --> 00:24:12,376 A:middle
to schedule the operation before
committing your command buffer

607
00:24:12,756 --> 00:24:15,686 A:middle
so that you basically call
the addPresent API to schedule

608
00:24:15,686 --> 00:24:18,286 A:middle
that so when the command
buffer is executed by the GPU,

609
00:24:18,576 --> 00:24:20,086 A:middle
the display will
basically know about it

610
00:24:20,086 --> 00:24:22,596 A:middle
and it will show your
image on the display.

611
00:24:24,176 --> 00:24:29,196 A:middle
Ok, now is an exciting part;
creating the command encoders

612
00:24:29,506 --> 00:24:31,786 A:middle
and actually encoding stuff.

613
00:24:32,146 --> 00:24:35,756 A:middle
Well it is exciting, but there's
actually not much left to do

614
00:24:35,806 --> 00:24:37,836 A:middle
at this point because you
have done everything up front.

615
00:24:38,536 --> 00:24:40,216 A:middle
So all we're going to
do is create an encoder

616
00:24:40,216 --> 00:24:41,406 A:middle
from the command
buffer this time.

617
00:24:41,716 --> 00:24:43,316 A:middle
There can only be one
command encoder active

618
00:24:43,316 --> 00:24:44,636 A:middle
at any time on a command buffer.

619
00:24:45,036 --> 00:24:46,246 A:middle
There's one exception to this;

620
00:24:46,246 --> 00:24:48,766 A:middle
this is a parallel
RenderCommandEncoder.

621
00:24:48,886 --> 00:24:51,566 A:middle
I'd like to take a look
at the programming guide

622
00:24:51,566 --> 00:24:52,656 A:middle
to understand when it's used.

623
00:24:52,656 --> 00:24:55,506 A:middle
It's mostly when you have a
huge render to texture pass

624
00:24:55,506 --> 00:24:57,636 A:middle
and you want to basically
paralyze operations

625
00:24:57,636 --> 00:24:59,576 A:middle
on multiple CPUs; that's
the only time you're going

626
00:24:59,576 --> 00:25:00,026 A:middle
to use it.

627

628
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

629
00:24:59,576 --> 00:25:00,026 A:middle
to use it.

630
00:25:00,636 --> 00:25:04,066 A:middle
But for most applications, there
will be one render encoder,

631
00:25:04,506 --> 00:25:06,796 A:middle
RenderCommandEncoder or
a blip command encoder

632
00:25:06,796 --> 00:25:09,606 A:middle
or a compute command
encoder active at any time.

633
00:25:10,426 --> 00:25:13,276 A:middle
So we created one in here;
it's a RenderCommandEncoder

634
00:25:13,276 --> 00:25:15,316 A:middle
for our shadowMap pass

635
00:25:15,686 --> 00:25:18,246 A:middle
and we create it using the
shadowMap pass descriptor

636
00:25:18,556 --> 00:25:20,776 A:middle
that we created just
a few minutes ago.

637
00:25:20,956 --> 00:25:23,826 A:middle
It has all the information
about the depth attachment

638
00:25:24,316 --> 00:25:26,846 A:middle
and the structure of the depth
attachment and how it's defined

639
00:25:26,846 --> 00:25:29,056 A:middle
and all the information
necessary

640
00:25:29,056 --> 00:25:30,066 A:middle
for creating this encoder.

641
00:25:30,136 --> 00:25:33,476 A:middle
And then what we do
is just set the sates;

642
00:25:33,746 --> 00:25:34,846 A:middle
they're all [inaudible] before

643
00:25:34,846 --> 00:25:36,256 A:middle
so we don't have
to validate them.

644
00:25:37,016 --> 00:25:41,736 A:middle
And we set the buffers as inputs
for texture samples as inputs

645
00:25:41,736 --> 00:25:45,096 A:middle
to our draw calls, and then
finally issue our draw calls.

646
00:25:45,096 --> 00:25:47,976 A:middle
And then repeat this hopefully
thousands and thousands of times

647
00:25:48,466 --> 00:25:50,716 A:middle
and in each one you will
basically be using a different

648
00:25:50,716 --> 00:25:51,416 A:middle
kind of state.

649
00:25:51,636 --> 00:25:54,446 A:middle
But the driver will be able to
just go ahead and fetch them

650
00:25:54,796 --> 00:25:57,476 A:middle
from a [inaudible] place instead
of creating them on the fly

651
00:25:57,476 --> 00:25:58,766 A:middle
or validating them on the fly

652
00:25:59,136 --> 00:26:01,996 A:middle
which makes Metal significantly
faster than the alternative app.

653

654
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

655
00:25:59,136 --> 00:26:01,996 A:middle
which makes Metal significantly
faster than the alternative app.

656
00:26:01,996 --> 00:26:05,366 A:middle
And once you're done,
you finish your encoding

657
00:26:05,366 --> 00:26:07,566 A:middle
by calling end encoding.

658
00:26:08,326 --> 00:26:11,726 A:middle
And at this point, the
commands are just created

659
00:26:11,726 --> 00:26:14,106 A:middle
in the command buffer, but
they're not really submitted

660
00:26:14,106 --> 00:26:16,956 A:middle
to the GPU; they cannot
be executed on the GPU

661
00:26:16,956 --> 00:26:18,776 A:middle
yet because that's only done

662
00:26:18,856 --> 00:26:20,346 A:middle
when you submit your
command buffer,

663
00:26:20,646 --> 00:26:22,586 A:middle
not when you finish
your encoding.

664
00:26:23,096 --> 00:26:25,876 A:middle
Let's go create the
encoding for the second pass

665
00:26:25,876 --> 00:26:28,006 A:middle
because it has an
interesting feature

666
00:26:28,006 --> 00:26:30,886 A:middle
that we couldn't finish
completing our vendor pass

667
00:26:30,886 --> 00:26:34,006 A:middle
descriptor early enough because
we didn't have the texture

668
00:26:34,336 --> 00:26:36,436 A:middle
for our drawable at that point.

669
00:26:37,016 --> 00:26:40,436 A:middle
So just in the previous session
if you saw that how we can get

670
00:26:40,436 --> 00:26:42,486 A:middle
that texture, if you
remember doing that,

671
00:26:42,486 --> 00:26:45,186 A:middle
and then assigning it our
first color attachment

672
00:26:45,186 --> 00:26:48,696 A:middle
to the texture point of
our first color attachment.

673
00:26:49,336 --> 00:26:52,186 A:middle
The rest of the descriptor
was well defined before;

674
00:26:52,186 --> 00:26:55,746 A:middle
we knew what textures to use
and how many textures there were

675
00:26:56,066 --> 00:26:58,306 A:middle
and so we don't actually
need to modify that part.

676
00:26:58,306 --> 00:26:59,946 A:middle
We're just going to
basically update this part

677
00:26:59,946 --> 00:27:02,236 A:middle
of the descriptor and
are going to use that one

678

679
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

680
00:26:59,946 --> 00:27:02,236 A:middle
of the descriptor and
are going to use that one

681
00:27:02,236 --> 00:27:04,586 A:middle
to create our
RenderCommandEncoder

682
00:27:04,586 --> 00:27:06,826 A:middle
for our deferred lighting pass.

683
00:27:07,516 --> 00:27:11,456 A:middle
We do the usual, just issue
draw calls and finally end

684
00:27:11,456 --> 00:27:14,076 A:middle
up finishing our draw calls

685
00:27:14,476 --> 00:27:16,486 A:middle
and closing our encoder
by end encoding.

686
00:27:16,826 --> 00:27:19,366 A:middle
And at this point for this
particular application

687
00:27:19,756 --> 00:27:22,726 A:middle
since you have only 2 passes,
we just call the command buffer

688
00:27:22,726 --> 00:27:25,086 A:middle
to commit and it
will go to the GPU

689
00:27:25,086 --> 00:27:27,516 A:middle
and the GPU will start executing
the commands we encoded

690
00:27:27,516 --> 00:27:27,836 A:middle
just now.

691
00:27:29,286 --> 00:27:31,266 A:middle
Ok, so that's all I
wanted to talk about;

692
00:27:31,266 --> 00:27:33,576 A:middle
how to structure your
application to take advantage

693
00:27:33,576 --> 00:27:36,866 A:middle
of Metal and we're going
to go into a really,

694
00:27:36,866 --> 00:27:40,186 A:middle
really interesting and new
feature that we have on iOS;

695
00:27:40,526 --> 00:27:42,676 A:middle
data-parallel computing
on the GPU with Metal

696
00:27:43,026 --> 00:27:44,656 A:middle
so Aaftab will talk about that.

697
00:27:44,656 --> 00:27:44,836 A:middle
Thank you.

698
00:27:45,516 --> 00:27:49,716 A:middle
[ Applause ]

699
00:27:50,216 --> 00:27:50,836 A:middle
>> Thanks Gokhan.

700
00:27:51,586 --> 00:27:54,516 A:middle
All right, I'm back.

701
00:27:54,516 --> 00:27:57,576 A:middle
All right, so I have
15 minutes to talk

702
00:27:57,576 --> 00:27:59,176 A:middle
about data-parallel
computing so I want to focus

703
00:27:59,176 --> 00:28:01,466 A:middle
on the key points I
wanted to get across.

704

705
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

706
00:27:59,176 --> 00:28:01,466 A:middle
on the key points I
wanted to get across.

707
00:28:01,466 --> 00:28:05,746 A:middle
So we'll first talk about...and
give a very high level overview

708
00:28:05,746 --> 00:28:07,096 A:middle
of what is data-parallel
computing,

709
00:28:07,666 --> 00:28:12,246 A:middle
how Metal does data-parallel
computing, and then we'll look

710
00:28:12,246 --> 00:28:17,536 A:middle
at how to write kernels in
metal and how to execute them.

711
00:28:17,616 --> 00:28:18,826 A:middle
And we'll actually
take an example,

712
00:28:18,826 --> 00:28:21,536 A:middle
a post processing example,
and show how you do that.

713
00:28:22,106 --> 00:28:23,356 A:middle
All right, so let's start.

714
00:28:23,766 --> 00:28:25,146 A:middle
So what is data-parallel
computing?

715
00:28:25,486 --> 00:28:27,896 A:middle
So imagine if you have a piece
of code, let's say a function,

716
00:28:28,546 --> 00:28:34,036 A:middle
that we can execute all elements
of your data; so maybe elements

717
00:28:34,036 --> 00:28:36,466 A:middle
in an array or pixels
of an image.

718
00:28:37,806 --> 00:28:41,436 A:middle
And these computations are
independent to each other.

719
00:28:41,856 --> 00:28:44,726 A:middle
So that means if I have you know
multiple threads of execution,

720
00:28:44,726 --> 00:28:48,176 A:middle
I can run them all in
parallel so that's what I mean

721
00:28:48,176 --> 00:28:49,096 A:middle
by data-parallel computing.

722
00:28:49,096 --> 00:28:51,746 A:middle
So this is actually a very
simple form a data-parallel

723
00:28:51,746 --> 00:28:54,436 A:middle
computing and I'll
talk a little bit more

724
00:28:54,436 --> 00:28:58,436 A:middle
about additional things
you can do in Metal

725
00:28:58,436 --> 00:28:59,496 A:middle
with data-parallel computing.

726
00:28:59,496 --> 00:29:04,026 A:middle
So a classic example of this
data-parallel computing is

727

728
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

729
00:28:59,496 --> 00:29:04,026 A:middle
So a classic example of this
data-parallel computing is

730
00:29:04,026 --> 00:29:05,366 A:middle
blurring an image, right?

731
00:29:05,366 --> 00:29:08,376 A:middle
So for example you
have an image.

732
00:29:08,376 --> 00:29:11,356 A:middle
For each pixel you're
looking at a nearby region

733
00:29:11,356 --> 00:29:12,366 A:middle
and you know applying a filter.

734
00:29:12,586 --> 00:29:14,366 A:middle
Well I could execute
these in parallel.

735
00:29:14,366 --> 00:29:16,536 A:middle
So if I had let's
say a 1k by 1k image

736
00:29:16,896 --> 00:29:18,056 A:middle
and I had a million threads,

737
00:29:18,306 --> 00:29:21,446 A:middle
I could execute each
pixel in parallel, right?

738
00:29:21,886 --> 00:29:23,956 A:middle
So how does that work in Metal?

739
00:29:24,426 --> 00:29:27,716 A:middle
So the code that you're
going to execute in parallel,

740
00:29:28,236 --> 00:29:29,436 A:middle
we call that a kernel.

741
00:29:30,056 --> 00:29:32,396 A:middle
And the thing that actually
executes independently,

742
00:29:32,716 --> 00:29:33,596 A:middle
we call that a work-item.

743
00:29:33,716 --> 00:29:38,066 A:middle
So on a GPU, a thread may
actually contain multiple

744
00:29:38,066 --> 00:29:41,496 A:middle
work-items because now a thread
actually may execute multiple

745
00:29:41,496 --> 00:29:44,146 A:middle
such things in SIMD fashion and
then you have multiple threads.

746
00:29:44,586 --> 00:29:46,006 A:middle
So the work-item is the thing

747
00:29:46,006 --> 00:29:48,726 A:middle
that identifies each
independent execution instance.

748
00:29:49,036 --> 00:29:52,636 A:middle
So you're going stop me
right there and say, "Hey,

749
00:29:52,636 --> 00:29:55,256 A:middle
that looks just like a
fragment shader," right?

750
00:29:55,256 --> 00:29:57,556 A:middle
Because that's what
fragment shaders do, right?

751
00:29:57,856 --> 00:29:59,976 A:middle
You execute the shader
in parallel

752

753
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

754
00:30:00,046 --> 00:30:02,886 A:middle
or multiple fragments; they
don't talk to each other.

755
00:30:03,056 --> 00:30:04,436 A:middle
Like they are in
their own world.

756
00:30:04,436 --> 00:30:06,166 A:middle
They take inputs;
produce outputs.

757
00:30:06,686 --> 00:30:08,126 A:middle
So what is this
data-parallelism?

758
00:30:08,626 --> 00:30:11,716 A:middle
So that is indeed; we
call it SIMD parallelism

759
00:30:11,716 --> 00:30:15,326 A:middle
and that is a data-parallelism
model supported in Metal.

760
00:30:15,666 --> 00:30:19,776 A:middle
And the only benefit here
is that you no longer have

761
00:30:19,776 --> 00:30:21,496 A:middle
to create a graphics pipeline;

762
00:30:21,496 --> 00:30:25,236 A:middle
you don't specify a vertex
shader and a fragment shader

763
00:30:25,236 --> 00:30:26,256 A:middle
and sate and things like that.

764
00:30:26,256 --> 00:30:27,846 A:middle
You just say, "Here
is my function,

765
00:30:27,986 --> 00:30:29,506 A:middle
here is my problem size,

766
00:30:29,706 --> 00:30:31,746 A:middle
go execute this function
over there."

767
00:30:31,826 --> 00:30:35,166 A:middle
But there's more to it than that
because in data-parallelism,

768
00:30:35,426 --> 00:30:38,926 A:middle
you can actually tell
the number of algorithms

769
00:30:38,926 --> 00:30:41,636 A:middle
where you actually
want these work-items

770
00:30:41,996 --> 00:30:43,466 A:middle
to communicate with each other.

771
00:30:43,566 --> 00:30:45,006 A:middle
Let's take an example;
let's say I want to --

772
00:30:45,106 --> 00:30:48,186 A:middle
a very simple example -- I want
to sum elements of an array.

773
00:30:48,216 --> 00:30:51,026 A:middle
It's referred to as a
classic problem of reduction.

774
00:30:51,556 --> 00:30:54,716 A:middle
So in that case, you now we
have these work-items generating

775
00:30:54,766 --> 00:30:57,506 A:middle
partial results and
you keep looking

776
00:30:57,506 --> 00:31:00,316 A:middle
over until you finally have
you know 2 partial sums

777

778
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

779
00:30:57,506 --> 00:31:00,316 A:middle
over until you finally have
you know 2 partial sums

780
00:31:00,316 --> 00:31:01,446 A:middle
and then you get the final sum.

781
00:31:01,656 --> 00:31:04,996 A:middle
But in order to make this
work, these work-items need

782
00:31:05,036 --> 00:31:08,746 A:middle
to know the results generated by
other work-items, so they need

783
00:31:08,746 --> 00:31:11,116 A:middle
to be able to talk and you
know talk is always good.

784
00:31:11,526 --> 00:31:14,476 A:middle
So what you can do in
Metal is you can say, "Hey,

785
00:31:14,476 --> 00:31:17,166 A:middle
these work-items, they
work together," ok?

786
00:31:17,166 --> 00:31:18,696 A:middle
And we call that a work-group.

787
00:31:19,456 --> 00:31:20,866 A:middle
And these work-items

788
00:31:20,866 --> 00:31:23,366 A:middle
in the work-group can
actually share data

789
00:31:23,926 --> 00:31:25,986 A:middle
through what we call
local memory.

790
00:31:25,986 --> 00:31:28,026 A:middle
Remember we talked in the
previous session about global

791
00:31:28,026 --> 00:31:30,536 A:middle
and constant and so for kernels,

792
00:31:30,706 --> 00:31:34,226 A:middle
you get an additional high
bandwidth low latency memory we

793
00:31:34,226 --> 00:31:34,946 A:middle
call "local memory."

794
00:31:34,946 --> 00:31:36,796 A:middle
Think of it just as
a user-managed cache.

795
00:31:36,896 --> 00:31:37,516 A:middle
that's all it is.

796
00:31:37,516 --> 00:31:39,886 A:middle
And then they can
synchronize because now

797
00:31:40,196 --> 00:31:43,276 A:middle
when these threads want...or
work-items want to communicate,

798
00:31:43,276 --> 00:31:45,536 A:middle
they need to make sure they
arrive at a place together

799
00:31:45,616 --> 00:31:48,996 A:middle
so they can exchange data
so you get all of that

800
00:31:49,406 --> 00:31:50,706 A:middle
with data-parallelism in Metal.

801
00:31:50,856 --> 00:31:51,806 A:middle
So let's...

802
00:31:53,206 --> 00:31:55,926 A:middle
Ok? So I wrote my code
that can do all of this,

803
00:31:56,086 --> 00:31:57,746 A:middle
but how do I describe
my problem?

804
00:31:58,326 --> 00:32:01,736 A:middle
So the thing is we called it a
computation domain so depending

805

806
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

807
00:31:58,326 --> 00:32:01,736 A:middle
So the thing is we called it a
computation domain so depending

808
00:32:01,736 --> 00:32:05,506 A:middle
on what thing you're going to
execute this function over,

809
00:32:05,506 --> 00:32:07,686 A:middle
if it's an array, your
problem is 1-dimensional.

810
00:32:08,156 --> 00:32:10,366 A:middle
If it's an image, your
problem is 2-dimensional.

811
00:32:11,036 --> 00:32:13,386 A:middle
So I've specified
the dimensions,

812
00:32:13,476 --> 00:32:14,926 A:middle
but what else do
I need to specify?

813
00:32:15,096 --> 00:32:17,586 A:middle
Well now I need to tell
you how many work items are

814
00:32:17,586 --> 00:32:20,456 A:middle
in my work-group and then how
many work-groups do I have?

815
00:32:20,826 --> 00:32:22,726 A:middle
So that describes the
number of work-items

816
00:32:23,276 --> 00:32:24,806 A:middle
in the work-group times
the number of work-groups

817
00:32:24,806 --> 00:32:26,136 A:middle
that describes the total problem

818
00:32:26,136 --> 00:32:28,046 A:middle
that will be executed
in parallel.

819
00:32:28,416 --> 00:32:30,926 A:middle
So choose the dimensions that
are best for your algorithm.

820
00:32:30,926 --> 00:32:32,326 A:middle
So if you're doing
an image processing,

821
00:32:32,326 --> 00:32:34,456 A:middle
a post processing effect,
you know you're going

822
00:32:34,456 --> 00:32:35,666 A:middle
to operate on textures.

823
00:32:35,666 --> 00:32:39,366 A:middle
Use 2D. Yeah, you could do it
in 1D, but who wants to do all

824
00:32:39,366 --> 00:32:41,346 A:middle
that work to turn that 2D to 1D?

825
00:32:41,416 --> 00:32:42,886 A:middle
And you shouldn't have to.

826
00:32:43,316 --> 00:32:46,346 A:middle
And the work-items you
have in your work-group,

827
00:32:46,496 --> 00:32:48,196 A:middle
how many they are,
it's going to depend

828
00:32:48,196 --> 00:32:49,696 A:middle
on the algorithm you're using.

829
00:32:49,696 --> 00:32:52,966 A:middle
It's going to depend on how many
loads to operations you're doing

830
00:32:52,966 --> 00:32:57,206 A:middle
and how much computations; a
ratio of memory to computations

831
00:32:57,386 --> 00:32:58,816 A:middle
and so play with that.

832
00:32:58,816 --> 00:32:59,706 A:middle
Choose the right dimensions.

833

834
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

835
00:33:00,286 --> 00:33:02,376 A:middle
You have the flexibility
because you can specify these.

836
00:33:03,306 --> 00:33:04,766 A:middle
All right, so let's
take an example.

837
00:33:04,966 --> 00:33:08,356 A:middle
We'll look at how to take
pseudo-code C, C Plus Plus code,

838
00:33:08,356 --> 00:33:09,486 A:middle
and make it into shaders.

839
00:33:09,826 --> 00:33:11,606 A:middle
We'll look at how we do that
for calls and we're going

840
00:33:11,606 --> 00:33:13,246 A:middle
to take a really,
really simple example.

841
00:33:13,246 --> 00:33:16,836 A:middle
So this function takes an
input, squares the result

842
00:33:16,836 --> 00:33:19,006 A:middle
for each element,
and writs it out.

843
00:33:19,306 --> 00:33:21,296 A:middle
And remember ah,

844
00:33:21,296 --> 00:33:23,416 A:middle
it has the...the
function is not complete.

845
00:33:24,356 --> 00:33:26,716 A:middle
So we include the standard
library just like we did

846
00:33:26,716 --> 00:33:28,846 A:middle
for shaders and we use
the Metal namespace.

847
00:33:29,196 --> 00:33:32,036 A:middle
So remember, we're going
to execute this function

848
00:33:32,036 --> 00:33:35,376 A:middle
for each index in
parallel but first,

849
00:33:35,666 --> 00:33:38,366 A:middle
I need to tell the compiler that
this is a data-parallel function

850
00:33:38,486 --> 00:33:39,826 A:middle
so that's what the
kernel is going

851
00:33:39,826 --> 00:33:41,276 A:middle
to do; that's the qualifier.

852
00:33:41,396 --> 00:33:45,526 A:middle
All right, I'm passing
pointers so I need

853
00:33:45,526 --> 00:33:48,806 A:middle
to specify these buffers, what
indices they're going to be in

854
00:33:48,806 --> 00:33:50,856 A:middle
and that they're in the
global address space.

855
00:33:50,856 --> 00:33:51,646 A:middle
Remember we talked

856
00:33:51,756 --> 00:33:53,446 A:middle
in the previous session
about address spaces?

857
00:33:53,446 --> 00:33:56,286 A:middle
So these are coming in
global and then I need

858
00:33:56,286 --> 00:33:59,526 A:middle
to tell the compiler that
this ID to I'm going to use

859
00:33:59,526 --> 00:34:03,226 A:middle
to index is unique for each
instance and so in this case,

860

861
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

862
00:33:59,526 --> 00:34:03,226 A:middle
to index is unique for each
instance and so in this case,

863
00:34:03,226 --> 00:34:05,326 A:middle
I call that a "global ID," ok?

864
00:34:05,606 --> 00:34:07,726 A:middle
So we have a vertex
ID and compute.

865
00:34:08,186 --> 00:34:09,696 A:middle
You have global IDs, ok?

866
00:34:09,835 --> 00:34:12,585 A:middle
So pretty simple;
pretty straightforward.

867
00:34:12,786 --> 00:34:14,446 A:middle
Well let's say if
I'm using textures,

868
00:34:14,446 --> 00:34:15,926 A:middle
how would I write a kernel.

869
00:34:16,016 --> 00:34:20,306 A:middle
So let's say I'm trying to just
mirror an image horizontally,

870
00:34:20,505 --> 00:34:24,906 A:middle
so this was my image and I
want to...remember what I said,

871
00:34:25,255 --> 00:34:26,206 A:middle
"Use the right dimensions?"

872
00:34:26,505 --> 00:34:28,156 A:middle
So since I'm operating
on an image,

873
00:34:28,246 --> 00:34:31,025 A:middle
I really want my global ID
to be 2-dimensional in nature

874
00:34:31,326 --> 00:34:32,476 A:middle
and that's what I'm doing here.

875
00:34:32,956 --> 00:34:35,626 A:middle
And I want to read
from my input texture

876
00:34:36,045 --> 00:34:37,446 A:middle
after I have mirrored
the coordinate

877
00:34:37,446 --> 00:34:38,876 A:middle
and then I want to write it out.

878
00:34:39,366 --> 00:34:42,196 A:middle
So you're going to find
in writing kernels,

879
00:34:43,016 --> 00:34:45,686 A:middle
just like writing
shaders, it's really easy.

880
00:34:45,985 --> 00:34:48,835 A:middle
Its C Plus Plus code; it's
standard with information

881
00:34:48,835 --> 00:34:51,636 A:middle
so that a compiler knows
what you are trying to do.

882
00:34:52,106 --> 00:34:55,356 A:middle
Ok, remember we talked
about built-in variables?

883
00:34:55,686 --> 00:34:59,606 A:middle
You had a special attribute
to say position, front-facing,

884
00:34:59,606 --> 00:35:00,866 A:middle
and things like that
for graphics?

885

886
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

887
00:34:59,606 --> 00:35:00,866 A:middle
and things like that
for graphics?

888
00:35:01,336 --> 00:35:03,706 A:middle
Well we have something
similar for kernels too.

889
00:35:04,576 --> 00:35:07,636 A:middle
Well global ID; you guys
already know it is now, right?

890
00:35:08,336 --> 00:35:12,186 A:middle
So in this case, my example, I'm
actually using...I'm operating

891
00:35:12,186 --> 00:35:15,016 A:middle
on a texture so my global
ID is 2-dimensional.

892
00:35:15,236 --> 00:35:17,936 A:middle
So it can be a ushort2 or uint2

893
00:35:18,466 --> 00:35:20,196 A:middle
so use the right
dimensions you want.

894
00:35:20,556 --> 00:35:24,096 A:middle
Now so that's great if I'm
only operating on textures

895
00:35:24,306 --> 00:35:27,126 A:middle
in my kernel, but what if
I'm passing in buffers too?

896
00:35:27,596 --> 00:35:29,226 A:middle
So when I access my texture,

897
00:35:29,266 --> 00:35:31,226 A:middle
I'm going to use my
2-dimensional global ID,

898
00:35:31,226 --> 00:35:34,416 A:middle
but if I access a buffer, I need
to create a 1-dimensional ID.

899
00:35:34,536 --> 00:35:38,006 A:middle
So we're trying to help you
not have to write all that code

900
00:35:38,006 --> 00:35:40,156 A:middle
because there may be bugs;
we fixed that for you

901
00:35:40,276 --> 00:35:41,556 A:middle
so that's the global linear ID.

902
00:35:42,006 --> 00:35:44,696 A:middle
So now remember we said,

903
00:35:44,696 --> 00:35:46,236 A:middle
"Work-items work
in a work-group?"

904
00:35:46,716 --> 00:35:47,936 A:middle
So within that work-group,

905
00:35:47,936 --> 00:35:49,846 A:middle
I need to know which
instance I am.

906
00:35:50,266 --> 00:35:53,506 A:middle
So I have global ID; we
call this the "local id."

907
00:35:54,186 --> 00:35:56,436 A:middle
And just like you can have
a 2-dimensional local ID,

908
00:35:57,016 --> 00:35:58,156 A:middle
there's also a 1-dimensional;

909
00:35:59,096 --> 00:36:00,326 A:middle
we call that that the
"local linear ID."

910

911
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

912
00:35:59,096 --> 00:36:00,326 A:middle
we call that that the
"local linear ID."

913
00:36:00,326 --> 00:36:03,166 A:middle
So you just specify these
attributes for the arguments

914
00:36:03,166 --> 00:36:06,516 A:middle
to your kernel function and
the compiler will generate the

915
00:36:06,516 --> 00:36:07,066 A:middle
right code.

916
00:36:07,556 --> 00:36:10,646 A:middle
And finally we call this
the "work-group ID."

917
00:36:10,646 --> 00:36:12,156 A:middle
And so why do I care about this?

918
00:36:12,476 --> 00:36:17,006 A:middle
Well remember you specify
the number of work-items

919
00:36:17,586 --> 00:36:19,166 A:middle
in the work-group and
number of work-groups?

920
00:36:19,596 --> 00:36:22,486 A:middle
So let's take...for an example
I'm generating a histogram.

921
00:36:22,806 --> 00:36:26,346 A:middle
So each work-group...one way you
could do this is each work-group

922
00:36:26,346 --> 00:36:28,666 A:middle
could generate a partial
histogram, so a histogram

923
00:36:28,666 --> 00:36:30,056 A:middle
for the things it's working on.

924
00:36:30,446 --> 00:36:31,646 A:middle
And then you will
run another kernel

925
00:36:31,646 --> 00:36:33,486 A:middle
that could sum these
partial histograms

926
00:36:33,486 --> 00:36:34,736 A:middle
and generate a final histogram.

927
00:36:35,996 --> 00:36:38,006 A:middle
Well so that means I
need to write the results

928
00:36:38,006 --> 00:36:41,096 A:middle
of these partial histograms
to some buffer, right?

929
00:36:41,516 --> 00:36:43,906 A:middle
Well I don't want to create
a buffer for each work-group

930
00:36:43,906 --> 00:36:45,996 A:middle
so I just want to
allocate one buffer

931
00:36:46,096 --> 00:36:49,566 A:middle
so guess what index
would I use to write?

932
00:36:49,936 --> 00:36:51,176 A:middle
That would be my work-group ID

933
00:36:51,176 --> 00:36:54,326 A:middle
so that's how you
would use it, ok?

934
00:36:54,966 --> 00:36:57,346 A:middle
All right, so let's see
how to execute kernels.

935
00:36:57,346 --> 00:37:01,276 A:middle
What commands do I
encode to send work

936

937
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

938
00:36:57,346 --> 00:37:01,276 A:middle
What commands do I
encode to send work

939
00:37:01,276 --> 00:37:02,606 A:middle
to the GPU to execute a kernel?

940
00:37:02,606 --> 00:37:04,606 A:middle
And we're going to take
a post-processing example

941
00:37:04,606 --> 00:37:06,596 A:middle
so this is going to do
some highlights, shadows,

942
00:37:06,636 --> 00:37:08,006 A:middle
renew the facts and
things like that

943
00:37:08,006 --> 00:37:09,476 A:middle
and I'll actually demo
that for you guys.

944
00:37:09,856 --> 00:37:11,706 A:middle
So let's look at the source.

945
00:37:11,706 --> 00:37:13,436 A:middle
I'm not going to give the
details of the source;

946
00:37:13,436 --> 00:37:15,936 A:middle
just give a very high-level
picture of what's happening.

947
00:37:15,986 --> 00:37:18,836 A:middle
So it takes a number of
images and some information.

948
00:37:19,066 --> 00:37:21,956 A:middle
It's going to take the
global ID and transform

949
00:37:21,956 --> 00:37:24,356 A:middle
that using some matrix;
an affine matrix.

950
00:37:24,816 --> 00:37:26,326 A:middle
It's going to sample
from an image

951
00:37:26,636 --> 00:37:28,596 A:middle
and then apply a
post-processing effect,

952
00:37:28,996 --> 00:37:30,896 A:middle
and then write to an image, ok?

953
00:37:30,896 --> 00:37:33,096 A:middle
And then you're going
to say, "That looks just

954
00:37:33,096 --> 00:37:33,936 A:middle
like a fragment shader."

955
00:37:34,646 --> 00:37:36,506 A:middle
Well in this case, yes it does.

956
00:37:37,096 --> 00:37:40,716 A:middle
But remember, the number
of work-items times number

957
00:37:40,716 --> 00:37:43,526 A:middle
of work-groups makeup the total
problem domain you're going

958
00:37:43,526 --> 00:37:44,066 A:middle
to operate on.

959
00:37:44,536 --> 00:37:45,566 A:middle
There is no such requirement

960
00:37:45,566 --> 00:37:48,086 A:middle
that each work-item must
only operate on only 1 pixel;

961
00:37:48,546 --> 00:37:50,146 A:middle
it could actually
operate on many pixels.

962
00:37:50,566 --> 00:37:52,996 A:middle
And depending on what you
are doing in your code --

963
00:37:52,996 --> 00:37:55,556 A:middle
again that computation
to memory ratio --

964
00:37:56,336 --> 00:37:59,736 A:middle
you may find its better to
do more work than less work.

965

966
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

967
00:38:00,326 --> 00:38:02,376 A:middle
So when we do this, we
actually modify this kernel.

968
00:38:02,536 --> 00:38:04,386 A:middle
So we have a crack
team working on it

969
00:38:04,896 --> 00:38:07,386 A:middle
and what they did
is they changed it

970
00:38:07,716 --> 00:38:09,306 A:middle
to 4 pixels per work-item.

971
00:38:10,756 --> 00:38:12,636 A:middle
It's like...it was
actually faster.

972
00:38:13,106 --> 00:38:14,616 A:middle
And so we like faster, don't we?

973
00:38:16,056 --> 00:38:19,066 A:middle
So that's what it's
doing; it's for...so and so

974
00:38:19,066 --> 00:38:22,256 A:middle
in fact each work-group is
doing the work of 4 work-groups

975
00:38:22,256 --> 00:38:25,306 A:middle
so we don't need to look at this
code, but its straightforward.

976
00:38:25,306 --> 00:38:26,896 A:middle
It's going to loop
over these things

977
00:38:26,896 --> 00:38:28,186 A:middle
that the compiler
is going to unroll.

978
00:38:28,576 --> 00:38:32,556 A:middle
But the point here is that
there is no requirement

979
00:38:32,556 --> 00:38:35,416 A:middle
of one-to-one mapping; you
can have one-to-end mapping.

980
00:38:35,686 --> 00:38:37,976 A:middle
And so you have a lot
of flexibility, ok?

981
00:38:37,976 --> 00:38:41,066 A:middle
And that can actually
help...really help you tune your

982
00:38:41,066 --> 00:38:42,936 A:middle
code; your data parellel
function that you want

983
00:38:42,936 --> 00:38:43,916 A:middle
to execute on the GPU.

984
00:38:45,196 --> 00:38:47,626 A:middle
All right, so let's talk about
the compute command encoder.

985
00:38:47,836 --> 00:38:49,846 A:middle
So this is what you
need to send commands

986
00:38:50,126 --> 00:38:51,656 A:middle
to execute kernels on the GPU.

987
00:38:52,106 --> 00:38:54,316 A:middle
So just like the
RenderCommandEncoder

988
00:38:54,486 --> 00:38:56,716 A:middle
for compute, we have this
compute command encoder

989
00:38:56,716 --> 00:38:58,096 A:middle
but first things first.

990
00:38:58,636 --> 00:39:00,266 A:middle
Remember I compiled my kernel

991

992
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

993
00:38:58,636 --> 00:39:00,266 A:middle
Remember I compiled my kernel

994
00:39:00,736 --> 00:39:02,616 A:middle
and so I have created
a Metal library.

995
00:39:03,086 --> 00:39:04,086 A:middle
And so I'm going to load that

996
00:39:04,086 --> 00:39:05,396 A:middle
and I'm going to
load that kernel.

997
00:39:06,236 --> 00:39:07,826 A:middle
The next thing I'm
going to do is I'm going

998
00:39:07,826 --> 00:39:08,936 A:middle
to create my compute state.

999
00:39:09,106 --> 00:39:10,736 A:middle
Just like we had the
render pipeline state,

1000
00:39:11,006 --> 00:39:12,396 A:middle
there's the compute
pipeline state.

1001
00:39:12,606 --> 00:39:15,496 A:middle
And all it takes in this
case is just the function.

1002
00:39:16,296 --> 00:39:17,976 A:middle
The compute doesn't
have a lot of states.

1003
00:39:18,686 --> 00:39:19,976 A:middle
So at this point in time,

1004
00:39:20,116 --> 00:39:23,226 A:middle
remember in the Metal library
the information we compiled

1005
00:39:23,226 --> 00:39:27,606 A:middle
from your source to Metal
IR, in LLVM-based IR,

1006
00:39:27,606 --> 00:39:28,906 A:middle
we're going to take that

1007
00:39:28,906 --> 00:39:30,836 A:middle
and when you create a new
compute pipeline state,

1008
00:39:30,836 --> 00:39:33,566 A:middle
we're going to compile it
to the actual GPU binary

1009
00:39:33,566 --> 00:39:35,506 A:middle
that the GPU is going
to execute, ok?

1010
00:39:36,296 --> 00:39:38,776 A:middle
I'm going to create my
compute command encoder.

1011
00:39:40,516 --> 00:39:42,046 A:middle
I'm ready to send commands now.

1012
00:39:43,266 --> 00:39:46,066 A:middle
So the first thing I'm going
to do is set my compute state.

1013
00:39:46,446 --> 00:39:49,446 A:middle
So then I'm going to set my
resources my kernel uses;

1014
00:39:49,446 --> 00:39:50,946 A:middle
remember the buffers
and textures.

1015
00:39:51,496 --> 00:39:54,506 A:middle
And then I'm going to execute
"ready to encode the command"

1016
00:39:54,506 --> 00:39:55,526 A:middle
to execute the kernel.

1017
00:39:55,836 --> 00:39:56,736 A:middle
So in order to do that,

1018
00:39:57,286 --> 00:39:59,966 A:middle
I need to first set the number
work-items in the work-group,

1019

1020
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1021
00:40:00,056 --> 00:40:01,176 A:middle
and how many work-groups
there are.

1022
00:40:01,326 --> 00:40:03,956 A:middle
So in this example,
I use a 16 by 16.

1023
00:40:04,036 --> 00:40:05,366 A:middle
Remember they are
2-dimensional problems;

1024
00:40:05,366 --> 00:40:07,986 A:middle
I'm going to give it
2-dimensional work-group size.

1025
00:40:08,436 --> 00:40:11,276 A:middle
And so I know the
output image dimensions,

1026
00:40:11,456 --> 00:40:13,076 A:middle
I know my work-group
size, so I'm going

1027
00:40:13,076 --> 00:40:15,476 A:middle
to know...calculate how many
work-groups there are going

1028
00:40:15,476 --> 00:40:15,796 A:middle
to be.

1029
00:40:17,186 --> 00:40:20,686 A:middle
And now, I encode the
command to execute the kernel.

1030
00:40:20,686 --> 00:40:22,976 A:middle
So 2 things I specify;
the work-group size

1031
00:40:22,976 --> 00:40:24,736 A:middle
and how many work-groups
there are, ok?

1032
00:40:24,736 --> 00:40:27,216 A:middle
And then I'm done encoding.

1033
00:40:27,786 --> 00:40:33,176 A:middle
So at this point in time,
commands have been encoded

1034
00:40:33,866 --> 00:40:35,396 A:middle
but the GPU hasn't
received them.

1035
00:40:35,546 --> 00:40:38,066 A:middle
So just like we talked
about sending commands,

1036
00:40:38,066 --> 00:40:40,246 A:middle
you have to commit the command
buffer and when you do that,

1037
00:40:40,586 --> 00:40:43,136 A:middle
the GPU will start
executing this kernel, ok?

1038
00:40:43,336 --> 00:40:46,216 A:middle
So let me show you a demo of
these filtering operations.

1039
00:40:47,026 --> 00:40:49,096 A:middle
All right, so that's
applying and we know the fact

1040
00:40:49,096 --> 00:40:49,976 A:middle
that we can do shadows.

1041
00:40:50,516 --> 00:40:54,546 A:middle
[ Applause ]

1042
00:40:55,046 --> 00:40:56,686 A:middle
Ok, so that's the
highlights and shadows filter,

1043
00:40:56,856 --> 00:40:58,276 A:middle
but I can actually
do a tune filter.

1044
00:40:58,276 --> 00:41:01,836 A:middle
And so this is actually...what
it's doing is its taking your

1045

1046
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1047
00:40:58,276 --> 00:41:01,836 A:middle
And so this is actually...what
it's doing is its taking your

1048
00:41:01,836 --> 00:41:03,376 A:middle
input image and
applying...converting it

1049
00:41:03,376 --> 00:41:05,276 A:middle
into a what we'll
call the LAB space

1050
00:41:05,276 --> 00:41:08,936 A:middle
which approximates human vision,
then does a bilateral filter,

1051
00:41:08,936 --> 00:41:10,346 A:middle
and then actually
does the tune filter,

1052
00:41:10,346 --> 00:41:12,186 A:middle
and then converts
it back to RGB.

1053
00:41:12,186 --> 00:41:14,076 A:middle
Or let's say I want to
sharpen it so I want

1054
00:41:14,076 --> 00:41:15,186 A:middle
to apply a sharpen filter.

1055
00:41:15,746 --> 00:41:19,306 A:middle
So you can see we adjusted the
image, it's getting sharpened.

1056
00:41:19,306 --> 00:41:22,796 A:middle
Hopefully you do see reduced of
the image getting sharpened, ok?

1057
00:41:22,976 --> 00:41:24,226 A:middle
So these are some of the filters

1058
00:41:24,456 --> 00:41:25,976 A:middle
and these are really,
really easy to write.

1059
00:41:25,976 --> 00:41:29,596 A:middle
Because in effect what you're
doing now is you're just writing

1060
00:41:29,596 --> 00:41:32,946 A:middle
your code, you're algorithm,
just as a set of functions.

1061
00:41:33,346 --> 00:41:34,826 A:middle
And saying, "Execute
this function

1062
00:41:34,826 --> 00:41:36,776 A:middle
or this problem domain."

1063
00:41:36,776 --> 00:41:39,006 A:middle
Really, really simple
to think about.

1064
00:41:39,006 --> 00:41:40,236 A:middle
So focus more on the algorithm

1065
00:41:40,236 --> 00:41:42,926 A:middle
and that's what data-parallel
computing allows you to do, ok?

1066
00:41:43,956 --> 00:41:46,486 A:middle
So that's all I could...that's
all I'm going to say

1067
00:41:46,486 --> 00:41:48,196 A:middle
about data-parallel
computing and next,

1068
00:41:48,406 --> 00:41:49,706 A:middle
we're going to have Serhat come

1069
00:41:49,706 --> 00:41:51,416 A:middle
and show you the
amazing tools we have

1070
00:41:51,416 --> 00:41:54,596 A:middle
and show you how you can debug
profile Metal applications

1071
00:41:54,596 --> 00:41:55,976 A:middle
in Xcode, so Serhat.

1072
00:41:56,516 --> 00:42:03,566 A:middle
[ Applause ]

1073

1074
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1075
00:41:56,516 --> 00:42:03,566 A:middle
[ Applause ]

1076
00:42:04,066 --> 00:42:05,956 A:middle
>> Well thank you Aaftab
and hello everyone.

1077
00:42:07,086 --> 00:42:09,846 A:middle
Now I'm going to show off the
great developer tools we have

1078
00:42:10,286 --> 00:42:12,106 A:middle
in Xcode for your Metal apps.

1079
00:42:12,956 --> 00:42:15,316 A:middle
We'll be focusing
on some combinations

1080
00:42:15,406 --> 00:42:19,426 A:middle
such as state setup, shadow
completion, and performance,

1081
00:42:20,046 --> 00:42:22,866 A:middle
and how you can use the tools
to address these issues.

1082
00:42:24,076 --> 00:42:28,166 A:middle
So I have the same app that
Gokhan showed you earlier here.

1083
00:42:28,646 --> 00:42:31,576 A:middle
The shadow buffer
pass has been modified

1084
00:42:31,576 --> 00:42:34,236 A:middle
to use percentage closer
filtering for softer shadows,

1085
00:42:34,236 --> 00:42:37,226 A:middle
but my app has a few issues
that I'm going to fix live.

1086
00:42:38,166 --> 00:42:41,086 A:middle
So let's go ahead and run it.

1087
00:42:41,336 --> 00:42:44,776 A:middle
Ok as you can see,
I've got some compilers

1088
00:42:44,996 --> 00:42:49,266 A:middle
and Xcode is pointing right
here at my G-buffer shader code.

1089
00:42:49,786 --> 00:42:52,506 A:middle
So one of the great things
with Metal is its support

1090
00:42:52,506 --> 00:42:54,946 A:middle
for pre-compiled shaders
right here in Xcode.

1091
00:42:55,626 --> 00:42:59,496 A:middle
So in addition to the improved
initialization time for my app

1092
00:42:59,496 --> 00:43:03,576 A:middle
and other benefits, I also
get to see the compilers

1093

1094
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1095
00:42:59,496 --> 00:43:03,576 A:middle
and other benefits, I also
get to see the compilers

1096
00:43:03,576 --> 00:43:06,296 A:middle
and warnings right here
in Xcode at build time

1097
00:43:06,436 --> 00:43:07,356 A:middle
as opposed to run time.

1098
00:43:08,286 --> 00:43:09,926 A:middle
Let's go in and fix
this real quick.

1099
00:43:10,926 --> 00:43:15,566 A:middle
Let's define usable
variables and launch the app.

1100
00:43:15,956 --> 00:43:19,226 A:middle
Now you can imagine this offers
a much more productive workflow

1101
00:43:19,226 --> 00:43:20,286 A:middle
for shader development.

1102
00:43:21,366 --> 00:43:23,666 A:middle
Also using it is pretty
easy, all you have

1103
00:43:23,666 --> 00:43:26,026 A:middle
to do is you add your
dot mil shader files,

1104
00:43:26,026 --> 00:43:30,096 A:middle
your Xcode project, and
Xcode takes care of the rest.

1105
00:43:30,096 --> 00:43:32,996 A:middle
Ok so my app is running now,
but there's something wrong

1106
00:43:32,996 --> 00:43:33,926 A:middle
with what I'm rendering.

1107
00:43:34,536 --> 00:43:37,076 A:middle
Now I'm going to take a
frame capture and bring

1108
00:43:37,076 --> 00:43:39,696 A:middle
up the frame developer so that
you can see the issue as well

1109
00:43:39,696 --> 00:43:42,666 A:middle
and to do that, I'm going to
click on this camera icon here

1110
00:43:42,666 --> 00:43:45,246 A:middle
in the Debug bar and
trigger a capture.

1111
00:43:46,396 --> 00:43:47,676 A:middle
When I trigger a capture,

1112
00:43:48,036 --> 00:43:50,856 A:middle
the frame debugger harvests
all the Metal commands

1113
00:43:50,856 --> 00:43:54,726 A:middle
that your application
uses in the frame along

1114
00:43:54,726 --> 00:43:57,056 A:middle
with all the other
resources that it uses

1115
00:43:57,056 --> 00:43:59,326 A:middle
as buffers, textures
and shaders.

1116
00:43:59,786 --> 00:44:03,146 A:middle
With these we can reconstruct
the frame and you can replay

1117

1118
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1119
00:43:59,786 --> 00:44:03,146 A:middle
With these we can reconstruct
the frame and you can replay

1120
00:44:03,146 --> 00:44:05,606 A:middle
to any particular Metal
command that we choose.

1121
00:44:06,306 --> 00:44:08,106 A:middle
So this is what I was seeing

1122
00:44:08,406 --> 00:44:10,816 A:middle
and you can see my theme
is completely in shadow

1123
00:44:12,106 --> 00:44:13,676 A:middle
and I'm missing my
directional light.

1124
00:44:14,356 --> 00:44:17,326 A:middle
So let's use the frame debugger
to figure out the problem.

1125
00:44:18,576 --> 00:44:21,336 A:middle
Well the first thing
I want to do is I want

1126
00:44:21,336 --> 00:44:23,486 A:middle
to check my commands and make
sure everything is in order.

1127
00:44:24,246 --> 00:44:26,726 A:middle
For that, I'm going to use
the debug navigator here

1128
00:44:26,726 --> 00:44:28,616 A:middle
on the left-hand side
of the Xcode window.

1129
00:44:29,836 --> 00:44:32,756 A:middle
This is where the debugger
shows the old Metal commands

1130
00:44:33,636 --> 00:44:34,986 A:middle
that were executing
in the frame.

1131
00:44:35,596 --> 00:44:38,346 A:middle
You can see that it also
reflects the natural hierarchy

1132
00:44:38,346 --> 00:44:40,036 A:middle
of your command encoders

1133
00:44:40,036 --> 00:44:43,086 A:middle
within your command buffers
that's making it a lot easier

1134
00:44:43,086 --> 00:44:44,256 A:middle
for you to navigate your frame.

1135
00:44:45,436 --> 00:44:48,336 A:middle
Well one thing to keep in mind
here though is the order you see

1136
00:44:48,336 --> 00:44:52,136 A:middle
here is the order that the
GPU executes these commands

1137
00:44:52,136 --> 00:44:53,796 A:middle
so it's a bit different
than CPU debugging.

1138
00:44:54,116 --> 00:44:57,906 A:middle
You can also see that most

1139
00:44:57,906 --> 00:45:00,046 A:middle
of my objects here have
human readable names,

1140

1141
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1142
00:44:57,906 --> 00:45:00,046 A:middle
of my objects here have
human readable names,

1143
00:45:00,046 --> 00:45:01,586 A:middle
not just draw pointer values.

1144
00:45:02,346 --> 00:45:05,946 A:middle
Metal class has a label
property that lets you set this

1145
00:45:06,026 --> 00:45:08,076 A:middle
and I highly recommend
taking advantage of it

1146
00:45:08,076 --> 00:45:09,666 A:middle
as it's an aid in debugging.

1147
00:45:11,136 --> 00:45:12,396 A:middle
Within the encoders,

1148
00:45:13,116 --> 00:45:16,596 A:middle
I can further annotate my
command stream using debug

1149
00:45:16,596 --> 00:45:19,556 A:middle
groups shown in the navigator
as these folder icons.

1150
00:45:20,996 --> 00:45:25,646 A:middle
Well I can do this by using
the push and pop debug APIs

1151
00:45:25,646 --> 00:45:28,196 A:middle
and the debug groups are great

1152
00:45:28,196 --> 00:45:30,866 A:middle
for bracketing related commands
together here in the navigator.

1153
00:45:31,556 --> 00:45:34,116 A:middle
Now let's investigate the
G-buffer pass and figure

1154
00:45:34,116 --> 00:45:35,286 A:middle
out what's wrong
with the shadows.

1155
00:45:35,286 --> 00:45:38,016 A:middle
I'm going to click on
this structure debug group

1156
00:45:38,066 --> 00:45:41,796 A:middle
to navigate there; there you go.

1157
00:45:42,016 --> 00:45:46,256 A:middle
And as I navigate my frame,
Xcode main editor area is going

1158
00:45:46,256 --> 00:45:49,016 A:middle
to update and show me
all the attachments

1159
00:45:49,016 --> 00:45:50,066 A:middle
for the current framebuffer.

1160
00:45:50,686 --> 00:45:53,846 A:middle
The assistant editor is
where I see all my textures,

1161
00:45:54,146 --> 00:45:55,766 A:middle
buffers, and functions.

1162
00:45:56,576 --> 00:45:59,456 A:middle
Currently sits in bound GPU
objects so it's only going

1163
00:45:59,456 --> 00:46:01,216 A:middle
to show me the objects
that are bound

1164

1165
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1166
00:45:59,456 --> 00:46:01,216 A:middle
to show me the objects
that are bound

1167
00:46:01,216 --> 00:46:03,006 A:middle
to the current command encoder.

1168
00:46:03,686 --> 00:46:07,536 A:middle
All right, so I can see that my
debuffer attachments look more

1169
00:46:07,536 --> 00:46:08,876 A:middle
or less correct except
for the color.

1170
00:46:09,516 --> 00:46:11,186 A:middle
But if I look at the assistant,

1171
00:46:12,006 --> 00:46:14,376 A:middle
I see that my shadow
texture bound

1172
00:46:14,376 --> 00:46:16,076 A:middle
to my fragment shader
here labeled

1173
00:46:16,076 --> 00:46:17,056 A:middle
as "shadow" is all black.

1174
00:46:18,176 --> 00:46:22,216 A:middle
So that explains why my scene
was completely in shadow,

1175
00:46:22,296 --> 00:46:24,756 A:middle
but it also means that my shadow
buffer passes aren't working

1176
00:46:24,756 --> 00:46:28,876 A:middle
properly so let's just go there
and investigate so I'm going

1177
00:46:28,876 --> 00:46:32,276 A:middle
to just expand this and
click on the encoder itself.

1178
00:46:33,376 --> 00:46:35,566 A:middle
Now looking at this
I can see right away

1179
00:46:35,736 --> 00:46:37,096 A:middle
that the depth attachment

1180
00:46:37,096 --> 00:46:39,236 A:middle
for this pass isn't
cleared when it starts.

1181
00:46:40,446 --> 00:46:41,886 A:middle
As Gokhan explained earlier,

1182
00:46:41,886 --> 00:46:44,346 A:middle
you control your
framebuffer attachment clears

1183
00:46:44,346 --> 00:46:46,636 A:middle
with the load action
property of the attachment.

1184
00:46:48,536 --> 00:46:52,096 A:middle
Now not only that, but this
don't look like it was rendered

1185
00:46:52,096 --> 00:46:55,296 A:middle
from the point of light either
but if I step through my frame

1186
00:46:55,596 --> 00:46:58,796 A:middle
to see my geometry,
that looks proper.

1187

1188
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1189
00:47:00,036 --> 00:47:03,646 A:middle
So let's look at the
framebuffer state and figure

1190
00:47:03,646 --> 00:47:04,616 A:middle
out what the problem is there.

1191
00:47:05,226 --> 00:47:06,676 A:middle
I can investigate this state

1192
00:47:06,676 --> 00:47:09,236 A:middle
of "any Metal object
using the variables view,"

1193
00:47:09,236 --> 00:47:10,016 A:middle
here at the bottom.

1194
00:47:10,056 --> 00:47:11,956 A:middle
I'll expand that a
little bit [inaudible].

1195
00:47:11,956 --> 00:47:16,786 A:middle
On the right-hand side, I have
a list of all my Metal objects.

1196
00:47:17,276 --> 00:47:20,216 A:middle
But I like to use the Auto
View you see on the left.

1197
00:47:20,216 --> 00:47:23,336 A:middle
This is where you see all the
relevant objects and their state

1198
00:47:23,766 --> 00:47:25,816 A:middle
for the current selected
command only.

1199
00:47:26,506 --> 00:47:28,256 A:middle
So I know what I'm looking for.

1200
00:47:29,136 --> 00:47:30,596 A:middle
My framebuffer state
is going to be

1201
00:47:30,596 --> 00:47:33,176 A:middle
under the RenderCommandEncoder
so I'm going to disclose that

1202
00:47:33,176 --> 00:47:35,366 A:middle
and search for framebuffer.

1203
00:47:35,886 --> 00:47:40,646 A:middle
And yeah, as I suspected, my
load action is not set to clear.

1204
00:47:40,646 --> 00:47:44,966 A:middle
And not only that, the attached
texture here is actually depth;

1205
00:47:45,116 --> 00:47:47,556 A:middle
the texture I was looking at
earlier was labeled "shadow."

1206
00:47:48,686 --> 00:47:51,946 A:middle
Now if I disclose my
frame reference setup

1207
00:47:51,946 --> 00:47:52,946 A:middle
that I prepared earlier,

1208
00:47:52,946 --> 00:47:56,236 A:middle
I can see that I already
have a shadow frame buffer

1209
00:47:56,236 --> 00:47:58,386 A:middle
but I'm using debug
framebuffer here.

1210
00:47:58,386 --> 00:48:01,836 A:middle
So that explains why I
was getting a blank shadow

1211

1212
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1213
00:47:58,386 --> 00:48:01,836 A:middle
So that explains why I
was getting a blank shadow

1214
00:48:01,836 --> 00:48:02,466 A:middle
buffer texture.

1215
00:48:02,846 --> 00:48:06,386 A:middle
I can quickly fix this by
using the debug navigator

1216
00:48:06,386 --> 00:48:07,766 A:middle
to take me straight
to the problem.

1217
00:48:08,666 --> 00:48:12,296 A:middle
And I can do that by going
back to the navigator.

1218
00:48:13,006 --> 00:48:14,796 A:middle
Now you setup your framebuffer

1219
00:48:14,796 --> 00:48:16,516 A:middle
when you're creating your
RenderCommandEncoder.

1220
00:48:16,676 --> 00:48:18,616 A:middle
I can disclose the back-trace

1221
00:48:19,106 --> 00:48:21,026 A:middle
where I create the
RenderCommandEncoder and use

1222
00:48:21,026 --> 00:48:23,306 A:middle
that to jump straight
to the source.

1223
00:48:24,236 --> 00:48:25,936 A:middle
So let me go ahead and
fix this real quick.

1224
00:48:29,756 --> 00:48:30,886 A:middle
It should be shadow.

1225
00:48:31,026 --> 00:48:33,956 A:middle
I like to stop my
app and relaunch it

1226
00:48:34,926 --> 00:48:36,636 A:middle
and make sure everything
is running properly.

1227
00:48:37,516 --> 00:48:43,086 A:middle
[ Pause ]

1228
00:48:43,586 --> 00:48:47,686 A:middle
All right, so my theme
looks great now but looking

1229
00:48:47,686 --> 00:48:49,466 A:middle
at the frames per
second tray here,

1230
00:48:50,216 --> 00:48:52,216 A:middle
I can see that I'm not really
getting the performance

1231
00:48:52,216 --> 00:48:52,846 A:middle
I expect.

1232
00:48:52,846 --> 00:48:55,006 A:middle
I'm going to click
on this tray to bring

1233
00:48:55,006 --> 00:48:57,476 A:middle
up the graphics performance
report.

1234
00:48:58,846 --> 00:49:02,746 A:middle
Now I'm getting about
35ish frames per second;

1235

1236
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1237
00:48:58,846 --> 00:49:02,746 A:middle
Now I'm getting about
35ish frames per second;

1238
00:49:02,746 --> 00:49:04,036 A:middle
I was getting 60 earlier.

1239
00:49:05,066 --> 00:49:08,366 A:middle
Now looking at the report, I can
tell my GPU is heavily utilized

1240
00:49:08,366 --> 00:49:10,176 A:middle
with most of the work
coming from the render

1241
00:49:10,216 --> 00:49:11,736 A:middle
or the fragment shader stage.

1242
00:49:13,086 --> 00:49:14,836 A:middle
Ok, to get a more
detailed picture,

1243
00:49:14,836 --> 00:49:16,796 A:middle
let's take another frame capture

1244
00:49:17,196 --> 00:49:19,626 A:middle
and see what the Shader
Profiler has to say about it.

1245
00:49:20,106 --> 00:49:23,556 A:middle
And the Shader Profiler
is at Sampling Profiler.

1246
00:49:24,036 --> 00:49:25,216 A:middle
That's going to automatically

1247
00:49:25,216 --> 00:49:27,116 A:middle
and repeatedly run
all my shaders

1248
00:49:27,116 --> 00:49:28,146 A:middle
in my frame for sampling.

1249
00:49:28,846 --> 00:49:31,626 A:middle
This may take a bit longer
for a more complicated scene,

1250
00:49:31,626 --> 00:49:34,266 A:middle
but that small amount of time
is well worth the investment

1251
00:49:34,266 --> 00:49:36,886 A:middle
as it offers an in depth
performance analysis

1252
00:49:36,886 --> 00:49:38,716 A:middle
that I otherwise
wouldn't be able to get.

1253
00:49:40,046 --> 00:49:41,936 A:middle
Ok, when the Shader
Profiler is done,

1254
00:49:42,546 --> 00:49:45,906 A:middle
I'm going to get this
program performance table here

1255
00:49:45,906 --> 00:49:46,466 A:middle
in the report.

1256
00:49:46,996 --> 00:49:51,276 A:middle
In this table, I get a breakdown
of the performance cost

1257
00:49:51,276 --> 00:49:54,576 A:middle
of all my render
pipelines in the frame along

1258
00:49:54,576 --> 00:49:57,826 A:middle
with all the draw calls
that use these pipelines;

1259
00:49:57,826 --> 00:49:59,366 A:middle
again close so you
don't see that.

1260

1261
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1262
00:50:00,466 --> 00:50:03,366 A:middle
Another great way to look
at this is to again go back

1263
00:50:03,366 --> 00:50:06,986 A:middle
to the navigator and
switch it to use the

1264
00:50:06,986 --> 00:50:08,236 A:middle
"View Frame by Program" mode.

1265
00:50:09,696 --> 00:50:11,206 A:middle
Now the nice thing about this is

1266
00:50:11,206 --> 00:50:14,676 A:middle
that I can both navigate my
frame and see my shader profiler

1267
00:50:14,716 --> 00:50:16,096 A:middle
and results at the same time.

1268
00:50:16,836 --> 00:50:20,236 A:middle
So let's look at the
most expensive draw call

1269
00:50:20,346 --> 00:50:22,426 A:middle
and the most expensive
pipeline real quick.

1270
00:50:22,916 --> 00:50:27,586 A:middle
I'm going to hide my
draw call highlight

1271
00:50:27,586 --> 00:50:29,986 A:middle
so that I can see my
attachments better.

1272
00:50:30,396 --> 00:50:32,036 A:middle
And in the Assistant,
I'm going to bring

1273
00:50:32,036 --> 00:50:34,546 A:middle
up that costly fragment shader,
so that I can look at this

1274
00:50:34,546 --> 00:50:36,036 A:middle
for us, make some
more room here.

1275
00:50:36,596 --> 00:50:36,686 A:middle
Oops.

1276
00:50:39,176 --> 00:50:44,346 A:middle
Ok, now as I look at
my code, I can see line

1277
00:50:44,346 --> 00:50:47,866 A:middle
by line profiling data
right alongside my code here

1278
00:50:47,866 --> 00:50:48,386 A:middle
in the editor.

1279
00:50:48,816 --> 00:50:50,336 A:middle
And if I keep scrolling down,

1280
00:50:51,156 --> 00:50:54,986 A:middle
I see that the most expensive
parts of my shader by far is

1281
00:50:54,986 --> 00:50:57,176 A:middle
where I'm doing the
shadow sampling loop.

1282
00:50:58,076 --> 00:50:59,636 A:middle
So this many samples
is an overkill.

1283
00:50:59,636 --> 00:51:04,596 A:middle
Let's reduce it to just a 2 by
2 grid and Save; Command 'S'.

1284

1285
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1286
00:50:59,636 --> 00:51:04,596 A:middle
Let's reduce it to just a 2 by
2 grid and Save; Command 'S'.

1287
00:51:05,366 --> 00:51:08,146 A:middle
Now when I do that, my shader
is going to get recompiled

1288
00:51:08,706 --> 00:51:10,656 A:middle
and my changes will
take effect immediately.

1289
00:51:11,776 --> 00:51:14,436 A:middle
And once the shader
profiler is done analyzing,

1290
00:51:14,576 --> 00:51:17,586 A:middle
I'm going to get updated
performance numbers as well.

1291
00:51:18,906 --> 00:51:22,006 A:middle
And I can see that my
attachments look more

1292
00:51:22,006 --> 00:51:23,416 A:middle
or less unaffected; that's good.

1293
00:51:23,796 --> 00:51:26,706 A:middle
And now I'm spending far less
time than the expensive part

1294
00:51:26,706 --> 00:51:28,576 A:middle
of my shader source
and that's great.

1295
00:51:28,846 --> 00:51:33,856 A:middle
And if I scroll all the way to
the end, this is my end result.

1296
00:51:34,776 --> 00:51:38,126 A:middle
Now I can go ahead
and resume my app

1297
00:51:38,386 --> 00:51:40,596 A:middle
and I see a nice smooth
60 frames per second.

1298
00:51:40,986 --> 00:51:41,436 A:middle
Excellent.

1299
00:51:42,066 --> 00:51:45,006 A:middle
With that, my work here
is done and it's time

1300
00:51:45,006 --> 00:51:46,366 A:middle
to leave the stage
back to Aaftab.

1301
00:51:46,366 --> 00:51:46,926 A:middle
Thank you.

1302
00:51:47,516 --> 00:51:53,936 A:middle
[ Applause ]

1303
00:51:54,436 --> 00:51:56,066 A:middle
All right, so let's
summarize, ok?

1304
00:51:56,486 --> 00:52:01,586 A:middle
So Gokhan you know took you
deeper into how Metal works.

1305

1306
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1307
00:51:56,486 --> 00:52:01,586 A:middle
So Gokhan you know took you
deeper into how Metal works.

1308
00:52:02,056 --> 00:52:05,336 A:middle
You know we talked about how
you structure the application.

1309
00:52:05,336 --> 00:52:07,706 A:middle
The descriptors and
state objects;

1310
00:52:07,706 --> 00:52:10,576 A:middle
how do you create them
and when to do what.

1311
00:52:10,576 --> 00:52:12,996 A:middle
Like for example; things
you want to do once

1312
00:52:13,436 --> 00:52:15,656 A:middle
like creating your
command queue.

1313
00:52:16,276 --> 00:52:18,296 A:middle
Things you need to
create whenever you need

1314
00:52:18,296 --> 00:52:22,026 A:middle
to like resources, and things
you must create every frame

1315
00:52:22,156 --> 00:52:24,206 A:middle
and every pass, right?

1316
00:52:24,206 --> 00:52:29,946 A:middle
And he showed you how you can do
multi-pass encoding with Metal.

1317
00:52:30,546 --> 00:52:34,286 A:middle
Then I gave you a
small, brief teaser

1318
00:52:34,286 --> 00:52:36,046 A:middle
into data parellel
computing, ok?

1319
00:52:36,196 --> 00:52:40,086 A:middle
And then finally we showed you
the amazing tools that we have

1320
00:52:40,086 --> 00:52:42,846 A:middle
in Metal that you can use to
write amazing applications.

1321
00:52:44,026 --> 00:52:44,766 A:middle
That was it.

1322
00:52:45,256 --> 00:52:49,186 A:middle
So for more information,
any questions, you know,

1323
00:52:49,186 --> 00:52:51,756 A:middle
Philip Iliescu [phonetic] and
Alan Shafer are evangelists;

1324
00:52:51,756 --> 00:52:53,076 A:middle
you know their emails are there.

1325
00:52:53,686 --> 00:52:55,416 A:middle
And documentation
is on our website.

1326
00:52:55,416 --> 00:52:59,696 A:middle
You know you can post questions,
emails, on the developer forums.

1327

1328
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1329
00:53:00,916 --> 00:53:03,056 A:middle
The first 2 sessions that
happened this morning,

1330
00:53:03,056 --> 00:53:04,266 A:middle
so these are the ones.

1331
00:53:04,886 --> 00:53:05,466 A:middle
Thank you guys.

1332
00:53:06,508 --> 00:53:08,508 A:middle
[ Applause ]

1333
