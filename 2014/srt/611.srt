X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:12,016 --> 00:00:13,736 A:middle
[ Applause ]

2
00:00:13,736 --> 00:00:14,316 A:middle
>> Thank you.

3
00:00:15,866 --> 00:00:16,286 A:middle
Thank you.

4
00:00:16,286 --> 00:00:17,586 A:middle
Good morning, good morning.

5
00:00:17,586 --> 00:00:18,216 A:middle
And welcome.

6
00:00:18,896 --> 00:00:21,986 A:middle
You know, I love games.

7
00:00:22,766 --> 00:00:24,526 A:middle
I've been playing
them my whole life.

8
00:00:24,526 --> 00:00:26,116 A:middle
I love making games.

9
00:00:26,646 --> 00:00:28,156 A:middle
I love teaching about games.

10
00:00:28,756 --> 00:00:30,996 A:middle
And I'm really excited
to talk to you today

11
00:00:31,226 --> 00:00:33,246 A:middle
about designing for
game controllers.

12
00:00:34,166 --> 00:00:37,966 A:middle
My name is JJ Cwik, and
I'm a software engineer

13
00:00:38,146 --> 00:00:39,746 A:middle
on the Game Play Technology Team

14
00:00:39,996 --> 00:00:41,736 A:middle
or on the Game Technology
Team at Apple.

15
00:00:41,736 --> 00:00:45,766 A:middle
Now, let me poll the audience.

16
00:00:46,246 --> 00:00:49,276 A:middle
How many of you have already
integrated game controllers

17
00:00:49,446 --> 00:00:50,256 A:middle
into a game before?

18
00:00:50,956 --> 00:00:52,906 A:middle
All right, a few.

19
00:00:52,906 --> 00:00:55,606 A:middle
Great. And for how many

20
00:00:55,606 --> 00:00:58,246 A:middle
of you will this be your first
talk on game controllers?

21
00:00:59,996 --> 00:01:01,216 A:middle
Good. Large majority.

22

23
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

24
00:00:59,996 --> 00:01:01,216 A:middle
Good. Large majority.

25
00:01:01,246 --> 00:01:02,456 A:middle
Great. Wonderful.

26
00:01:02,456 --> 00:01:04,245 A:middle
So, this is going to be fun.

27
00:01:04,245 --> 00:01:04,965 A:middle
Let's get started.

28
00:01:06,206 --> 00:01:07,766 A:middle
When I talk about
game controllers,

29
00:01:08,236 --> 00:01:11,496 A:middle
what Apple is delivering
is in two parts.

30
00:01:12,646 --> 00:01:15,836 A:middle
The first part is the
MFi Specification.

31
00:01:16,556 --> 00:01:19,086 A:middle
Now, this is for third-party
controller developers.

32
00:01:19,606 --> 00:01:22,866 A:middle
It defines all the hardware
requirements of the controllers.

33
00:01:23,336 --> 00:01:26,076 A:middle
Things like: the control
layouts on the gamepad itself;

34
00:01:26,666 --> 00:01:28,546 A:middle
how the buttons feel
when you press them;

35
00:01:29,836 --> 00:01:32,116 A:middle
and the communication
protocols between the device.

36
00:01:32,706 --> 00:01:36,926 A:middle
And the goal with this
program is to give confidence

37
00:01:36,926 --> 00:01:40,096 A:middle
to consumers that when they
purchase a game controller

38
00:01:40,316 --> 00:01:44,516 A:middle
that has one of these icons
on the box, they're assured

39
00:01:44,516 --> 00:01:47,576 A:middle
that their game controller
is going to work

40
00:01:47,576 --> 00:01:50,606 A:middle
with all your games that support
the game controller framework.

41
00:01:51,306 --> 00:01:54,166 A:middle
So that's the first part,
the MFi Specification.

42
00:01:55,616 --> 00:01:58,706 A:middle
The second part is the
game controller framework.

43
00:01:59,386 --> 00:02:01,036 A:middle
This is the software
side of things,

44

45
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

46
00:01:59,386 --> 00:02:01,036 A:middle
This is the software
side of things,

47
00:02:01,446 --> 00:02:03,706 A:middle
what you as game
developers will be using

48
00:02:03,906 --> 00:02:05,996 A:middle
to integrate game
controllers into your games.

49
00:02:07,246 --> 00:02:10,645 A:middle
This is an iOS and OS X
cross-platform framework.

50
00:02:11,196 --> 00:02:13,196 A:middle
So code that you write
for game controllers

51
00:02:13,196 --> 00:02:15,236 A:middle
in one is directly
usable in the other.

52
00:02:15,366 --> 00:02:19,256 A:middle
And it features a simple
API, which allows you

53
00:02:19,256 --> 00:02:22,896 A:middle
to find controllers and read the
input off of those controllers.

54
00:02:23,746 --> 00:02:29,126 A:middle
And the goal with this side of
things with the framework is

55
00:02:29,126 --> 00:02:32,506 A:middle
to give you one API
so that you can focus

56
00:02:32,506 --> 00:02:33,666 A:middle
on developing your game,

57
00:02:34,196 --> 00:02:37,276 A:middle
integrating game controllers
really smoothly and not have

58
00:02:37,336 --> 00:02:39,986 A:middle
to worry about little
variations in all sorts

59
00:02:39,986 --> 00:02:41,186 A:middle
of different controllers.

60
00:02:41,766 --> 00:02:45,616 A:middle
So that's the second part,
the game controller framework.

61
00:02:46,526 --> 00:02:48,696 A:middle
Now, what kind of
controllers are available?

62
00:02:50,026 --> 00:02:51,006 A:middle
There are three types.

63
00:02:51,596 --> 00:02:54,526 A:middle
The first type is a form-fitting
standard controller.

64
00:02:55,406 --> 00:02:57,426 A:middle
And by form-fitting, we mean

65
00:02:57,426 --> 00:02:59,766 A:middle
that the controller
encases the device.

66

67
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

68
00:03:01,436 --> 00:03:05,246 A:middle
Therefore, the touch screen is
easily accessible while they're

69
00:03:05,246 --> 00:03:06,226 A:middle
playing with the game pad,

70
00:03:06,366 --> 00:03:08,846 A:middle
and so is motion
control of the device.

71
00:03:09,926 --> 00:03:13,256 A:middle
And by "standard," we're
referring to the controls layout

72
00:03:13,336 --> 00:03:17,066 A:middle
on the gamepad, specifically
that there's a D-pad,

73
00:03:17,146 --> 00:03:21,726 A:middle
that there are four face
buttons (A, B, X and Y,

74
00:03:21,726 --> 00:03:24,016 A:middle
always in these colors
and in these locations)

75
00:03:24,816 --> 00:03:27,916 A:middle
and two shoulder
buttons (L and R).

76
00:03:28,426 --> 00:03:29,816 A:middle
So that's the first
controller type.

77
00:03:30,576 --> 00:03:34,066 A:middle
The second controller
is the form-fitting

78
00:03:34,066 --> 00:03:35,136 A:middle
extended controller.

79
00:03:35,596 --> 00:03:37,056 A:middle
So it too is form-fitting.

80
00:03:38,086 --> 00:03:41,636 A:middle
And the extended control layout
has all the same controls

81
00:03:41,966 --> 00:03:43,136 A:middle
of the standard controller,

82
00:03:43,906 --> 00:03:49,086 A:middle
but it adds to it two
thumbsticks and two triggers.

83
00:03:49,586 --> 00:03:52,636 A:middle
That's the second
controller type.

84
00:03:53,536 --> 00:03:57,816 A:middle
The third controller type is the
standalone extended controller.

85
00:03:58,466 --> 00:04:03,496 A:middle
And by standalone, we mean
the controller does not encase

86

87
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

88
00:03:58,466 --> 00:04:03,496 A:middle
And by standalone, we mean
the controller does not encase

89
00:04:03,546 --> 00:04:04,166 A:middle
the device.

90
00:04:05,176 --> 00:04:07,766 A:middle
So the touch screen is
not easily accessible.

91
00:04:08,156 --> 00:04:09,986 A:middle
Motion control is not an option.

92
00:04:10,646 --> 00:04:13,276 A:middle
You're only getting input
from the controller itself.

93
00:04:14,386 --> 00:04:17,146 A:middle
And again, this has the exact
same extended control layout

94
00:04:17,146 --> 00:04:18,505 A:middle
as the previous extended
controller.

95
00:04:19,185 --> 00:04:22,506 A:middle
So that's an overview.

96
00:04:23,366 --> 00:04:26,096 A:middle
Now, I'm going to focus
the rest of my talk

97
00:04:26,136 --> 00:04:28,896 A:middle
on the game controller
framework itself

98
00:04:28,946 --> 00:04:30,946 A:middle
and how you use the framework

99
00:04:31,266 --> 00:04:32,956 A:middle
to integrate game
controllers into your games.

100
00:04:33,476 --> 00:04:36,796 A:middle
Specifically, we're going to
find out inside your game,

101
00:04:36,896 --> 00:04:37,586 A:middle
how do you know

102
00:04:37,876 --> 00:04:40,216 A:middle
which controllers are
available for your game to use?

103
00:04:40,756 --> 00:04:42,156 A:middle
We're going to talk about
finding controllers.

104
00:04:43,036 --> 00:04:45,466 A:middle
I'm also going to talk about
the various inputs found

105
00:04:45,466 --> 00:04:49,246 A:middle
on controllers, like the buttons
and the D-pads and how those map

106
00:04:49,356 --> 00:04:51,846 A:middle
in software, and how
you can read whether

107
00:04:51,846 --> 00:04:54,056 A:middle
or not a player is pressing
the A button or the D-pad.

108
00:04:55,346 --> 00:04:57,606 A:middle
I'm also going to
talk about what's new.

109
00:04:58,166 --> 00:04:59,576 A:middle
What have we been
working on this past year?

110
00:04:59,576 --> 00:05:01,226 A:middle
What are we introducing at iOS 8

111

112
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

113
00:04:59,576 --> 00:05:01,226 A:middle
What are we introducing at iOS 8

114
00:05:01,226 --> 00:05:02,686 A:middle
and with respect to
game controllers?

115
00:05:03,436 --> 00:05:05,376 A:middle
One really cool thing that
I'm excited to tell you

116
00:05:05,376 --> 00:05:08,246 A:middle
about is controller forwarding.

117
00:05:09,166 --> 00:05:14,096 A:middle
In a nutshell, this is
a way for a controller

118
00:05:14,096 --> 00:05:17,696 A:middle
with a snapped-in iPhone to be
used as a wireless controller

119
00:05:17,696 --> 00:05:19,546 A:middle
to control the game
play experience

120
00:05:19,606 --> 00:05:23,746 A:middle
on another device, like an iPad.

121
00:05:23,926 --> 00:05:25,356 A:middle
And throughout the talk,

122
00:05:25,406 --> 00:05:30,796 A:middle
I'm going to be giving a heavy
emphasis to design guidance.

123
00:05:31,346 --> 00:05:33,106 A:middle
It's actually fairly
straightforward

124
00:05:33,106 --> 00:05:35,376 A:middle
to integrate game
controllers into your game.

125
00:05:36,256 --> 00:05:38,996 A:middle
And it's going to be
really instructive to talk

126
00:05:38,996 --> 00:05:41,186 A:middle
about design guidance
based on things

127
00:05:41,186 --> 00:05:43,436 A:middle
that we've seen this past year.

128
00:05:44,046 --> 00:05:47,716 A:middle
And I'd really like
to focus especially

129
00:05:48,006 --> 00:05:51,466 A:middle
on an Apple Design Award winning
game this year, Leo's Fortune,

130
00:05:52,326 --> 00:05:55,566 A:middle
because it integrates game
controllers really, really well.

131
00:05:55,726 --> 00:05:56,946 A:middle
It's a fantastic integration.

132
00:05:56,946 --> 00:05:57,686 A:middle
And I think it's going

133
00:05:57,686 --> 00:06:02,226 A:middle
to be really instructive
for all of us.

134

135
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

136
00:05:57,686 --> 00:06:02,226 A:middle
to be really instructive
for all of us.

137
00:06:02,486 --> 00:06:04,946 A:middle
So, let's talk about
finding controllers.

138
00:06:05,066 --> 00:06:08,116 A:middle
How do I know which controllers
are available to my game?

139
00:06:08,756 --> 00:06:13,106 A:middle
The first thing you're going
to want know is the main class

140
00:06:13,156 --> 00:06:14,276 A:middle
that you're going
to be interacting

141
00:06:14,276 --> 00:06:16,316 A:middle
with in the game
controller framework is

142
00:06:16,316 --> 00:06:17,486 A:middle
called GCController.

143
00:06:17,486 --> 00:06:20,946 A:middle
Now, this is the same class
for all controller types.

144
00:06:21,826 --> 00:06:24,116 A:middle
And it allows you to do a
few things, like finding

145
00:06:24,116 --> 00:06:27,016 A:middle
which controllers are available,
reading the inputs off

146
00:06:27,016 --> 00:06:30,106 A:middle
of the controllers and
additional information

147
00:06:30,106 --> 00:06:32,416 A:middle
about the controller
itself, such as whether

148
00:06:32,416 --> 00:06:35,406 A:middle
or not it's form-fitting, if
it's standard or extended.

149
00:06:36,126 --> 00:06:40,706 A:middle
Now, to find which controllers
are currently connected,

150
00:06:41,616 --> 00:06:44,766 A:middle
call the controllers class
method on GCController.

151
00:06:45,296 --> 00:06:48,026 A:middle
It returns you an array of
currently connected controllers.

152
00:06:48,666 --> 00:06:51,926 A:middle
Or, an empty array if no
controllers are connected.

153
00:06:53,356 --> 00:06:55,066 A:middle
Now, this array starts
off empty.

154
00:06:55,646 --> 00:06:58,036 A:middle
And it's updated as
controllers are added

155
00:06:58,036 --> 00:06:59,256 A:middle
and removed from the system.

156
00:06:59,796 --> 00:07:01,286 A:middle
So whenever you check
this method,

157

158
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

159
00:06:59,796 --> 00:07:01,286 A:middle
So whenever you check
this method,

160
00:07:02,206 --> 00:07:03,856 A:middle
it'll return you the
latest information

161
00:07:03,856 --> 00:07:05,066 A:middle
on what's currently connected.

162
00:07:05,286 --> 00:07:09,736 A:middle
Now let me explain
visually how we're going

163
00:07:09,736 --> 00:07:10,816 A:middle
to structure our code.

164
00:07:11,856 --> 00:07:15,216 A:middle
There are two methods that we're
particularly interested in.

165
00:07:15,686 --> 00:07:18,236 A:middle
"One is application:
didFinishLaunching WithOptions".

166
00:07:18,876 --> 00:07:21,626 A:middle
And the second is a method
you're expected to create.

167
00:07:22,296 --> 00:07:24,406 A:middle
In this case we're calling
it setupControllers.

168
00:07:25,416 --> 00:07:28,696 A:middle
Now setupControllers
is your central method

169
00:07:28,736 --> 00:07:33,076 A:middle
where you track controller
state and take action

170
00:07:33,076 --> 00:07:34,706 A:middle
as appropriate to your game.

171
00:07:35,376 --> 00:07:36,976 A:middle
In there we're going to
check the controllers array.

172
00:07:38,626 --> 00:07:42,946 A:middle
Next, we're going to connect
and disconnect controllers.

173
00:07:42,946 --> 00:07:44,846 A:middle
And we want to find
out specifically

174
00:07:44,846 --> 00:07:46,126 A:middle
when they connect
and disconnect.

175
00:07:46,156 --> 00:07:47,846 A:middle
So we're going to
set up notifications

176
00:07:48,146 --> 00:07:49,976 A:middle
to be notified when
players do this.

177
00:07:51,096 --> 00:07:53,706 A:middle
And importantly,
we're going to --

178
00:07:53,946 --> 00:07:56,176 A:middle
the action we're going to take
whenever a controller connects

179
00:07:56,176 --> 00:07:59,406 A:middle
or disconnects is to call
our setupControllers method.

180

181
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

182
00:08:00,346 --> 00:08:02,656 A:middle
Lastly, we're going to setup --

183
00:08:02,656 --> 00:08:05,206 A:middle
we're going to kick off a
wireless discovery process.

184
00:08:05,696 --> 00:08:08,896 A:middle
And what this does is it
allows those controllers

185
00:08:09,016 --> 00:08:11,496 A:middle
which communicate
wirelessly to pair

186
00:08:11,496 --> 00:08:14,736 A:middle
with your phone right
within your game.

187
00:08:15,086 --> 00:08:16,866 A:middle
So you don't have to exit to --

188
00:08:16,986 --> 00:08:18,666 A:middle
or your players don't
have to exit

189
00:08:18,666 --> 00:08:21,126 A:middle
to the settings screen
in order to do that.

190
00:08:21,886 --> 00:08:23,996 A:middle
And importantly, notice
the cascade effect here.

191
00:08:24,316 --> 00:08:26,116 A:middle
When we kickoff wireless
discovery,

192
00:08:26,596 --> 00:08:28,556 A:middle
whenever controllers
happen to be discovered,

193
00:08:29,616 --> 00:08:31,926 A:middle
connection notifications
are posted,

194
00:08:32,296 --> 00:08:33,686 A:middle
which in turn will cascade down

195
00:08:33,686 --> 00:08:35,155 A:middle
and call our setupControllers
method.

196
00:08:35,655 --> 00:08:36,666 A:middle
So that's the game plan.

197
00:08:36,666 --> 00:08:38,765 A:middle
Let's look at the code
for how to do that.

198
00:08:40,006 --> 00:08:42,596 A:middle
We're within application:
didFinishLaunching WithOptions.

199
00:08:43,006 --> 00:08:46,256 A:middle
And you'll notice the first
thing we do is we call --

200
00:08:46,396 --> 00:08:49,746 A:middle
or we check whether the
GCController class exists.

201
00:08:50,416 --> 00:08:52,686 A:middle
And by extension, what we're
doing here is we're checking

202
00:08:52,686 --> 00:08:55,906 A:middle
whether the game controller
framework exists in the version

203
00:08:55,906 --> 00:08:58,056 A:middle
of the operating system that
your game is running on.

204
00:08:58,936 --> 00:09:00,066 A:middle
This is important for those

205

206
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

207
00:08:58,936 --> 00:09:00,066 A:middle
This is important for those

208
00:09:00,066 --> 00:09:04,926 A:middle
of you whose games support
operating systems earlier

209
00:09:04,926 --> 00:09:08,336 A:middle
than iOS 7 and earlier
than OS X Mavericks.

210
00:09:08,946 --> 00:09:11,466 A:middle
(The operating systems where
the game controller framework

211
00:09:11,466 --> 00:09:12,146 A:middle
was introduced.)

212
00:09:13,846 --> 00:09:16,196 A:middle
Assuming the game
controller framework exists,

213
00:09:16,806 --> 00:09:18,616 A:middle
then we go ahead and register

214
00:09:18,616 --> 00:09:21,276 A:middle
for notifications whenever
controllers connect

215
00:09:21,276 --> 00:09:21,896 A:middle
and disconnect.

216
00:09:22,886 --> 00:09:24,646 A:middle
We do this using the
notification names

217
00:09:24,936 --> 00:09:27,446 A:middle
GCControllerDid
ConnectNotification

218
00:09:27,906 --> 00:09:30,376 A:middle
and GCControllerDid
DisconnectNotification.

219
00:09:30,926 --> 00:09:34,026 A:middle
And you'll notice that in
both of these situations,

220
00:09:34,236 --> 00:09:36,116 A:middle
whenever these notifications
are posted,

221
00:09:36,816 --> 00:09:38,376 A:middle
we're calling setupControllers.

222
00:09:40,856 --> 00:09:44,656 A:middle
Lastly, we call
startWirelessController

223
00:09:44,656 --> 00:09:46,386 A:middle
Discovery WithCompletionHandler.

224
00:09:47,026 --> 00:09:50,306 A:middle
Now, this kicks off
asynchronous scanning

225
00:09:50,686 --> 00:09:52,246 A:middle
of wireless controllers.

226
00:09:52,826 --> 00:09:58,166 A:middle
When the completion handler
is called, the scanning

227
00:09:58,166 --> 00:10:00,066 A:middle
of wireless controllers
has stopped.

228

229
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

230
00:09:58,166 --> 00:10:00,066 A:middle
of wireless controllers
has stopped.

231
00:10:00,746 --> 00:10:04,086 A:middle
And any controllers
that are wireless

232
00:10:04,086 --> 00:10:07,156 A:middle
that have already been
discovered will have already

233
00:10:07,156 --> 00:10:10,206 A:middle
called, or rather, posted
notifications for connection.

234
00:10:10,716 --> 00:10:11,946 A:middle
And by association,

235
00:10:11,946 --> 00:10:14,186 A:middle
setupControllers will
have already been called.

236
00:10:15,386 --> 00:10:18,826 A:middle
So the important takeaway here
is it's completely unnecessary

237
00:10:18,826 --> 00:10:21,076 A:middle
to explicitly call
setupControllers

238
00:10:21,156 --> 00:10:21,936 A:middle
within the handler.

239
00:10:21,936 --> 00:10:26,286 A:middle
Now let's look at our other
method, setupControllers.

240
00:10:27,616 --> 00:10:29,286 A:middle
Here we're checking
the controllers array.

241
00:10:30,386 --> 00:10:33,406 A:middle
And if it's non-empty, we take
action appropriate to our game.

242
00:10:34,046 --> 00:10:35,856 A:middle
So that's it.

243
00:10:35,856 --> 00:10:36,656 A:middle
That's how you find

244
00:10:36,656 --> 00:10:38,606 A:middle
which controllers are
available on your system.

245
00:10:39,596 --> 00:10:42,516 A:middle
Now, I'd like to offer
some design guidance on how

246
00:10:42,516 --> 00:10:45,096 A:middle
to gracefully handle
connections and disconnections.

247
00:10:45,936 --> 00:10:47,946 A:middle
When a player connects
a controller,

248
00:10:49,336 --> 00:10:52,476 A:middle
they're communicating intent
to use that controller

249
00:10:52,476 --> 00:10:54,406 A:middle
as their preferred control
scheme for your game.

250
00:10:55,696 --> 00:10:57,936 A:middle
And your game should
react accordingly.

251
00:10:58,436 --> 00:11:01,606 A:middle
So, specifically, move to
controller-based input.

252

253
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

254
00:10:58,436 --> 00:11:01,606 A:middle
So, specifically, move to
controller-based input.

255
00:11:02,806 --> 00:11:06,156 A:middle
Remove any on-screen
visuals that are virtual,

256
00:11:06,156 --> 00:11:09,746 A:middle
like virtual D-pads and analog
sticks, virtual buttons.

257
00:11:10,296 --> 00:11:13,916 A:middle
Those are now redundant since
the gamepad already has those.

258
00:11:15,336 --> 00:11:17,296 A:middle
Each gamepad also
has a pause button.

259
00:11:17,296 --> 00:11:19,076 A:middle
So even the little
pause button overlay

260
00:11:19,076 --> 00:11:22,246 A:middle
on the screen can be
offloaded from the screen

261
00:11:22,686 --> 00:11:25,166 A:middle
because the game
controller has that.

262
00:11:25,356 --> 00:11:27,906 A:middle
And lastly, you're going to
want to set the playerIndex,

263
00:11:28,306 --> 00:11:29,766 A:middle
which is a property
on the controller.

264
00:11:30,176 --> 00:11:32,496 A:middle
And this will light up the
LEDs on the controller.

265
00:11:32,966 --> 00:11:34,686 A:middle
This gives important
feedback to your player

266
00:11:34,936 --> 00:11:37,196 A:middle
that this game controller
is recognized

267
00:11:37,196 --> 00:11:38,416 A:middle
and being used by your game.

268
00:11:38,946 --> 00:11:42,466 A:middle
And disconnections can happen
for a variety of reasons.

269
00:11:42,466 --> 00:11:44,926 A:middle
Either the player explicitly
disconnects the controller,

270
00:11:45,166 --> 00:11:48,586 A:middle
or maybe for whatever reason,
the connection becomes loose

271
00:11:48,586 --> 00:11:50,546 A:middle
or the batteries run out.

272
00:11:50,546 --> 00:11:53,796 A:middle
In this case, as a
convenience to the players,

273
00:11:53,836 --> 00:11:55,066 A:middle
consider pausing the game play

274
00:11:55,066 --> 00:11:56,406 A:middle
if that's appropriate
for your game.

275
00:11:57,036 --> 00:11:59,506 A:middle
Give them an opportunity
to reconnect or return

276
00:11:59,506 --> 00:12:01,846 A:middle
to regular controls if
that's an appropriate action.

277

278
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

279
00:11:59,506 --> 00:12:01,846 A:middle
to regular controls if
that's an appropriate action.

280
00:12:02,676 --> 00:12:06,686 A:middle
Now, I'd like to focus
in on the player's intent

281
00:12:06,686 --> 00:12:07,436 A:middle
when they connect.

282
00:12:09,276 --> 00:12:11,946 A:middle
Some games that use
tilt-and-touch control,

283
00:12:13,336 --> 00:12:15,676 A:middle
upon entering gameplay,
they present the player

284
00:12:15,676 --> 00:12:17,886 A:middle
with this kind of an
option: "Do you want

285
00:12:17,886 --> 00:12:19,596 A:middle
to use tilt control
or touch control?"

286
00:12:20,226 --> 00:12:24,646 A:middle
And this is a great option for
games to present to players.

287
00:12:26,356 --> 00:12:28,766 A:middle
Until they snap in
a game controller.

288
00:12:30,006 --> 00:12:32,586 A:middle
Now, the player's intent is
to use the game controller.

289
00:12:33,056 --> 00:12:35,956 A:middle
And this kind of a choice
is actually confusing

290
00:12:35,956 --> 00:12:36,626 A:middle
to the players.

291
00:12:37,086 --> 00:12:37,926 A:middle
Does this actually mean

292
00:12:37,926 --> 00:12:39,876 A:middle
that this game doesn't
support game controllers?

293
00:12:40,956 --> 00:12:43,296 A:middle
Or does it mean that my
controller isn't connected

294
00:12:43,296 --> 00:12:44,476 A:middle
properly to my phone?

295
00:12:45,556 --> 00:12:47,016 A:middle
Or if I select one
of these options,

296
00:12:47,016 --> 00:12:49,526 A:middle
will that disable
game controller input?

297
00:12:50,876 --> 00:12:53,326 A:middle
Instead, if you have a
dialog that looks like this

298
00:12:53,326 --> 00:12:55,906 A:middle
in your game, gate it on whether

299
00:12:55,906 --> 00:12:57,686 A:middle
or not a controller is
currently connected.

300
00:12:58,136 --> 00:13:01,366 A:middle
If it is, that is sufficient
intent that the player wishes

301

302
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

303
00:12:58,136 --> 00:13:01,366 A:middle
If it is, that is sufficient
intent that the player wishes

304
00:13:01,366 --> 00:13:02,476 A:middle
to use game controllers.

305
00:13:02,476 --> 00:13:04,126 A:middle
And this kind of a
dialog is unnecessary.

306
00:13:05,946 --> 00:13:09,466 A:middle
Now, another kind of dialog
you might be tempted to put

307
00:13:09,466 --> 00:13:12,266 A:middle
up is one like this:
"Game controller detected.

308
00:13:12,546 --> 00:13:13,366 A:middle
Would you like to use it?

309
00:13:13,366 --> 00:13:13,966 A:middle
Yes or No."

310
00:13:13,966 --> 00:13:16,496 A:middle
And at least we're giving
feedback to the player that,

311
00:13:16,496 --> 00:13:18,926 A:middle
yes, this controller is
connected and recognized.

312
00:13:19,376 --> 00:13:22,906 A:middle
But again, the intent
that the player has

313
00:13:22,906 --> 00:13:24,326 A:middle
when they connect
the controller is

314
00:13:24,326 --> 00:13:25,536 A:middle
that they actually
want to use it.

315
00:13:25,746 --> 00:13:27,856 A:middle
And so such a dialog
is redundant.

316
00:13:28,256 --> 00:13:29,496 A:middle
If you have this
kind of a dialog,

317
00:13:29,706 --> 00:13:31,746 A:middle
you don't actually need it.

318
00:13:31,836 --> 00:13:33,616 A:middle
Just use the controller
if it's available.

319
00:13:34,796 --> 00:13:37,166 A:middle
And as an example of a game
that does this really well,

320
00:13:37,166 --> 00:13:38,856 A:middle
I'd like to look
at Leo's Fortune.

321
00:13:39,436 --> 00:13:41,486 A:middle
Here it is in one of
its touchscreen modes

322
00:13:41,876 --> 00:13:44,536 A:middle
where you're controlling the
main character using virtual

323
00:13:44,536 --> 00:13:45,936 A:middle
buttons along the
bottom of the screen.

324
00:13:46,586 --> 00:13:47,226 A:middle
This is great.

325
00:13:47,316 --> 00:13:48,916 A:middle
We don't have a game
controller attached.

326
00:13:49,636 --> 00:13:51,636 A:middle
And the game is very
obviously presenting these

327
00:13:51,636 --> 00:13:52,436 A:middle
control options.

328
00:13:53,026 --> 00:13:55,086 A:middle
Now watch what happens when
we connect a controller.

329
00:13:57,436 --> 00:13:59,266 A:middle
The virtual buttons went away.

330
00:13:59,346 --> 00:14:03,536 A:middle
And importantly, the player
didn't have to take any action.

331

332
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

333
00:13:59,346 --> 00:14:03,536 A:middle
And importantly, the player
didn't have to take any action.

334
00:14:05,086 --> 00:14:06,366 A:middle
No dialogs were presented.

335
00:14:06,516 --> 00:14:07,716 A:middle
No choice was given.

336
00:14:08,176 --> 00:14:10,746 A:middle
The game just assumes
that the existence

337
00:14:10,956 --> 00:14:15,626 A:middle
of a connected controller is
intent and permission to use it.

338
00:14:19,666 --> 00:14:21,776 A:middle
So, we've talked about
finding controllers.

339
00:14:22,096 --> 00:14:24,926 A:middle
The next step is how do I
actually read the inputs?

340
00:14:25,716 --> 00:14:27,866 A:middle
How do I find out if the
A button is being pressed?

341
00:14:28,206 --> 00:14:31,216 A:middle
And before I get to that,
let's go through and talk

342
00:14:31,216 --> 00:14:33,716 A:middle
about what kind of inputs
you're going to find

343
00:14:33,716 --> 00:14:34,936 A:middle
on the controllers themselves.

344
00:14:38,256 --> 00:14:40,946 A:middle
So, first and foremost,
when you're designing

345
00:14:40,946 --> 00:14:45,106 A:middle
for game controllers, keep in
mind to first design for touch.

346
00:14:45,596 --> 00:14:48,706 A:middle
You want the native controls
of your operating system

347
00:14:49,076 --> 00:14:50,446 A:middle
to be usable at all times.

348
00:14:50,786 --> 00:14:51,806 A:middle
And this makes sense.

349
00:14:52,426 --> 00:14:55,066 A:middle
If a game player downloads
your game from the App Store,

350
00:14:56,126 --> 00:14:58,686 A:middle
they're going to have the
expectation -- correctly so --

351
00:14:58,686 --> 00:15:00,916 A:middle
that they're able to play
it regardless of whether

352

353
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

354
00:14:58,686 --> 00:15:00,916 A:middle
that they're able to play
it regardless of whether

355
00:15:00,916 --> 00:15:02,216 A:middle
or not they have
a game controller.

356
00:15:03,196 --> 00:15:04,496 A:middle
So, put another way,

357
00:15:04,746 --> 00:15:08,166 A:middle
game controllers cannot be
required to play your game.

358
00:15:08,166 --> 00:15:11,886 A:middle
Now, let's talk about profiles.

359
00:15:12,176 --> 00:15:16,166 A:middle
So profiles are the software
mapping to the hardware.

360
00:15:16,926 --> 00:15:18,826 A:middle
So we have three
different controller types.

361
00:15:19,516 --> 00:15:22,476 A:middle
And they are mapped in software
to two different profiles.

362
00:15:23,686 --> 00:15:26,126 A:middle
One is called gamepad,
and the second is

363
00:15:26,126 --> 00:15:28,026 A:middle
called extendedGamepad.

364
00:15:28,366 --> 00:15:31,576 A:middle
And you'll notice all
controllers support the

365
00:15:31,576 --> 00:15:32,706 A:middle
gamepad profile.

366
00:15:32,706 --> 00:15:37,206 A:middle
Now, the physical controllers,

367
00:15:37,206 --> 00:15:39,706 A:middle
which are extended
control layouts,

368
00:15:40,056 --> 00:15:42,436 A:middle
also support the
extendedGamepad.

369
00:15:43,456 --> 00:15:47,996 A:middle
So if you support only
the gamepad profile,

370
00:15:47,996 --> 00:15:49,936 A:middle
you're guaranteed that
your game will be playable

371
00:15:49,936 --> 00:15:51,246 A:middle
on any controller available.

372
00:15:51,536 --> 00:15:54,826 A:middle
And if you wish to support
the analog thumbsticks

373
00:15:54,826 --> 00:15:58,376 A:middle
and the triggers, then you'll
target the extendedGamepad

374
00:15:58,376 --> 00:15:59,186 A:middle
profile as well.

375

376
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

377
00:16:00,106 --> 00:16:02,116 A:middle
So these are properties on
the controller instance.

378
00:16:02,376 --> 00:16:06,556 A:middle
Let's look at what properties
are within the gamepad profile.

379
00:16:06,686 --> 00:16:12,856 A:middle
We have buttonA, buttonB,
buttonX, and buttonY.

380
00:16:12,856 --> 00:16:14,946 A:middle
And these correspond to
the four face buttons.

381
00:16:16,006 --> 00:16:18,906 A:middle
Similarly, the two shoulder
buttons are called leftShoulder

382
00:16:18,906 --> 00:16:20,316 A:middle
and rightShoulder
in the framework.

383
00:16:20,316 --> 00:16:24,066 A:middle
And the D-pad is
simply called dpad.

384
00:16:24,226 --> 00:16:27,046 A:middle
Now, switching over to
the extended profile,

385
00:16:27,706 --> 00:16:32,576 A:middle
extendedGamepad, it has all the
same properties from gamepad

386
00:16:32,616 --> 00:16:36,336 A:middle
and in addition, we
add leftThumbstick

387
00:16:36,336 --> 00:16:41,826 A:middle
and rightThumbstick, and
leftTrigger and rightTrigger,

388
00:16:42,516 --> 00:16:44,126 A:middle
corresponding to the
additional controls

389
00:16:44,166 --> 00:16:45,626 A:middle
that extended gamepads give us.

390
00:16:46,066 --> 00:16:48,856 A:middle
Now I'd like to call your
attention to the fact

391
00:16:48,856 --> 00:16:52,826 A:middle
that triggers and face buttons,
while physically different

392
00:16:53,456 --> 00:16:54,826 A:middle
to the Game Controller
framework,

393
00:16:54,826 --> 00:16:58,236 A:middle
we use the same data type:
GCControllerButtonInput.

394
00:16:59,626 --> 00:17:02,316 A:middle
Similarly, D-pads
and thumbsticks,

395

396
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

397
00:16:59,626 --> 00:17:02,316 A:middle
Similarly, D-pads
and thumbsticks,

398
00:17:02,726 --> 00:17:05,606 A:middle
while being physically,
different share the same class,

399
00:17:05,876 --> 00:17:07,516 A:middle
called GCControllerDirectionPad.

400
00:17:08,286 --> 00:17:13,826 A:middle
So let's talk about those
classes, buttons and D-pads.

401
00:17:14,016 --> 00:17:17,215 A:middle
GCControllerButtonInput
represents all the buttons

402
00:17:17,425 --> 00:17:18,586 A:middle
available on the controller.

403
00:17:19,165 --> 00:17:20,915 A:middle
And these can be
read in two ways.

404
00:17:21,496 --> 00:17:23,776 A:middle
One is with the pressed
property.

405
00:17:23,866 --> 00:17:27,175 A:middle
And this returns the
classic, digital version

406
00:17:27,226 --> 00:17:29,996 A:middle
of a button whether or not
it's being pressed: Yes or No.

407
00:17:31,396 --> 00:17:34,506 A:middle
But, all buttons on game
controllers are also

408
00:17:34,506 --> 00:17:35,376 A:middle
pressure sensitive.

409
00:17:35,956 --> 00:17:38,176 A:middle
And if this something
that's useful for your game,

410
00:17:38,696 --> 00:17:40,616 A:middle
you read that using
the value property.

411
00:17:41,416 --> 00:17:44,886 A:middle
This returns you a float
normalized between 0

412
00:17:44,886 --> 00:17:47,926 A:middle
and 1 indicating how hard
the button is being pressed.

413
00:17:48,406 --> 00:17:56,116 A:middle
Now, the A and B buttons have a
special convention in iOS games

414
00:17:56,116 --> 00:17:57,176 A:middle
and GameController games.

415
00:17:58,206 --> 00:18:00,986 A:middle
The A button is intended
to be your primary action.

416

417
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

418
00:17:58,206 --> 00:18:00,986 A:middle
The A button is intended
to be your primary action.

419
00:18:01,706 --> 00:18:05,166 A:middle
And the B button is to be
used as the secondary action.

420
00:18:05,976 --> 00:18:07,826 A:middle
And so you need to think
about, with your game:

421
00:18:07,986 --> 00:18:09,416 A:middle
"What is my primary action?

422
00:18:09,876 --> 00:18:10,796 A:middle
Is it jumping?

423
00:18:11,236 --> 00:18:12,306 A:middle
Is it shooting?

424
00:18:12,866 --> 00:18:14,716 A:middle
Is it throwing a ball?"

425
00:18:15,836 --> 00:18:17,936 A:middle
And also, think about
it in the context of UI.

426
00:18:18,656 --> 00:18:21,406 A:middle
If you're not in actual game
play, what are the primary

427
00:18:21,406 --> 00:18:22,516 A:middle
and secondary actions?

428
00:18:23,766 --> 00:18:27,126 A:middle
For UI, it should be
to confirm and accept

429
00:18:27,476 --> 00:18:28,676 A:middle
for the primary action.

430
00:18:29,836 --> 00:18:31,186 A:middle
And the B button should be used

431
00:18:31,636 --> 00:18:33,836 A:middle
as cancelling, the
secondary action.

432
00:18:37,836 --> 00:18:41,146 A:middle
Let's talk about
GCControllerDirectionPad now.

433
00:18:41,786 --> 00:18:44,396 A:middle
Again, this is used for
both D-pads and thumbsticks.

434
00:18:45,026 --> 00:18:47,376 A:middle
And it's treated in
two different ways.

435
00:18:47,756 --> 00:18:51,776 A:middle
One is that it's treated
as four buttons named Up,

436
00:18:51,776 --> 00:18:53,026 A:middle
Down, Left and Right.

437
00:18:53,026 --> 00:18:58,776 A:middle
And the second way we treat it
is as two axes, xAxis and yAxis.

438
00:18:59,946 --> 00:19:02,076 A:middle
And you'll recall that
I said each button

439

440
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

441
00:18:59,946 --> 00:19:02,076 A:middle
And you'll recall that
I said each button

442
00:19:02,076 --> 00:19:04,606 A:middle
on the control pad is
pressure sensitive?

443
00:19:04,736 --> 00:19:06,996 A:middle
Well, that's also true of
Up, Down, Left and Right,

444
00:19:06,996 --> 00:19:08,106 A:middle
since they're the same class.

445
00:19:09,206 --> 00:19:11,586 A:middle
So D-pads are effectively
pressure sensitive

446
00:19:11,686 --> 00:19:12,946 A:middle
and digital as well.

447
00:19:14,126 --> 00:19:15,946 A:middle
Let's look at the axis.

448
00:19:16,236 --> 00:19:19,656 A:middle
Now axes -- the value that's
returned from an axis --

449
00:19:19,946 --> 00:19:22,836 A:middle
is normalized between
negative 1 and positive 1.

450
00:19:22,996 --> 00:19:28,766 A:middle
And a value of 0 you can rely
on being the axis at rest,

451
00:19:29,446 --> 00:19:31,586 A:middle
meaning the player is
not pressing that axis.

452
00:19:32,846 --> 00:19:34,746 A:middle
Now, you have a guaranteed
minimum range

453
00:19:34,746 --> 00:19:35,656 A:middle
of the unit circle.

454
00:19:36,276 --> 00:19:37,856 A:middle
Maximum range of
the unit square.

455
00:19:38,726 --> 00:19:41,066 A:middle
And for those of you who may
have dealt with calibration

456
00:19:41,066 --> 00:19:45,226 A:middle
of joysticks and deadzoning
before, do not do that yourself.

457
00:19:45,226 --> 00:19:48,876 A:middle
We already take care
of that for you.

458
00:19:49,426 --> 00:19:50,656 A:middle
So that's all the controls.

459
00:19:50,656 --> 00:19:52,236 A:middle
And now you can get
on with the business

460
00:19:52,236 --> 00:19:55,646 A:middle
of assigning game actions
to controller inputs.

461
00:19:56,406 --> 00:20:00,646 A:middle
And one piece of advice I can
offer is a principle which a lot

462

463
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

464
00:19:56,406 --> 00:20:00,646 A:middle
And one piece of advice I can
offer is a principle which a lot

465
00:20:00,646 --> 00:20:02,106 A:middle
of games use to great effect,

466
00:20:02,236 --> 00:20:04,986 A:middle
which is to group
logically similar actions.

467
00:20:05,616 --> 00:20:07,386 A:middle
So in Leo's Fortune,
for instance,

468
00:20:07,746 --> 00:20:09,586 A:middle
our main character
has four actions.

469
00:20:09,846 --> 00:20:14,086 A:middle
He can walk left, right and
he can jump and he can stomp.

470
00:20:14,686 --> 00:20:20,416 A:middle
So the developers have
mapped walking left

471
00:20:20,416 --> 00:20:22,946 A:middle
and walking right to the D-pad.

472
00:20:23,616 --> 00:20:26,266 A:middle
Walking left and walking right
are logically similar actions.

473
00:20:26,266 --> 00:20:27,016 A:middle
It's just walking.

474
00:20:28,066 --> 00:20:30,076 A:middle
And so it makes sense to
group those on the D-pad.

475
00:20:31,066 --> 00:20:34,086 A:middle
Also, they're making good
use of the D-pad's ability

476
00:20:34,086 --> 00:20:35,676 A:middle
to readily switch directions.

477
00:20:37,186 --> 00:20:41,106 A:middle
Now, jumping is assigned
to the A button.

478
00:20:42,436 --> 00:20:45,826 A:middle
This is because jumping
is logically dissimilar

479
00:20:45,826 --> 00:20:48,496 A:middle
from horizontal movement,
and so it's separated.

480
00:20:51,316 --> 00:20:53,776 A:middle
They could have assigned
jumping to the Up button,

481
00:20:54,826 --> 00:20:57,036 A:middle
but it's a logically
dissimilar action,

482
00:20:57,036 --> 00:20:59,076 A:middle
so it might have been a little
bit more confusing for players.

483
00:20:59,636 --> 00:21:01,656 A:middle
And, the D-pad's ability

484

485
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

486
00:20:59,636 --> 00:21:01,656 A:middle
And, the D-pad's ability

487
00:21:01,656 --> 00:21:04,986 A:middle
to readily switch directions
could actually fight the game

488
00:21:04,986 --> 00:21:09,596 A:middle
player in this case
and result in a lot

489
00:21:09,596 --> 00:21:13,256 A:middle
of inadvertent jumps
instead of lateral movement.

490
00:21:13,826 --> 00:21:16,856 A:middle
Now the last ability
is the stomp ability.

491
00:21:17,066 --> 00:21:18,446 A:middle
That's been assigned
to the B button.

492
00:21:18,556 --> 00:21:20,886 A:middle
So again, logically
dissimilar from walking,

493
00:21:21,116 --> 00:21:22,036 A:middle
so we've separated it.

494
00:21:22,036 --> 00:21:24,406 A:middle
But logically similar
to jumping,

495
00:21:24,686 --> 00:21:27,866 A:middle
so it's nearby to the A button.

496
00:21:28,246 --> 00:21:31,876 A:middle
So now let's actually find
out, now that you know

497
00:21:31,876 --> 00:21:35,226 A:middle
which controls you want
to assign to which actions

498
00:21:35,226 --> 00:21:37,766 A:middle
in your game, let's actually
go ahead and read some input.

499
00:21:38,936 --> 00:21:40,576 A:middle
How do you find out if
the A button is pressed?

500
00:21:40,666 --> 00:21:42,676 A:middle
Well, it's really just as
simple as reading a series

501
00:21:42,676 --> 00:21:45,676 A:middle
of properties:
myController.gamepad --

502
00:21:45,676 --> 00:21:49,706 A:middle
gamepad being the profile
-- .buttonA.pressed.

503
00:21:50,206 --> 00:21:52,316 A:middle
Recall that pressed gives
us the Boolean state

504
00:21:52,316 --> 00:21:53,286 A:middle
for whether the button's
pressed.

505
00:21:53,786 --> 00:21:55,516 A:middle
In this case, we're
going to fire our lasers.

506
00:21:57,096 --> 00:21:58,866 A:middle
Now also in our weapons code,

507
00:21:58,976 --> 00:22:02,656 A:middle
we're going to use
the B button's analog

508

509
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

510
00:21:58,976 --> 00:22:02,656 A:middle
we're going to use
the B button's analog

511
00:22:02,656 --> 00:22:06,056 A:middle
and digital representations for
this portion of the game play.

512
00:22:06,876 --> 00:22:08,996 A:middle
If the B button is
being pressed at (all

513
00:22:08,996 --> 00:22:12,786 A:middle
in the digital sense) then we go
ahead and start firing missiles

514
00:22:12,866 --> 00:22:15,586 A:middle
at a rate that increases
the harder

515
00:22:15,586 --> 00:22:18,386 A:middle
that button is pressed;
B-button .value.

516
00:22:21,096 --> 00:22:23,906 A:middle
Then we apply thrust
to our spaceship based

517
00:22:23,906 --> 00:22:26,436 A:middle
on whether the player is
pressing the D-pad up or down.

518
00:22:27,426 --> 00:22:29,886 A:middle
This is perfect for the
yAxis, so we're going

519
00:22:29,886 --> 00:22:32,066 A:middle
to use the yAxis
representation of the D-pad.

520
00:22:32,646 --> 00:22:37,506 A:middle
And note that we're not guarding
this line of code with a query

521
00:22:37,576 --> 00:22:39,566 A:middle
for whether or not
the axis is pressed.

522
00:22:40,176 --> 00:22:42,236 A:middle
We're leveraging the
fact that we can rely

523
00:22:42,236 --> 00:22:45,386 A:middle
on the yAxis's value being 0

524
00:22:45,386 --> 00:22:46,696 A:middle
when the player's
not pressing it.

525
00:22:47,186 --> 00:22:50,166 A:middle
And our applyThrust
method is resilient to that

526
00:22:50,166 --> 00:22:55,316 A:middle
and does nothing when a
value of 0 is pressed.

527
00:22:55,466 --> 00:22:58,516 A:middle
Lastly, we're taking
special action

528
00:22:58,706 --> 00:23:01,246 A:middle
if the controller that's
controlling our game happens

529

530
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

531
00:22:58,706 --> 00:23:01,246 A:middle
if the controller that's
controlling our game happens

532
00:23:01,276 --> 00:23:02,656 A:middle
to be an extended controller.

533
00:23:03,466 --> 00:23:05,626 A:middle
You can check if a
controller is extended merely

534
00:23:05,626 --> 00:23:08,896 A:middle
by checking whether or not the
extendedGamepad profile is nil.

535
00:23:10,456 --> 00:23:12,496 A:middle
Notice we weren't doing
that above for gamepad,

536
00:23:12,496 --> 00:23:15,346 A:middle
because gamepad is guaranteed to
be non-nil since it's supported

537
00:23:15,346 --> 00:23:16,556 A:middle
across all controller types.

538
00:23:17,096 --> 00:23:21,626 A:middle
And in this case, we're using
the right thumbstick's position

539
00:23:22,176 --> 00:23:24,926 A:middle
to move a camera in our
game back and forth.

540
00:23:25,656 --> 00:23:27,936 A:middle
Now notice: the weapons
and thrust code,

541
00:23:29,226 --> 00:23:33,116 A:middle
we don't explicitly program for
the extendedGamepad profile.

542
00:23:33,786 --> 00:23:37,236 A:middle
But, the extended
gamepad will fall back

543
00:23:37,236 --> 00:23:39,506 A:middle
and use the same behavior
that's specified here

544
00:23:39,766 --> 00:23:43,896 A:middle
since it's not being
overridden with competing code

545
00:23:43,896 --> 00:23:45,646 A:middle
for the extendedGamepad profile.

546
00:23:46,096 --> 00:23:48,916 A:middle
And what this means for
you is that you don't have

547
00:23:48,916 --> 00:23:52,796 A:middle
to duplicate the same code for
both gamepad and extendedGamepad

548
00:23:52,906 --> 00:23:54,786 A:middle
if you want it to do the
same thing regardless

549
00:23:54,786 --> 00:23:55,606 A:middle
of the type of controller.

550
00:23:56,246 --> 00:24:01,946 A:middle
So that's one way to read
controller inputs, is polling.

551

552
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

553
00:23:56,246 --> 00:24:01,946 A:middle
So that's one way to read
controller inputs, is polling.

554
00:24:02,166 --> 00:24:04,036 A:middle
Doing this once every
game frame, typically.

555
00:24:05,036 --> 00:24:06,536 A:middle
The other way is using events.

556
00:24:06,746 --> 00:24:09,276 A:middle
Sometimes you just want to
be notified when something

557
00:24:09,276 --> 00:24:11,206 A:middle
on your control pad changes.

558
00:24:11,746 --> 00:24:15,846 A:middle
Whether it's a button or
an axis, even collections

559
00:24:16,586 --> 00:24:21,506 A:middle
such as D-pads and thumbsticks,
or profiles if you want to know

560
00:24:21,506 --> 00:24:23,156 A:middle
if anything on the
controller has changed.

561
00:24:23,906 --> 00:24:26,866 A:middle
And you do this by registering
a block as a change handler.

562
00:24:27,516 --> 00:24:29,586 A:middle
Basically, "here's the
code I want you to run

563
00:24:29,886 --> 00:24:31,536 A:middle
when this input changes."

564
00:24:32,796 --> 00:24:34,766 A:middle
So we have valueChangedHandlers.

565
00:24:35,166 --> 00:24:36,856 A:middle
Note "value" corresponds

566
00:24:36,856 --> 00:24:40,506 A:middle
to our querying the
pressure-sensitive nature

567
00:24:40,506 --> 00:24:42,416 A:middle
of the buttons, the
float values.

568
00:24:42,986 --> 00:24:47,796 A:middle
And new for iOS 8, we have
a pressedChangedHandler.

569
00:24:48,646 --> 00:24:50,916 A:middle
This is for querying
digital changes.

570
00:24:52,196 --> 00:24:54,206 A:middle
Let's look at an example of
the pressedChangedHandler.

571
00:24:55,826 --> 00:24:56,706 A:middle
In our game, we want

572
00:24:56,706 --> 00:24:59,626 A:middle
to be notified whenever
the Y button changes state

573

574
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

575
00:25:00,076 --> 00:25:01,126 A:middle
in the digital sense.

576
00:25:02,566 --> 00:25:05,066 A:middle
So we've set up the
pressedChangedHandler.

577
00:25:05,316 --> 00:25:08,996 A:middle
And it's called twice, once
when the button is pressed

578
00:25:08,996 --> 00:25:11,096 A:middle
and another time when
the button is released.

579
00:25:12,026 --> 00:25:15,226 A:middle
And you can filter that based
on the pressed parameter here.

580
00:25:16,076 --> 00:25:17,876 A:middle
In this case, we
actually care about both.

581
00:25:18,016 --> 00:25:21,936 A:middle
So when the button is pressed,
we begin charging a speed boost.

582
00:25:22,576 --> 00:25:26,406 A:middle
And when the button is released,
we actually do the speed boost.

583
00:25:29,306 --> 00:25:31,536 A:middle
Now, use pressure
sensitivity with discernment.

584
00:25:31,586 --> 00:25:34,086 A:middle
There are certain times where
you might be tempted to see

585
00:25:34,086 --> 00:25:36,936 A:middle
if a trigger, for
instance, is being pulled.

586
00:25:37,606 --> 00:25:41,856 A:middle
Don't use the analog "value"
if what you really want to find

587
00:25:41,856 --> 00:25:43,956 A:middle
out is whether or not that
control is being pressed.

588
00:25:44,576 --> 00:25:47,436 A:middle
If so, use "pressed" instead,
the Boolean representation.

589
00:25:48,336 --> 00:25:50,686 A:middle
Also, take advantage of
the pressure-sensitivity

590
00:25:50,686 --> 00:25:54,486 A:middle
of buttons and D-pads.

591
00:25:54,546 --> 00:25:56,366 A:middle
D-pads, while thought
of traditionally

592
00:25:56,366 --> 00:26:00,286 A:middle
as a digital-only
input, are a great way

593

594
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

595
00:25:56,366 --> 00:26:00,286 A:middle
as a digital-only
input, are a great way

596
00:26:00,606 --> 00:26:02,266 A:middle
to get 360 degree movement.

597
00:26:02,746 --> 00:26:04,706 A:middle
So this is really
important for players

598
00:26:04,706 --> 00:26:09,476 A:middle
who have a standard gamepad
without analog thumbsticks.

599
00:26:09,636 --> 00:26:11,176 A:middle
The D-pad behaves really nicely.

600
00:26:11,176 --> 00:26:13,716 A:middle
We spent a lot of work
making it work really nicely

601
00:26:13,716 --> 00:26:15,696 A:middle
as an analog supplement.

602
00:26:17,026 --> 00:26:18,096 A:middle
And Face Buttons.

603
00:26:18,876 --> 00:26:20,436 A:middle
You can add nuance to your game

604
00:26:21,046 --> 00:26:22,786 A:middle
by using the pressure
sensitive values.

605
00:26:23,046 --> 00:26:26,176 A:middle
Maybe you have a soccer
game and you gate how hard

606
00:26:26,176 --> 00:26:30,096 A:middle
or soft your passes and your
shots are based on how hard

607
00:26:30,096 --> 00:26:31,826 A:middle
or soft the player
taps the button.

608
00:26:32,436 --> 00:26:35,976 A:middle
And please remember
to tell the player

609
00:26:35,976 --> 00:26:38,016 A:middle
when you're using
pressure-sensitive nature

610
00:26:38,196 --> 00:26:39,076 A:middle
of the controls.

611
00:26:39,326 --> 00:26:41,696 A:middle
Nothing's worse than me
playing a soccer game for a week

612
00:26:42,156 --> 00:26:45,596 A:middle
and seeing all my shots fly
over the net hard and fast only

613
00:26:45,596 --> 00:26:48,196 A:middle
to realize sometime
in the future, "Oh,

614
00:26:48,446 --> 00:26:51,766 A:middle
they're actually wanting
me to use a little nuance

615
00:26:51,766 --> 00:26:54,616 A:middle
when I'm playing the game, and
I need to use a softer touch."

616
00:26:55,176 --> 00:27:00,646 A:middle
And that relates to how are
you going to be a good teacher

617

618
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

619
00:26:55,176 --> 00:27:00,646 A:middle
And that relates to how are
you going to be a good teacher

620
00:27:00,896 --> 00:27:02,226 A:middle
of your controls to your player?

621
00:27:03,006 --> 00:27:06,486 A:middle
What you see on screen
here, a visual overlay

622
00:27:06,896 --> 00:27:10,296 A:middle
that is a reference for players
to know what game inputs do what

623
00:27:10,296 --> 00:27:12,616 A:middle
in your game, is a
great starting point.

624
00:27:14,516 --> 00:27:17,706 A:middle
But, we want to be
not just a teacher,

625
00:27:17,706 --> 00:27:19,666 A:middle
but we want to be
a good teacher.

626
00:27:20,716 --> 00:27:22,396 A:middle
So let's look at what
Leo's Fortune does.

627
00:27:23,096 --> 00:27:24,296 A:middle
This is the opening level.

628
00:27:24,296 --> 00:27:25,636 A:middle
I've dropped into game play.

629
00:27:26,056 --> 00:27:29,256 A:middle
And the first thing I see is a
little floating icon over top

630
00:27:29,446 --> 00:27:32,046 A:middle
that suggests I press left
and right on the D-pad.

631
00:27:32,656 --> 00:27:34,236 A:middle
This is great for a
number of reasons.

632
00:27:34,436 --> 00:27:36,036 A:middle
It keeps me in the experience.

633
00:27:36,206 --> 00:27:37,746 A:middle
The game has not paused.

634
00:27:37,746 --> 00:27:38,976 A:middle
I don't have any overlays.

635
00:27:39,666 --> 00:27:41,556 A:middle
And I can move the
character back

636
00:27:41,556 --> 00:27:43,846 A:middle
and forth while this is
onscreen the entire time.

637
00:27:44,676 --> 00:27:46,846 A:middle
It's iconic and it
allows the player

638
00:27:46,846 --> 00:27:48,216 A:middle
to progress at their own pace.

639
00:27:48,846 --> 00:27:49,936 A:middle
And it's out of the way.

640
00:27:50,236 --> 00:27:52,556 A:middle
It's down in the terrain where
it's not blocking my view.

641
00:27:54,096 --> 00:27:55,936 A:middle
After playing with
that for a little bit,

642
00:27:55,936 --> 00:27:58,756 A:middle
I come to the first portion of
the level where I need to jump.

643
00:27:58,856 --> 00:28:03,086 A:middle
And again, in a similar fashion,
they kindly and gently suggest

644

645
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

646
00:27:58,856 --> 00:28:03,086 A:middle
And again, in a similar fashion,
they kindly and gently suggest

647
00:28:03,126 --> 00:28:04,336 A:middle
that I press the A button.

648
00:28:04,856 --> 00:28:09,386 A:middle
Now important to note here also,
is they're not overwhelming me

649
00:28:09,386 --> 00:28:12,146 A:middle
at the start with all the
controls for the entire game.

650
00:28:12,606 --> 00:28:14,656 A:middle
They're introducing it
in piecemeal fashion

651
00:28:14,656 --> 00:28:17,706 A:middle
so that I can understand
it, practice it

652
00:28:17,906 --> 00:28:21,626 A:middle
and then learn the next step.

653
00:28:21,756 --> 00:28:22,076 A:middle
All right.

654
00:28:22,076 --> 00:28:23,036 A:middle
Where are we in the talk?

655
00:28:23,256 --> 00:28:25,356 A:middle
I've given you an overview
of game controllers.

656
00:28:26,296 --> 00:28:28,576 A:middle
We know which controllers
are connected to our system.

657
00:28:28,576 --> 00:28:30,406 A:middle
We know how to read
the controller inputs.

658
00:28:30,856 --> 00:28:33,706 A:middle
So now it's time to talk
about what's new in iOS 8.

659
00:28:34,916 --> 00:28:36,036 A:middle
And I'm happy to tell you

660
00:28:36,036 --> 00:28:39,096 A:middle
about a brand new feature
called Controller Forwarding.

661
00:28:39,696 --> 00:28:43,046 A:middle
This allows your game controller
with the snapped-in iPhone

662
00:28:43,196 --> 00:28:44,966 A:middle
to be used as a wireless
controller

663
00:28:45,146 --> 00:28:49,336 A:middle
to control another device
like an iPad or a MacBook Air.

664
00:28:49,836 --> 00:28:52,276 A:middle
This works over Bluetooth
and Wi-Fi.

665
00:28:52,316 --> 00:28:54,876 A:middle
And Bluetooth devices
-- or sorry --

666
00:28:54,876 --> 00:28:56,836 A:middle
the two devices need
to be signed

667
00:28:56,836 --> 00:28:58,086 A:middle
into the same iCloud account.

668
00:28:58,966 --> 00:29:01,166 A:middle
Since this is a new
feature, let me walk you

669

670
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

671
00:28:58,966 --> 00:29:01,166 A:middle
Since this is a new
feature, let me walk you

672
00:29:01,226 --> 00:29:02,876 A:middle
through the flow
of what happens.

673
00:29:05,736 --> 00:29:08,706 A:middle
So we've installed
the game on the iPad.

674
00:29:08,706 --> 00:29:11,226 A:middle
It is not installed on our
phone in the controller.

675
00:29:11,836 --> 00:29:14,326 A:middle
We start playing it.

676
00:29:14,326 --> 00:29:16,476 A:middle
And then through the
magic of continuity,

677
00:29:16,746 --> 00:29:19,936 A:middle
a little gamepad
icon is displayed

678
00:29:19,936 --> 00:29:21,676 A:middle
in the lower corner
of the lock screen.

679
00:29:22,506 --> 00:29:23,966 A:middle
The player swipes up on that

680
00:29:23,966 --> 00:29:26,886 A:middle
and a wireless connection
is established.

681
00:29:28,206 --> 00:29:32,616 A:middle
And all the controller events
are forwarded wirelessly

682
00:29:32,616 --> 00:29:37,796 A:middle
and automatically to the gamepad
-- or to the iPad, sorry.

683
00:29:37,966 --> 00:29:41,956 A:middle
Now, which of this do you
have to take responsibility

684
00:29:42,026 --> 00:29:43,226 A:middle
for and program yourself?

685
00:29:44,936 --> 00:29:45,936 A:middle
Absolutely nothing.

686
00:29:46,636 --> 00:29:49,566 A:middle
As long you're calling
startWirelessController

687
00:29:49,566 --> 00:29:52,856 A:middle
DiscoveryWith CompletionHandler,
all this happens for free.

688
00:29:53,556 --> 00:29:56,816 A:middle
And the beauty is that
the controller appears

689
00:29:56,816 --> 00:29:58,606 A:middle
as any other in the framework.

690
00:29:59,076 --> 00:30:00,876 A:middle
You can read the button
presses off of it.

691

692
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

693
00:29:59,076 --> 00:30:00,876 A:middle
You can read the button
presses off of it.

694
00:30:02,016 --> 00:30:02,936 A:middle
You can find out when

695
00:30:02,936 --> 00:30:04,706 A:middle
that controller connects
and disconnects.

696
00:30:05,286 --> 00:30:08,246 A:middle
You can query whether it's
an extended controller

697
00:30:08,246 --> 00:30:09,366 A:middle
or a standard controller.

698
00:30:10,366 --> 00:30:11,076 A:middle
It just works.

699
00:30:13,136 --> 00:30:17,506 A:middle
Now we figured since phones have
accelerometers and gyroscopes,

700
00:30:18,686 --> 00:30:21,246 A:middle
why don't we go ahead and send
that information along, too.

701
00:30:22,316 --> 00:30:26,316 A:middle
So this way, if your game
supports motion control

702
00:30:26,316 --> 00:30:30,936 A:middle
and game controllers, you don't
need to capture that information

703
00:30:30,936 --> 00:30:34,106 A:middle
and set up a side communication
channel and serialize

704
00:30:34,106 --> 00:30:35,536 A:middle
and de-serialize the data

705
00:30:35,536 --> 00:30:37,456 A:middle
and then synchronize
it on the other end.

706
00:30:37,796 --> 00:30:39,106 A:middle
You don't have to worry
about any of that.

707
00:30:39,106 --> 00:30:40,106 A:middle
We take care of that for you.

708
00:30:40,426 --> 00:30:44,506 A:middle
And all this is found in a new
profile we're calling Motion.

709
00:30:45,616 --> 00:30:48,696 A:middle
Motion is of the
class type GCMotion.

710
00:30:48,896 --> 00:30:50,806 A:middle
So let's look at
what that gives us.

711
00:30:53,226 --> 00:30:58,096 A:middle
Here we have four properties,
gravity, user acceleration,

712
00:30:58,526 --> 00:31:00,836 A:middle
attitude and rotation rate.

713

714
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

715
00:30:58,526 --> 00:31:00,836 A:middle
attitude and rotation rate.

716
00:31:02,006 --> 00:31:04,356 A:middle
Now these are probably very
familiar to those of you

717
00:31:04,356 --> 00:31:05,646 A:middle
who have used Core
Motion before.

718
00:31:06,716 --> 00:31:09,786 A:middle
Let's look at each of these
in a little more detail.

719
00:31:10,196 --> 00:31:11,136 A:middle
First: gravity.

720
00:31:13,276 --> 00:31:15,756 A:middle
Gravity is type GCAcceleration.

721
00:31:16,146 --> 00:31:20,036 A:middle
And it returns a vector
oriented in the direction

722
00:31:20,036 --> 00:31:22,026 A:middle
in which gravity is
pulling the device.

723
00:31:23,106 --> 00:31:24,476 A:middle
The units are in G's.

724
00:31:25,596 --> 00:31:29,016 A:middle
And so if the device is
lying flat on a table

725
00:31:29,476 --> 00:31:33,476 A:middle
with the screen facing up, this
vector will return you a value

726
00:31:33,476 --> 00:31:37,196 A:middle
of 0, 0, negative 1
because gravity is pointing

727
00:31:37,196 --> 00:31:41,726 A:middle
in the exact same direction
as the negative zAxis.

728
00:31:41,846 --> 00:31:43,376 A:middle
Next we have userAcceleration.

729
00:31:44,066 --> 00:31:48,596 A:middle
This is used to find out
inertial acceleration

730
00:31:48,596 --> 00:31:50,136 A:middle
when the player is
shaking the controller.

731
00:31:51,626 --> 00:31:52,896 A:middle
It excludes gravity.

732
00:31:52,896 --> 00:31:55,906 A:middle
And the units are also in G's.

733
00:31:56,356 --> 00:31:59,396 A:middle
So in the same scenario, when
the phone is at rest on a table,

734
00:31:59,396 --> 00:32:01,806 A:middle
the acceleration
will be 0, 0, 0.

735

736
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

737
00:31:59,396 --> 00:32:01,806 A:middle
the acceleration
will be 0, 0, 0.

738
00:32:02,406 --> 00:32:05,536 A:middle
We also have attitude.

739
00:32:06,336 --> 00:32:10,106 A:middle
This allows you to know the
3D orientation of the device.

740
00:32:10,556 --> 00:32:14,626 A:middle
And from that, you can determine
the yaw, the pitch and the roll

741
00:32:14,626 --> 00:32:17,116 A:middle
of the device, if that's
important for your game.

742
00:32:17,996 --> 00:32:19,556 A:middle
Lastly we have rotation rate.

743
00:32:20,136 --> 00:32:24,376 A:middle
This tells you how the phone is
being spun and on which axis.

744
00:32:25,346 --> 00:32:27,516 A:middle
And the units here are
in radians per second.

745
00:32:27,866 --> 00:32:32,016 A:middle
Now, at a high level,
you're going to want

746
00:32:32,016 --> 00:32:33,516 A:middle
to organize your code like this.

747
00:32:34,476 --> 00:32:37,786 A:middle
First you check the
motionProfile on the controller

748
00:32:37,986 --> 00:32:39,306 A:middle
and whether or not it's nil.

749
00:32:39,866 --> 00:32:43,076 A:middle
If it's non-nil, that means
our controller supports motion.

750
00:32:43,806 --> 00:32:45,926 A:middle
And we go ahead and use that.

751
00:32:46,796 --> 00:32:49,286 A:middle
Otherwise, we use
motion from the device.

752
00:32:49,826 --> 00:32:52,456 A:middle
Now, I'd like to
draw your attention

753
00:32:52,456 --> 00:32:55,066 A:middle
to the overall structure
of this if-else statement.

754
00:32:55,146 --> 00:33:00,466 A:middle
In our example, our iPad
was running the game.

755

756
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

757
00:32:55,146 --> 00:33:00,466 A:middle
In our example, our iPad
was running the game.

758
00:33:01,246 --> 00:33:04,256 A:middle
And the iPad has
motion capabilities.

759
00:33:04,876 --> 00:33:07,566 A:middle
But we don't want to use
those motion capabilities

760
00:33:07,566 --> 00:33:09,926 A:middle
because that device
is just sitting there

761
00:33:09,926 --> 00:33:12,756 A:middle
on the table while we
play with our phone.

762
00:33:12,896 --> 00:33:15,246 A:middle
We want to use the phone's
motion capabilities.

763
00:33:15,726 --> 00:33:22,216 A:middle
Hence, we prioritize
that if it exists.

764
00:33:22,336 --> 00:33:23,676 A:middle
A few notes as well.

765
00:33:24,356 --> 00:33:27,826 A:middle
These axes you see drawn on
the screen with the iPhone,

766
00:33:28,086 --> 00:33:30,706 A:middle
they move with the
phone as it moves.

767
00:33:31,266 --> 00:33:37,896 A:middle
So, what in this orientation has
the positive Y vector pointing

768
00:33:37,896 --> 00:33:42,356 A:middle
straight up towards the sky,
when this phone is snapped

769
00:33:42,356 --> 00:33:44,946 A:middle
into a controller and held
in landscape orientation,

770
00:33:46,026 --> 00:33:48,176 A:middle
positive Y is now
pointing to the left.

771
00:33:48,616 --> 00:33:49,846 A:middle
So this is just something
to be aware

772
00:33:49,846 --> 00:33:50,886 A:middle
of as you're coding your game.

773
00:33:51,886 --> 00:33:53,746 A:middle
Also, Motion data
will be jittery.

774
00:33:54,346 --> 00:33:57,136 A:middle
You're going to want to apply
some sort of a filter to this,

775
00:33:57,486 --> 00:34:02,336 A:middle
maybe a running average of
the last x number of frames.

776

777
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

778
00:33:57,486 --> 00:34:02,336 A:middle
maybe a running average of
the last x number of frames.

779
00:34:02,676 --> 00:34:05,816 A:middle
Also new for iOS 8 is
Idle Timer behavior.

780
00:34:06,596 --> 00:34:08,196 A:middle
The idle timer is
what governs whether

781
00:34:08,196 --> 00:34:10,606 A:middle
or not the screen turns
off to save battery power.

782
00:34:10,686 --> 00:34:14,176 A:middle
And in iOS 8, this is
handled automatically for you.

783
00:34:14,815 --> 00:34:18,406 A:middle
Playing a game with the gamepad
will keep your screen alive.

784
00:34:19,565 --> 00:34:23,056 A:middle
In iOS 7, you're going to
want to handle this yourself.

785
00:34:23,545 --> 00:34:25,786 A:middle
And if you want to do
that, this is what you use.

786
00:34:25,916 --> 00:34:29,636 A:middle
You set the IdleTimerDisabled
on the UIApplication instance.

787
00:34:30,706 --> 00:34:31,726 A:middle
Now be careful here.

788
00:34:32,036 --> 00:34:36,116 A:middle
You also need to know when
to re-enable the idle timer.

789
00:34:36,116 --> 00:34:38,096 A:middle
And that's out of the
scope of this talk,

790
00:34:38,096 --> 00:34:39,876 A:middle
so please read the
documentation on that.

791
00:34:41,076 --> 00:34:44,976 A:middle
Also of note is that motion
apps need to do this as well.

792
00:34:45,806 --> 00:34:48,106 A:middle
Moving the phone does not
keep the screen alive.

793
00:34:48,255 --> 00:34:52,676 A:middle
And so regardless of which OS
you're on, you have to do this

794
00:34:52,676 --> 00:34:57,726 A:middle
if you're using motion
in your game.

795
00:34:57,946 --> 00:34:58,606 A:middle
All right.

796
00:34:58,606 --> 00:35:01,886 A:middle
Let me talk about a
little bit more guidance.

797

798
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

799
00:34:58,606 --> 00:35:01,886 A:middle
Let me talk about a
little bit more guidance.

800
00:35:02,966 --> 00:35:04,686 A:middle
All controllers have
a pause button.

801
00:35:05,476 --> 00:35:08,186 A:middle
So if your game supports
game controllers,

802
00:35:08,766 --> 00:35:10,866 A:middle
you have to implement
a pause button handler.

803
00:35:11,636 --> 00:35:14,186 A:middle
This is found on
controller instances.

804
00:35:14,316 --> 00:35:15,916 A:middle
It's called
controllerPausedHandler.

805
00:35:16,086 --> 00:35:19,786 A:middle
And whenever this is called you
want to treat it as a toggle.

806
00:35:19,786 --> 00:35:20,536 A:middle
So if you're in the middle

807
00:35:20,536 --> 00:35:22,476 A:middle
of active game play,
pause the game.

808
00:35:23,296 --> 00:35:26,476 A:middle
If you're not -- or sorry,
if your game is paused

809
00:35:26,476 --> 00:35:28,026 A:middle
and this is called,
then un-pause.

810
00:35:28,986 --> 00:35:31,376 A:middle
If you're in a context where
pausing doesn't make sense,

811
00:35:31,376 --> 00:35:34,456 A:middle
like a main menu, it's entirely
appropriate to do nothing.

812
00:35:36,196 --> 00:35:37,976 A:middle
Also: Player Indicator LEDs.

813
00:35:38,816 --> 00:35:42,896 A:middle
Always set the -- sorry,
always set the playerIndex

814
00:35:43,076 --> 00:35:45,796 A:middle
on the controller whenever
you find a controller

815
00:35:45,796 --> 00:35:46,766 A:middle
and are about to use it.

816
00:35:47,356 --> 00:35:50,126 A:middle
This gives players feedback that
the controller is recognized

817
00:35:50,126 --> 00:35:51,476 A:middle
by the game and being used.

818
00:35:52,106 --> 00:35:54,016 A:middle
So in a single player
game, it's as easy

819
00:35:54,016 --> 00:35:55,336 A:middle
as checking the player index.

820
00:35:56,086 --> 00:35:58,476 A:middle
If it's unset, as denoted

821
00:35:58,476 --> 00:36:02,596 A:middle
by this handy flag called
GCControllerPlayerIndexUnset,

822

823
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

824
00:35:58,476 --> 00:36:02,596 A:middle
by this handy flag called
GCControllerPlayerIndexUnset,

825
00:36:02,896 --> 00:36:05,006 A:middle
then go ahead and set
the playerIndex to 0.

826
00:36:05,886 --> 00:36:07,496 A:middle
This is a zero-based index.

827
00:36:07,646 --> 00:36:10,096 A:middle
So this will light up the
first LED on the control pad.

828
00:36:10,226 --> 00:36:14,766 A:middle
Now let's talk about
multiple-controller games.

829
00:36:17,126 --> 00:36:20,916 A:middle
In all of my examples, I'm
calling self.myController.

830
00:36:21,496 --> 00:36:24,666 A:middle
Well, when you have a
multi-player split-screen game,

831
00:36:25,346 --> 00:36:28,646 A:middle
or a game where players
are sharing the same view,

832
00:36:28,646 --> 00:36:30,896 A:middle
you're going to have multiple
controllers, so keep track

833
00:36:30,896 --> 00:36:33,046 A:middle
of them with an array --
myController is plural.

834
00:36:33,606 --> 00:36:36,716 A:middle
And you want to make sure
to set the playerIndex

835
00:36:36,716 --> 00:36:37,856 A:middle
for all the controllers.

836
00:36:38,356 --> 00:36:39,856 A:middle
And I'll show you how
to do that momentarily.

837
00:36:41,326 --> 00:36:45,686 A:middle
Also, consider which controllers
you allow to navigate menus.

838
00:36:45,946 --> 00:36:48,786 A:middle
It can be very confusing if you
have multiple players all trying

839
00:36:48,786 --> 00:36:51,286 A:middle
to navigate a menu at the same
time competing with each other.

840
00:36:51,656 --> 00:36:53,176 A:middle
In that case it may
be appropriate

841
00:36:53,416 --> 00:36:55,626 A:middle
to let only Player
1 control the menus.

842
00:36:57,156 --> 00:36:59,956 A:middle
Also, think about what
a disconnection means

843
00:36:59,956 --> 00:37:01,856 A:middle
in the context of a
multi-player game.

844

845
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

846
00:36:59,956 --> 00:37:01,856 A:middle
in the context of a
multi-player game.

847
00:37:02,556 --> 00:37:04,876 A:middle
In some games like a
one-on-one tennis match,

848
00:37:05,426 --> 00:37:08,356 A:middle
game play cannot proceed
without the second player.

849
00:37:08,406 --> 00:37:11,106 A:middle
And so in that case,
we pause the game.

850
00:37:12,396 --> 00:37:15,876 A:middle
Other types of games with live
drop-in/drop-out game play,

851
00:37:16,626 --> 00:37:21,356 A:middle
can proceed with game play as
players connect and disconnect.

852
00:37:21,566 --> 00:37:23,446 A:middle
So in that case, you
don't necessarily need

853
00:37:23,446 --> 00:37:24,416 A:middle
to pause the game play.

854
00:37:24,696 --> 00:37:25,356 A:middle
It can proceed.

855
00:37:25,996 --> 00:37:28,026 A:middle
So take whatever action is
appropriate for your game.

856
00:37:28,726 --> 00:37:30,466 A:middle
Now let's look at a code sample.

857
00:37:30,466 --> 00:37:33,086 A:middle
Here we are back in our
friend setupControllers.

858
00:37:34,266 --> 00:37:36,876 A:middle
And we're looping over every
controller in our array.

859
00:37:37,396 --> 00:37:40,346 A:middle
And for each one of those we're
checking if the index is unset.

860
00:37:41,066 --> 00:37:43,856 A:middle
If we find even one
controllerIndex that's unset,

861
00:37:43,926 --> 00:37:45,796 A:middle
we display a player
picker to the UI.

862
00:37:46,566 --> 00:37:49,136 A:middle
This allows them to choose which
character they are in the game

863
00:37:49,446 --> 00:37:51,066 A:middle
or to know which
quadrant they're in.

864
00:37:51,886 --> 00:37:54,676 A:middle
And within there, we're
going to set the playerIndex

865
00:37:54,846 --> 00:37:57,046 A:middle
so that the players know
what they're controlling

866
00:37:57,126 --> 00:37:59,386 A:middle
on the screen.

867
00:37:59,446 --> 00:38:01,206 A:middle
Now another piece
of design guidance

868

869
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

870
00:37:59,446 --> 00:38:01,206 A:middle
Now another piece
of design guidance

871
00:38:01,206 --> 00:38:02,006 A:middle
that I'd like to give you...

872
00:38:02,196 --> 00:38:06,086 A:middle
Very important: respond to
game controller inputs early.

873
00:38:06,656 --> 00:38:10,016 A:middle
When a player snaps in
a controller and taps

874
00:38:10,016 --> 00:38:11,886 A:middle
and launches your game
from a home screen,

875
00:38:12,646 --> 00:38:13,796 A:middle
what is the first thing they do?

876
00:38:14,396 --> 00:38:15,876 A:middle
They start mashing
the buttons, right?

877
00:38:15,876 --> 00:38:17,756 A:middle
They start pressing
the A button.

878
00:38:17,756 --> 00:38:19,106 A:middle
They start moving the D-pad.

879
00:38:19,366 --> 00:38:21,596 A:middle
They want to see if your game
supports game controllers.

880
00:38:22,156 --> 00:38:24,456 A:middle
And every response you make

881
00:38:24,996 --> 00:38:28,946 A:middle
or response your game doesn't
make communicates something

882
00:38:28,946 --> 00:38:29,576 A:middle
to the players.

883
00:38:30,116 --> 00:38:33,456 A:middle
And responding early
tells players, yes,

884
00:38:33,636 --> 00:38:35,286 A:middle
this game supports
game controllers.

885
00:38:36,146 --> 00:38:40,566 A:middle
Now splash screens, introductory
cinematics and the main menu

886
00:38:40,566 --> 00:38:45,006 A:middle
at the latest are great
opportunities to respond

887
00:38:45,006 --> 00:38:46,306 A:middle
to controller inputs early.

888
00:38:46,936 --> 00:38:51,806 A:middle
The longer you wait and the
deeper a player has to get

889
00:38:51,806 --> 00:38:54,866 A:middle
into your game to discover the
game controller integration,

890
00:38:55,336 --> 00:38:57,956 A:middle
the more likely they
are to miss-assume

891
00:38:58,146 --> 00:39:00,086 A:middle
that this game doesn't even
support game controllers

892

893
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

894
00:38:58,146 --> 00:39:00,086 A:middle
that this game doesn't even
support game controllers

895
00:39:00,436 --> 00:39:02,946 A:middle
and unplug their controller
and just use native inputs,

896
00:39:03,086 --> 00:39:04,946 A:middle
missing all the hard work
you put into your game play.

897
00:39:05,236 --> 00:39:08,776 A:middle
Let's look at what
Leo's Fortune does.

898
00:39:09,416 --> 00:39:10,506 A:middle
So the game launches.

899
00:39:10,606 --> 00:39:12,226 A:middle
It starts off with
the splash screen

900
00:39:12,226 --> 00:39:13,426 A:middle
and introductory cinematic.

901
00:39:13,426 --> 00:39:18,536 A:middle
And pressing the A button
allows you to skip the rest

902
00:39:18,536 --> 00:39:21,606 A:middle
of that cinematic and jump
straight to the main menu.

903
00:39:22,406 --> 00:39:25,216 A:middle
So right there, within a few
seconds of launching the app,

904
00:39:26,166 --> 00:39:27,596 A:middle
the game has told
the player, yes,

905
00:39:27,676 --> 00:39:29,176 A:middle
this game supports
game controllers.

906
00:39:30,776 --> 00:39:33,396 A:middle
Now, at the main menu,
and this is really slick,

907
00:39:33,396 --> 00:39:37,296 A:middle
only when a game controller's
attached do the green portions

908
00:39:37,296 --> 00:39:41,736 A:middle
of the buttons glow,
telling you which button

909
00:39:41,736 --> 00:39:43,166 A:middle
on the screen is active.

910
00:39:44,186 --> 00:39:46,496 A:middle
By using the D-pad
and navigating over,

911
00:39:47,276 --> 00:39:49,476 A:middle
another button begins
glowing instead telling you

912
00:39:49,476 --> 00:39:50,716 A:middle
that that's the active button.

913
00:39:51,236 --> 00:39:54,266 A:middle
So once again, the game
is confirming now, yes,

914
00:39:54,456 --> 00:39:55,926 A:middle
this game supports
game controllers.

915
00:39:56,806 --> 00:39:59,986 A:middle
And the player is highly
likely to enter game play

916
00:39:59,986 --> 00:40:01,686 A:middle
and enjoy the experience
with the controller.

917

918
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

919
00:39:59,986 --> 00:40:01,686 A:middle
and enjoy the experience
with the controller.

920
00:40:02,926 --> 00:40:07,956 A:middle
Now, another reason, if that's
not enough, to mechanize your UI

921
00:40:07,956 --> 00:40:10,906 A:middle
for game controller support is

922
00:40:10,906 --> 00:40:12,726 A:middle
because we have standard
controllers,

923
00:40:13,256 --> 00:40:14,526 A:middle
which are standalone --

924
00:40:14,646 --> 00:40:16,626 A:middle
or sorry, extended
standalone controllers.

925
00:40:17,476 --> 00:40:19,276 A:middle
These controllers, as
I mentioned previously,

926
00:40:19,906 --> 00:40:23,136 A:middle
don't have the touchscreen
easily accessible.

927
00:40:24,116 --> 00:40:26,946 A:middle
And so all the inputs are coming
exclusively from the controller.

928
00:40:27,836 --> 00:40:31,846 A:middle
So support mechanizing your
UI so that game controllers

929
00:40:31,846 --> 00:40:34,046 A:middle
which are standalone
are supported.

930
00:40:34,046 --> 00:40:36,976 A:middle
So what did we learn today?

931
00:40:37,436 --> 00:40:41,026 A:middle
I gave you an overview of
what the game controllers are

932
00:40:41,026 --> 00:40:41,526 A:middle
from Apple.

933
00:40:41,726 --> 00:40:45,666 A:middle
Basically it's a two-part
-- it comes in two parts.

934
00:40:45,666 --> 00:40:48,016 A:middle
The first part being
the MFi specification,

935
00:40:48,326 --> 00:40:51,426 A:middle
and the second part being
the GameController framework.

936
00:40:51,826 --> 00:40:53,876 A:middle
We talked about how
we find controllers,

937
00:40:54,576 --> 00:40:56,676 A:middle
how we read inputs off
of those controllers.

938
00:40:57,566 --> 00:41:01,456 A:middle
I talked about what's new,
forwarding, motion forwarding

939

940
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

941
00:40:57,566 --> 00:41:01,456 A:middle
I talked about what's new,
forwarding, motion forwarding

942
00:41:01,926 --> 00:41:03,146 A:middle
and the idle timer behavior.

943
00:41:03,976 --> 00:41:06,526 A:middle
And throughout we talked
about design guidance:

944
00:41:06,786 --> 00:41:09,306 A:middle
things that you can do
to make the experience

945
00:41:09,306 --> 00:41:11,816 A:middle
of game controllers
really intuitive

946
00:41:12,076 --> 00:41:14,086 A:middle
and integrated really
nicely with your game

947
00:41:14,086 --> 00:41:17,076 A:middle
so the player can just
enjoy your underlying game.

948
00:41:20,076 --> 00:41:22,316 A:middle
For more information
on game controllers,

949
00:41:22,506 --> 00:41:25,046 A:middle
please contact Allan or Filip.

950
00:41:27,956 --> 00:41:31,096 A:middle
For related sessions, if
you want to make a 2D game,

951
00:41:31,096 --> 00:41:32,956 A:middle
check out the SpriteKit
sessions:

952
00:41:33,416 --> 00:41:35,956 A:middle
"What's New in SpriteKit"
and "Best Practices

953
00:41:35,956 --> 00:41:37,386 A:middle
for Building Spritekit Games."

954
00:41:37,916 --> 00:41:40,906 A:middle
If you're interested
in 3D games,

955
00:41:41,026 --> 00:41:43,846 A:middle
check out the SceneKit
presentations:

956
00:41:44,146 --> 00:41:47,846 A:middle
"What's New in SceneKit" and
"Building a Game with SceneKit."

957
00:41:48,956 --> 00:41:49,896 A:middle
Thank you so much.

958
00:41:49,896 --> 00:41:51,936 A:middle
I'm really excited to see what
you're going to do with this.

959
00:41:52,016 --> 00:41:54,000 A:middle
[ Applause ]

960
