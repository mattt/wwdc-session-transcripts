X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:13,356 --> 00:00:14,436 A:middle
>> Welcome everyone.

2
00:00:14,896 --> 00:00:17,336 A:middle
Welcome. Welcome to WWDC,

3
00:00:17,656 --> 00:00:20,906 A:middle
and welcome to our Introductory
Session about Working

4
00:00:21,146 --> 00:00:25,206 A:middle
with Metal, and we're incredibly
excited to get to talk

5
00:00:25,206 --> 00:00:26,386 A:middle
to you today about Metal.

6
00:00:27,076 --> 00:00:30,696 A:middle
We believe it's literally going
to be a game changer for you,

7
00:00:31,336 --> 00:00:33,586 A:middle
your applications, and for iOS.

8
00:00:34,566 --> 00:00:36,246 A:middle
Now as you've heard
in the keynote,

9
00:00:36,846 --> 00:00:40,926 A:middle
Metal is our new
low-overhead, high-performance,

10
00:00:41,006 --> 00:00:43,926 A:middle
and incredibly efficient
GPU programming API.

11
00:00:45,046 --> 00:00:49,016 A:middle
It provides dramatically reduced
overhead for executing work

12
00:00:49,196 --> 00:00:51,356 A:middle
such as graphics and
compute on a GPU.

13
00:00:52,406 --> 00:00:54,866 A:middle
And with the support for
a precompiled shaders

14
00:00:55,046 --> 00:00:59,076 A:middle
and incredibly efficient
threading, we designed it to run

15
00:00:59,076 --> 00:01:01,096 A:middle
like a dream on the A7 chip.

16

17
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

18
00:00:59,076 --> 00:01:01,096 A:middle
like a dream on the A7 chip.

19
00:01:02,476 --> 00:01:05,355 A:middle
Now today in this session,
I'm going to talk to you

20
00:01:05,355 --> 00:01:07,986 A:middle
at a relatively high level
about the background, the how

21
00:01:07,986 --> 00:01:09,756 A:middle
and why we created
Metal and some

22
00:01:09,756 --> 00:01:12,046 A:middle
of the conceptual
framework for the API.

23
00:01:12,046 --> 00:01:15,836 A:middle
I'll also touch briefly on
the Metal shading language

24
00:01:16,416 --> 00:01:17,596 A:middle
and our developer tools.

25
00:01:18,816 --> 00:01:21,136 A:middle
The sessions that follow
will go into much more detail

26
00:01:21,136 --> 00:01:23,746 A:middle
about exactly how to use
the Metal API and how

27
00:01:23,746 --> 00:01:25,806 A:middle
to build your applications,
but we'll keep things

28
00:01:25,806 --> 00:01:27,326 A:middle
at a high level for
this session.

29
00:01:28,686 --> 00:01:31,346 A:middle
So, first, a bit of
background on Metal itself.

30
00:01:31,576 --> 00:01:35,616 A:middle
Now you also heard in a
keynote that Metal provides

31
00:01:36,046 --> 00:01:39,606 A:middle
up to 10x the number of draw
calls for your application.

32
00:01:40,186 --> 00:01:41,986 A:middle
Now what does that really mean?

33
00:01:42,886 --> 00:01:45,736 A:middle
Well, it's important to think
about draw calls in this way.

34
00:01:46,056 --> 00:01:50,546 A:middle
Each draw call requires its
own graphics state vector.

35
00:01:51,266 --> 00:01:54,166 A:middle
So when you're specifying that
you would like to draw something

36
00:01:54,166 --> 00:01:57,886 A:middle
with the GPU, you also need
to tell the GPU which shaders,

37
00:01:57,886 --> 00:02:00,246 A:middle
which states, how you want
to configure the textures

38

39
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

40
00:01:57,886 --> 00:02:00,246 A:middle
which states, how you want
to configure the textures

41
00:02:00,246 --> 00:02:01,566 A:middle
and the Rendering destinations.

42
00:02:02,676 --> 00:02:06,376 A:middle
This is very important in order
to get the effect you're looking

43
00:02:06,376 --> 00:02:08,876 A:middle
for from the GPU,
but, unfortunately,

44
00:02:08,916 --> 00:02:11,166 A:middle
with previous API's
changing state vectors,

45
00:02:11,316 --> 00:02:12,966 A:middle
it'd be extremely expensive.

46
00:02:13,526 --> 00:02:17,076 A:middle
You have to translate between
the API state and the state

47
00:02:17,076 --> 00:02:18,336 A:middle
that the hardware's
going to consume.

48
00:02:19,436 --> 00:02:23,346 A:middle
When I say expensive, I mean,
not for the GPU, but for the CPU

49
00:02:24,126 --> 00:02:26,646 A:middle
because it's the CPU that's
doing that type of translation.

50
00:02:26,646 --> 00:02:30,406 A:middle
So let's take a look
at a quick example.

51
00:02:31,416 --> 00:02:34,006 A:middle
If your application is
setting up for a new draw call,

52
00:02:34,176 --> 00:02:35,906 A:middle
you'll want to specify
the shaders and the state

53
00:02:35,906 --> 00:02:39,986 A:middle
and the textures for each
draw operation, and you'll do

54
00:02:39,986 --> 00:02:42,326 A:middle
that each time you want to
specify a new draw call.

55
00:02:42,776 --> 00:02:44,846 A:middle
And then the CPU gets
involved and spends a bunch

56
00:02:44,846 --> 00:02:49,116 A:middle
of time translating those state
changes and those requests

57
00:02:49,116 --> 00:02:53,096 A:middle
to draw in the hardware commands
before sending it to the GPU.

58
00:02:54,216 --> 00:02:56,706 A:middle
So if we had a way to make
that much less expensive,

59
00:02:56,876 --> 00:02:59,616 A:middle
we could give you a lot
more draw calls per frame,

60

61
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

62
00:03:00,266 --> 00:03:01,536 A:middle
and you might ask
yourself, well,

63
00:03:01,606 --> 00:03:03,206 A:middle
why do I want more
draw calls per frame?

64
00:03:03,916 --> 00:03:07,336 A:middle
Well, more draw calls lets
you build much better games

65
00:03:07,336 --> 00:03:08,266 A:middle
and applications.

66
00:03:08,776 --> 00:03:11,046 A:middle
You can build many
more unique objects,

67
00:03:11,326 --> 00:03:13,906 A:middle
have many more bad guys, or
other characters in the scene.

68
00:03:14,506 --> 00:03:17,226 A:middle
You can add a lot more
visual variety to your games,

69
00:03:17,926 --> 00:03:21,506 A:middle
but probably the most important
reason is your game artists

70
00:03:21,556 --> 00:03:23,606 A:middle
and designers are going
to thank you profusely

71
00:03:23,606 --> 00:03:25,406 A:middle
because you're going to
give them more freedom

72
00:03:25,406 --> 00:03:29,276 A:middle
to realize their vision without
having to jump through all types

73
00:03:29,276 --> 00:03:32,396 A:middle
of draw call gymnastics to
fit what they'd like to see

74
00:03:32,396 --> 00:03:34,586 A:middle
on screen into a tiny
number of draw calls.

75
00:03:34,586 --> 00:03:37,796 A:middle
Now let's take a
little bit of a look

76
00:03:38,306 --> 00:03:40,246 A:middle
at what life was
like before Metal.

77
00:03:41,386 --> 00:03:45,816 A:middle
Now Apple has a long history
of GPU programming API's,

78
00:03:45,816 --> 00:03:46,896 A:middle
both implementing them,

79
00:03:46,896 --> 00:03:48,356 A:middle
maintaining them,
developing them.

80
00:03:49,566 --> 00:03:53,646 A:middle
We've supported standard
API's like OpenGL and OpenCL.

81
00:03:54,996 --> 00:03:57,276 A:middle
We've supported API's across
a wide variety of domains,

82
00:03:57,276 --> 00:03:59,716 A:middle
both at the high level and the
low level of GP programming

83
00:03:59,716 --> 00:04:01,246 A:middle
for things like 2D, 3D,

84

85
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

86
00:03:59,716 --> 00:04:01,246 A:middle
for things like 2D, 3D,

87
00:04:01,406 --> 00:04:03,026 A:middle
animations, and image
processing.

88
00:04:03,936 --> 00:04:07,836 A:middle
And we've supported a wide
variety of architectures

89
00:04:08,216 --> 00:04:12,266 A:middle
in the hardware, across
platforms, computers, devices,

90
00:04:12,646 --> 00:04:17,466 A:middle
phones, iPads, and a
wide variety of GPU's.

91
00:04:18,466 --> 00:04:20,416 A:middle
And during all this time,
as we're supporting all

92
00:04:20,416 --> 00:04:21,755 A:middle
of this variety, we realized

93
00:04:21,755 --> 00:04:24,776 A:middle
that there was something pretty
fundamental missing from all

94
00:04:24,776 --> 00:04:29,966 A:middle
of these API's, and that was
the level of deep integration

95
00:04:30,246 --> 00:04:32,126 A:middle
that Apple brings
to its products.

96
00:04:32,866 --> 00:04:36,176 A:middle
Now Apple, as you know,
provides the operating system,

97
00:04:36,916 --> 00:04:40,816 A:middle
the hardware, and the
products as a complete package.

98
00:04:41,076 --> 00:04:42,876 A:middle
They're designed to work
together seamlessly.

99
00:04:43,676 --> 00:04:46,106 A:middle
And so we thought
to ourselves what

100
00:04:46,106 --> 00:04:49,376 A:middle
if we could take the same
approach to GPU programming

101
00:04:49,376 --> 00:04:50,986 A:middle
that we take to our
products as a whole?

102
00:04:51,906 --> 00:04:53,676 A:middle
If we could build these
to work seamlessly,

103
00:04:54,266 --> 00:04:56,556 A:middle
we knew we could do the
same for GPU programming,

104
00:04:57,086 --> 00:04:58,256 A:middle
and that's what we've
done with Metal.

105
00:04:58,256 --> 00:05:01,836 A:middle
Now as I said, we have a
long history at looking

106

107
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

108
00:04:58,256 --> 00:05:01,836 A:middle
Now as I said, we have a
long history at looking

109
00:05:01,836 --> 00:05:03,326 A:middle
at these different types
of programming API's,

110
00:05:03,326 --> 00:05:07,896 A:middle
and we realized that if we
wanted to get a tenfold in order

111
00:05:07,896 --> 00:05:10,486 A:middle
of magnitude improvement in
performance, we're going to have

112
00:05:10,486 --> 00:05:11,906 A:middle
to do some pretty
radical things.

113
00:05:12,376 --> 00:05:20,076 A:middle
We decided to take a clean
sheet approach to this design,

114
00:05:20,656 --> 00:05:25,146 A:middle
and the key design goals that
we had were outlined here.

115
00:05:26,146 --> 00:05:29,796 A:middle
First, we knew we wanted to
have the thinnest possible API

116
00:05:29,796 --> 00:05:31,386 A:middle
that we could create.

117
00:05:31,516 --> 00:05:34,266 A:middle
We wanted to be, reduce
the amount of code

118
00:05:34,266 --> 00:05:36,866 A:middle
that was executing in
between your application

119
00:05:37,056 --> 00:05:38,616 A:middle
and the GPU to a bare minimum.

120
00:05:40,656 --> 00:05:43,096 A:middle
We knew it needed to
support the most modern GPU

121
00:05:43,196 --> 00:05:44,106 A:middle
hardware features.

122
00:05:44,686 --> 00:05:47,146 A:middle
We didn't want it bogged down
with the [inaudible] of 20 years

123
00:05:47,426 --> 00:05:48,726 A:middle
of previous GPU designs.

124
00:05:48,726 --> 00:05:52,006 A:middle
We wanted to focus entirely
and squarely on the future.

125
00:05:52,426 --> 00:05:56,006 A:middle
We knew that there were some
expensive CPU operations

126
00:05:56,006 --> 00:05:58,876 A:middle
that needed to take place, but
we wanted to carefully control

127
00:05:58,936 --> 00:06:00,656 A:middle
when those happen and
make sure that they happen

128

129
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

130
00:05:58,936 --> 00:06:00,656 A:middle
when those happen and
make sure that they happen

131
00:06:00,656 --> 00:06:02,496 A:middle
as infrequently as possible.

132
00:06:02,866 --> 00:06:07,826 A:middle
And we wanted to give you
the developer predictable

133
00:06:07,936 --> 00:06:10,456 A:middle
performance so you
would know exactly when

134
00:06:10,556 --> 00:06:13,536 A:middle
and how those expensive
operations could take place.

135
00:06:13,876 --> 00:06:18,026 A:middle
We wanted to give
you explicit control

136
00:06:18,026 --> 00:06:21,006 A:middle
over when the work was
executed on the GPU.

137
00:06:21,086 --> 00:06:24,396 A:middle
So you could decide when and
how to kick off that work

138
00:06:24,726 --> 00:06:27,066 A:middle
and never be surprised by what
the implementation might do

139
00:06:27,066 --> 00:06:29,546 A:middle
behind your back.

140
00:06:29,546 --> 00:06:32,296 A:middle
And, last but not least, we
knew it had to be highly,

141
00:06:32,296 --> 00:06:35,426 A:middle
highly optimized for
the A7 CPU behavior

142
00:06:35,946 --> 00:06:37,746 A:middle
as this will become
key in a few moments.

143
00:06:38,086 --> 00:06:40,896 A:middle
So how to think about Metal.

144
00:06:41,086 --> 00:06:43,116 A:middle
Well, where does it fit?

145
00:06:43,266 --> 00:06:45,296 A:middle
Well, let's say you have your
application here represented

146
00:06:45,296 --> 00:06:47,026 A:middle
at the top of this
diagram in green,

147
00:06:47,416 --> 00:06:48,756 A:middle
and you like to talk to the GPU.

148
00:06:49,456 --> 00:06:51,916 A:middle
Well, Apple provides a
wide variety of API's

149
00:06:51,916 --> 00:06:55,016 A:middle
to do just that, but they
come at different levels

150
00:06:55,016 --> 00:06:58,466 A:middle
of abstraction, different
levels of conceptual distance

151
00:06:58,496 --> 00:07:00,046 A:middle
between you and the GPU.

152

153
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

154
00:06:58,496 --> 00:07:00,046 A:middle
between you and the GPU.

155
00:07:00,846 --> 00:07:04,006 A:middle
So at a high level, you have
awesome API's like Scene Kit

156
00:07:04,056 --> 00:07:07,206 A:middle
and Sprite Kit that give high
level services for scene graphs

157
00:07:07,206 --> 00:07:09,896 A:middle
for 2D and 3D animations,
and they're great.

158
00:07:10,166 --> 00:07:13,786 A:middle
They provide a lot of services,
but they are relatively far

159
00:07:13,886 --> 00:07:15,596 A:middle
from the GPU in terms
of abstraction.

160
00:07:16,816 --> 00:07:19,226 A:middle
And then, of course, we have our
2D graphics and imaging API's

161
00:07:19,226 --> 00:07:22,916 A:middle
such as Core Animation, Core
Image, and Core Graphics,

162
00:07:23,346 --> 00:07:25,006 A:middle
and these, too, provide
a lot of services,

163
00:07:25,236 --> 00:07:27,296 A:middle
and if this is the type
of operation you're doing,

164
00:07:27,896 --> 00:07:30,856 A:middle
these are perfect API's for you.

165
00:07:30,856 --> 00:07:33,816 A:middle
And, as always, we have the
standard space 3D graphics

166
00:07:33,816 --> 00:07:35,446 A:middle
approach with OpenGL ES.

167
00:07:36,796 --> 00:07:38,466 A:middle
But when we wanted to
do something better,

168
00:07:38,466 --> 00:07:42,076 A:middle
and to give you high
efficiency GPU access

169
00:07:42,376 --> 00:07:44,126 A:middle
at the thinnest possible
API layer,

170
00:07:44,446 --> 00:07:46,046 A:middle
that's where Metal comes in.

171
00:07:47,016 --> 00:07:51,036 A:middle
So how do we do this?

172
00:07:51,036 --> 00:07:52,396 A:middle
Well, first thing we wanted

173
00:07:52,396 --> 00:07:55,316 A:middle
to understand is how
most modern games try

174
00:07:55,316 --> 00:07:57,786 A:middle
to manage their CPU
and GPU workloads.

175
00:07:58,216 --> 00:08:00,606 A:middle
So most games will
target a frame rate.

176

177
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

178
00:07:58,216 --> 00:08:00,606 A:middle
So most games will
target a frame rate.

179
00:08:00,966 --> 00:08:02,756 A:middle
Oftentimes, it could
be 60 frames a second,

180
00:08:03,416 --> 00:08:04,266 A:middle
sometimes at 30.

181
00:08:04,396 --> 00:08:06,666 A:middle
In this example, we're using
30, which works out to be

182
00:08:06,666 --> 00:08:09,796 A:middle
about 33.3 milliseconds
per frame.

183
00:08:11,096 --> 00:08:13,576 A:middle
Now on this timeline, you can
see how most games would try

184
00:08:13,576 --> 00:08:16,136 A:middle
to optimize for this
type of timeline.

185
00:08:16,606 --> 00:08:21,866 A:middle
They'll try to balance the
amount of CPU work and the type

186
00:08:21,866 --> 00:08:25,286 A:middle
of GPU work to fill the entire
frame, but they'll do so offset.

187
00:08:25,356 --> 00:08:27,316 A:middle
So the CPU will be working
and generating commands

188
00:08:27,316 --> 00:08:30,336 A:middle
for one frame, and the GPU will
then consume those commands

189
00:08:30,336 --> 00:08:32,956 A:middle
in the next frame, and
while the CPU is doing that,

190
00:08:33,285 --> 00:08:37,885 A:middle
the GPU is busily working on the
previous frame, and you lay this

191
00:08:37,885 --> 00:08:40,385 A:middle
out on a timeline, and you
can see how you get relatively

192
00:08:40,385 --> 00:08:41,576 A:middle
perfect parallelism.

193
00:08:42,046 --> 00:08:45,936 A:middle
Well, let's look at one frame
in particular, and you'll notice

194
00:08:45,936 --> 00:08:49,716 A:middle
in this example we're assuming
a completely balanced frame

195
00:08:50,206 --> 00:08:55,016 A:middle
where the CPU and GPU are
occupying all of the time.

196
00:08:55,196 --> 00:08:58,176 A:middle
Now, unfortunately, real life
is not quite so balanced,

197
00:08:58,546 --> 00:09:01,756 A:middle
and oftentimes you'll find
that the CPU can take more time

198

199
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

200
00:08:58,546 --> 00:09:01,756 A:middle
and oftentimes you'll find
that the CPU can take more time

201
00:09:01,896 --> 00:09:05,596 A:middle
to generate these commands than
the GPU does to consume them,

202
00:09:06,046 --> 00:09:10,316 A:middle
and this is unfortunate because
it often leads the GPU idle.

203
00:09:10,646 --> 00:09:13,246 A:middle
So you're not even using the
system to its fullest capacity,

204
00:09:13,676 --> 00:09:14,836 A:middle
and if you were, it would be

205
00:09:14,836 --> 00:09:16,836 A:middle
like having a 50
percent faster GPU,

206
00:09:17,056 --> 00:09:18,056 A:middle
but it's just sitting
there dark.

207
00:09:18,056 --> 00:09:22,086 A:middle
So you say to yourself, "Well,
I'd like to fix this problem.

208
00:09:22,086 --> 00:09:25,646 A:middle
I'm just going to give more work
to the GPU", and, unfortunately,

209
00:09:25,646 --> 00:09:28,506 A:middle
what you'll find is that to give
more work to the GPU you have

210
00:09:28,506 --> 00:09:30,516 A:middle
to first spin up
more work on the CPU.

211
00:09:31,306 --> 00:09:33,186 A:middle
And if you were already bound by
the amount of work you could do

212
00:09:33,186 --> 00:09:35,926 A:middle
on the CPU, this pushes you, out
your frame time even further.

213
00:09:35,926 --> 00:09:38,566 A:middle
Now we're below our 30
frames per second target.

214
00:09:39,696 --> 00:09:42,476 A:middle
And to add insult to
injury, the GPU is still idle

215
00:09:42,956 --> 00:09:45,006 A:middle
because now our frame
time is actually longer,

216
00:09:45,206 --> 00:09:46,746 A:middle
and the GPU can't
fill that work either.

217
00:09:47,256 --> 00:09:51,476 A:middle
So to understand what's
happening here, it's helpful

218
00:09:51,476 --> 00:09:54,216 A:middle
to realize that the CPU
workload is actually split

219
00:09:54,216 --> 00:09:55,136 A:middle
into two parts.

220
00:09:56,226 --> 00:09:57,956 A:middle
You have the applications
workload,

221
00:09:57,956 --> 00:09:59,066 A:middle
what you guys are providing,

222
00:09:59,626 --> 00:10:01,376 A:middle
and then you have all
the implementation work

223

224
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

225
00:09:59,626 --> 00:10:01,376 A:middle
and then you have all
the implementation work

226
00:10:01,376 --> 00:10:01,976 A:middle
for the GPU API itself.

227
00:10:02,366 --> 00:10:06,216 A:middle
So whenever you make a
GPU programming call,

228
00:10:07,026 --> 00:10:08,406 A:middle
we're going to have to translate

229
00:10:08,406 --> 00:10:09,936 A:middle
that in the way I
described earlier.

230
00:10:11,176 --> 00:10:14,586 A:middle
Well, it's this GPU
programming API time on the CPU

231
00:10:14,586 --> 00:10:16,186 A:middle
that we're focused
on with Metal,

232
00:10:16,916 --> 00:10:19,936 A:middle
and Metal dramatically
reduces this time

233
00:10:21,076 --> 00:10:22,136 A:middle
down to a bare minimum.

234
00:10:23,236 --> 00:10:25,166 A:middle
Now in this example,
we've actually freed

235
00:10:25,166 --> 00:10:27,176 A:middle
up additional CPU time.

236
00:10:27,176 --> 00:10:28,526 A:middle
Now it's the CPU that's idle,

237
00:10:28,816 --> 00:10:31,216 A:middle
and our frame time has
become limited by the GPU,

238
00:10:31,376 --> 00:10:33,776 A:middle
and we're actually beating our
30 frames per second target.

239
00:10:34,256 --> 00:10:35,996 A:middle
So if that was your goal,
you can now Render faster

240
00:10:35,996 --> 00:10:39,166 A:middle
than 30 frames per second,
but you have another option.

241
00:10:39,756 --> 00:10:42,976 A:middle
You can actually use that
CPU time to improve your game

242
00:10:42,976 --> 00:10:43,826 A:middle
and make it even better.

243
00:10:44,396 --> 00:10:49,246 A:middle
You could add more physics
or may AI or other types

244
00:10:49,306 --> 00:10:51,386 A:middle
of workloads to your
application.

245
00:10:52,196 --> 00:10:54,146 A:middle
We have a little bit of
CPU idle time here left.

246
00:10:55,016 --> 00:10:56,586 A:middle
We can actually choose
to go back

247
00:10:56,586 --> 00:10:58,586 A:middle
to our 30 frames
per second target,

248
00:10:59,216 --> 00:11:01,806 A:middle
and add even more draw calls
with Metal providing you

249

250
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

251
00:10:59,216 --> 00:11:01,806 A:middle
and add even more draw calls
with Metal providing you

252
00:11:01,806 --> 00:11:03,816 A:middle
up to a 10x increase
in efficiency,

253
00:11:04,296 --> 00:11:06,836 A:middle
and you can either draw
more things with the GPU,

254
00:11:06,966 --> 00:11:09,376 A:middle
or maybe just draw them in
a much more flexible manner

255
00:11:09,846 --> 00:11:11,216 A:middle
so you can get more
visual variety.

256
00:11:12,266 --> 00:11:13,746 A:middle
So that's what we're
trying to do with Metal.

257
00:11:15,946 --> 00:11:19,466 A:middle
Now why is this GPU programming
so expensive on the CPU?

258
00:11:19,466 --> 00:11:21,356 A:middle
To understand what we did
with Metal, it's helpful

259
00:11:21,356 --> 00:11:24,426 A:middle
to take a deeper look here, too,
and there are 3 main reasons.

260
00:11:25,546 --> 00:11:28,646 A:middle
First, you have what's
called state validation.

261
00:11:29,336 --> 00:11:32,216 A:middle
Now some people think state
validation is just having the

262
00:11:32,216 --> 00:11:34,976 A:middle
implementation verify that
you're calling the API

263
00:11:34,976 --> 00:11:37,016 A:middle
in the right way and
that's certainly true,

264
00:11:37,946 --> 00:11:41,166 A:middle
but it also involves encoding
the state from the API

265
00:11:41,786 --> 00:11:45,456 A:middle
to the hardware and translating
it and oftentimes looking

266
00:11:45,456 --> 00:11:46,806 A:middle
at different aspects
of the state

267
00:11:46,806 --> 00:11:49,176 A:middle
and different state objects in
the API and figuring out how

268
00:11:49,176 --> 00:11:50,726 A:middle
to combine them into a way

269
00:11:50,726 --> 00:11:52,396 A:middle
that the hardware's
going to understand.

270
00:11:52,726 --> 00:11:53,586 A:middle
This can be expensive,

271
00:11:54,336 --> 00:11:56,026 A:middle
and perhaps the most
expensive version

272
00:11:56,026 --> 00:11:58,286 A:middle
of this is actually the
shader compilation itself.

273
00:11:59,436 --> 00:12:01,796 A:middle
So you take your source
code shaders for your vertex

274

275
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

276
00:11:59,436 --> 00:12:01,796 A:middle
So you take your source
code shaders for your vertex

277
00:12:01,796 --> 00:12:04,326 A:middle
and pixel shaders, and they
have to be compiled at run time

278
00:12:04,696 --> 00:12:07,546 A:middle
and to generate the
GPU's machine code.

279
00:12:08,126 --> 00:12:12,366 A:middle
What's worse is that in a lot
of API's before Metal, the state

280
00:12:13,216 --> 00:12:16,176 A:middle
and the shader code was not
described in the API in a way

281
00:12:16,176 --> 00:12:19,096 A:middle
that really mapped well to what
the hardware actually was going

282
00:12:19,096 --> 00:12:19,726 A:middle
to expect.

283
00:12:20,356 --> 00:12:22,816 A:middle
And so when you change
certain states, you could find

284
00:12:22,816 --> 00:12:24,876 A:middle
that behind the scenes,
we actually had to go back

285
00:12:24,876 --> 00:12:27,756 A:middle
and recompile your shaders,
causing even more CPU work.

286
00:12:29,096 --> 00:12:32,566 A:middle
And, last, they're sending
the work to the GPU itself,

287
00:12:32,826 --> 00:12:33,836 A:middle
and this can be expensive.

288
00:12:34,236 --> 00:12:36,996 A:middle
The resources, the memory, the
textures have to all be managed

289
00:12:36,996 --> 00:12:39,016 A:middle
and given to the GPU in
the way it can expect.

290
00:12:39,016 --> 00:12:42,516 A:middle
And because those first
two items are so expensive,

291
00:12:42,806 --> 00:12:45,186 A:middle
we often have encouraged you
with previous API's to batch

292
00:12:45,186 --> 00:12:46,406 A:middle
up lots of work to send,

293
00:12:46,766 --> 00:12:48,756 A:middle
to try to amortize
these expensive costs

294
00:12:49,096 --> 00:12:50,646 A:middle
across a fewer number
of draw calls

295
00:12:50,646 --> 00:12:52,926 A:middle
and just give more per
draw call to the GPU.

296
00:12:53,566 --> 00:12:57,526 A:middle
And, of course, this tends to
work at the cost of flexibility

297
00:12:57,526 --> 00:12:59,686 A:middle
to you, the developer, and
to your game designers,

298

299
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

300
00:13:00,346 --> 00:13:03,456 A:middle
but it also increases latency
because now the GPU has more

301
00:13:03,456 --> 00:13:05,266 A:middle
to work on in a single chunk.

302
00:13:06,336 --> 00:13:08,976 A:middle
So we wanted to fix
these 3 key areas

303
00:13:09,416 --> 00:13:11,346 A:middle
of expense for GPU programming.

304
00:13:12,296 --> 00:13:16,576 A:middle
To do that, we thought
about 3 times, 3 occurrences

305
00:13:16,906 --> 00:13:18,976 A:middle
in the application life
cycle to focus in on.

306
00:13:19,456 --> 00:13:20,756 A:middle
There's the application
build time,

307
00:13:21,616 --> 00:13:23,616 A:middle
there's when you're loading
the content for your game,

308
00:13:23,916 --> 00:13:26,136 A:middle
and then when, there's when
you draw, and they occur

309
00:13:26,136 --> 00:13:27,196 A:middle
at different frequencies.

310
00:13:28,396 --> 00:13:30,496 A:middle
So, first, application
build time.

311
00:13:31,156 --> 00:13:32,556 A:middle
This basically never occurs.

312
00:13:33,806 --> 00:13:35,636 A:middle
I see some surprised
look on your faces

313
00:13:35,636 --> 00:13:38,066 A:middle
because as developers you think
you're building your application

314
00:13:38,186 --> 00:13:40,606 A:middle
all the time, and that's true.

315
00:13:41,126 --> 00:13:43,556 A:middle
But from your customer's
perspective,

316
00:13:43,556 --> 00:13:45,196 A:middle
from the people using
your application,

317
00:13:45,446 --> 00:13:46,396 A:middle
they never see this.

318
00:13:46,396 --> 00:13:49,126 A:middle
So if we can move things to
occur at application build time,

319
00:13:49,586 --> 00:13:51,046 A:middle
you've just eliminated
this expense

320
00:13:51,296 --> 00:13:52,396 A:middle
from the experience
of your game.

321
00:13:52,856 --> 00:13:55,096 A:middle
And then you have
content loading time,

322
00:13:55,416 --> 00:13:58,456 A:middle
which is relatively rare, again,
from a user's perspective.

323
00:13:58,456 --> 00:14:01,156 A:middle
They're only going to load a
level a few times per play.

324

325
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

326
00:13:58,456 --> 00:14:01,156 A:middle
They're only going to load a
level a few times per play.

327
00:14:01,656 --> 00:14:05,236 A:middle
You have draw calls, on the
other hand, you're going

328
00:14:05,236 --> 00:14:07,956 A:middle
to do this thousands, ideally
thousands of times per frame.

329
00:14:08,746 --> 00:14:12,846 A:middle
And before Metal, unfortunately,
all 3 of those expensive bits

330
00:14:12,846 --> 00:14:15,476 A:middle
of operations for
the CPU occurred

331
00:14:15,476 --> 00:14:18,226 A:middle
in this last time,
at draw call time.

332
00:14:18,946 --> 00:14:21,076 A:middle
Thousands of time per
frame, or more likely,

333
00:14:21,246 --> 00:14:22,416 A:middle
a few hundred times per frame

334
00:14:22,416 --> 00:14:24,076 A:middle
because that's all
the CPU could absorb.

335
00:14:25,296 --> 00:14:28,946 A:middle
Now with metal, we've moved
these expensive operations

336
00:14:28,946 --> 00:14:30,736 A:middle
to occur much more optimally.

337
00:14:31,416 --> 00:14:34,556 A:middle
So you put shader compilation to
occur at application build time,

338
00:14:34,716 --> 00:14:37,586 A:middle
again, out of the field of view
for the users of your game.

339
00:14:38,326 --> 00:14:41,826 A:middle
And content loading, that's
when we do state validation.

340
00:14:42,336 --> 00:14:43,896 A:middle
This, again, is relatively rare.

341
00:14:44,656 --> 00:14:46,056 A:middle
This means the only
thing we have to do

342
00:14:46,056 --> 00:14:47,946 A:middle
at draw call time is the
most important thing to do

343
00:14:47,946 --> 00:14:50,606 A:middle
at draw call time, which is
kick off the work on the GPU.

344
00:14:51,086 --> 00:14:56,156 A:middle
So that's the how and the why
we created Metal, and now I want

345
00:14:56,156 --> 00:14:59,636 A:middle
to take a deeper look at the API
itself, and we'll take a look

346
00:14:59,636 --> 00:15:02,496 A:middle
at some of the conceptual
framework for the API starting

347

348
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

349
00:14:59,636 --> 00:15:02,496 A:middle
at some of the conceptual
framework for the API starting

350
00:15:03,256 --> 00:15:04,466 A:middle
with the objects in the API.

351
00:15:05,166 --> 00:15:08,286 A:middle
So the first object to talk

352
00:15:08,286 --> 00:15:10,096 A:middle
about in the Metal
API is the device,

353
00:15:10,846 --> 00:15:13,196 A:middle
and this essentially is just
an abstraction on the GPU,

354
00:15:13,196 --> 00:15:13,796 A:middle
the thing that's going

355
00:15:13,796 --> 00:15:16,476 A:middle
to consume your Rendering
and compute commands.

356
00:15:17,936 --> 00:15:20,286 A:middle
Those commands will be
stored and submitted

357
00:15:20,286 --> 00:15:21,816 A:middle
to the GPU in a command queue.

358
00:15:22,566 --> 00:15:25,036 A:middle
Now the command queue, its
job is simply to decide

359
00:15:25,036 --> 00:15:28,846 A:middle
and let you specify what order
those commands will be executed.

360
00:15:30,156 --> 00:15:31,826 A:middle
Those commands themselves
are stored

361
00:15:31,826 --> 00:15:33,206 A:middle
in what's called
a command buffer.

362
00:15:34,216 --> 00:15:36,966 A:middle
This stores the translated
hardware commands ready

363
00:15:36,966 --> 00:15:38,866 A:middle
for consumption by the GPU.

364
00:15:39,296 --> 00:15:44,536 A:middle
And the command encoder is the
API object that's responsible

365
00:15:44,536 --> 00:15:45,596 A:middle
for that translation.

366
00:15:45,886 --> 00:15:49,166 A:middle
So when you create a command
encoder, and you use it to write

367
00:15:49,166 --> 00:15:51,936 A:middle
into a command buffer,
that's the translation.

368
00:15:53,946 --> 00:15:56,566 A:middle
The state of the API is
described in a series

369
00:15:56,566 --> 00:15:58,566 A:middle
of state objects for things

370
00:15:58,566 --> 00:16:01,446 A:middle
like how your frame buffers
are set up, how you're blending

371

372
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

373
00:15:58,566 --> 00:16:01,446 A:middle
like how your frame buffers
are set up, how you're blending

374
00:16:01,446 --> 00:16:03,376 A:middle
and your depth and your
sample state is set up.

375
00:16:03,456 --> 00:16:06,546 A:middle
These are all described to the
API in objects, which we'll talk

376
00:16:06,546 --> 00:16:08,806 A:middle
about in all 3 sessions today.

377
00:16:10,006 --> 00:16:10,886 A:middle
And you have the code.

378
00:16:11,606 --> 00:16:13,876 A:middle
Your shaders, your
vertex, your pixel shaders.

379
00:16:14,156 --> 00:16:21,346 A:middle
And, last, you have your data,
your resources, your memory,

380
00:16:21,346 --> 00:16:23,966 A:middle
the textures and
the vertex buffers

381
00:16:23,966 --> 00:16:24,986 A:middle
and the shader constants.

382
00:16:25,016 --> 00:16:26,936 A:middle
Those are all stored
in resources.

383
00:16:27,306 --> 00:16:28,926 A:middle
So let's take a look
next at kind

384
00:16:28,926 --> 00:16:31,286 A:middle
of how these objects
fit together by walking

385
00:16:31,286 --> 00:16:33,416 A:middle
through a bit about how
we construct the objects

386
00:16:33,546 --> 00:16:35,806 A:middle
in the API.

387
00:16:36,026 --> 00:16:38,126 A:middle
So first thing you
have is the device.

388
00:16:39,216 --> 00:16:41,336 A:middle
So like we said, this is
the device's, the GPU.

389
00:16:41,336 --> 00:16:42,716 A:middle
The thing that's going
to consume your commands,

390
00:16:42,916 --> 00:16:44,816 A:middle
and from that you
create the command queue,

391
00:16:45,066 --> 00:16:47,216 A:middle
and typically you'll have one
of these in your application.

392
00:16:48,076 --> 00:16:49,976 A:middle
From the command
queue, you'll create one

393
00:16:49,976 --> 00:16:52,566 A:middle
or more command buffers to use
to store the hardware commands,

394
00:16:52,766 --> 00:16:54,076 A:middle
and you'll write
into those commands

395
00:16:54,336 --> 00:16:56,446 A:middle
with a Render Command
Encoder in this example.

396
00:16:58,386 --> 00:17:00,556 A:middle
Now, in order to
generate those commands,

397

398
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

399
00:16:58,386 --> 00:17:00,556 A:middle
Now, in order to
generate those commands,

400
00:17:00,556 --> 00:17:01,976 A:middle
you need to specify
some information

401
00:17:01,976 --> 00:17:02,966 A:middle
of the Render Command Encoder,

402
00:17:03,296 --> 00:17:06,016 A:middle
and you do that by
attaching various objects

403
00:17:06,126 --> 00:17:07,756 A:middle
to the Render Command
Encoder before you use it.

404
00:17:08,296 --> 00:17:10,876 A:middle
So, for instance, you
specify your data buffers

405
00:17:11,096 --> 00:17:13,356 A:middle
and your textures
that you want to use

406
00:17:13,526 --> 00:17:15,036 A:middle
to do this Rendering operation.

407
00:17:15,826 --> 00:17:18,425 A:middle
Now you'll notice in this
diagram we also show something

408
00:17:18,425 --> 00:17:19,776 A:middle
called the texture descriptor,

409
00:17:20,156 --> 00:17:23,046 A:middle
and the texture descriptor is
used to create the textures.

410
00:17:23,185 --> 00:17:25,306 A:middle
It specifies all of the
necessary state used

411
00:17:25,306 --> 00:17:26,566 A:middle
for texture object creation.

412
00:17:28,236 --> 00:17:30,926 A:middle
Probably the biggest state
object is the Render Pipeline

413
00:17:30,926 --> 00:17:34,126 A:middle
state, and it, too, is
constructed from a descriptor,

414
00:17:34,756 --> 00:17:36,826 A:middle
and the descriptor in
this case describes all

415
00:17:36,826 --> 00:17:38,926 A:middle
of the 3D Rendering
state you need

416
00:17:38,926 --> 00:17:41,606 A:middle
to create a single
Render Pipeline.

417
00:17:42,566 --> 00:17:45,686 A:middle
Similarly, you have descriptors
for your depth and stencil state

418
00:17:45,686 --> 00:17:50,376 A:middle
that you use to create those
objects, and we have a series

419
00:17:50,376 --> 00:17:53,996 A:middle
of state for describing
the Render pass itself.

420
00:17:54,186 --> 00:17:55,886 A:middle
How you're going to
output your Rendering.

421
00:17:56,536 --> 00:17:59,156 A:middle
Now the reason we split the
state up into descriptors

422
00:17:59,486 --> 00:18:02,826 A:middle
and state objects is because
once you've specified what all

423

424
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

425
00:17:59,486 --> 00:18:02,826 A:middle
and state objects is because
once you've specified what all

426
00:18:02,826 --> 00:18:06,366 A:middle
these state combinations should
be, Metal bakes all of these

427
00:18:06,406 --> 00:18:08,966 A:middle
into a small number
of state objects.

428
00:18:08,966 --> 00:18:11,136 A:middle
That now all of the state
has been translated,

429
00:18:11,136 --> 00:18:12,446 A:middle
all the shaders have
been compiled,

430
00:18:12,916 --> 00:18:14,476 A:middle
and the system is ready to go.

431
00:18:14,816 --> 00:18:17,356 A:middle
You can now issue your draw
calls incredibly quickly

432
00:18:17,516 --> 00:18:19,676 A:middle
without worrying that the
implementation's going to have

433
00:18:19,676 --> 00:18:22,376 A:middle
to come around and do some late
binding translation or figure

434
00:18:22,376 --> 00:18:24,356 A:middle
out if what you're trying to
do is valid in the first place.

435
00:18:24,686 --> 00:18:26,756 A:middle
A couple more notes.

436
00:18:27,326 --> 00:18:30,566 A:middle
So the source resources of
textures and buffers here,

437
00:18:30,566 --> 00:18:31,876 A:middle
you can change those as you go.

438
00:18:32,386 --> 00:18:34,356 A:middle
The Render targets
themselves are fixed

439
00:18:34,426 --> 00:18:35,966 A:middle
for a given Render
command decoder.

440
00:18:36,466 --> 00:18:41,866 A:middle
We'll talk more about why that's
important in just a moment.

441
00:18:41,866 --> 00:18:43,516 A:middle
Now inverting this
diagram a little bit,

442
00:18:43,516 --> 00:18:45,736 A:middle
we can see how objects
are actually sending data

443
00:18:45,736 --> 00:18:46,396 A:middle
to the device.

444
00:18:46,686 --> 00:18:48,606 A:middle
You can have one or more
Render Command Encoders,

445
00:18:48,806 --> 00:18:51,756 A:middle
one for each Rendering pass,
writing into the command buffer.

446
00:18:53,056 --> 00:18:55,566 A:middle
You can also interleave
different types of commands.

447
00:18:55,666 --> 00:18:57,496 A:middle
In this case, I'm
using compute commands

448
00:18:57,526 --> 00:19:00,206 A:middle
in the middle of my frame.

449

450
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

451
00:18:57,526 --> 00:19:00,206 A:middle
in the middle of my frame.

452
00:19:01,176 --> 00:19:05,066 A:middle
And, as we said, Metal supports
efficient multi-threading.

453
00:19:05,066 --> 00:19:07,526 A:middle
You can actually construct
multiple command buffers

454
00:19:07,526 --> 00:19:09,486 A:middle
in parallel using
multiple threads.

455
00:19:09,486 --> 00:19:12,036 A:middle
So let's talk a little bit more

456
00:19:12,036 --> 00:19:13,676 A:middle
about the command
submission model itself

457
00:19:13,766 --> 00:19:14,886 A:middle
to understand how this works.

458
00:19:15,626 --> 00:19:18,566 A:middle
Just as we've said, command
encoders will encode the API

459
00:19:18,566 --> 00:19:20,976 A:middle
of your, it will
encode the API commands

460
00:19:20,976 --> 00:19:21,906 A:middle
into the hardware state,

461
00:19:22,456 --> 00:19:24,176 A:middle
and then they'll
store those commands

462
00:19:24,276 --> 00:19:25,606 A:middle
in the hardware command buffer.

463
00:19:27,176 --> 00:19:29,116 A:middle
There are 3 types
of command encoders

464
00:19:29,116 --> 00:19:32,476 A:middle
for generating 3 different
types of work on the GPU.

465
00:19:32,926 --> 00:19:35,976 A:middle
We have Render, Compute,
and Blit, and we'll talk

466
00:19:35,976 --> 00:19:37,016 A:middle
about each of them in detail.

467
00:19:37,766 --> 00:19:38,886 A:middle
But important to realize here is

468
00:19:38,886 --> 00:19:41,026 A:middle
that you can interleave these
different types of operations

469
00:19:41,336 --> 00:19:42,606 A:middle
in a single command buffer

470
00:19:42,866 --> 00:19:45,066 A:middle
and within a single
frame very efficiently.

471
00:19:45,586 --> 00:19:48,416 A:middle
And this is because the command
encoders themselves encapsulate

472
00:19:48,416 --> 00:19:50,526 A:middle
all the state necessary
so that we don't have

473
00:19:50,566 --> 00:19:53,676 A:middle
to do implicit transitions
between different types

474
00:19:53,676 --> 00:19:56,836 A:middle
of operations and behind the
scenes we don't have to try

475
00:19:56,836 --> 00:19:58,876 A:middle
to save and restore all
of the state necessary

476
00:19:58,876 --> 00:19:59,976 A:middle
for using these different
types of operations.

477

478
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

479
00:20:00,106 --> 00:20:02,656 A:middle
It's all under your
explicit control.

480
00:20:03,156 --> 00:20:07,876 A:middle
The command buffers themselves
are incredibly lightweight,

481
00:20:07,876 --> 00:20:10,336 A:middle
and most applications are
going to create a large number

482
00:20:10,336 --> 00:20:11,526 A:middle
of these in their frames.

483
00:20:11,876 --> 00:20:15,846 A:middle
And you control exactly when

484
00:20:15,846 --> 00:20:19,606 A:middle
and how these get
submitted to the GPU.

485
00:20:19,796 --> 00:20:20,896 A:middle
Once they've been submitted,

486
00:20:21,166 --> 00:20:22,966 A:middle
Metal signals you
the application

487
00:20:23,466 --> 00:20:25,606 A:middle
when those command buffers
have completed their execution

488
00:20:25,606 --> 00:20:26,086 A:middle
on the GPU.

489
00:20:26,086 --> 00:20:29,216 A:middle
And so you get very fine grain
control and clear notifications

490
00:20:29,216 --> 00:20:31,226 A:middle
about exactly what's happening
at any one point in time.

491
00:20:32,556 --> 00:20:35,736 A:middle
And very important to realize
is that these command encoders,

492
00:20:35,976 --> 00:20:38,686 A:middle
they're not just sending some
work off that later is going

493
00:20:38,686 --> 00:20:40,796 A:middle
to be consumed by the CPU.

494
00:20:40,926 --> 00:20:43,206 A:middle
They're actually generating
these commands immediately.

495
00:20:43,206 --> 00:20:44,866 A:middle
There's no deferred
state validation.

496
00:20:45,246 --> 00:20:47,266 A:middle
It's essentially like
they're making a direct call

497
00:20:47,436 --> 00:20:48,336 A:middle
to the GPU driver.

498
00:20:48,856 --> 00:20:52,346 A:middle
As I mentioned, you can also
multi-thread this command

499
00:20:52,346 --> 00:20:54,706 A:middle
encoding to get even
more performance.

500
00:20:55,736 --> 00:20:57,666 A:middle
Multiple command buffers
can be encoded in parallel

501
00:20:57,666 --> 00:21:01,036 A:middle
across threads, and, yet,
you get to decide exactly

502

503
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

504
00:20:57,666 --> 00:21:01,036 A:middle
across threads, and, yet,
you get to decide exactly

505
00:21:01,036 --> 00:21:02,816 A:middle
when those commands
will be executed.

506
00:21:02,816 --> 00:21:05,276 A:middle
So you have the control to
both to split out the order

507
00:21:05,276 --> 00:21:08,216 A:middle
in which the commands will be
constructed while maintaining

508
00:21:08,216 --> 00:21:10,446 A:middle
the order you wish for
their execution on the GPU.

509
00:21:11,076 --> 00:21:13,386 A:middle
And we've provided an incredibly
efficient implementation

510
00:21:13,386 --> 00:21:14,346 A:middle
with no automic [phonetic] locks

511
00:21:14,346 --> 00:21:16,086 A:middle
to make sure you can
get scalable performance

512
00:21:16,236 --> 00:21:17,666 A:middle
across CPU course.

513
00:21:18,266 --> 00:21:19,686 A:middle
So that's the commands.

514
00:21:20,366 --> 00:21:22,756 A:middle
Next we're going to take a look
at the resources, the memory,

515
00:21:22,876 --> 00:21:25,606 A:middle
the objects in the API
for specifying data.

516
00:21:26,266 --> 00:21:30,286 A:middle
Now we've designed the resource
model in Metal explicitly

517
00:21:30,286 --> 00:21:33,066 A:middle
for the A7's unified
memory system.

518
00:21:33,916 --> 00:21:37,466 A:middle
This means that the CPU and the
GPU are sharing the exact same

519
00:21:37,466 --> 00:21:39,656 A:middle
memory for exchanging data.

520
00:21:40,136 --> 00:21:41,456 A:middle
There's no implicit copies.

521
00:21:41,456 --> 00:21:44,306 A:middle
We're not coming in behind
the scenes and taking the data

522
00:21:44,306 --> 00:21:47,426 A:middle
and moving it somewhere
else for the GPU to see it.

523
00:21:47,926 --> 00:21:51,396 A:middle
We also manage the CPU and
GPU cache coherency for you.

524
00:21:51,646 --> 00:21:53,336 A:middle
You don't have to worry
about flushing caches

525
00:21:53,336 --> 00:21:54,636 A:middle
between the CPU and the GPU.

526
00:21:54,926 --> 00:21:57,476 A:middle
You simply have to make sure
that you schedule your work

527
00:21:57,476 --> 00:22:00,926 A:middle
to occur such that the GPU
and the CPU are not writing

528

529
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

530
00:21:57,476 --> 00:22:00,926 A:middle
to occur such that the GPU
and the CPU are not writing

531
00:22:00,926 --> 00:22:02,546 A:middle
to the same chunk of
memory at the same time,

532
00:22:02,676 --> 00:22:05,016 A:middle
but you don't have to do
anything to manage caches.

533
00:22:05,656 --> 00:22:08,556 A:middle
And by you taking on
this responsibility

534
00:22:08,556 --> 00:22:10,826 A:middle
for synchronization
between the GPU and the CPU,

535
00:22:10,976 --> 00:22:13,106 A:middle
we can offer you
significantly higher performance

536
00:22:13,526 --> 00:22:15,416 A:middle
because we're not implicitly
synchronizing things

537
00:22:15,416 --> 00:22:17,436 A:middle
that didn't necessarily
need to be synchronized.

538
00:22:19,376 --> 00:22:21,616 A:middle
There are 2 different
types of resources for you

539
00:22:22,166 --> 00:22:23,766 A:middle
to use in your application.

540
00:22:24,396 --> 00:22:28,096 A:middle
The first is textures, which
are simply formatted image data

541
00:22:28,096 --> 00:22:31,986 A:middle
that you use for
Rendering for source data

542
00:22:32,316 --> 00:22:35,226 A:middle
or for Rendering destinations,
and there are data buffers

543
00:22:35,346 --> 00:22:38,666 A:middle
which are essentially
unformatted ranges of memory.

544
00:22:38,756 --> 00:22:40,266 A:middle
You can think of them
like just a bag of bytes

545
00:22:40,266 --> 00:22:42,336 A:middle
to store your vertex data,
your shader constants,

546
00:22:42,336 --> 00:22:45,086 A:middle
any output memory from
your GPU workloads.

547
00:22:45,086 --> 00:22:49,206 A:middle
The important thing to remember
with Metal is that the structure

548
00:22:49,736 --> 00:22:52,386 A:middle
of these resources is immutable.

549
00:22:52,386 --> 00:22:53,276 A:middle
You cannot change it.

550
00:22:53,276 --> 00:22:56,706 A:middle
Once you create a texture of
a given size or given level

551
00:22:56,706 --> 00:22:59,226 A:middle
or a given format, it's baked,

552
00:22:59,716 --> 00:23:02,796 A:middle
and this lets us avoid
costly resource validation

553

554
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

555
00:22:59,716 --> 00:23:02,796 A:middle
and this lets us avoid
costly resource validation

556
00:23:03,516 --> 00:23:05,416 A:middle
that would previously have
taken place in other API's

557
00:23:05,416 --> 00:23:07,646 A:middle
where we'd have to
figure out, hey,

558
00:23:07,646 --> 00:23:10,056 A:middle
not that you've changed how
a texture is structured,

559
00:23:10,416 --> 00:23:11,236 A:middle
is it still valid.

560
00:23:11,236 --> 00:23:13,296 A:middle
Can we still use it as
a Rendering destination?

561
00:23:13,296 --> 00:23:14,286 A:middle
Is it still [inaudible]
complete?

562
00:23:14,286 --> 00:23:15,506 A:middle
We don't have to do any of that

563
00:23:15,506 --> 00:23:17,196 A:middle
because you've specified
it all up front.

564
00:23:18,326 --> 00:23:20,816 A:middle
If you want to use two
different textures with, sorry.

565
00:23:20,816 --> 00:23:23,666 A:middle
If you want to use two different
formats for your texture,

566
00:23:23,666 --> 00:23:25,436 A:middle
you simply create two
different textures,

567
00:23:25,766 --> 00:23:27,096 A:middle
and this is actually
much more efficient.

568
00:23:27,096 --> 00:23:29,976 A:middle
We can rapidly switch
between these on,

569
00:23:30,036 --> 00:23:31,136 A:middle
in the Metal implementation.

570
00:23:31,656 --> 00:23:35,676 A:middle
Of course, you can still change
the contents of your textures

571
00:23:35,766 --> 00:23:37,746 A:middle
for your buffers,
and to do that,

572
00:23:38,026 --> 00:23:39,146 A:middle
we provide several methods.

573
00:23:39,976 --> 00:23:41,826 A:middle
So you can update
data buffers directly.

574
00:23:42,006 --> 00:23:44,276 A:middle
You simply get a pointer
to the underlying storage.

575
00:23:44,636 --> 00:23:47,106 A:middle
There's no lock API needed
because, again, this is running

576
00:23:47,106 --> 00:23:50,306 A:middle
on a unified memory
system, and for textures,

577
00:23:50,556 --> 00:23:52,816 A:middle
we have what's called an
implementation private storage.

578
00:23:53,116 --> 00:23:54,676 A:middle
Now this doesn't mean that
we're copying the data

579
00:23:54,676 --> 00:23:55,886 A:middle
and moving it somewhere else.

580
00:23:56,126 --> 00:23:58,396 A:middle
This simply means that we
will reformat the textures

581
00:23:58,396 --> 00:24:00,476 A:middle
for efficient Rendering
on the GPU,

582

583
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

584
00:23:58,396 --> 00:24:00,476 A:middle
for efficient Rendering
on the GPU,

585
00:24:00,476 --> 00:24:03,556 A:middle
but we provide some
blazing fast update routines

586
00:24:03,626 --> 00:24:05,016 A:middle
in Metal to do that.

587
00:24:05,446 --> 00:24:09,426 A:middle
If you need an asynchronous
update routine for your textures

588
00:24:09,426 --> 00:24:11,556 A:middle
or your buffers, you can do
this via the Blit Encoder,

589
00:24:11,836 --> 00:24:14,156 A:middle
and we'll talk in just a
moment about how that works.

590
00:24:16,726 --> 00:24:19,146 A:middle
Now one other thing you can do
with resources, and textures

591
00:24:19,146 --> 00:24:21,326 A:middle
in particular, is you can
actually share the underlying

592
00:24:21,326 --> 00:24:23,266 A:middle
storage across multiple textures

593
00:24:23,636 --> 00:24:26,826 A:middle
and reinterpret the pixel
data differently in each one.

594
00:24:27,456 --> 00:24:29,026 A:middle
So, for instance, if
you have a texture

595
00:24:29,446 --> 00:24:32,916 A:middle
that is using a single
32-bit integer pixel format,

596
00:24:33,466 --> 00:24:34,526 A:middle
you can have another texture

597
00:24:34,526 --> 00:24:39,806 A:middle
which is using a 4-component
RGBA8 pixel format,

598
00:24:39,806 --> 00:24:41,096 A:middle
and they can actually
be pointing

599
00:24:41,096 --> 00:24:42,336 A:middle
at the same underlying storage

600
00:24:42,556 --> 00:24:45,206 A:middle
because the pixel size is
the same between the 2.

601
00:24:46,496 --> 00:24:48,556 A:middle
And you can also share
the texture storage

602
00:24:48,966 --> 00:24:49,666 A:middle
with data buffers.

603
00:24:50,126 --> 00:24:53,506 A:middle
This will allow you direct
access to the underlying storage

604
00:24:53,506 --> 00:24:55,556 A:middle
with the CPU and to use
the underlying storage

605
00:24:55,556 --> 00:24:58,806 A:middle
as a data buffer, and we
simply assume row lineal,

606
00:24:58,986 --> 00:25:02,336 A:middle
row linear pixel order
in this particular case.

607

608
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

609
00:24:58,986 --> 00:25:02,336 A:middle
row linear pixel order
in this particular case.

610
00:25:02,496 --> 00:25:04,046 A:middle
OK. Those are resources.

611
00:25:04,266 --> 00:25:05,286 A:middle
Now I'm going to talk briefly

612
00:25:05,446 --> 00:25:08,146 A:middle
about the command encoders
themselves, and as I mentioned,

613
00:25:08,226 --> 00:25:10,316 A:middle
there are 3 basic
command encoder types.

614
00:25:11,146 --> 00:25:15,336 A:middle
You have your Render, Compute,
and Blit command encoders,

615
00:25:15,496 --> 00:25:18,066 A:middle
and I'm going to talk about
each of these in sequence.

616
00:25:18,776 --> 00:25:21,196 A:middle
So first off the
Render Command Encoder.

617
00:25:21,196 --> 00:25:24,576 A:middle
Now the Render Command Encoder,
you can think about this as all

618
00:25:24,576 --> 00:25:25,996 A:middle
of the hardware commands
necessary

619
00:25:26,136 --> 00:25:29,496 A:middle
for generating a single
Rendering pass, and by pass,

620
00:25:29,496 --> 00:25:32,516 A:middle
I mean all of the Rendering
to one frame buffer object,

621
00:25:32,516 --> 00:25:33,696 A:middle
one set of Render targets.

622
00:25:34,226 --> 00:25:37,656 A:middle
If you want to change to
another set of Render targets

623
00:25:37,736 --> 00:25:38,846 A:middle
to another frame buffer,

624
00:25:39,386 --> 00:25:41,626 A:middle
you simply use another
Render Command Encoder,

625
00:25:42,216 --> 00:25:45,096 A:middle
and this is all the state
for specifying the vertex

626
00:25:45,096 --> 00:25:47,896 A:middle
and fragment stages
of the 3D pipeline.

627
00:25:48,376 --> 00:25:51,366 A:middle
And it allows you to
interleave these state changes,

628
00:25:51,486 --> 00:25:53,966 A:middle
the resources, and any
draw calls necessary

629
00:25:53,966 --> 00:25:56,356 A:middle
for constructing your
pass, but, critically,

630
00:25:56,726 --> 00:25:59,016 A:middle
there's no draw time
compilation.

631
00:25:59,926 --> 00:26:02,606 A:middle
You get to control, the
app developer, exactly when

632

633
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

634
00:25:59,926 --> 00:26:02,606 A:middle
You get to control, the
app developer, exactly when

635
00:26:02,606 --> 00:26:04,796 A:middle
and how all of the
state compilation

636
00:26:04,796 --> 00:26:06,846 A:middle
and expensive validation
actually takes place.

637
00:26:08,166 --> 00:26:11,296 A:middle
And you do that with a series
of API calls and state objects,

638
00:26:11,466 --> 00:26:12,906 A:middle
and I'll show you just
a few of those here.

639
00:26:13,576 --> 00:26:15,966 A:middle
So as we talked about, you have
your depth and stencil objects,

640
00:26:16,546 --> 00:26:18,176 A:middle
sampler objects,
the Render Pipeline,

641
00:26:18,476 --> 00:26:20,436 A:middle
and they describe
various aspects

642
00:26:20,516 --> 00:26:23,596 A:middle
of the 3D Rendering state.

643
00:26:25,146 --> 00:26:28,246 A:middle
Basically, almost everything
fits in the Render Pipeline

644
00:26:28,526 --> 00:26:30,246 A:middle
where you, that's where
you specify your shaders,

645
00:26:30,776 --> 00:26:33,386 A:middle
your blend states, all, how
your vertex data is actually

646
00:26:33,386 --> 00:26:36,736 A:middle
specified, and all of that can
fit into these state objects.

647
00:26:36,936 --> 00:26:40,166 A:middle
Now important to
realize in Metal is

648
00:26:40,166 --> 00:26:42,406 A:middle
that not all state
objects are created equal.

649
00:26:42,716 --> 00:26:45,176 A:middle
Some of the states are actually
very expensive to change,

650
00:26:45,356 --> 00:26:47,986 A:middle
and for these, we've put them
in what's called immutable

651
00:26:47,986 --> 00:26:49,466 A:middle
or unchangeable state objects,

652
00:26:50,456 --> 00:26:51,826 A:middle
and you can't change
these states

653
00:26:51,876 --> 00:26:53,376 A:middle
after you've created
the objects.

654
00:26:53,696 --> 00:26:56,616 A:middle
These are the types of things
that affect expensive operations

655
00:26:56,616 --> 00:26:58,686 A:middle
or cause recompilation to occur.

656
00:26:59,346 --> 00:27:02,336 A:middle
So things like the shaders
themselves we don't want to be,

657

658
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

659
00:26:59,346 --> 00:27:02,336 A:middle
So things like the shaders
themselves we don't want to be,

660
00:27:02,336 --> 00:27:04,466 A:middle
you don't us to be
recompiling them all the time.

661
00:27:04,856 --> 00:27:07,436 A:middle
So once you specified
those into a state object,

662
00:27:07,866 --> 00:27:08,506 A:middle
you can't change them.

663
00:27:09,226 --> 00:27:10,926 A:middle
But other things, like
the viewport and scissor,

664
00:27:10,926 --> 00:27:13,366 A:middle
are actually really cheap
to specify and really cheap

665
00:27:13,366 --> 00:27:15,636 A:middle
to change, and so
those remain flexible.

666
00:27:16,146 --> 00:27:21,106 A:middle
Now I talked a few times
about how the API was designed

667
00:27:21,386 --> 00:27:25,766 A:middle
with the A7 in mind, and one of
the key ways you can see this is

668
00:27:25,766 --> 00:27:28,166 A:middle
in how we handle frame
buffer loads and stores.

669
00:27:28,166 --> 00:27:34,346 A:middle
Now the A7 GPU is a
tile-based deferred mode Render.

670
00:27:34,346 --> 00:27:37,716 A:middle
Now I'm not going to go into
the details of what this means,

671
00:27:37,716 --> 00:27:39,786 A:middle
but one important
piece of that is

672
00:27:39,786 --> 00:27:45,366 A:middle
that it has what's called a tile
cache, and a tile cache is used

673
00:27:45,366 --> 00:27:47,466 A:middle
at the beginning and end
of each Rendering pass

674
00:27:47,766 --> 00:27:50,806 A:middle
to load the contents of
the previous frame buffer

675
00:27:50,806 --> 00:27:53,726 A:middle
or to write it up to memory.

676
00:27:53,726 --> 00:27:57,366 A:middle
And so you need some explicit
control over this tile cache

677
00:27:57,366 --> 00:27:58,586 A:middle
to get optimal performance

678
00:27:58,586 --> 00:28:00,486 A:middle
and to make sure you're
not doing needless reads

679

680
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

681
00:27:58,586 --> 00:28:00,486 A:middle
and to make sure you're
not doing needless reads

682
00:28:00,486 --> 00:28:01,206 A:middle
and writes to memory.

683
00:28:01,886 --> 00:28:04,846 A:middle
In Metal, you can specify
load and store actions

684
00:28:04,846 --> 00:28:07,556 A:middle
on the frame buffer to make
this incredibly efficient,

685
00:28:07,556 --> 00:28:09,216 A:middle
and I'll show you an example
of how that works here.

686
00:28:10,626 --> 00:28:13,546 A:middle
So let's say, as an example,
this is before Metal,

687
00:28:14,016 --> 00:28:17,296 A:middle
you had one frame
for which you wanted

688
00:28:17,296 --> 00:28:20,376 A:middle
to do two Rendering passes, and
in this example, you're going

689
00:28:20,376 --> 00:28:21,736 A:middle
to take the color frame
buffer, you're going to have

690
00:28:21,736 --> 00:28:22,606 A:middle
to redo the beginning.

691
00:28:22,656 --> 00:28:24,726 A:middle
You're going to write it
out at one pass through,

692
00:28:24,726 --> 00:28:26,666 A:middle
and then you're going to do
the same for the second pass,

693
00:28:26,896 --> 00:28:29,716 A:middle
and you'll probably want to
use a depth buffer as well.

694
00:28:30,166 --> 00:28:33,916 A:middle
So before Metal, you can
actually see here there was

695
00:28:33,916 --> 00:28:35,526 A:middle
quite a lot of memory
bandwidth taking place

696
00:28:35,526 --> 00:28:36,506 A:middle
across these passes.

697
00:28:36,826 --> 00:28:40,086 A:middle
You end up with 2 reads and 2
writes for each of the color

698
00:28:40,086 --> 00:28:42,576 A:middle
and the depth buffer, which
is a lot of memory traffic.

699
00:28:43,916 --> 00:28:46,876 A:middle
Well, with Metal, we
actually let you specify

700
00:28:47,166 --> 00:28:49,746 A:middle
which of those reads and writes
you actually need to occur.

701
00:28:50,206 --> 00:28:51,856 A:middle
So, for instance,
you can say, well,

702
00:28:51,856 --> 00:28:54,496 A:middle
I'm going to Render every
pixel of my frame anyway.

703
00:28:54,496 --> 00:28:56,846 A:middle
There's no point in loading
the tile cache at the beginning

704
00:28:56,846 --> 00:28:58,696 A:middle
of the frame, and I can
save that bandwidth.

705
00:28:59,466 --> 00:29:01,736 A:middle
And if you're going to write
out the pass and then read it

706

707
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

708
00:28:59,466 --> 00:29:01,736 A:middle
And if you're going to write
out the pass and then read it

709
00:29:01,736 --> 00:29:04,526 A:middle
in the second pass, you probably
would need to actually do that,

710
00:29:05,186 --> 00:29:07,266 A:middle
but when you look at the depth
buffer, you can see a lot

711
00:29:07,266 --> 00:29:08,646 A:middle
of unnecessary reads and writes.

712
00:29:08,926 --> 00:29:11,876 A:middle
And so you can specify that we
should probably just clear the

713
00:29:11,876 --> 00:29:13,356 A:middle
depth buffer at the
beginning of the frame

714
00:29:13,356 --> 00:29:15,206 A:middle
because you're not going to
need its previous contents,

715
00:29:15,596 --> 00:29:17,296 A:middle
and you don't need to write
it out at the end of the frame

716
00:29:17,296 --> 00:29:18,796 A:middle
because you're not using
it in a second pass.

717
00:29:18,796 --> 00:29:21,216 A:middle
You're simply going to clear it
again, and then you don't need

718
00:29:21,216 --> 00:29:22,126 A:middle
to write it out there either,

719
00:29:22,586 --> 00:29:24,846 A:middle
and we can get some
dramatic reductions

720
00:29:24,876 --> 00:29:26,526 A:middle
in memory traffic
as a result of this.

721
00:29:27,786 --> 00:29:30,456 A:middle
You can reduce the overall
amount of reads and writes

722
00:29:30,646 --> 00:29:32,376 A:middle
to a fraction of
what it was before,

723
00:29:32,546 --> 00:29:34,296 A:middle
and you can gain
significant performance

724
00:29:34,296 --> 00:29:35,066 A:middle
for your application.

725
00:29:35,856 --> 00:29:37,336 A:middle
So this is just one of the ways

726
00:29:37,336 --> 00:29:39,506 A:middle
in which we've designed
Metal with the A7 in mind.

727
00:29:39,916 --> 00:29:42,566 A:middle
Alright. That's Rendering.

728
00:29:42,566 --> 00:29:45,376 A:middle
Now we're going to look at
the next area we introduced

729
00:29:45,376 --> 00:29:48,416 A:middle
with Metal, a functionality,
which is Compute.

730
00:29:49,156 --> 00:29:51,086 A:middle
So we're not going to spend
a lot of time today talking

731
00:29:51,086 --> 00:29:54,506 A:middle
about general purpose data
parallel computation in the GPU,

732
00:29:54,696 --> 00:29:56,076 A:middle
but for those of you
who have done this type

733
00:29:56,076 --> 00:29:57,826 A:middle
of operation before,
you're going to find

734
00:29:57,826 --> 00:29:59,976 A:middle
that this is a very familiar
run time in memory model.

735

736
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

737
00:30:00,066 --> 00:30:03,266 A:middle
It uses the same
textures and data buffers

738
00:30:03,266 --> 00:30:07,496 A:middle
from the Metal graphics API's,
has the same basic kinds

739
00:30:07,496 --> 00:30:10,096 A:middle
of memory hierarchy,
barriers, memories,

740
00:30:10,096 --> 00:30:11,156 A:middle
and load stores you might find

741
00:30:11,156 --> 00:30:13,036 A:middle
in other data parallel
programming API's,

742
00:30:13,516 --> 00:30:14,486 A:middle
and you can configure

743
00:30:14,486 --> 00:30:16,696 A:middle
and specify exactly
how the work groups

744
00:30:16,696 --> 00:30:19,236 A:middle
for your Compute operations
will be executed by the GPU.

745
00:30:21,116 --> 00:30:24,716 A:middle
Probably more important
to realize with Metal is

746
00:30:24,716 --> 00:30:27,256 A:middle
that it is, the Compute
operations are fully integrated

747
00:30:27,256 --> 00:30:27,746 A:middle
with graphics.

748
00:30:28,856 --> 00:30:32,106 A:middle
This means you get a unified
API, a single shading language,

749
00:30:32,286 --> 00:30:34,446 A:middle
and a single set of
fantastic developer tools

750
00:30:34,446 --> 00:30:37,046 A:middle
for both graphics and
compute operations on the GPU.

751
00:30:37,046 --> 00:30:40,316 A:middle
And probably more
important for performance,

752
00:30:40,756 --> 00:30:43,266 A:middle
we can efficiently
interleave these operations

753
00:30:43,436 --> 00:30:45,116 A:middle
between Compute, Rendering,

754
00:30:45,506 --> 00:30:47,766 A:middle
and data [inaudible]
operations in Blit.

755
00:30:49,336 --> 00:30:53,416 A:middle
Similarly, to graphics, there's
no execution time compilation

756
00:30:53,566 --> 00:30:54,716 A:middle
with the Compute operations.

757
00:30:55,036 --> 00:30:59,116 A:middle
You control exactly when these
expensive compilation activities

758
00:30:59,116 --> 00:30:59,546 A:middle
will occur.

759

760
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

761
00:31:00,056 --> 00:31:02,316 A:middle
And probably a little
bit different

762
00:31:02,316 --> 00:31:06,156 A:middle
from how graphics looks in
Metal, there's very little state

763
00:31:06,206 --> 00:31:07,556 A:middle
in the Compute command encoder.

764
00:31:07,976 --> 00:31:09,546 A:middle
There's some state
for specifying exactly

765
00:31:09,546 --> 00:31:10,996 A:middle
which Compute kernels
you're going to be using

766
00:31:10,996 --> 00:31:12,516 A:middle
and how you're going to
configure work groups,

767
00:31:12,516 --> 00:31:13,476 A:middle
and that's pretty much it.

768
00:31:13,966 --> 00:31:15,586 A:middle
And that's it.

769
00:31:15,746 --> 00:31:17,456 A:middle
If the Compute command
encoder seems simple,

770
00:31:17,486 --> 00:31:19,856 A:middle
that's because it is,
and that brings us

771
00:31:19,856 --> 00:31:22,666 A:middle
to our last command encoder,
the Blit Command Encoder,

772
00:31:23,226 --> 00:31:25,976 A:middle
and this is what you're going to
use for asynchronous data copies

773
00:31:26,006 --> 00:31:29,216 A:middle
between resources on the GPU,
and this can happen in parallel

774
00:31:29,216 --> 00:31:31,376 A:middle
with your compute and
your graphics operations.

775
00:31:32,216 --> 00:31:34,606 A:middle
You can use this to upload
textures, to copy data

776
00:31:34,606 --> 00:31:38,846 A:middle
between textures and buffers,
or to generate your mipmaps.

777
00:31:39,596 --> 00:31:42,756 A:middle
You can also update the data
buffers themselves, again,

778
00:31:42,756 --> 00:31:45,016 A:middle
copying to and from
textures or other buffers,

779
00:31:45,196 --> 00:31:47,716 A:middle
and you can actually fill
the buffers themselves

780
00:31:47,716 --> 00:31:49,896 A:middle
with constant values and
Blit Command Encoder.

781
00:31:50,266 --> 00:31:53,956 A:middle
Alright. That's it for the
API high level summary.

782
00:31:53,956 --> 00:31:55,416 A:middle
Now I'm going to
take a quick tour

783
00:31:55,626 --> 00:31:56,746 A:middle
through the shading
language itself.

784

785
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

786
00:32:00,506 --> 00:32:04,216 A:middle
Alright. So the Metal
shading language is a unified

787
00:32:04,216 --> 00:32:04,986 A:middle
shading language.

788
00:32:05,306 --> 00:32:07,926 A:middle
This means use the same
language, syntax, constructs,

789
00:32:07,926 --> 00:32:10,096 A:middle
tool change for both graphics
and compute processing,

790
00:32:10,696 --> 00:32:14,636 A:middle
and it's based on C++11,
essentially a static subset

791
00:32:14,856 --> 00:32:19,186 A:middle
of this language, and it's
built out of LLVM and clang,

792
00:32:19,366 --> 00:32:21,316 A:middle
which means you get
incredibly high performance

793
00:32:21,316 --> 00:32:24,696 A:middle
and incredibly high quality
code generation for the GPU.

794
00:32:25,006 --> 00:32:28,336 A:middle
The only thing we've really
had to do was add some syntax

795
00:32:28,336 --> 00:32:30,356 A:middle
for describing certain
hardware functionality

796
00:32:30,356 --> 00:32:32,116 A:middle
such as how you're going
to control texture sampling

797
00:32:32,116 --> 00:32:34,806 A:middle
and rasterization, and then
we've added a few things

798
00:32:34,806 --> 00:32:37,086 A:middle
to make shader authoring
much more convenient

799
00:32:37,086 --> 00:32:39,426 A:middle
such as function overloading
and basic template support.

800
00:32:40,456 --> 00:32:40,966 A:middle
But that's it.

801
00:32:41,046 --> 00:32:44,666 A:middle
If you know C++, you understand
Metal shading language.

802
00:32:44,956 --> 00:32:50,076 A:middle
As I said, we added just a
few data types and some syntax

803
00:32:50,076 --> 00:32:52,306 A:middle
for handling graphics and
compute functionality.

804
00:32:52,466 --> 00:32:55,296 A:middle
Some basic data types you'll
probably find very useful

805
00:32:55,296 --> 00:32:56,926 A:middle
such as scaler, vector,
and matrix types,

806
00:32:57,516 --> 00:33:01,106 A:middle
and then we've used what's
called the attribute syntax

807

808
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

809
00:32:57,516 --> 00:33:01,106 A:middle
and then we've used what's
called the attribute syntax

810
00:33:01,136 --> 00:33:04,926 A:middle
to specify a lot of the
connection between the Metal API

811
00:33:04,926 --> 00:33:06,276 A:middle
and the Metal shading language.

812
00:33:06,496 --> 00:33:08,886 A:middle
So things like how do you get
data in and out of your shaders.

813
00:33:08,886 --> 00:33:11,076 A:middle
You specify those with
function arguments

814
00:33:11,076 --> 00:33:14,576 A:middle
and use the attribute syntax to
actually identify which textures

815
00:33:14,576 --> 00:33:15,656 A:middle
and buffers you want to use.

816
00:33:16,606 --> 00:33:19,186 A:middle
Or how to implement programmable
blending in your shaders.

817
00:33:19,186 --> 00:33:20,536 A:middle
You can actually use
the attribute syntax

818
00:33:20,536 --> 00:33:23,856 A:middle
to specify pixels you want to
read from the frame buffer.

819
00:33:24,236 --> 00:33:27,706 A:middle
The Metal shading language
itself is incredibly easy

820
00:33:27,706 --> 00:33:28,236 A:middle
to use.

821
00:33:28,436 --> 00:33:30,936 A:middle
You can put multiple shaders
in a single source code file,

822
00:33:31,126 --> 00:33:34,276 A:middle
and then we will build those
source code files with Xcode

823
00:33:34,276 --> 00:33:35,976 A:middle
when you're building
your application

824
00:33:36,376 --> 00:33:38,416 A:middle
into Metal library files,

825
00:33:38,916 --> 00:33:41,586 A:middle
and the Metal library files
are essentially just an archive

826
00:33:41,586 --> 00:33:42,576 A:middle
of your Metal shaders.

827
00:33:43,596 --> 00:33:44,676 A:middle
With the Metal run time API's,

828
00:33:44,676 --> 00:33:46,526 A:middle
you can actually
load a Metal library,

829
00:33:46,596 --> 00:33:48,396 A:middle
and then you can
finalize the compilation

830
00:33:48,396 --> 00:33:51,016 A:middle
into this device's
machine specific code.

831
00:33:52,036 --> 00:33:54,716 A:middle
We also include an
awesome standard library

832
00:33:54,716 --> 00:33:58,336 A:middle
of very commonly used and
incredibly performing graphics

833
00:33:58,336 --> 00:33:59,166 A:middle
and compute functions.

834
00:33:59,556 --> 00:34:02,866 A:middle
One other thing to realize

835

836
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

837
00:33:59,556 --> 00:34:02,866 A:middle
One other thing to realize

838
00:34:02,866 --> 00:34:04,826 A:middle
about the Metal shading language
is you need to get data in

839
00:34:04,826 --> 00:34:05,786 A:middle
and out of your shaders.

840
00:34:05,986 --> 00:34:09,076 A:middle
So we specify, use a method
called argument tables

841
00:34:09,106 --> 00:34:11,755 A:middle
to let you specify which
arguments, which resources,

842
00:34:12,036 --> 00:34:14,136 A:middle
and which data needs
to move between the API

843
00:34:14,136 --> 00:34:15,795 A:middle
and the shading environment.

844
00:34:17,735 --> 00:34:20,536 A:middle
So each command encoder will
include what's called an

845
00:34:20,536 --> 00:34:22,656 A:middle
argument table, and
this is simply a list

846
00:34:22,656 --> 00:34:25,235 A:middle
of the resources you want to use
in the API that you want to read

847
00:34:25,235 --> 00:34:28,386 A:middle
and access and write in
the shader themselves.

848
00:34:28,755 --> 00:34:34,466 A:middle
There's one table for each type
of resource, and then the shader

849
00:34:34,686 --> 00:34:38,036 A:middle
and the host code will simply
use an index into that table

850
00:34:38,036 --> 00:34:39,255 A:middle
to refer to the same resource.

851
00:34:39,255 --> 00:34:40,025 A:middle
Let's see an example.

852
00:34:40,196 --> 00:34:44,746 A:middle
So on the right here, I simply
have a representation of one

853
00:34:44,746 --> 00:34:45,755 A:middle
of the command encoders.

854
00:34:45,795 --> 00:34:47,795 A:middle
Could be Render Command
Encoder, for instance.

855
00:34:48,426 --> 00:34:51,136 A:middle
And you have a table
in the command encoder

856
00:34:51,136 --> 00:34:53,226 A:middle
that describes the resources.

857
00:34:53,295 --> 00:34:55,846 A:middle
So you have a list of all
of the textures you want

858
00:34:55,846 --> 00:34:57,206 A:middle
to use in your shaders.

859
00:34:59,256 --> 00:35:01,806 A:middle
Similar tables exist for
buffers and samplers.

860

861
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

862
00:34:59,256 --> 00:35:01,806 A:middle
Similar tables exist for
buffers and samplers.

863
00:35:02,196 --> 00:35:03,366 A:middle
Now I've simplified
this a little bit

864
00:35:03,366 --> 00:35:05,666 A:middle
because there's actually 1 of
these sets of tables for each

865
00:35:05,666 --> 00:35:07,356 A:middle
of the vertex and
fragment shader stages.

866
00:35:07,596 --> 00:35:09,116 A:middle
Well, let's take a look
at an example shader.

867
00:35:09,266 --> 00:35:13,236 A:middle
So in this, we have a vertex
shader and a fragment shader

868
00:35:13,416 --> 00:35:14,596 A:middle
in Metal shader code
on the left,

869
00:35:14,596 --> 00:35:16,336 A:middle
and you'll see it
looks quite familiar.

870
00:35:16,666 --> 00:35:18,666 A:middle
You'll get a lot more
information about how this works

871
00:35:18,666 --> 00:35:20,576 A:middle
in the next session, but
you can get a good sense

872
00:35:20,576 --> 00:35:21,776 A:middle
of how this works
just from looking

873
00:35:21,776 --> 00:35:25,226 A:middle
at the code itself right here.

874
00:35:25,226 --> 00:35:28,946 A:middle
So in the fragment shader, we're
simply referring to texture

875
00:35:29,056 --> 00:35:32,096 A:middle
at index 1 to identify that we
would like to use the texture

876
00:35:32,096 --> 00:35:34,906 A:middle
that we set up in the
command encoder to read

877
00:35:35,226 --> 00:35:36,176 A:middle
in this fragment shader.

878
00:35:36,996 --> 00:35:39,906 A:middle
And, similarly, in the vertex
shader, we can do the same thing

879
00:35:39,906 --> 00:35:42,706 A:middle
with the buffers, and use those
as inputs to the vertex shader

880
00:35:42,746 --> 00:35:45,356 A:middle
and refer back to the
argument index table

881
00:35:45,466 --> 00:35:46,286 A:middle
and the command encoder.

882
00:35:46,726 --> 00:35:49,126 A:middle
So you set up the command
encoder's argument tables

883
00:35:49,336 --> 00:35:53,036 A:middle
with the API and simply
refer to those resources

884
00:35:53,466 --> 00:35:55,396 A:middle
in your shaders using
the attribute syntax

885
00:35:55,586 --> 00:35:56,946 A:middle
and function arguments
themselves.

886
00:35:57,306 --> 00:35:58,666 A:middle
And that's it.

887
00:35:59,206 --> 00:36:01,406 A:middle
The shading language is
actually pretty simple,

888

889
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

890
00:35:59,206 --> 00:36:01,406 A:middle
The shading language is
actually pretty simple,

891
00:36:01,476 --> 00:36:03,156 A:middle
and we think you're
going to really like it.

892
00:36:03,566 --> 00:36:04,936 A:middle
And, next, I'm going
to talk about how

893
00:36:04,936 --> 00:36:07,126 A:middle
to build your Metal
application using our awesome

894
00:36:07,126 --> 00:36:07,966 A:middle
developer tools.

895
00:36:08,296 --> 00:36:09,826 A:middle
And probably the most important

896
00:36:09,826 --> 00:36:14,566 A:middle
of those developer tools is
the Metal shader complier.

897
00:36:15,726 --> 00:36:17,626 A:middle
Now, ideally, you don't
even know this exists

898
00:36:17,896 --> 00:36:20,426 A:middle
because we're simply going to
build your shader sources just

899
00:36:20,426 --> 00:36:22,396 A:middle
like we build the rest of
your application sources

900
00:36:22,516 --> 00:36:23,626 A:middle
at application build time.

901
00:36:24,006 --> 00:36:26,756 A:middle
There's no need for you to
separate out your shaders

902
00:36:26,756 --> 00:36:28,096 A:middle
and specify them at run time.

903
00:36:28,386 --> 00:36:29,736 A:middle
You can actually ship them

904
00:36:30,026 --> 00:36:32,826 A:middle
with your application already
having been precompiled.

905
00:36:32,826 --> 00:36:34,656 A:middle
So there's no source
code that needs to go

906
00:36:34,656 --> 00:36:36,836 A:middle
with your application
for your shaders.

907
00:36:37,176 --> 00:36:39,406 A:middle
But probably more important from
the developer's point of view is

908
00:36:39,406 --> 00:36:41,966 A:middle
that we can actually give you
errors and warnings and guidance

909
00:36:41,966 --> 00:36:44,116 A:middle
about your shaders at
the time you're building

910
00:36:44,116 --> 00:36:44,886 A:middle
your application.

911
00:36:45,106 --> 00:36:45,956 A:middle
So you don't have to wait

912
00:36:46,336 --> 00:36:49,186 A:middle
until your customers are
running your game to find

913
00:36:49,186 --> 00:36:50,746 A:middle
out that you have an error
in one of your shaders.

914
00:36:51,586 --> 00:36:52,136 A:middle
This is awesome.

915
00:36:53,436 --> 00:36:56,346 A:middle
Those shaders will then be
compiled into Metal libraries

916
00:36:56,346 --> 00:36:59,456 A:middle
by Xcode and then
compiled to device code

917
00:36:59,796 --> 00:37:02,046 A:middle
at the time you create your
state objects themselves.

918

919
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

920
00:36:59,796 --> 00:37:02,046 A:middle
at the time you create your
state objects themselves.

921
00:37:02,416 --> 00:37:04,366 A:middle
So, again, there's no
draw time compilation,

922
00:37:05,276 --> 00:37:07,466 A:middle
and we will cache
this compilation,

923
00:37:07,546 --> 00:37:09,876 A:middle
this final device machine
specific compilation

924
00:37:10,676 --> 00:37:11,386 A:middle
on the device.

925
00:37:12,196 --> 00:37:15,106 A:middle
So we won't be continually doing
even this last translation step.

926
00:37:16,396 --> 00:37:19,436 A:middle
Now for those of you who like
to specify your source code

927
00:37:19,676 --> 00:37:22,006 A:middle
at run time, perhaps you're
constructing strings on the fly,

928
00:37:22,006 --> 00:37:24,226 A:middle
we do provide a runtime
shader compiler as well.

929
00:37:24,466 --> 00:37:26,196 A:middle
This can also be really
useful for debugging.

930
00:37:27,586 --> 00:37:29,876 A:middle
It, too, has no draw time
compilation overhead.

931
00:37:30,046 --> 00:37:32,376 A:middle
It operates just like
the precompile shaders,

932
00:37:32,916 --> 00:37:34,366 A:middle
but for best performance,

933
00:37:34,366 --> 00:37:36,656 A:middle
we generally recommend you
use the offline compiler.

934
00:37:36,826 --> 00:37:38,266 A:middle
We can give you the
most information

935
00:37:38,266 --> 00:37:40,646 A:middle
to help you build the
best possible shaders

936
00:37:40,646 --> 00:37:41,316 A:middle
if you do it this way.

937
00:37:41,946 --> 00:37:43,066 A:middle
Well, let's see what
this would look like.

938
00:37:43,346 --> 00:37:44,416 A:middle
So here's an example.

939
00:37:44,416 --> 00:37:47,656 A:middle
You're building your application
in Xcode, and you have a series

940
00:37:48,086 --> 00:37:52,226 A:middle
of Metal shader files, and
each shader files are passed

941
00:37:52,436 --> 00:37:54,696 A:middle
to the Metal shader
compiler, the compiler

942
00:37:54,696 --> 00:37:55,806 A:middle
or the Metal shader sources

943
00:37:55,916 --> 00:37:57,286 A:middle
at the time you build
your application,

944
00:37:57,536 --> 00:37:59,826 A:middle
and a Metal library
file is generated.

945

946
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

947
00:38:00,656 --> 00:38:04,536 A:middle
That Metal library file will be
packaged with your application,

948
00:38:04,986 --> 00:38:08,036 A:middle
and so then when you deploy
your application to a device,

949
00:38:09,486 --> 00:38:11,436 A:middle
that Metal library file
goes along for the ride.

950
00:38:11,996 --> 00:38:13,306 A:middle
Then at application run time

951
00:38:13,306 --> 00:38:15,866 A:middle
when you're constructing
your pipeline objects,

952
00:38:16,506 --> 00:38:19,456 A:middle
you specify which vertex
and fragment shaders you'd

953
00:38:19,456 --> 00:38:21,656 A:middle
like to use from
that Metal library.

954
00:38:22,466 --> 00:38:25,056 A:middle
Metal implementation then will
look up those shaders to see

955
00:38:25,056 --> 00:38:27,616 A:middle
if it's already cached them
once before, and if not,

956
00:38:27,686 --> 00:38:30,206 A:middle
we'll compile them to the
final machine device code

957
00:38:31,226 --> 00:38:32,176 A:middle
and send it to the GPU.

958
00:38:32,666 --> 00:38:34,516 A:middle
And that's it.

959
00:38:34,946 --> 00:38:37,296 A:middle
Most of this happens
automatically for you, but,

960
00:38:37,296 --> 00:38:41,786 A:middle
critically, exactly
when you want it to.

961
00:38:41,996 --> 00:38:45,016 A:middle
Now if you've used our OpenGL
ES debugging tools and Xcode,

962
00:38:45,016 --> 00:38:46,366 A:middle
you're going to feel
right at home.

963
00:38:46,366 --> 00:38:49,606 A:middle
We have an awesome set of
GPU programming debugging

964
00:38:49,606 --> 00:38:52,026 A:middle
and profiling tools integrated
right into Xcode, and I'm going

965
00:38:52,526 --> 00:38:53,976 A:middle
to give you a quick
tour of those now.

966
00:38:54,496 --> 00:38:58,976 A:middle
So this is an example
application inside Xcode

967
00:38:58,976 --> 00:39:01,636 A:middle
where you get visual
debugging tools built right

968

969
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

970
00:38:58,976 --> 00:39:01,636 A:middle
where you get visual
debugging tools built right

971
00:39:01,636 --> 00:39:03,406 A:middle
in the same environment
you're using

972
00:39:03,406 --> 00:39:04,686 A:middle
to build the rest
of your application.

973
00:39:05,046 --> 00:39:07,866 A:middle
On the left-hand side, we
have what's called the frame

974
00:39:07,866 --> 00:39:11,516 A:middle
navigator, which shows you
exactly which Metal API calls,

975
00:39:11,516 --> 00:39:15,046 A:middle
draw calls you issued and
in what order they occurred,

976
00:39:15,506 --> 00:39:18,366 A:middle
and in the middle, you have
the frame navigator, or, sorry,

977
00:39:18,366 --> 00:39:21,316 A:middle
the frame buffer view where you
can actually see the results

978
00:39:21,316 --> 00:39:25,026 A:middle
of those draw calls and state
operations happening live

979
00:39:25,026 --> 00:39:26,226 A:middle
as you're constructing
your frame.

980
00:39:27,616 --> 00:39:30,106 A:middle
We also have the resource
view, where you can see all

981
00:39:30,106 --> 00:39:33,196 A:middle
of the textures, resources, data
buffers, everything you're using

982
00:39:33,196 --> 00:39:36,096 A:middle
to construct your frame,
inspect them, and make sure

983
00:39:36,096 --> 00:39:37,796 A:middle
that they're exactly
as you set them up.

984
00:39:38,226 --> 00:39:42,696 A:middle
And at the bottom, you can
see the Metal state inspector

985
00:39:42,696 --> 00:39:44,926 A:middle
where you can see all
of the API state and all

986
00:39:44,926 --> 00:39:47,996 A:middle
of the important bits of
control and information you have

987
00:39:48,386 --> 00:39:49,816 A:middle
about your application in Metal.

988
00:39:51,786 --> 00:39:55,516 A:middle
We also provide some
really fantastic profiling

989
00:39:55,516 --> 00:39:56,666 A:middle
and performance tools.

990
00:39:57,216 --> 00:39:58,326 A:middle
So in this example,

991
00:39:58,606 --> 00:39:59,976 A:middle
we're showing the Metal
performance report.

992

993
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

994
00:40:01,056 --> 00:40:02,906 A:middle
You can see things
like your frame rate

995
00:40:03,246 --> 00:40:04,536 A:middle
or how much you're
using the GPU.

996
00:40:04,566 --> 00:40:09,236 A:middle
You can also see exactly which
shaders are the most expensive,

997
00:40:09,816 --> 00:40:12,496 A:middle
and you can see how much time
they're taking per frame.

998
00:40:13,206 --> 00:40:13,906 A:middle
This is awesome.

999
00:40:14,286 --> 00:40:16,886 A:middle
You can also see for
each of those shaders

1000
00:40:17,256 --> 00:40:20,086 A:middle
in milliseconds how much time
they're taking as a whole,

1001
00:40:20,646 --> 00:40:22,166 A:middle
but you can get a feel

1002
00:40:22,166 --> 00:40:25,716 A:middle
for exactly what are the most
expensive lines of each shader.

1003
00:40:25,716 --> 00:40:28,376 A:middle
So if you want to really
optimize your shaders,

1004
00:40:28,576 --> 00:40:31,366 A:middle
you can find out which line
is taking up the most time

1005
00:40:31,726 --> 00:40:33,926 A:middle
and focus in on that,
and this is all built

1006
00:40:33,926 --> 00:40:36,186 A:middle
for you right inside of Xcode.

1007
00:40:37,516 --> 00:40:42,526 A:middle
[ Applause ]

1008
00:40:43,026 --> 00:40:43,676 A:middle
I'm glad you like it.

1009
00:40:45,126 --> 00:40:47,436 A:middle
So you can also build
your shaders,

1010
00:40:47,436 --> 00:40:48,646 A:middle
as we said, inside Xcode.

1011
00:40:48,646 --> 00:40:49,876 A:middle
You can actually
edit them as well,

1012
00:40:49,876 --> 00:40:51,976 A:middle
and you get all the
familiar syntax highlighting

1013
00:40:52,246 --> 00:40:55,636 A:middle
and code completion, and you
get warnings and errors right

1014
00:40:55,636 --> 00:40:56,786 A:middle
for you inside of Xcode, too.

1015
00:40:57,346 --> 00:40:58,746 A:middle
We think this is
really fantastic.

1016
00:40:58,746 --> 00:41:00,286 A:middle
It makes writing and editing

1017

1018
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1019
00:40:58,746 --> 00:41:00,286 A:middle
It makes writing and editing

1020
00:41:00,286 --> 00:41:02,706 A:middle
and profiling shaders a
much more natural part

1021
00:41:02,706 --> 00:41:04,516 A:middle
of the process, and
we've designed Metal

1022
00:41:04,516 --> 00:41:06,806 A:middle
to work seamlessly
in this environment.

1023
00:41:07,436 --> 00:41:11,046 A:middle
Alright. So that's the developer
tools, the API concepts,

1024
00:41:11,046 --> 00:41:12,276 A:middle
and the shading language.

1025
00:41:12,516 --> 00:41:15,656 A:middle
Now as you heard in the keynote,
we've been working with Metal,

1026
00:41:16,486 --> 00:41:18,866 A:middle
some leading game
engine providers

1027
00:41:19,416 --> 00:41:23,256 A:middle
such as Electronic Arts,
Epic, Unity, and Crytek,

1028
00:41:23,726 --> 00:41:25,766 A:middle
and we've been amazed at what
they've been able to create

1029
00:41:25,926 --> 00:41:27,256 A:middle
in just a short amount of time.

1030
00:41:27,796 --> 00:41:29,496 A:middle
Well, I'm very happy
to introduce

1031
00:41:29,496 --> 00:41:31,536 A:middle
up on stage Sean
Tracey from Crytek,

1032
00:41:31,756 --> 00:41:33,746 A:middle
who's going to show you what
they've been able to create

1033
00:41:33,746 --> 00:41:35,356 A:middle
with Metal in just a few weeks.

1034
00:41:35,866 --> 00:41:36,076 A:middle
Sean.

1035
00:41:37,456 --> 00:41:41,496 A:middle
>> Thanks a lot, Jeremy.

1036
00:41:42,256 --> 00:41:44,176 A:middle
Crytek is known for
pushing the boundaries

1037
00:41:44,806 --> 00:41:47,526 A:middle
and for developing
blockbuster hits such as Crysis

1038
00:41:47,526 --> 00:41:48,676 A:middle
and Ryse for the consoles.

1039
00:41:49,326 --> 00:41:51,716 A:middle
The CRYENGINE is going
mobile, and our latest game,

1040
00:41:51,716 --> 00:41:53,986 A:middle
The Collectables, was recently
released on the App Store.

1041
00:41:54,366 --> 00:41:57,186 A:middle
Integrating Metal into the
game gives us opportunities

1042
00:41:57,186 --> 00:41:58,286 A:middle
that we didn't have before,

1043
00:41:58,346 --> 00:42:01,026 A:middle
and the added performance
changes the way we think

1044

1045
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1046
00:41:58,346 --> 00:42:01,026 A:middle
and the added performance
changes the way we think

1047
00:42:01,026 --> 00:42:03,646 A:middle
about creating mobile game
play and mobile game content.

1048
00:42:04,346 --> 00:42:05,976 A:middle
Today, we'd like to show
you the next version

1049
00:42:05,976 --> 00:42:08,446 A:middle
of The Collectibles, and to
show you how we use Metal

1050
00:42:08,566 --> 00:42:09,546 A:middle
to change the game.

1051
00:42:10,016 --> 00:42:10,586 A:middle
Let's take a look.

1052
00:42:11,346 --> 00:42:15,446 A:middle
In The Collectibles, you control
a renegade team of mercenaries,

1053
00:42:15,446 --> 00:42:17,476 A:middle
and today we're on a daring
hit-and-run mission to take

1054
00:42:17,476 --> 00:42:18,536 A:middle
out the enemy artillery.

1055
00:42:19,506 --> 00:42:21,966 A:middle
As you can see, the environment
is incredibly dynamic

1056
00:42:22,456 --> 00:42:26,836 A:middle
and very rich with wind
affecting vegetation and more.

1057
00:42:28,046 --> 00:42:29,726 A:middle
Looks like the enemy's
set up a roadblock ahead.

1058
00:42:29,726 --> 00:42:31,546 A:middle
Let's take out these
jeeps with our RPGs.

1059
00:42:33,746 --> 00:42:36,046 A:middle
So you can see this level

1060
00:42:36,046 --> 00:42:38,296 A:middle
of cinematic destruction
simply wasn't possible

1061
00:42:38,296 --> 00:42:39,086 A:middle
on mobile before.

1062
00:42:39,376 --> 00:42:40,296 A:middle
When those jeeps explode,

1063
00:42:40,296 --> 00:42:43,006 A:middle
there's over 168 unique
pieces that come flying off.

1064
00:42:43,316 --> 00:42:45,436 A:middle
The tires, windshield,
engine block, and more.

1065
00:42:46,666 --> 00:42:47,626 A:middle
Using the power of Metal,

1066
00:42:47,626 --> 00:42:50,356 A:middle
we're able to leverage
our geom cache technology

1067
00:42:50,666 --> 00:42:52,086 A:middle
as seen in Ryse on console.

1068
00:42:53,026 --> 00:42:56,306 A:middle
And there it is, our
objective, the enemy artillery.

1069
00:42:56,656 --> 00:42:57,736 A:middle
It's a pretty big mother.

1070
00:42:57,736 --> 00:42:58,666 A:middle
So let's go ahead and call

1071
00:42:58,666 --> 00:43:00,656 A:middle
in our AC130 gunship
for air support.

1072

1073
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1074
00:42:58,666 --> 00:43:00,656 A:middle
in our AC130 gunship
for air support.

1075
00:43:01,516 --> 00:43:07,466 A:middle
[ Background Sounds ]

1076
00:43:07,966 --> 00:43:11,176 A:middle
Geom cache uses cache-based
animation

1077
00:43:11,466 --> 00:43:14,806 A:middle
to realize extremely complex
simulation and special effects,

1078
00:43:15,046 --> 00:43:16,926 A:middle
as you saw in the
destruction of those buildings.

1079
00:43:18,376 --> 00:43:20,666 A:middle
So as our players make their
way to their next objective,

1080
00:43:21,006 --> 00:43:22,426 A:middle
let's take a look
at another example

1081
00:43:22,426 --> 00:43:26,146 A:middle
of how we can use this power
to turn the environment

1082
00:43:26,296 --> 00:43:27,836 A:middle
into a weapon for our player.

1083
00:43:28,346 --> 00:43:30,296 A:middle
Sounds like trouble ahead.

1084
00:43:30,856 --> 00:43:31,786 A:middle
Yeah, they've got a tank.

1085
00:43:31,786 --> 00:43:33,676 A:middle
Alright. We need to block off
that road and get out of here,

1086
00:43:33,676 --> 00:43:34,506 A:middle
or we're going to be toast.

1087
00:43:34,826 --> 00:43:35,826 A:middle
Let's try taking
out the chimney.

1088
00:43:41,596 --> 00:43:43,726 A:middle
And that's how you stop a
tank in The Collectibles.

1089
00:43:44,386 --> 00:43:45,836 A:middle
When that building
and chimney come down,

1090
00:43:45,836 --> 00:43:48,216 A:middle
there's over 4,000
draw calls on screen,

1091
00:43:48,456 --> 00:43:50,676 A:middle
4,000 draw calls on an iPad.

1092
00:43:51,936 --> 00:43:54,796 A:middle
Ah, they've got another tank,
and we're out of chimneys.

1093
00:43:54,856 --> 00:43:56,036 A:middle
So mission accomplished.

1094
00:43:56,246 --> 00:43:56,836 A:middle
Let's get out of here.

1095
00:43:59,186 --> 00:44:00,556 A:middle
As you can see, the
performance game

1096

1097
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1098
00:43:59,186 --> 00:44:00,556 A:middle
As you can see, the
performance game

1099
00:44:00,616 --> 00:44:03,626 A:middle
with Metal gives us a
tenfold performance increase

1100
00:44:03,846 --> 00:44:07,676 A:middle
that allows us to bring the
Crytek DNA alive on mobile.

1101
00:44:08,266 --> 00:44:09,886 A:middle
We look forward to seeing
you guys in the game.

1102
00:44:10,326 --> 00:44:10,976 A:middle
Thanks a lot.

1103
00:44:11,516 --> 00:44:17,776 A:middle
[ Applause ]

1104
00:44:18,276 --> 00:44:18,576 A:middle
>> Alright.

1105
00:44:18,576 --> 00:44:19,206 A:middle
Thanks, Sean.

1106
00:44:19,866 --> 00:44:20,906 A:middle
That's really amazing.

1107
00:44:20,906 --> 00:44:23,776 A:middle
So 4,000 draw calls
is a tenfold increase

1108
00:44:24,096 --> 00:44:26,116 A:middle
over what was previously
possible before Metal,

1109
00:44:26,116 --> 00:44:28,606 A:middle
and we're are truly, truly
excited to see it in action.

1110
00:44:29,936 --> 00:44:31,166 A:middle
Alright. So that's Metal.

1111
00:44:31,456 --> 00:44:33,566 A:middle
Metal is our new low overhead,

1112
00:44:33,836 --> 00:44:37,546 A:middle
high-performance GPU programming
API which can provide you

1113
00:44:37,546 --> 00:44:40,316 A:middle
with dramatic increase
in efficiency

1114
00:44:40,316 --> 00:44:41,416 A:middle
and performance for your game.

1115
00:44:42,256 --> 00:44:46,356 A:middle
We've designed it from
scratch to run like a dream

1116
00:44:46,356 --> 00:44:49,756 A:middle
on the A7 chip and
our iOS products.

1117
00:44:50,346 --> 00:44:51,996 A:middle
And we've streamlined
the feature set

1118
00:44:51,996 --> 00:44:55,636 A:middle
and the API footprint to focus
on the most modern GPU features

1119
00:44:55,766 --> 00:44:57,376 A:middle
such as unified graphics
and compute,

1120
00:44:57,626 --> 00:45:01,276 A:middle
and the most modern GPU game
programming techniques such,

1121

1122
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1123
00:44:57,626 --> 00:45:01,276 A:middle
and the most modern GPU game
programming techniques such,

1124
00:45:01,346 --> 00:45:04,666 A:middle
that require fine grain control
and efficient multi-threading.

1125
00:45:05,396 --> 00:45:08,956 A:middle
With support for precompiled
shaders and a fantastic set

1126
00:45:08,956 --> 00:45:11,546 A:middle
of developer tools, we
believe you're going to be able

1127
00:45:11,546 --> 00:45:14,326 A:middle
to use Metal to create
an entirely new class

1128
00:45:14,466 --> 00:45:16,716 A:middle
of games for your customers.

1129
00:45:17,416 --> 00:45:19,226 A:middle
We're really looking forward
to what you guys are going

1130
00:45:19,226 --> 00:45:20,736 A:middle
to be able to create with Metal.

1131
00:45:20,876 --> 00:45:24,086 A:middle
We think it's just a truly,
truly fantastic thing.

1132
00:45:24,606 --> 00:45:27,276 A:middle
For more information
about Metal,

1133
00:45:27,776 --> 00:45:30,726 A:middle
you can come see our
Evangelists, Filip and Allan,

1134
00:45:31,106 --> 00:45:33,916 A:middle
and we have an amazing set
of documentation about Metal

1135
00:45:33,916 --> 00:45:35,306 A:middle
on our developer
relations website.

1136
00:45:35,696 --> 00:45:37,826 A:middle
You can also check out
the developer forums

1137
00:45:37,826 --> 00:45:40,726 A:middle
where you can talk with folks
about Metal, and you can come

1138
00:45:41,026 --> 00:45:43,656 A:middle
to the next two sessions which
we're going to go into Metal

1139
00:45:43,656 --> 00:45:45,286 A:middle
in a much more level of detail.

1140
00:45:45,286 --> 00:45:48,386 A:middle
So you can see how Metal
works in your application,

1141
00:45:48,386 --> 00:45:51,456 A:middle
how to build your first Metal
application, how to build scenes

1142
00:45:51,456 --> 00:45:54,816 A:middle
out of Metal and use
it to control the GPU,

1143
00:45:54,816 --> 00:45:56,626 A:middle
how the Metal shading
language itself works,

1144
00:45:57,106 --> 00:45:58,546 A:middle
and then we'll have
a second session

1145
00:45:58,676 --> 00:46:00,726 A:middle
where we cover some
more advanced techniques

1146

1147
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1148
00:45:58,676 --> 00:46:00,726 A:middle
where we cover some
more advanced techniques

1149
00:46:01,026 --> 00:46:03,426 A:middle
such as using multi-pass
Rendering and Compute.

1150
00:46:04,306 --> 00:46:06,376 A:middle
We're really looking forward
to what you're going to be able

1151
00:46:06,376 --> 00:46:07,956 A:middle
to create with this API.

1152
00:46:07,956 --> 00:46:08,976 A:middle
Thank you very much for coming.

1153
