X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1
00:00:00,506 --> 00:00:11,516 A:middle
[ Silence ]

2
00:00:12,016 --> 00:00:20,000 A:middle
[ Applause ]

3
00:00:22,556 --> 00:00:26,286 A:middle
>> Hi. My name is John McCall.

4
00:00:26,286 --> 00:00:27,726 A:middle
I'm a compiler engineer

5
00:00:27,726 --> 00:00:30,976 A:middle
on the Swift project
and a horrible nerd.

6
00:00:31,876 --> 00:00:37,326 A:middle
And today I want to talk
to you about how, you know,

7
00:00:37,326 --> 00:00:39,206 A:middle
you can take advantage
of really,

8
00:00:39,206 --> 00:00:41,236 A:middle
all of the language tools
that we've built into Swift

9
00:00:41,236 --> 00:00:44,436 A:middle
to make your code so
much more expressive,

10
00:00:44,436 --> 00:00:46,226 A:middle
and powerful, and safe.

11
00:00:46,956 --> 00:00:49,086 A:middle
We're going to start
off by talking

12
00:00:49,086 --> 00:00:51,376 A:middle
about how you can take control

13
00:00:51,376 --> 00:00:54,946 A:middle
of really the basic
language and syntax of Swift.

14
00:00:54,946 --> 00:00:57,106 A:middle
We're going to follow
that up by talking

15
00:00:57,106 --> 00:01:01,616 A:middle
about a much more advanced
topic of generic programming,

16

17
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

18
00:00:57,106 --> 00:01:01,616 A:middle
about a much more advanced
topic of generic programming,

19
00:01:01,616 --> 00:01:04,906 A:middle
and then we're going to finish
that up real quick by talking

20
00:01:04,906 --> 00:01:09,346 A:middle
about how Swift is implemented
and how it turns your code

21
00:01:09,346 --> 00:01:12,766 A:middle
into great machine code
that's finally executed.

22
00:01:14,236 --> 00:01:19,416 A:middle
So when we designed
Swift we wanted

23
00:01:19,416 --> 00:01:21,916 A:middle
to avoid hard coding too
much about the language.

24
00:01:22,886 --> 00:01:24,146 A:middle
We think it's really important

25
00:01:24,146 --> 00:01:26,456 A:middle
to provide a great
standard library

26
00:01:26,456 --> 00:01:31,686 A:middle
that lets you really get started
right away and making great apps

27
00:01:31,886 --> 00:01:36,686 A:middle
for your users and just
jump right in and be able

28
00:01:36,686 --> 00:01:37,786 A:middle
to do what you need to do.

29
00:01:38,506 --> 00:01:41,386 A:middle
But we didn't want to lock you

30
00:01:41,386 --> 00:01:43,256 A:middle
into just the tools
that we provided.

31
00:01:43,866 --> 00:01:47,346 A:middle
We wanted you to be able to
extend that basic language

32
00:01:47,406 --> 00:01:52,386 A:middle
with new idioms, new
abstractions, and not feel

33
00:01:52,386 --> 00:01:54,076 A:middle
like you're locking
yourself into that.

34
00:01:55,826 --> 00:01:58,426 A:middle
In order to show you what
I'm trying to get at here,

35
00:01:58,426 --> 00:01:59,976 A:middle
I want to work through
an example.

36
00:01:59,976 --> 00:02:03,216 A:middle
And since this is an
advanced talk I want to work

37

38
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

39
00:01:59,976 --> 00:02:03,216 A:middle
And since this is an
advanced talk I want to work

40
00:02:03,216 --> 00:02:05,866 A:middle
through an example that
really shows off the advanced

41
00:02:05,866 --> 00:02:10,056 A:middle
capabilities of our platforms.

42
00:02:10,106 --> 00:02:12,256 A:middle
If you've never seen a
text adventure before --

43
00:02:15,516 --> 00:02:18,886 A:middle
[ Applause ]

44
00:02:19,386 --> 00:02:21,136 A:middle
If you've never seen a
text adventure before,

45
00:02:21,136 --> 00:02:22,306 A:middle
the idea is pretty simple.

46
00:02:22,796 --> 00:02:26,186 A:middle
You as the player are wandering
around the world solving puzzles

47
00:02:26,186 --> 00:02:27,246 A:middle
and having adventures.

48
00:02:27,846 --> 00:02:31,676 A:middle
You interact with the
game by typing in commands

49
00:02:31,786 --> 00:02:36,126 A:middle
at a terminal prompt and the
game responds back to you

50
00:02:36,126 --> 00:02:39,376 A:middle
by interpreting those commands,
trying to carry them out

51
00:02:39,626 --> 00:02:40,846 A:middle
and then telling
you what happens.

52
00:02:41,986 --> 00:02:45,866 A:middle
So for example in
the game you're going

53
00:02:46,926 --> 00:02:50,346 A:middle
to be wandering around,
exploring a lot

54
00:02:50,346 --> 00:02:53,326 A:middle
of new locations, and finding
a bunch of new objects.

55
00:02:53,326 --> 00:02:55,666 A:middle
And when you find an object
you're going to be able to --

56
00:02:56,076 --> 00:02:58,636 A:middle
you want to be able to
look at it, and you know,

57
00:02:58,636 --> 00:03:01,466 A:middle
try to interact with
it, and maybe even sort

58

59
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

60
00:02:58,636 --> 00:03:01,466 A:middle
try to interact with
it, and maybe even sort

61
00:03:01,466 --> 00:03:03,646 A:middle
of tear things apart
and really get chaotic.

62
00:03:05,036 --> 00:03:09,316 A:middle
Now, in this scene we've got a
whole bunch of different objects

63
00:03:09,706 --> 00:03:11,066 A:middle
that in our game,
we're going to have

64
00:03:11,066 --> 00:03:13,386 A:middle
to like manually
model one-by-one.

65
00:03:13,916 --> 00:03:18,066 A:middle
It's going to be a lot of text.

66
00:03:18,066 --> 00:03:20,966 A:middle
All these objects are going

67
00:03:20,966 --> 00:03:24,446 A:middle
to be instances ultimately
of this Thing class.

68
00:03:24,936 --> 00:03:27,466 A:middle
A Thing is really simple
it's not anything more

69
00:03:27,466 --> 00:03:29,286 A:middle
than just a name
and a description

70
00:03:29,636 --> 00:03:31,416 A:middle
and a current location
of the object.

71
00:03:34,976 --> 00:03:39,736 A:middle
Here's a couple of really simple
objects that are nothing more

72
00:03:39,736 --> 00:03:41,676 A:middle
than just a name
and a description.

73
00:03:42,386 --> 00:03:44,326 A:middle
You can see, you know,

74
00:03:45,266 --> 00:03:47,686 A:middle
we're just calling the
initializer directly passing

75
00:03:47,686 --> 00:03:50,656 A:middle
in a couple literal values.

76
00:03:51,396 --> 00:03:53,336 A:middle
We're going to have a
ton of objects like this,

77
00:03:53,516 --> 00:03:56,046 A:middle
scenery objects, maybe
three or four of these

78
00:03:56,046 --> 00:03:57,676 A:middle
in every single place
in the game.

79
00:03:58,286 --> 00:04:00,476 A:middle
Added up over what could
be a very large game

80

81
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

82
00:03:58,286 --> 00:04:00,476 A:middle
Added up over what could
be a very large game

83
00:04:00,476 --> 00:04:03,286 A:middle
that means we're going
to have several hundreds

84
00:04:03,286 --> 00:04:04,756 A:middle
of these, maybe even thousands.

85
00:04:04,756 --> 00:04:06,886 A:middle
And it's going to be
really important to me

86
00:04:06,886 --> 00:04:09,836 A:middle
that this code end up
looking really compact.

87
00:04:10,116 --> 00:04:14,076 A:middle
That it be really
convenient to read and write.

88
00:04:14,196 --> 00:04:20,606 A:middle
Well it's already pretty compact
but these keyword arguments,

89
00:04:20,685 --> 00:04:23,766 A:middle
these argument names aren't
really doing a whole lot for me.

90
00:04:23,906 --> 00:04:27,396 A:middle
I can actually tell
straight off what each one

91
00:04:27,396 --> 00:04:30,286 A:middle
of these things are because
there's two different strings,

92
00:04:30,286 --> 00:04:31,536 A:middle
there's a name of an object.

93
00:04:31,586 --> 00:04:33,446 A:middle
The two strings, one of
them is really short,

94
00:04:33,446 --> 00:04:34,526 A:middle
one of them is really long.

95
00:04:35,376 --> 00:04:37,716 A:middle
It doesn't take much
for me to memorize this.

96
00:04:37,876 --> 00:04:40,146 A:middle
It would be really great since
I'm going to be writing this

97
00:04:40,146 --> 00:04:41,686 A:middle
over and over again,
if I didn't have

98
00:04:41,736 --> 00:04:43,056 A:middle
to have all this redundancy.

99
00:04:44,106 --> 00:04:48,626 A:middle
So how do we go about actually
changing argument names?

100
00:04:49,546 --> 00:04:53,486 A:middle
Well in Swift these
argument names come

101
00:04:54,046 --> 00:04:57,936 A:middle
from the declaration
of the initializer.

102
00:04:58,216 --> 00:05:01,896 A:middle
By default the parameter
names that we use

103

104
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

105
00:04:58,216 --> 00:05:01,896 A:middle
By default the parameter
names that we use

106
00:05:01,896 --> 00:05:04,546 A:middle
in initializer are also going
to be the argument names.

107
00:05:05,166 --> 00:05:07,766 A:middle
But that's just the default
we can expand this syntax

108
00:05:07,766 --> 00:05:08,796 A:middle
out like so.

109
00:05:09,386 --> 00:05:10,566 A:middle
It's exactly equivalent.

110
00:05:10,706 --> 00:05:14,076 A:middle
Now I've got the argument
names specifically right next

111
00:05:14,076 --> 00:05:15,726 A:middle
to the parameter name.

112
00:05:18,016 --> 00:05:20,676 A:middle
But how do we actually
make something anonymous?

113
00:05:21,786 --> 00:05:26,166 A:middle
Well Swift has a very consistent
syntax for doing this.

114
00:05:26,506 --> 00:05:30,126 A:middle
Instead of giving it a real
meaningful identifier you just

115
00:05:30,126 --> 00:05:31,176 A:middle
give it an underscore.

116
00:05:31,486 --> 00:05:33,026 A:middle
You can use this syntax in a lot

117
00:05:33,026 --> 00:05:34,656 A:middle
of different places
in the language.

118
00:05:35,026 --> 00:05:38,486 A:middle
For example, in this
small for loop,

119
00:05:38,486 --> 00:05:41,346 A:middle
I'm just iterating all the
entries in the dictionary.

120
00:05:41,756 --> 00:05:44,706 A:middle
But I don't actually care about
the values in the dictionary,

121
00:05:45,006 --> 00:05:46,586 A:middle
I just want to print
out all the keys.

122
00:05:47,396 --> 00:05:50,956 A:middle
I could give this, you
know, its own parameter --

123
00:05:51,006 --> 00:05:55,116 A:middle
its own local variable name, but
then if this were a larger loop,

124
00:05:55,216 --> 00:05:57,086 A:middle
you know, somebody coming along

125
00:05:57,086 --> 00:05:59,906 A:middle
and reading it later would
instinctively feel --

126

127
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

128
00:06:00,036 --> 00:06:03,786 A:middle
wonder, if I was actually using
the value somewhere in the loop

129
00:06:03,956 --> 00:06:05,076 A:middle
and then feel like they needed

130
00:06:05,076 --> 00:06:07,136 A:middle
to visually search
the entire loop.

131
00:06:07,516 --> 00:06:09,646 A:middle
So instead I can just
name it with an underscore

132
00:06:09,646 --> 00:06:13,286 A:middle
which isn't a real variable,
it just says ignore this value.

133
00:06:13,826 --> 00:06:17,036 A:middle
And that's not just
in initializations,

134
00:06:17,036 --> 00:06:19,686 A:middle
I can even assign it
as a sort of value sync

135
00:06:20,006 --> 00:06:22,146 A:middle
so if I have a color,
I can break it

136
00:06:22,146 --> 00:06:25,486 A:middle
down into its color components.

137
00:06:25,906 --> 00:06:27,736 A:middle
But in this case I
only care about the red

138
00:06:27,736 --> 00:06:30,096 A:middle
and blue components, not
the green and the alpha.

139
00:06:30,426 --> 00:06:34,276 A:middle
So I just assigned the green and
alpha components to underscore,

140
00:06:34,506 --> 00:06:37,586 A:middle
which just immediately
drops them.

141
00:06:37,796 --> 00:06:42,866 A:middle
Going back to our initializer,
I have all these argument names

142
00:06:43,146 --> 00:06:45,816 A:middle
and if I just removed
them I'd end up back

143
00:06:45,816 --> 00:06:46,966 A:middle
in that default state

144
00:06:46,966 --> 00:06:50,226 A:middle
where Swift was using
the parameter names

145
00:06:50,226 --> 00:06:51,756 A:middle
as the default argument names.

146
00:06:52,516 --> 00:06:55,856 A:middle
But if I want to drop them
completely, I need to tell Swift

147
00:06:55,856 --> 00:06:57,056 A:middle
that I don't want this.

148
00:06:57,056 --> 00:07:00,176 A:middle
And the way I do that is I
name it with an underscore.

149

150
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

151
00:06:57,056 --> 00:07:00,176 A:middle
And the way I do that is I
name it with an underscore.

152
00:07:01,456 --> 00:07:03,916 A:middle
This is just a very simple way

153
00:07:03,916 --> 00:07:06,286 A:middle
of telling Swift I don't
want any argument names,

154
00:07:06,376 --> 00:07:09,846 A:middle
just let me call this
initializer positionally.

155
00:07:10,406 --> 00:07:15,676 A:middle
And so I get a much
more compact --

156
00:07:15,676 --> 00:07:17,306 A:middle
I get much more compact
definitions

157
00:07:17,306 --> 00:07:18,376 A:middle
of all of my objects.

158
00:07:18,756 --> 00:07:20,496 A:middle
This isn't something
you'd necessarily want

159
00:07:20,496 --> 00:07:22,136 A:middle
to do all over the place.

160
00:07:22,466 --> 00:07:24,486 A:middle
There's a lot of
value that I get

161
00:07:24,486 --> 00:07:26,736 A:middle
from keyword arguments,
from argument names.

162
00:07:27,856 --> 00:07:30,776 A:middle
Usually it provides a really
important semantic cue,

163
00:07:30,776 --> 00:07:34,256 A:middle
but in this case I've thought
about it very carefully

164
00:07:34,256 --> 00:07:36,546 A:middle
and decided that it's
not providing much value

165
00:07:36,546 --> 00:07:38,316 A:middle
and that I'd much rather
have the compactness.

166
00:07:38,476 --> 00:07:43,056 A:middle
All right those were a
couple simple objects.

167
00:07:43,446 --> 00:07:45,516 A:middle
In a more complicated
object I'm going to --

168
00:07:45,776 --> 00:07:49,116 A:middle
want to be able to give it a
-- maybe even additional state,

169
00:07:49,506 --> 00:07:53,256 A:middle
additional logic, maybe make
it respond to an action.

170
00:07:53,706 --> 00:07:56,466 A:middle
So for example going back to
that original scene I had up,

171
00:07:56,726 --> 00:07:59,356 A:middle
I had some boards that were
nailed up in front of the door.

172
00:07:59,676 --> 00:08:02,946 A:middle
I want these boards to be
pullable, so I'm going to end

173

174
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

175
00:07:59,676 --> 00:08:02,946 A:middle
I want these boards to be
pullable, so I'm going to end

176
00:08:02,946 --> 00:08:05,776 A:middle
up giving it its own
subclass of the Thing class.

177
00:08:08,566 --> 00:08:12,986 A:middle
Well how do I actually
make it pullable?

178
00:08:13,076 --> 00:08:19,466 A:middle
My game, when the user types in
pull boards, it's going to hand

179
00:08:19,466 --> 00:08:22,136 A:middle
that string off to the parser
which will break it down

180
00:08:22,406 --> 00:08:25,246 A:middle
and look -- find
out the verb pull,

181
00:08:25,246 --> 00:08:28,496 A:middle
and look around for an
object called boards.

182
00:08:29,276 --> 00:08:31,046 A:middle
Let's take over from that part.

183
00:08:31,306 --> 00:08:33,586 A:middle
We're going to implement
a function that takes

184
00:08:33,626 --> 00:08:35,385 A:middle
in a resolved object

185
00:08:35,596 --> 00:08:37,905 A:middle
and implements the
pull command on it.

186
00:08:38,496 --> 00:08:40,926 A:middle
Well how do we want that
to work at a high level?

187
00:08:41,546 --> 00:08:45,346 A:middle
If the object is
pullable, we want to pull it

188
00:08:45,346 --> 00:08:47,126 A:middle
and otherwise we're going
to print out some sort

189
00:08:47,126 --> 00:08:49,816 A:middle
of error message saying hey,
look you can't pull this thing.

190
00:08:51,466 --> 00:08:54,146 A:middle
Well that's a great
use of a protocol.

191
00:08:55,506 --> 00:08:58,236 A:middle
We've talked about protocols
a lot in other talks,

192
00:08:58,296 --> 00:09:01,566 A:middle
but I want to show you what
a protocol looks like now.

193

194
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

195
00:08:58,296 --> 00:09:01,566 A:middle
but I want to show you what
a protocol looks like now.

196
00:09:01,996 --> 00:09:03,836 A:middle
You've probably seen
this in, you know,

197
00:09:04,066 --> 00:09:08,796 A:middle
reading the entire book, but
a protocol really just looks

198
00:09:08,796 --> 00:09:10,576 A:middle
like a sort of blueprint
for a type

199
00:09:10,826 --> 00:09:13,016 A:middle
where you aren't actually
implementing any of the things

200
00:09:13,016 --> 00:09:15,356 A:middle
in it, you're just describing
what requirements are

201
00:09:15,356 --> 00:09:16,126 A:middle
actually there.

202
00:09:16,126 --> 00:09:19,536 A:middle
A pullable protocol
is extremely simple.

203
00:09:19,536 --> 00:09:22,466 A:middle
It just has one method,
doesn't take any arguments,

204
00:09:22,466 --> 00:09:23,516 A:middle
doesn't return anything.

205
00:09:23,516 --> 00:09:29,166 A:middle
In order to adapt this
protocol, we just go back

206
00:09:29,236 --> 00:09:33,126 A:middle
to our boards class and either
extend it or add pullable

207
00:09:33,296 --> 00:09:36,486 A:middle
to the main definition of it.

208
00:09:37,096 --> 00:09:40,386 A:middle
In this case I've decided to
add it to the main definition.

209
00:09:41,196 --> 00:09:44,256 A:middle
The compiler warns
me straight off

210
00:09:44,356 --> 00:09:47,776 A:middle
that I haven't actually
fully implemented this,

211
00:09:48,326 --> 00:09:49,806 A:middle
so I need to go add
the pull method.

212
00:09:50,256 --> 00:09:52,576 A:middle
Which for my boards
is going to be --

213
00:09:52,726 --> 00:09:55,106 A:middle
is very straightforward
in its functionality.

214
00:09:55,406 --> 00:09:58,376 A:middle
You just check to see
whether the boards are still

215
00:09:58,376 --> 00:10:01,256 A:middle
on the wall, and if
they are you move them

216

217
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

218
00:09:58,376 --> 00:10:01,256 A:middle
on the wall, and if
they are you move them

219
00:10:01,256 --> 00:10:02,976 A:middle
to the ground and
print a message.

220
00:10:04,106 --> 00:10:05,696 A:middle
And then we'll just
print an error message

221
00:10:05,696 --> 00:10:08,716 A:middle
if they're not still on the
board so that the player knows

222
00:10:08,716 --> 00:10:11,616 A:middle
that they don't need to care
about these boards anymore,

223
00:10:11,616 --> 00:10:16,036 A:middle
they're not going to be useful
in the rest of the game.

224
00:10:16,266 --> 00:10:19,586 A:middle
Now let's go back to our
perform pull function.

225
00:10:20,326 --> 00:10:22,886 A:middle
How do we actually check
whether something is pullable?

226
00:10:23,436 --> 00:10:24,756 A:middle
Well that's very
straightforward.

227
00:10:24,756 --> 00:10:28,576 A:middle
We can just use a conditional
pass down to the protocol type.

228
00:10:29,376 --> 00:10:33,446 A:middle
This conditional pass will give
us a value of a pullable type,

229
00:10:33,906 --> 00:10:36,226 A:middle
which we can then actually
pull if it succeeds.

230
00:10:36,946 --> 00:10:39,546 A:middle
And if it doesn't
succeed we're just going

231
00:10:39,546 --> 00:10:40,706 A:middle
to print out an error message.

232
00:10:41,956 --> 00:10:42,706 A:middle
And that's it.

233
00:10:42,706 --> 00:10:43,916 A:middle
That's all we needed
to do in order

234
00:10:43,916 --> 00:10:45,166 A:middle
to implement the pull method.

235
00:10:46,526 --> 00:10:49,546 A:middle
Now how do we -- now I want
to take a little bit closer

236
00:10:49,546 --> 00:10:51,306 A:middle
of a look at this error message.

237
00:10:51,936 --> 00:10:55,256 A:middle
I'm going to have a lot of
text like this in my game,

238
00:10:55,256 --> 00:10:56,846 A:middle
a lot of messages
that need to work --

239
00:10:57,006 --> 00:10:58,806 A:middle
apply to an arbitrary object.

240
00:10:59,486 --> 00:11:00,836 A:middle
And this isn't bad.

241

242
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

243
00:10:59,486 --> 00:11:00,836 A:middle
And this isn't bad.

244
00:11:01,366 --> 00:11:06,976 A:middle
This isn't awful syntax, but
it's less compact, less natural

245
00:11:06,976 --> 00:11:08,816 A:middle
than it needs to be
because of this .name.

246
00:11:09,336 --> 00:11:12,596 A:middle
Why can't I just put object
and string interpolation here?

247
00:11:13,456 --> 00:11:14,346 A:middle
Well I can.

248
00:11:15,016 --> 00:11:17,946 A:middle
Swift knows how to print
out an arbitrary object.

249
00:11:18,356 --> 00:11:21,836 A:middle
However, the rules that
Swift will use to print

250
00:11:21,836 --> 00:11:24,306 A:middle
out an arbitrary object
aren't necessarily the most

251
00:11:24,306 --> 00:11:25,096 A:middle
useful defaults.

252
00:11:27,006 --> 00:11:30,456 A:middle
How do I actually take
over this syntax and hook

253
00:11:30,456 --> 00:11:34,106 A:middle
into string interpolation
to actually do what I want?

254
00:11:34,876 --> 00:11:38,356 A:middle
In general the way that you hook
into a sort of language feature

255
00:11:38,356 --> 00:11:40,226 A:middle
like this in Swift
is that you're going

256
00:11:40,226 --> 00:11:41,476 A:middle
to implement a protocol.

257
00:11:41,746 --> 00:11:44,216 A:middle
A special protocol that the
compiler actually already

258
00:11:44,216 --> 00:11:44,796 A:middle
knows about.

259
00:11:46,166 --> 00:11:50,386 A:middle
For example, I can use
special built-in protocols

260
00:11:50,386 --> 00:11:53,426 A:middle
to make my type be usable
as a [inaudible] condition.

261
00:11:53,746 --> 00:11:57,356 A:middle
Or to allow the user to iterate
over it using a forward loop.

262
00:11:57,626 --> 00:12:00,656 A:middle
Or I could even take over one
of the basic literal syntaxes.

263

264
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

265
00:11:57,626 --> 00:12:00,656 A:middle
Or I could even take over one
of the basic literal syntaxes.

266
00:12:01,126 --> 00:12:03,336 A:middle
But in this example what
I want is the second one.

267
00:12:03,616 --> 00:12:06,326 A:middle
I want to implement printable
so that I can actually --

268
00:12:06,596 --> 00:12:08,946 A:middle
which is how you take
over string interpolation.

269
00:12:10,116 --> 00:12:13,926 A:middle
Printable is again a
very simple protocol.

270
00:12:14,186 --> 00:12:17,276 A:middle
It just has one requirement,
which is a property.

271
00:12:17,476 --> 00:12:20,346 A:middle
And all I have to do for
that property is implement --

272
00:12:20,386 --> 00:12:21,646 A:middle
is provide a getter for it.

273
00:12:21,646 --> 00:12:23,506 A:middle
Could also provide a
setter, but I don't have

274
00:12:23,566 --> 00:12:25,906 A:middle
to because protocol
doesn't require it.

275
00:12:26,976 --> 00:12:29,626 A:middle
So in this case I'm going to
go back and add an extension

276
00:12:29,626 --> 00:12:31,376 A:middle
to thing that implements
printable.

277
00:12:31,776 --> 00:12:33,816 A:middle
I have to provide
description protocol

278
00:12:33,816 --> 00:12:35,616 A:middle
and I'll just have it
return the name property.

279
00:12:36,186 --> 00:12:37,866 A:middle
And that's it.

280
00:12:38,236 --> 00:12:39,196 A:middle
That's all I needed to do.

281
00:12:40,426 --> 00:12:43,696 A:middle
Well is this really going to
work for an arbitrary object?

282
00:12:45,116 --> 00:12:48,136 A:middle
I mean if I look at this text up
here, it doesn't even read right

283
00:12:48,166 --> 00:12:51,916 A:middle
to me as an English
speaker, because a object.

284
00:12:52,836 --> 00:12:53,816 A:middle
That's not grammatical.

285
00:12:54,406 --> 00:12:57,266 A:middle
When I come along and pull --

286
00:12:57,266 --> 00:13:01,286 A:middle
and try to pull something that
starts with a vowel sound,

287

288
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

289
00:12:57,266 --> 00:13:01,286 A:middle
and try to pull something that
starts with a vowel sound,

290
00:13:01,656 --> 00:13:04,416 A:middle
or that's a plural, or
a mass noun in English,

291
00:13:04,786 --> 00:13:06,616 A:middle
you can't just put
A in front of it.

292
00:13:06,856 --> 00:13:09,576 A:middle
I need this to be able to
work for an arbitrary thing

293
00:13:09,576 --> 00:13:12,306 A:middle
which means I need -- and if
I want this to feel natural

294
00:13:12,306 --> 00:13:15,536 A:middle
to the user, so I don't take the
player out of their experience,

295
00:13:15,826 --> 00:13:17,886 A:middle
I want this to be
actually grammatical.

296
00:13:19,396 --> 00:13:22,506 A:middle
Well, how do I actually do that?

297
00:13:23,136 --> 00:13:29,486 A:middle
From a class design perspective,
I can just define a new property

298
00:13:30,036 --> 00:13:32,536 A:middle
on Thing that's going
to be name with article

299
00:13:32,536 --> 00:13:34,716 A:middle
that will throw the right word
in front of it, that's great.

300
00:13:34,796 --> 00:13:37,716 A:middle
This is a great class design,

301
00:13:37,716 --> 00:13:41,306 A:middle
but it's not actually very
usable for me if I'm going

302
00:13:41,366 --> 00:13:45,446 A:middle
to have a ton of text
printing out this thing.

303
00:13:45,636 --> 00:13:48,136 A:middle
This is actually worse
than just object .name was.

304
00:13:48,256 --> 00:13:50,016 A:middle
So how can I do better
than this?

305
00:13:50,156 --> 00:13:51,926 A:middle
Well I really want
to stick something

306
00:13:51,966 --> 00:13:55,006 A:middle
in the string interpolation
to sort of modify it.

307
00:13:55,946 --> 00:13:58,036 A:middle
It would be great if I
could just write this --

308
00:13:58,146 --> 00:13:59,776 A:middle
write an object right there.

309
00:13:59,776 --> 00:14:03,396 A:middle
But that's not actually
valid Swift syntax for a lot

310

311
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

312
00:13:59,776 --> 00:14:03,396 A:middle
But that's not actually
valid Swift syntax for a lot

313
00:14:03,396 --> 00:14:07,656 A:middle
of very good reasons, but I
can sort of slightly tweak this

314
00:14:07,796 --> 00:14:10,296 A:middle
in a way that still
feels very natural,

315
00:14:10,476 --> 00:14:11,596 A:middle
that's still very readable,

316
00:14:11,956 --> 00:14:14,396 A:middle
by instead of just putting
them next to each other,

317
00:14:15,066 --> 00:14:16,916 A:middle
separating them with
a binary operator.

318
00:14:18,056 --> 00:14:21,036 A:middle
This is a new binary operator
that's not currently defined

319
00:14:21,036 --> 00:14:21,766 A:middle
in language.

320
00:14:22,146 --> 00:14:25,666 A:middle
So how do I go about
actually adding it?

321
00:14:25,936 --> 00:14:29,576 A:middle
Well the way that you define
a new operator for, you know,

322
00:14:29,576 --> 00:14:31,716 A:middle
either taking an existing
operator and defining it

323
00:14:31,716 --> 00:14:32,766 A:middle
for a new set of types,

324
00:14:32,816 --> 00:14:36,546 A:middle
or actually adding a new
operator entirely is you're

325
00:14:36,546 --> 00:14:37,876 A:middle
going to need a global function.

326
00:14:38,486 --> 00:14:40,786 A:middle
And the global function
just takes

327
00:14:41,246 --> 00:14:43,786 A:middle
for a binary operator it's just
going to take two arguments,

328
00:14:43,856 --> 00:14:46,256 A:middle
one for the left hand side, and
one for the right hand side.

329
00:14:46,486 --> 00:14:49,156 A:middle
And it's just normal
global function

330
00:14:49,156 --> 00:14:50,176 A:middle
with a kind of funky name.

331
00:14:51,206 --> 00:14:53,996 A:middle
But Swift won't actually
let me do this

332
00:14:54,026 --> 00:14:56,006 A:middle
because it's actually
checking up on me.

333
00:14:56,496 --> 00:14:59,246 A:middle
Swift doesn't know how to
actually parse an expression

334
00:14:59,546 --> 00:15:01,496 A:middle
that uses this as
a binary operator.

335

336
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

337
00:14:59,546 --> 00:15:01,496 A:middle
that uses this as
a binary operator.

338
00:15:01,496 --> 00:15:03,746 A:middle
I need to tell Swift
the basic rules

339
00:15:03,746 --> 00:15:06,066 A:middle
for this as a binary operator.

340
00:15:06,066 --> 00:15:10,796 A:middle
In order to do that I just need

341
00:15:10,796 --> 00:15:13,056 A:middle
to provide an operator
declaration somewhere

342
00:15:13,056 --> 00:15:13,816 A:middle
in my program.

343
00:15:14,636 --> 00:15:16,846 A:middle
I could throw a lot of
information up in here in order

344
00:15:16,846 --> 00:15:20,256 A:middle
to describe how to -- how
this operator associates

345
00:15:20,256 --> 00:15:22,576 A:middle
with other binary operators, but
in this case I'm not planning

346
00:15:22,576 --> 00:15:25,916 A:middle
on actually using it next to
any other binary operators.

347
00:15:25,916 --> 00:15:27,306 A:middle
So all of that is unnecessary.

348
00:15:27,306 --> 00:15:29,186 A:middle
I can just have a very
simple declaration.

349
00:15:31,296 --> 00:15:33,196 A:middle
Now let's go back to this
function declaration.

350
00:15:33,776 --> 00:15:36,926 A:middle
The right hand side of this,
we want it to be an object.

351
00:15:37,496 --> 00:15:39,096 A:middle
What do we want the
left hand side to be?

352
00:15:40,546 --> 00:15:42,406 A:middle
Remember that this is the syntax

353
00:15:42,406 --> 00:15:44,696 A:middle
that we actually want
to be able to write.

354
00:15:45,506 --> 00:15:48,316 A:middle
Object here is just an arbitrary
expression that's going

355
00:15:48,316 --> 00:15:50,706 A:middle
to be resolved in global scope.

356
00:15:51,386 --> 00:15:56,186 A:middle
And we need -- and it's also
going to be an identifier.

357
00:15:56,186 --> 00:15:59,306 A:middle
It needs to actually resolve
to something in scope.

358
00:15:59,926 --> 00:16:01,656 A:middle
But we want this to
be usable anywhere,

359

360
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

361
00:15:59,926 --> 00:16:01,656 A:middle
But we want this to
be usable anywhere,

362
00:16:01,656 --> 00:16:03,626 A:middle
so this has to be something
that's actually defined

363
00:16:03,626 --> 00:16:04,526 A:middle
at global scope.

364
00:16:05,056 --> 00:16:07,186 A:middle
And the most natural thing
to put at global scope

365
00:16:07,186 --> 00:16:09,466 A:middle
in this case would
just be a function.

366
00:16:10,296 --> 00:16:14,166 A:middle
By using a function and having
it take the object that was

367
00:16:14,166 --> 00:16:15,326 A:middle
on the right hand side,

368
00:16:15,586 --> 00:16:18,906 A:middle
I can make this syntax very
naturally extend to any sort

369
00:16:18,906 --> 00:16:21,446 A:middle
of declarator that I want to
stick on the left hand side,

370
00:16:21,536 --> 00:16:25,586 A:middle
I just have to define a new
global function with that name.

371
00:16:25,586 --> 00:16:29,506 A:middle
The and function we're just
going to implement by using

372
00:16:29,506 --> 00:16:33,006 A:middle
that name with article property
that we already defined.

373
00:16:33,756 --> 00:16:38,156 A:middle
With all of that, I can go
back to my operator function

374
00:16:38,156 --> 00:16:40,556 A:middle
and the left hand side
of this is now going

375
00:16:40,556 --> 00:16:41,936 A:middle
to be a function value.

376
00:16:42,506 --> 00:16:43,556 A:middle
And the way that we're going

377
00:16:43,556 --> 00:16:47,136 A:middle
to implement this is we're just
going to call the function value

378
00:16:47,826 --> 00:16:50,486 A:middle
with the object that
we will provide it

379
00:16:50,486 --> 00:16:51,386 A:middle
on the right hand side.

380
00:16:51,386 --> 00:16:53,296 A:middle
And that's it.

381
00:16:53,296 --> 00:16:57,056 A:middle
That gives me great -- a great
new idiom for expressing a sort

382
00:16:57,056 --> 00:16:59,066 A:middle
of decorated interpolated
string.

383

384
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

385
00:17:00,316 --> 00:17:02,186 A:middle
This isn't something that
you would necessarily want

386
00:17:02,186 --> 00:17:06,705 A:middle
to use casually, but in my
game it's valuable enough to me

387
00:17:06,986 --> 00:17:08,425 A:middle
to make this easy to write,

388
00:17:08,915 --> 00:17:12,925 A:middle
that it's worth forcing
everybody who's reading my code

389
00:17:12,925 --> 00:17:14,226 A:middle
to learn this new idiom.

390
00:17:14,746 --> 00:17:17,776 A:middle
I want to work through
one more example.

391
00:17:18,406 --> 00:17:23,175 A:middle
I talked a lot about
objects in the game,

392
00:17:23,175 --> 00:17:24,856 A:middle
but I haven't talked
about places.

393
00:17:25,415 --> 00:17:29,776 A:middle
In the game you're
going to be able

394
00:17:29,776 --> 00:17:32,206 A:middle
to walk around, visiting
new places.

395
00:17:32,556 --> 00:17:35,496 A:middle
And all those places are going
to be connected to other places,

396
00:17:35,586 --> 00:17:37,966 A:middle
by going east, by going
north, by going south.

397
00:17:39,386 --> 00:17:41,966 A:middle
In our class system, place
is just a special kind

398
00:17:41,966 --> 00:17:44,526 A:middle
of thing that's going to
also have a dictionary

399
00:17:44,526 --> 00:17:46,126 A:middle
that describes all
the exits out.

400
00:17:46,856 --> 00:17:50,466 A:middle
When I'm defining objects, this
is what that's going to look

401
00:17:50,466 --> 00:17:51,996 A:middle
like as the sort of first pass.

402
00:17:52,716 --> 00:17:54,786 A:middle
But this is kind of
syntactically heavyweight.

403
00:17:55,136 --> 00:17:57,746 A:middle
Again, I'm going to have
lots of places in my game.

404
00:17:57,746 --> 00:18:00,266 A:middle
I'd like this to look really
convenient and natural

405

406
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

407
00:17:57,746 --> 00:18:00,266 A:middle
I'd like this to look really
convenient and natural

408
00:18:00,266 --> 00:18:01,756 A:middle
and more compact than this.

409
00:18:02,476 --> 00:18:05,846 A:middle
Well, why do I have
to write .exits here?

410
00:18:06,606 --> 00:18:08,526 A:middle
Isn't the exits dictionary sort

411
00:18:08,526 --> 00:18:13,646 A:middle
of an implementation
detail of my place class?

412
00:18:15,296 --> 00:18:19,746 A:middle
Wouldn't it be more natural if
I could just directly subscript

413
00:18:19,746 --> 00:18:24,936 A:middle
into a place and specify where
a particular exit goes to?

414
00:18:25,606 --> 00:18:28,366 A:middle
The way that you do that is
with a subscript declaration.

415
00:18:29,646 --> 00:18:33,126 A:middle
A subscript declaration in Swift
feels a lot like a property.

416
00:18:33,126 --> 00:18:37,076 A:middle
You use the subscript keyword

417
00:18:37,076 --> 00:18:42,036 A:middle
and then you give it a parameter
clause, which is kind of like --

418
00:18:42,196 --> 00:18:43,886 A:middle
which is going to
be all the indexes

419
00:18:43,886 --> 00:18:46,276 A:middle
that are being used
to subscript in.

420
00:18:46,276 --> 00:18:51,056 A:middle
And then kind of like a
function you give it a return --

421
00:18:51,176 --> 00:18:55,046 A:middle
what feels like a return type,
that's the type of the element

422
00:18:55,676 --> 00:18:56,576 A:middle
that you subscript to.

423
00:18:58,446 --> 00:19:00,476 A:middle
But here's where it starts
feeling more like a property.

424

425
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

426
00:18:58,446 --> 00:19:00,476 A:middle
But here's where it starts
feeling more like a property.

427
00:19:00,476 --> 00:19:06,426 A:middle
You just provide a get and a set
method like any other property.

428
00:19:06,976 --> 00:19:09,876 A:middle
So the get is just going
to delegate to exits.

429
00:19:10,286 --> 00:19:13,866 A:middle
And the set just
writes back into exits.

430
00:19:13,866 --> 00:19:20,586 A:middle
All I've done here is provide
a subscript directly on place

431
00:19:20,756 --> 00:19:24,396 A:middle
that just immediately delegates
down to the exits' property.

432
00:19:25,516 --> 00:19:28,646 A:middle
But that's going to let me write
this in a much more compact

433
00:19:28,646 --> 00:19:30,596 A:middle
and natural style
over, and over again.

434
00:19:31,196 --> 00:19:36,756 A:middle
I've been talking a lot about
the ways that you can hook

435
00:19:36,756 --> 00:19:39,886 A:middle
into the basic syntax of Swift.

436
00:19:40,066 --> 00:19:41,686 A:middle
I do want to talk a little bit

437
00:19:41,686 --> 00:19:46,296 A:middle
about when you should
actually do this.

438
00:19:46,516 --> 00:19:51,526 A:middle
Taking over a basic syntax like
this, developing new idioms,

439
00:19:51,526 --> 00:19:54,826 A:middle
developing things that don't
look exactly like other things

440
00:19:54,826 --> 00:19:57,366 A:middle
in Swift can be a
little bit dangerous.

441
00:19:57,696 --> 00:20:00,066 A:middle
Not in the sense of
being dynamically unsafe,

442

443
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

444
00:19:57,696 --> 00:20:00,066 A:middle
Not in the sense of
being dynamically unsafe,

445
00:20:00,416 --> 00:20:02,976 A:middle
but in the sense of making your
code a lot harder to understand.

446
00:20:03,046 --> 00:20:07,226 A:middle
The key thing to doing this
well is to make it feel natural.

447
00:20:07,726 --> 00:20:09,526 A:middle
Think about how someone
coming along

448
00:20:09,526 --> 00:20:11,256 A:middle
and reading your
code later is going

449
00:20:11,256 --> 00:20:13,876 A:middle
to understand it
sort of intuitively.

450
00:20:14,606 --> 00:20:17,446 A:middle
Think about what your
syntax actually suggests

451
00:20:17,446 --> 00:20:20,396 A:middle
about what it's actually doing.

452
00:20:21,296 --> 00:20:25,786 A:middle
A major part of that means
not taking existing syntax

453
00:20:25,936 --> 00:20:28,266 A:middle
and making it do
something that doesn't feel

454
00:20:28,406 --> 00:20:31,046 A:middle
like what other instances
of that syntax are doing.

455
00:20:31,686 --> 00:20:36,956 A:middle
For example, my subscript is
just sort of providing a view

456
00:20:37,436 --> 00:20:39,536 A:middle
of an aspect of a place.

457
00:20:40,396 --> 00:20:41,606 A:middle
You wouldn't want a subscript

458
00:20:41,606 --> 00:20:43,266 A:middle
to do something completely
different.

459
00:20:43,666 --> 00:20:46,166 A:middle
You could syntactically,
of course,

460
00:20:46,216 --> 00:20:49,326 A:middle
the language would let you
use subscript operators

461
00:20:49,626 --> 00:20:51,166 A:middle
to do anything you want.

462
00:20:51,166 --> 00:20:54,296 A:middle
You can make it do calls,
you can make it take all

463
00:20:54,296 --> 00:20:57,286 A:middle
of your methods and implement
them using subscript methods,

464
00:20:57,526 --> 00:20:59,016 A:middle
but that wouldn't be natural.

465
00:20:59,436 --> 00:21:04,356 A:middle
It wouldn't feel like
you're really accessing part

466

467
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

468
00:20:59,436 --> 00:21:04,356 A:middle
It wouldn't feel like
you're really accessing part

469
00:21:04,356 --> 00:21:07,326 A:middle
of the object in a way that
a subscript operator does.

470
00:21:07,486 --> 00:21:09,526 A:middle
And that's going to
make it a major obstacle

471
00:21:09,526 --> 00:21:11,736 A:middle
to somebody trying to
actually understand your code.

472
00:21:13,466 --> 00:21:17,716 A:middle
And finally it's okay to add
new idioms that everybody

473
00:21:17,716 --> 00:21:19,866 A:middle
who reads your code is
going to have to learn.

474
00:21:21,256 --> 00:21:23,546 A:middle
People coming into
new code bases have

475
00:21:23,546 --> 00:21:25,116 A:middle
to learn new idioms anyway even

476
00:21:25,116 --> 00:21:27,676 A:middle
if they're just expressed
using properties and methods,

477
00:21:28,856 --> 00:21:33,816 A:middle
but when you're inventing new
idioms using basic syntax,

478
00:21:34,566 --> 00:21:36,646 A:middle
it has a sort of extra cost.

479
00:21:36,996 --> 00:21:39,476 A:middle
It's an extra, you
know, thing to learn,

480
00:21:39,636 --> 00:21:41,566 A:middle
that the programmer
needs to learn just

481
00:21:41,566 --> 00:21:45,486 A:middle
to understand even what
your code looks like.

482
00:21:47,326 --> 00:21:51,656 A:middle
That's okay to do -- that's
okay to expect someone to do

483
00:21:52,046 --> 00:21:53,806 A:middle
if it's actually worthwhile.

484
00:21:54,566 --> 00:21:57,326 A:middle
Make sure that the syntax
is paying for itself.

485
00:21:57,546 --> 00:22:00,856 A:middle
That it's worth somebody's time
to have actually learned it.

486

487
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

488
00:21:57,546 --> 00:22:00,856 A:middle
That it's worth somebody's time
to have actually learned it.

489
00:22:00,856 --> 00:22:02,576 A:middle
And that the value
that you're deriving

490
00:22:02,576 --> 00:22:07,666 A:middle
from it actually pays for it.

491
00:22:07,666 --> 00:22:10,866 A:middle
I've been talking a lot
about a bunch of very sort

492
00:22:11,696 --> 00:22:15,106 A:middle
of superficial ways that
you can extend the language.

493
00:22:15,106 --> 00:22:16,986 A:middle
I'd like to bring up
Dave Abrahams to bring

494
00:22:16,986 --> 00:22:20,356 A:middle
up a much deeper and
interesting topic,

495
00:22:20,766 --> 00:22:21,836 A:middle
which is generic programming .

496
00:22:22,056 --> 00:22:22,976 A:middle
>> Thanks John.

497
00:22:23,516 --> 00:22:27,546 A:middle
[ Applause ]

498
00:22:28,046 --> 00:22:30,386 A:middle
How's everybody doing?

499
00:22:30,386 --> 00:22:32,496 A:middle
Good? Because we were
a little concerned.

500
00:22:33,096 --> 00:22:37,736 A:middle
You know. We thought maybe after
three days of total immersion

501
00:22:37,736 --> 00:22:40,616 A:middle
in Swift you might be
feeling a little uneasy,

502
00:22:40,616 --> 00:22:42,736 A:middle
maybe a little jittery even,

503
00:22:43,216 --> 00:22:44,626 A:middle
because you haven't seen
one of these in a while.

504
00:22:46,666 --> 00:22:48,446 A:middle
So I'm just going to
give you a moment to sit

505
00:22:48,446 --> 00:22:49,776 A:middle
with it, okay [applause].

506
00:22:50,536 --> 00:22:51,186 A:middle
Drink it in.

507
00:22:52,436 --> 00:22:54,236 A:middle
Okay. Because you won't see
another one before the end

508
00:22:54,236 --> 00:22:54,706 A:middle
of the talk.

509
00:22:55,496 --> 00:22:59,896 A:middle
And we're going to go to our
first slide in three, two, one.

510

511
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

512
00:23:02,446 --> 00:23:04,776 A:middle
Sorry semicolon lovers.

513
00:23:05,516 --> 00:23:08,966 A:middle
Okay so let me tell you a
story about my friend, Crusty.

514
00:23:10,186 --> 00:23:11,656 A:middle
Crusty is old school.

515
00:23:12,456 --> 00:23:15,986 A:middle
Programming in Swift is like
his one concession to modernity

516
00:23:17,036 --> 00:23:21,216 A:middle
and he doesn't trust modern
tools IDEs or debuggers,

517
00:23:21,616 --> 00:23:25,916 A:middle
no he likes to debug his Swift
code by logging to the console.

518
00:23:26,436 --> 00:23:29,106 A:middle
He was using a family of
logging functions like this.

519
00:23:30,196 --> 00:23:33,926 A:middle
Now when he needed to look

520
00:23:33,926 --> 00:23:36,646 A:middle
at an interesting string
value he would peek String.

521
00:23:37,586 --> 00:23:39,436 A:middle
And if he wanted to peek at
an interesting int value,

522
00:23:39,436 --> 00:23:42,306 A:middle
he would peek int and so on.

523
00:23:42,756 --> 00:23:44,586 A:middle
But it turns out every once

524
00:23:44,586 --> 00:23:47,566 A:middle
in a while even old Crusty
takes a step into the future.

525
00:23:48,756 --> 00:23:51,536 A:middle
And one day he strode into
my office and announced

526
00:23:51,536 --> 00:23:57,806 A:middle
that he had rewritten his
logging to use overloading.

527
00:23:59,046 --> 00:24:04,996 A:middle
He said to me, "Dave, well Swift
takes a look at the arguments

528

529
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

530
00:23:59,046 --> 00:24:04,996 A:middle
He said to me, "Dave, well Swift
takes a look at the arguments

531
00:24:04,996 --> 00:24:06,556 A:middle
that I'm actually
passing and figures

532
00:24:06,556 --> 00:24:08,636 A:middle
out which function
I want to call.

533
00:24:10,916 --> 00:24:13,886 A:middle
Now I just always write peek
and leave off the type name."

534
00:24:15,266 --> 00:24:18,916 A:middle
Now I had used overloading
before so, you know,

535
00:24:19,026 --> 00:24:21,776 A:middle
this wasn't a big deal for me,
but it is kind of a big day

536
00:24:21,776 --> 00:24:24,756 A:middle
when Crusty changes,
well anything.

537
00:24:25,656 --> 00:24:28,196 A:middle
So I didn't want to burst
his bubble, you know.

538
00:24:28,796 --> 00:24:33,366 A:middle
I was about to say something
encouraging when he looked

539
00:24:33,366 --> 00:24:35,806 A:middle
over my shoulder and said,
"What in tarnation is that?"

540
00:24:37,446 --> 00:24:38,596 A:middle
And "What," I said.

541
00:24:39,926 --> 00:24:40,686 A:middle
He said, "That."

542
00:24:41,706 --> 00:24:44,566 A:middle
Leaving a smudge on my
gorgeous retina display.

543
00:24:46,516 --> 00:24:50,126 A:middle
[ Applause ]

544
00:24:50,626 --> 00:24:56,326 A:middle
"Oh Any? Well any is the empty
protocol type," I told him.

545
00:24:56,326 --> 00:24:57,976 A:middle
"It's got no operations in it,

546
00:24:58,286 --> 00:25:00,316 A:middle
but it can hold literally
anything.

547

548
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

549
00:24:58,286 --> 00:25:00,316 A:middle
but it can hold literally
anything.

550
00:25:01,366 --> 00:25:05,386 A:middle
And by the time I had
looked up Crusty was gone.

551
00:25:05,426 --> 00:25:06,696 A:middle
He had run back to his office

552
00:25:06,696 --> 00:25:10,736 A:middle
to re-implement his
logging functions like this.

553
00:25:10,916 --> 00:25:14,606 A:middle
Now this version of peek
worked great and it left room

554
00:25:14,646 --> 00:25:17,106 A:middle
for more code in the
80x24 terminal windows

555
00:25:17,106 --> 00:25:17,976 A:middle
that crusty favored [laughter].

556
00:25:21,016 --> 00:25:25,936 A:middle
Also since everything in Swift
can be printed, peek even worked

557
00:25:26,316 --> 00:25:30,906 A:middle
for some types that Crusty
had never peeked at before.

558
00:25:31,026 --> 00:25:34,146 A:middle
So all was right with the
world and Crusty was happy.

559
00:25:34,756 --> 00:25:37,936 A:middle
That is at least until
the doghouse showed

560
00:25:37,936 --> 00:25:38,986 A:middle
up in his window title.

561
00:25:40,196 --> 00:25:44,146 A:middle
Now this was a problem because
nothing gets old Crusty's dander

562
00:25:44,146 --> 00:25:47,166 A:middle
up like pesky emoji
in his window title.

563
00:25:47,776 --> 00:25:49,426 A:middle
So he said.

564
00:25:50,336 --> 00:25:53,506 A:middle
See he had written
this fancy extension

565
00:25:53,506 --> 00:25:55,966 A:middle
on string adding a
computed property

566
00:25:56,566 --> 00:25:58,536 A:middle
so he could eliminate
these emoji.

567
00:25:59,126 --> 00:26:02,666 A:middle
And he carefully
used this property

568

569
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

570
00:25:59,126 --> 00:26:02,666 A:middle
And he carefully
used this property

571
00:26:03,656 --> 00:26:06,086 A:middle
in his computation
of the window title.

572
00:26:07,196 --> 00:26:10,296 A:middle
Crusty scratched his head and
thought about his next moved.

573
00:26:10,856 --> 00:26:15,466 A:middle
He figured what I
really need to do is see

574
00:26:15,466 --> 00:26:18,586 A:middle
if the offending characters are
there in the original string.

575
00:26:19,326 --> 00:26:23,056 A:middle
So I'm going to peek at
that -- that sub expression.

576
00:26:26,396 --> 00:26:29,546 A:middle
Now normally he might have
rewritten his code like this,

577
00:26:30,126 --> 00:26:32,346 A:middle
so breaking out the
expression of interest

578
00:26:32,346 --> 00:26:37,326 A:middle
into a name constant, peeking
at that and then carrying

579
00:26:37,326 --> 00:26:38,406 A:middle
on with a computation.

580
00:26:39,986 --> 00:26:42,126 A:middle
But old Crusty had been
in a fix like this before.

581
00:26:42,776 --> 00:26:44,266 A:middle
He was sick and tired

582
00:26:44,266 --> 00:26:46,846 A:middle
of reformatting his code
every time he wanted

583
00:26:46,846 --> 00:26:47,976 A:middle
to do a little debugging work.

584
00:26:51,506 --> 00:26:53,936 A:middle
"Ah-ha," thought Crusty,
"I know what I'll do.

585
00:26:54,076 --> 00:26:56,356 A:middle
I'll return the interesting
value from peek

586
00:26:56,356 --> 00:26:58,906 A:middle
and then I'll be
able to insert a call

587
00:26:58,906 --> 00:27:00,216 A:middle
to it right in the expression."

588

589
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

590
00:26:58,906 --> 00:27:00,216 A:middle
to it right in the expression."

591
00:27:01,546 --> 00:27:06,306 A:middle
Which was an awesome idea,
except that doesn't work.

592
00:27:07,916 --> 00:27:12,286 A:middle
So, you see using Any
throws away the stringiness

593
00:27:12,476 --> 00:27:13,176 A:middle
of the argument.

594
00:27:13,726 --> 00:27:17,146 A:middle
So of course the compiler
doesn't know what's coming

595
00:27:17,146 --> 00:27:18,826 A:middle
out of that peek function.

596
00:27:20,166 --> 00:27:22,876 A:middle
It could be an NS document
controller delegate,

597
00:27:23,106 --> 00:27:24,846 A:middle
or it could be an int,
or it could be a string.

598
00:27:26,486 --> 00:27:30,526 A:middle
At the call site the complier
only sees that signature.

599
00:27:33,296 --> 00:27:37,866 A:middle
So Crusty knew that he could
always downcast to string

600
00:27:37,866 --> 00:27:40,756 A:middle
to get his string
back out of the Any.

601
00:27:41,816 --> 00:27:44,266 A:middle
But if there's one thing
I can say for Crusty,

602
00:27:44,266 --> 00:27:48,446 A:middle
the man's got taste, you know,
he cannot tolerate ugly code

603
00:27:48,446 --> 00:27:49,646 A:middle
and this was starting
to get ugly.

604
00:27:50,186 --> 00:27:54,896 A:middle
That's when Crusty dove into
the Swift language guide

605
00:27:55,256 --> 00:27:57,666 A:middle
and discovered that the
tiniest change could make all

606
00:27:57,666 --> 00:27:58,216 A:middle
the difference.

607
00:27:58,546 --> 00:28:03,606 A:middle
What he did here was turn
peek into a generic function.

608

609
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

610
00:27:58,546 --> 00:28:03,606 A:middle
What he did here was turn
peek into a generic function.

611
00:28:04,726 --> 00:28:07,286 A:middle
Now a generic function
is declared

612
00:28:07,286 --> 00:28:10,836 A:middle
with a type parameter
list in angle brackets

613
00:28:11,196 --> 00:28:12,406 A:middle
after the base function name.

614
00:28:13,526 --> 00:28:17,476 A:middle
In this case, there's
just one T.

615
00:28:18,406 --> 00:28:21,506 A:middle
Now you can thing of T as
a placeholder for any type.

616
00:28:21,506 --> 00:28:24,276 A:middle
And when you write
a function this way,

617
00:28:24,456 --> 00:28:27,456 A:middle
Swift deduces what
T is from the type

618
00:28:27,566 --> 00:28:29,156 A:middle
of the actual argument you pass.

619
00:28:29,606 --> 00:28:31,276 A:middle
It's a lot like figuring
out which function

620
00:28:31,276 --> 00:28:32,466 A:middle
to call in an overload set.

621
00:28:33,366 --> 00:28:36,536 A:middle
In the case above we
passed a string to peek

622
00:28:36,536 --> 00:28:37,786 A:middle
so peek returns a string.

623
00:28:38,376 --> 00:28:40,926 A:middle
Not string wrapped in an
any, but good old string.

624
00:28:42,806 --> 00:28:44,996 A:middle
And it just worked.

625
00:28:46,506 --> 00:28:49,646 A:middle
Now we've seen two very
different ways to deal

626
00:28:49,756 --> 00:28:51,666 A:middle
with things of arbitrary type.

627
00:28:52,806 --> 00:28:56,326 A:middle
We could pass them as instances
of a protocol type like Any

628
00:28:56,326 --> 00:28:58,136 A:middle
or pullable that
John showed you,

629
00:28:59,676 --> 00:29:01,146 A:middle
which erases type information.

630

631
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

632
00:28:59,676 --> 00:29:01,146 A:middle
which erases type information.

633
00:29:01,836 --> 00:29:04,956 A:middle
Or we could pass them
as generic parameters,

634
00:29:05,546 --> 00:29:09,576 A:middle
we could let their types bind
to the generic parameters

635
00:29:09,576 --> 00:29:12,676 A:middle
of generic functions and that
can serve as type information.

636
00:29:13,886 --> 00:29:17,336 A:middle
Now there's nothing wrong
with erasing type information

637
00:29:17,626 --> 00:29:19,796 A:middle
when what you want is
dynamic polymorphism.

638
00:29:20,216 --> 00:29:23,016 A:middle
So you want to make a
collection of objects

639
00:29:23,076 --> 00:29:26,336 A:middle
that are all different
types of objects.

640
00:29:26,936 --> 00:29:29,556 A:middle
And you know that has to
be dynamic at runtime.

641
00:29:30,446 --> 00:29:32,186 A:middle
Great. Use type eraser.

642
00:29:32,786 --> 00:29:34,846 A:middle
But when you don't need
dynamic polymorphism,

643
00:29:35,276 --> 00:29:36,956 A:middle
there's some pretty
compelling upsides

644
00:29:36,956 --> 00:29:38,326 A:middle
to conserving type information.

645
00:29:39,346 --> 00:29:42,116 A:middle
So first, when the
compiler keeps track

646
00:29:42,366 --> 00:29:45,236 A:middle
of what types you're actually
using, you don't have to resort

647
00:29:45,236 --> 00:29:48,676 A:middle
to unsafe downcasts like we
saw in the previous example.

648
00:29:49,416 --> 00:29:51,136 A:middle
And you don't have to
deal with the possibility

649
00:29:51,136 --> 00:29:52,336 A:middle
that those casts might fail.

650
00:29:52,886 --> 00:29:57,216 A:middle
And second, when the compiler
knows just what types you're

651
00:29:57,216 --> 00:29:59,986 A:middle
dealing with, it can
generate much better code,

652
00:29:59,986 --> 00:30:01,976 A:middle
it can generate code
just for those types.

653

654
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

655
00:29:59,986 --> 00:30:01,976 A:middle
it can generate code
just for those types.

656
00:30:02,636 --> 00:30:05,556 A:middle
And John will be talking
more when he comes back

657
00:30:05,646 --> 00:30:09,546 A:middle
about how the internal
mechanisms work with that.

658
00:30:11,306 --> 00:30:14,766 A:middle
Another reason to like
conserving type information is

659
00:30:14,766 --> 00:30:18,616 A:middle
that it allows us to express
relationships among types.

660
00:30:19,956 --> 00:30:23,216 A:middle
Consider this function,
which comes with Swift.

661
00:30:23,786 --> 00:30:25,796 A:middle
It just exchanges
two arbitrary values.

662
00:30:26,796 --> 00:30:30,036 A:middle
Here, X and Y can
have any type at all,

663
00:30:30,036 --> 00:30:33,186 A:middle
as long as they have
the same type.

664
00:30:34,036 --> 00:30:38,906 A:middle
So for example student teacher
ratios being what they are,

665
00:30:38,906 --> 00:30:41,396 A:middle
it might make sense to
exchange the number of students

666
00:30:41,396 --> 00:30:44,656 A:middle
with the number or teachers,
but exchanging the name

667
00:30:44,656 --> 00:30:52,976 A:middle
of your school with the number
of students is nonsense.

668
00:30:53,866 --> 00:30:56,806 A:middle
I love the way Swift helps we
write correct code the first

669
00:30:56,806 --> 00:30:59,446 A:middle
time because it doesn't
tolerate this kind of stuff.

670

671
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

672
00:31:00,616 --> 00:31:03,326 A:middle
Note that you can't do
anything like this with Any

673
00:31:03,326 --> 00:31:07,376 A:middle
or with your similar thing
in Objective-C like ID,

674
00:31:07,806 --> 00:31:10,296 A:middle
because converting to
these types throws away the

675
00:31:10,296 --> 00:31:11,066 A:middle
type information.

676
00:31:11,566 --> 00:31:12,766 A:middle
It takes real generics,

677
00:31:13,306 --> 00:31:16,006 A:middle
which conserve type
information to get this right.

678
00:31:17,366 --> 00:31:19,896 A:middle
Okay let's look at a
more interesting example.

679
00:31:21,976 --> 00:31:25,356 A:middle
Here's a simple function that
takes an array of strings,

680
00:31:25,356 --> 00:31:30,096 A:middle
iterates through the indices in
the array, looking for an index

681
00:31:30,096 --> 00:31:32,756 A:middle
where there's a string that
matches the one that you passed.

682
00:31:33,676 --> 00:31:35,796 A:middle
And if it finds it,
it returns the index,

683
00:31:36,316 --> 00:31:37,326 A:middle
otherwise it returns nil.

684
00:31:38,006 --> 00:31:41,686 A:middle
Right? It's returning
an optional.

685
00:31:41,816 --> 00:31:44,346 A:middle
Okay so let's generalize this.

686
00:31:45,616 --> 00:31:48,836 A:middle
First we just find the
concrete types that we want

687
00:31:48,836 --> 00:31:52,336 A:middle
to make variable, string
and we replace those

688
00:31:52,336 --> 00:31:53,316 A:middle
with generic parameters.

689
00:31:53,846 --> 00:31:59,636 A:middle
But it's not quite that simple.

690
00:31:59,756 --> 00:32:03,916 A:middle
Right, now that T is no longer
a known type like string.

691

692
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

693
00:31:59,756 --> 00:32:03,916 A:middle
Right, now that T is no longer
a known type like string.

694
00:32:04,296 --> 00:32:06,076 A:middle
The compiler isn't entirely sure

695
00:32:06,076 --> 00:32:08,986 A:middle
that we can compare these
two things with equal equal.

696
00:32:09,996 --> 00:32:14,586 A:middle
So let's fix that by
constraining T to be equatable.

697
00:32:18,416 --> 00:32:21,736 A:middle
See, the function signature
already imposed one type

698
00:32:21,736 --> 00:32:23,266 A:middle
constraint, that the type

699
00:32:23,266 --> 00:32:28,386 A:middle
of value matched the
element type of the array.

700
00:32:28,386 --> 00:32:30,336 A:middle
Equatable adds another
kind of type constraint

701
00:32:30,896 --> 00:32:32,146 A:middle
for callers to find value.

702
00:32:32,516 --> 00:32:34,536 A:middle
And in exchange for
constraining callers,

703
00:32:34,976 --> 00:32:37,516 A:middle
now we have a new
capability inside of the body,

704
00:32:37,896 --> 00:32:39,706 A:middle
which is to compare
with equal equal.

705
00:32:40,276 --> 00:32:43,776 A:middle
All right let's see how
equatable is compared.

706
00:32:45,876 --> 00:32:47,626 A:middle
Of course equatable
is a protocol,

707
00:32:49,066 --> 00:32:52,266 A:middle
a blueprint for type
as John put it.

708
00:32:52,586 --> 00:32:54,496 A:middle
Now this one imposes
a single requirement

709
00:32:54,496 --> 00:32:55,916 A:middle
that there's an equal
equal operator.

710
00:32:56,476 --> 00:33:00,176 A:middle
If you're familiar with
protocols in Objective-C,

711

712
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

713
00:32:56,476 --> 00:33:00,176 A:middle
If you're familiar with
protocols in Objective-C,

714
00:33:00,736 --> 00:33:04,116 A:middle
it may help to know that every
single Objective-C protocol is

715
00:33:04,116 --> 00:33:05,246 A:middle
also a Swift protocol.

716
00:33:06,496 --> 00:33:09,656 A:middle
However, Swift protocols
have some capabilities

717
00:33:09,656 --> 00:33:11,196 A:middle
that Objective-C
protocols don't,

718
00:33:11,606 --> 00:33:14,366 A:middle
which makes them especially
well-suited to generic program.

719
00:33:15,856 --> 00:33:20,136 A:middle
Case in point, because
Swift generics conserve type

720
00:33:20,136 --> 00:33:22,146 A:middle
information, they have access

721
00:33:22,146 --> 00:33:24,766 A:middle
to the full type
implementing Any protocol.

722
00:33:25,756 --> 00:33:28,476 A:middle
Here we're saying that there
must be an equality operator

723
00:33:28,476 --> 00:33:31,856 A:middle
that takes two instances of the
type implementing equatable.

724
00:33:32,366 --> 00:33:37,016 A:middle
Note that some popular languages
implement what they call

725
00:33:37,016 --> 00:33:41,596 A:middle
generics with type eraser,
essentially Any plus downcasts.

726
00:33:42,436 --> 00:33:45,226 A:middle
And because these languages
throw type information away,

727
00:33:45,686 --> 00:33:48,506 A:middle
they're unable to express
even something as fundamental

728
00:33:48,506 --> 00:33:50,826 A:middle
and basic as this in
their generic system.

729
00:33:51,146 --> 00:33:52,706 A:middle
But Swift handles
it beautifully.

730
00:33:52,706 --> 00:33:55,806 A:middle
All right now let's quickly --

731
00:33:56,296 --> 00:33:56,966 A:middle
Thank you very much.

732
00:33:57,516 --> 00:34:01,126 A:middle
[ Applause ]

733

734
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

735
00:33:57,516 --> 00:34:01,126 A:middle
[ Applause ]

736
00:34:01,626 --> 00:34:04,926 A:middle
Now let's quickly make
an equatable type.

737
00:34:05,796 --> 00:34:11,056 A:middle
So temperature here is just a
little wrapper over and int.

738
00:34:11,056 --> 00:34:13,025 A:middle
And there's a couple
of things to notice.

739
00:34:13,025 --> 00:34:14,926 A:middle
First temperature is a struct.

740
00:34:15,616 --> 00:34:20,366 A:middle
Protocol adoption is available
to structs, enums, and classes.

741
00:34:20,366 --> 00:34:22,176 A:middle
Not just classes
as an Objective-C.

742
00:34:23,646 --> 00:34:28,056 A:middle
Second of all, we've satisfied
its operator requirement outside

743
00:34:28,056 --> 00:34:32,436 A:middle
the type body and
that's sort of specific

744
00:34:32,436 --> 00:34:34,126 A:middle
to operator requirements.

745
00:34:34,416 --> 00:34:37,196 A:middle
All other requirements you'll
find satisfied inside the type

746
00:34:37,226 --> 00:34:38,966 A:middle
body or inside an extension.

747
00:34:41,936 --> 00:34:47,096 A:middle
Okay. So you may be wondering,
well where's not equal.

748
00:34:48,246 --> 00:34:51,826 A:middle
Well it's not a requirement,
we didn't have to write it,

749
00:34:52,176 --> 00:34:53,636 A:middle
because Swift provides this one.

750
00:34:54,436 --> 00:35:00,256 A:middle
It's a generic not equal
that depends on equatable

751

752
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

753
00:34:54,436 --> 00:35:00,256 A:middle
It's a generic not equal
that depends on equatable

754
00:35:01,256 --> 00:35:04,246 A:middle
and uses the equal equal
operator to implement it.

755
00:35:04,976 --> 00:35:07,176 A:middle
So that works for
every equatable type,

756
00:35:07,346 --> 00:35:08,616 A:middle
which is pretty Swift indeed.

757
00:35:09,516 --> 00:35:14,886 A:middle
[ Applause ]

758
00:35:15,386 --> 00:35:18,096 A:middle
Okay let's look at an example

759
00:35:18,096 --> 00:35:20,016 A:middle
of how we can use what
we've seen so far.

760
00:35:20,686 --> 00:35:23,636 A:middle
Now I wanted to come up with
a really practical example.

761
00:35:23,956 --> 00:35:27,106 A:middle
Something that, you know, you
would use in your day to day

762
00:35:27,106 --> 00:35:28,056 A:middle
in your Cocoa programming.

763
00:35:28,476 --> 00:35:31,506 A:middle
So what we're going to be doing
is computing phi the Golden

764
00:35:31,506 --> 00:35:37,296 A:middle
Mean, which is the ratio of
consecutive Fibonacci numbers

765
00:35:37,296 --> 00:35:38,746 A:middle
as N approaches infinity.

766
00:35:40,126 --> 00:35:42,666 A:middle
The slide warned you that we
were horrible nerds right?

767
00:35:43,796 --> 00:35:50,126 A:middle
Okay. So first we need to
computer the N Fibonacci number.

768
00:35:50,706 --> 00:35:56,176 A:middle
So that's just the sum of the
previous two Fibonacci numbers

769
00:35:56,656 --> 00:35:59,216 A:middle
where the first two Fibonacci
numbers are zero and 1.

770

771
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

772
00:36:00,436 --> 00:36:02,156 A:middle
Okay, this is not
the fastest way

773
00:36:02,156 --> 00:36:05,716 A:middle
to compute the Fibonacci
numbers, but it is really hard

774
00:36:05,716 --> 00:36:07,066 A:middle
to beat for its simplicity,

775
00:36:07,066 --> 00:36:08,886 A:middle
and mathematical
purity, and elegance.

776
00:36:09,436 --> 00:36:11,506 A:middle
It's really easy to verify

777
00:36:11,506 --> 00:36:13,086 A:middle
that this does exactly
the right thing.

778
00:36:15,876 --> 00:36:16,416 A:middle
And here's phi.

779
00:36:16,416 --> 00:36:21,296 A:middle
We need to go a few
iterations right up to about 45

780
00:36:21,296 --> 00:36:23,656 A:middle
so that we get enough
precision with our estimate.

781
00:36:25,116 --> 00:36:29,556 A:middle
Now running this part of our
program takes 11 seconds,

782
00:36:30,776 --> 00:36:33,316 A:middle
11 seconds on a fast machine.

783
00:36:34,416 --> 00:36:38,336 A:middle
Well it's easy to see why if
you look at the call graph.

784
00:36:39,096 --> 00:36:42,926 A:middle
So just looking at
Fibonacci at 5, that depends

785
00:36:42,926 --> 00:36:44,826 A:middle
on Fibonacci of 4 and 3.

786
00:36:45,696 --> 00:36:50,206 A:middle
And Fibonacci of 4 depends
on Fibonacci of 3 and 2.

787
00:36:50,206 --> 00:36:51,516 A:middle
And you can already start to see

788
00:36:51,516 --> 00:36:53,356 A:middle
that it repeated
computations in here.

789
00:36:53,816 --> 00:36:55,516 A:middle
And if you look at
the entire call graph,

790
00:36:55,946 --> 00:36:57,826 A:middle
well you can see there's
a lot of repetition.

791
00:36:58,706 --> 00:37:01,136 A:middle
Now expand this up 45 levels

792

793
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

794
00:36:58,706 --> 00:37:01,136 A:middle
Now expand this up 45 levels

795
00:37:01,796 --> 00:37:06,236 A:middle
and you've got a recipe
for a slow program.

796
00:37:07,636 --> 00:37:11,286 A:middle
However, if we could
just store our results

797
00:37:11,286 --> 00:37:13,416 A:middle
in a dictionary the first
time we compute them,

798
00:37:14,896 --> 00:37:19,146 A:middle
then we could turn all of these
calls into fast lookups, right.

799
00:37:19,936 --> 00:37:23,966 A:middle
And these calls well they
would just disappear entirely.

800
00:37:24,486 --> 00:37:28,206 A:middle
This technique is
called memoization.

801
00:37:28,626 --> 00:37:31,396 A:middle
And while Fibonacci makes
a great example for it

802
00:37:31,396 --> 00:37:33,906 A:middle
because it -- you know,
recalls the same function over,

803
00:37:33,906 --> 00:37:34,306 A:middle
and over.

804
00:37:34,626 --> 00:37:38,496 A:middle
You can apply it to speed
up any pure function

805
00:37:39,026 --> 00:37:40,666 A:middle
where you might be
calling it over,

806
00:37:40,666 --> 00:37:42,596 A:middle
and over with the same
sets of arguments.

807
00:37:45,326 --> 00:37:49,346 A:middle
Okay let's manually
memoize Fibonacci, okay.

808
00:37:49,836 --> 00:37:53,996 A:middle
First we need a dictionary.

809
00:37:54,036 --> 00:37:58,286 A:middle
Next we change the function body
so that it checks the dictionary

810
00:37:58,286 --> 00:38:01,686 A:middle
to see if it's got the result
and only computes the result

811

812
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

813
00:37:58,286 --> 00:38:01,686 A:middle
to see if it's got the result
and only computes the result

814
00:38:01,686 --> 00:38:05,036 A:middle
if it isn't found there.

815
00:38:05,256 --> 00:38:08,316 A:middle
Now how does our
function perform?

816
00:38:08,426 --> 00:38:11,246 A:middle
Okay 100x speedup,
that's pretty good.

817
00:38:11,246 --> 00:38:15,296 A:middle
It's 100 times more
Swift, okay [applause].

818
00:38:16,016 --> 00:38:17,956 A:middle
Please forgive me,
please forgive me.

819
00:38:19,856 --> 00:38:21,936 A:middle
Now this is awesome,
but we've kind

820
00:38:21,936 --> 00:38:23,596 A:middle
of destroyed the readability

821
00:38:23,786 --> 00:38:25,826 A:middle
and mathematical
purity of our function.

822
00:38:26,376 --> 00:38:29,056 A:middle
I mean, if you look in there
really hard you might be able

823
00:38:29,056 --> 00:38:33,346 A:middle
to find the original computation
among all of that boilerplate.

824
00:38:33,526 --> 00:38:35,896 A:middle
There it is.

825
00:38:35,896 --> 00:38:38,986 A:middle
It would be nice if we
could encapsulate all

826
00:38:38,986 --> 00:38:40,546 A:middle
of that road code transformation

827
00:38:40,986 --> 00:38:43,366 A:middle
so we could easily
memoize any function

828
00:38:43,986 --> 00:38:45,366 A:middle
without destroying
its readability.

829
00:38:45,876 --> 00:38:49,106 A:middle
Something like this.

830
00:38:49,326 --> 00:38:50,846 A:middle
Well in Swift, you can.

831
00:38:51,416 --> 00:38:55,416 A:middle
In fact memoize isn't
in the language,

832
00:38:56,596 --> 00:38:58,136 A:middle
it's just a generic
function I wrote.

833
00:38:58,646 --> 00:39:03,546 A:middle
And the code between the
curlies, well that's a closure

834

835
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

836
00:38:58,646 --> 00:39:03,546 A:middle
And the code between the
curlies, well that's a closure

837
00:39:03,846 --> 00:39:07,756 A:middle
or an anonymous function being
passed as an argument to memoize

838
00:39:08,056 --> 00:39:10,046 A:middle
with trailing closure syntax.

839
00:39:11,216 --> 00:39:14,296 A:middle
Memoize returns another closure

840
00:39:15,356 --> 00:39:18,826 A:middle
and that's what we're
storing in Fibonacci.

841
00:39:18,826 --> 00:39:20,956 A:middle
So Fibonacci's just
like a function.

842
00:39:20,956 --> 00:39:24,386 A:middle
You know a regular function
is just a constant bound

843
00:39:25,136 --> 00:39:26,266 A:middle
to a closure.

844
00:39:27,476 --> 00:39:29,956 A:middle
So in fact you don't even
need that type annotation

845
00:39:29,956 --> 00:39:33,786 A:middle
in this case because Swift type
inference can figure it all

846
00:39:33,786 --> 00:39:34,266 A:middle
out for you.

847
00:39:35,306 --> 00:39:37,306 A:middle
And now memoize is general.

848
00:39:38,076 --> 00:39:42,086 A:middle
So when I discover that my
app is bleeding CPU cycles

849
00:39:42,136 --> 00:39:45,976 A:middle
by parsing the same
property list strings over

850
00:39:45,976 --> 00:39:47,966 A:middle
and over again I can go back

851
00:39:47,966 --> 00:39:52,816 A:middle
and use memoize again,
just like this.

852
00:39:53,036 --> 00:39:54,876 A:middle
Okay let me show
you how this works.

853
00:39:55,446 --> 00:39:59,776 A:middle
So this is a first cut at
a memoization function.

854

855
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

856
00:40:01,466 --> 00:40:02,176 A:middle
A simple version.

857
00:40:03,006 --> 00:40:05,236 A:middle
All right, yes I know it
doesn't look that simple,

858
00:40:05,296 --> 00:40:06,706 A:middle
but I'll take it apart for you.

859
00:40:07,466 --> 00:40:10,686 A:middle
So it takes one parameter
called body

860
00:40:11,406 --> 00:40:13,156 A:middle
which is the closure, right?

861
00:40:14,076 --> 00:40:16,626 A:middle
And the types, the
argument and return types

862
00:40:16,626 --> 00:40:18,936 A:middle
of that closure are
arbitrary except

863
00:40:18,936 --> 00:40:20,746 A:middle
that there's this constraint

864
00:40:21,526 --> 00:40:23,186 A:middle
on the argument type
that it be hashable.

865
00:40:24,416 --> 00:40:25,356 A:middle
Why do we need that?

866
00:40:25,516 --> 00:40:28,606 A:middle
Well so we can use the argument
type as a key in the dictionary.

867
00:40:30,526 --> 00:40:34,456 A:middle
Right? And it returns the same
type of closure that it gets.

868
00:40:37,166 --> 00:40:41,536 A:middle
Okay. Inside the body this is
actually pretty straightforward.

869
00:40:42,076 --> 00:40:44,726 A:middle
So first we create the
dictionary that we're going

870
00:40:44,726 --> 00:40:46,356 A:middle
to need to use to
memoize that function.

871
00:40:48,316 --> 00:40:51,796 A:middle
And then we return a
closure which is wrapped

872
00:40:51,796 --> 00:40:56,346 A:middle
around an invocation of the body
which is the actual computation,

873
00:40:56,616 --> 00:40:58,996 A:middle
right, and the usual
memoization dance.

874
00:40:59,526 --> 00:41:02,286 A:middle
Where we look in the dictionary
and return the value we found

875

876
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

877
00:40:59,526 --> 00:41:02,286 A:middle
Where we look in the dictionary
and return the value we found

878
00:41:02,286 --> 00:41:04,476 A:middle
if we found it, otherwise
compute

879
00:41:04,476 --> 00:41:05,776 A:middle
and put it in the dictionary.

880
00:41:07,366 --> 00:41:10,586 A:middle
Okay. Now this version
of memoize works great

881
00:41:11,246 --> 00:41:13,836 A:middle
for functions like
parse property list.

882
00:41:15,216 --> 00:41:17,376 A:middle
This just works,
which is awesome,

883
00:41:17,706 --> 00:41:21,056 A:middle
but for recursive
functions, like factorial,

884
00:41:21,366 --> 00:41:24,806 A:middle
or Fibonacci, well not so much.

885
00:41:25,696 --> 00:41:27,816 A:middle
You see Swift doesn't want us

886
00:41:27,846 --> 00:41:33,436 A:middle
to use a variable's only
value to initialize it.

887
00:41:33,676 --> 00:41:36,186 A:middle
Like initialize itself
in terms of itself.

888
00:41:36,186 --> 00:41:37,996 A:middle
That just doesn't
make sense, right,

889
00:41:38,326 --> 00:41:40,346 A:middle
it's usually a terrible
programming error.

890
00:41:41,016 --> 00:41:43,766 A:middle
So what can we do
to get out of this?

891
00:41:43,966 --> 00:41:47,016 A:middle
Well we could do this
two-phase initialization dance.

892
00:41:48,576 --> 00:41:52,376 A:middle
Here what we've done is we've
made factorial a variable.

893
00:41:52,956 --> 00:41:55,006 A:middle
And we've initialized it
with something throwaway

894
00:41:55,006 --> 00:41:57,216 A:middle
like the identity
function, right?

895
00:41:57,396 --> 00:42:00,176 A:middle
Dollar zero in braces just
returns the argument it gets.

896

897
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

898
00:41:57,396 --> 00:42:00,176 A:middle
Dollar zero in braces just
returns the argument it gets.

899
00:42:01,316 --> 00:42:03,496 A:middle
And then we reassign
factorial to memoize.

900
00:42:04,016 --> 00:42:09,746 A:middle
Okay this works, but
it's got a few downsides.

901
00:42:09,746 --> 00:42:12,296 A:middle
First of all, it's ugly
so Crusty's not going

902
00:42:12,296 --> 00:42:13,896 A:middle
to be happy with us, right.

903
00:42:14,366 --> 00:42:16,286 A:middle
Second of all we had to write

904
00:42:16,286 --> 00:42:19,396 A:middle
out the explicit type
annotation, that Int arrow Int.

905
00:42:20,176 --> 00:42:22,266 A:middle
And that used to
be deduced for us.

906
00:42:22,716 --> 00:42:27,246 A:middle
But most importantly of all,
it makes factorial mutable,

907
00:42:27,536 --> 00:42:28,566 A:middle
which we didn't intend.

908
00:42:29,456 --> 00:42:32,606 A:middle
And keeping things immutable
as often as possible is a,

909
00:42:32,996 --> 00:42:36,596 A:middle
you know, is a great path toward
correctness and easy to reason

910
00:42:36,596 --> 00:42:40,006 A:middle
about programs and all kinds of
things, including thread safety.

911
00:42:41,426 --> 00:42:43,746 A:middle
So fortunately, there's
a better way.

912
00:42:45,836 --> 00:42:46,896 A:middle
Ready for take two?

913
00:42:47,526 --> 00:42:49,316 A:middle
I'm going to warn you in advance

914
00:42:49,636 --> 00:42:52,626 A:middle
that this is a little
bit mind blowing, okay?

915
00:42:52,626 --> 00:42:55,166 A:middle
If your mind's not
already blown.

916
00:42:56,216 --> 00:43:00,736 A:middle
So let's just have
memoize pass factorial

917

918
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

919
00:42:56,216 --> 00:43:00,736 A:middle
So let's just have
memoize pass factorial

920
00:43:01,186 --> 00:43:03,446 A:middle
as an argument to its own body.

921
00:43:04,706 --> 00:43:11,796 A:middle
Right? Okay but stick with
me you'll get it, okay.

922
00:43:12,396 --> 00:43:16,716 A:middle
So if we can pass factorial in
it as an argument to this body,

923
00:43:17,206 --> 00:43:18,956 A:middle
then that factorial
on the right,

924
00:43:18,956 --> 00:43:23,216 A:middle
well that refers just back
to the function parameter.

925
00:43:23,216 --> 00:43:26,996 A:middle
It's just like referring to X.

926
00:43:27,236 --> 00:43:31,956 A:middle
See now our closure has two
parameters, a function and X.

927
00:43:33,056 --> 00:43:37,976 A:middle
All right so what do we need
to do to make this happen?

928
00:43:38,166 --> 00:43:42,616 A:middle
Well first we need an additional
parameter to body right.

929
00:43:42,616 --> 00:43:44,746 A:middle
You can see body is
taking now a new parameter.

930
00:43:45,856 --> 00:43:47,476 A:middle
And that parameter
has the same type

931
00:43:47,476 --> 00:43:49,076 A:middle
as we're returning for memoize.

932
00:43:49,916 --> 00:43:53,616 A:middle
Whoa lots of arrow.

933
00:43:53,616 --> 00:43:55,506 A:middle
Everybody okay?

934
00:43:56,056 --> 00:43:57,546 A:middle
Okay. I'm sorry.

935
00:43:58,236 --> 00:44:01,286 A:middle
Next -- it will get easy again.

936

937
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

938
00:43:58,236 --> 00:44:01,286 A:middle
Next -- it will get easy again.

939
00:44:02,266 --> 00:44:08,746 A:middle
Next, we do the two-phase
initialization dance.

940
00:44:08,906 --> 00:44:12,266 A:middle
So here we can't really get

941
00:44:12,266 --> 00:44:14,626 A:middle
out of the two-phase
initialization problem,

942
00:44:14,656 --> 00:44:17,296 A:middle
but at least we can hide
it inside of memoize.

943
00:44:18,256 --> 00:44:20,646 A:middle
And two-phase initialization
scenarios

944
00:44:20,646 --> 00:44:23,476 A:middle
like this one are
a great application

945
00:44:23,626 --> 00:44:25,236 A:middle
for implicitly unwrapped
optionals.

946
00:44:25,956 --> 00:44:28,886 A:middle
Because right, once you've
initialized the thing,

947
00:44:28,986 --> 00:44:30,586 A:middle
after that the thing
can never be nil.

948
00:44:30,586 --> 00:44:32,596 A:middle
So there's no point
in going through all

949
00:44:32,596 --> 00:44:34,896 A:middle
that syntactic baggage
of unwrapping it.

950
00:44:35,426 --> 00:44:39,486 A:middle
And in this case, the implicitly
unwrapped optional unwraps

951
00:44:39,486 --> 00:44:41,596 A:middle
when we return it as
a non-optional, right.

952
00:44:42,766 --> 00:44:44,996 A:middle
And because it dies at
the end of this scope,

953
00:44:45,606 --> 00:44:48,956 A:middle
well any scary possibilities of
it being nil die along with it.

954
00:44:49,876 --> 00:44:54,326 A:middle
So this is actually
pretty elegant.

955
00:44:54,406 --> 00:44:58,016 A:middle
Now all that remains is
to pass result to the body

956
00:44:58,376 --> 00:45:01,366 A:middle
when it's invoked and
there you have it.

957

958
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

959
00:44:58,376 --> 00:45:01,366 A:middle
when it's invoked and
there you have it.

960
00:45:02,996 --> 00:45:06,696 A:middle
A reusable tool that
elegantly memoizes even

961
00:45:06,696 --> 00:45:07,516 A:middle
recursive functions.

962
00:45:08,516 --> 00:45:14,876 A:middle
[ Applause ]

963
00:45:15,376 --> 00:45:17,796 A:middle
Now the point of course is not
that you're going to go out

964
00:45:17,796 --> 00:45:19,226 A:middle
and memoize all your functions,

965
00:45:19,676 --> 00:45:21,496 A:middle
but that you can do
stuff like this in Swift.

966
00:45:22,076 --> 00:45:24,866 A:middle
You can write your
own modifying,

967
00:45:25,046 --> 00:45:27,226 A:middle
crazy language extension-type
functions like this.

968
00:45:28,126 --> 00:45:28,896 A:middle
And it's pretty cool.

969
00:45:30,056 --> 00:45:34,336 A:middle
So being able to do this
relied on the synergy

970
00:45:34,336 --> 00:45:36,466 A:middle
of three powerful features.

971
00:45:37,376 --> 00:45:40,786 A:middle
First, type deduction
for concision,

972
00:45:40,936 --> 00:45:43,726 A:middle
so we would have contact
and readable code.

973
00:45:44,306 --> 00:45:47,906 A:middle
Next, trailing closure syntax,

974
00:45:48,776 --> 00:45:52,276 A:middle
which evokes control flow
while supporting functional

975
00:45:52,326 --> 00:45:53,706 A:middle
programming idioms.

976
00:45:54,446 --> 00:45:58,186 A:middle
And lastly, truly
generic functions

977
00:45:58,656 --> 00:46:03,266 A:middle
that are flexible,
safe, and fast.

978

979
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

980
00:45:58,656 --> 00:46:03,266 A:middle
that are flexible,
safe, and fast.

981
00:46:04,656 --> 00:46:06,756 A:middle
Okay. Now I want to
bring it back down

982
00:46:06,836 --> 00:46:09,456 A:middle
and talk a little bit
about generic types.

983
00:46:10,916 --> 00:46:13,936 A:middle
So you've already seen a bunch
of generic types yourself.

984
00:46:14,516 --> 00:46:17,436 A:middle
Arrays in Swift are
just generic structs

985
00:46:17,746 --> 00:46:19,096 A:middle
and so are our dictionaries.

986
00:46:19,826 --> 00:46:21,736 A:middle
And optionals are
just generic enums.

987
00:46:22,136 --> 00:46:24,536 A:middle
And if you've watched
the other presentations,

988
00:46:24,536 --> 00:46:25,326 A:middle
I know that was covered.

989
00:46:26,496 --> 00:46:28,216 A:middle
You can also make
generic classes in Swift.

990
00:46:28,706 --> 00:46:31,066 A:middle
Let's make a generic struct.

991
00:46:32,716 --> 00:46:35,386 A:middle
So we'll start with a
simple concrete struct,

992
00:46:35,826 --> 00:46:37,706 A:middle
concrete stack of strings.

993
00:46:38,916 --> 00:46:40,286 A:middle
It's got push and pop methods

994
00:46:40,286 --> 00:46:42,496 A:middle
and it's just implemented
in terms of an array.

995
00:46:43,796 --> 00:46:45,466 A:middle
Now let's make this into
a stack of any type.

996
00:46:46,196 --> 00:46:50,226 A:middle
We just do what we did
with our generic functions.

997
00:46:50,296 --> 00:46:51,936 A:middle
When we made a concrete
function generic,

998
00:46:52,256 --> 00:46:53,966 A:middle
we took the concrete
types and replaced them

999
00:46:53,966 --> 00:46:57,406 A:middle
with a type parameter,
and there you have it.

1000
00:46:58,076 --> 00:47:02,976 A:middle
Now I can make a stack
of Ints or a stack

1001

1002
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1003
00:46:58,076 --> 00:47:02,976 A:middle
Now I can make a stack
of Ints or a stack

1004
00:47:02,976 --> 00:47:04,806 A:middle
of NSWindows if I like.

1005
00:47:05,616 --> 00:47:08,686 A:middle
So notice that unlike
with generic functions,

1006
00:47:09,016 --> 00:47:14,166 A:middle
when you use a generic type
you actually supply the type

1007
00:47:14,436 --> 00:47:16,286 A:middle
arguments explicitly
most of the time.

1008
00:47:17,116 --> 00:47:19,506 A:middle
With functions the type
arguments are always deduced.

1009
00:47:20,026 --> 00:47:25,326 A:middle
Now Crusty probably wants
to be able to log our stack.

1010
00:47:25,956 --> 00:47:29,466 A:middle
And he would probably write
his logging function like this.

1011
00:47:30,736 --> 00:47:32,946 A:middle
But unfortunately
that's not going to work.

1012
00:47:33,756 --> 00:47:36,556 A:middle
It's not going to work
because the for Int syntax

1013
00:47:36,556 --> 00:47:39,786 A:middle
as John mentioned is governed
by this sequence protocol

1014
00:47:39,786 --> 00:47:40,806 A:middle
and we haven't implemented it.

1015
00:47:41,356 --> 00:47:42,846 A:middle
So let's take a look
under the hood

1016
00:47:43,236 --> 00:47:45,576 A:middle
at how Swift does
for...in loops.

1017
00:47:46,526 --> 00:47:48,486 A:middle
So when you write
a loop like this,

1018
00:47:49,376 --> 00:47:53,026 A:middle
Swift internally rewrites
your code like this.

1019
00:47:53,026 --> 00:47:55,696 A:middle
So what's happening here?

1020
00:47:56,406 --> 00:47:59,336 A:middle
First it goes to your
sequence and it calls generate,

1021
00:47:59,636 --> 00:48:00,616 A:middle
to get a generator out.

1022

1023
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1024
00:47:59,636 --> 00:48:00,616 A:middle
to get a generator out.

1025
00:48:01,066 --> 00:48:07,296 A:middle
Next, it repeatedly
calls the next function

1026
00:48:07,296 --> 00:48:09,846 A:middle
on your generator
until it gets nil.

1027
00:48:10,126 --> 00:48:11,876 A:middle
So next returns an optional.

1028
00:48:12,326 --> 00:48:14,706 A:middle
And those optionals are
filled in with values

1029
00:48:14,706 --> 00:48:15,856 A:middle
until the sequence runs out.

1030
00:48:16,476 --> 00:48:18,976 A:middle
Okay so what is this
generator thing?

1031
00:48:19,476 --> 00:48:20,426 A:middle
I'm sure you can guess.

1032
00:48:21,276 --> 00:48:23,996 A:middle
It's a protocol, okay.

1033
00:48:24,356 --> 00:48:25,756 A:middle
And the first thing you see

1034
00:48:25,756 --> 00:48:28,316 A:middle
in this protocol
is this type alias.

1035
00:48:29,576 --> 00:48:31,906 A:middle
Now when you see a type
alias in a protocol,

1036
00:48:32,536 --> 00:48:35,076 A:middle
that's called an
associated type requirement.

1037
00:48:37,476 --> 00:48:39,136 A:middle
Okay, it can be satisfied just

1038
00:48:39,136 --> 00:48:43,426 A:middle
by writing any nested type
called element inside your

1039
00:48:43,726 --> 00:48:46,276 A:middle
generator, but why
do we do this?

1040
00:48:46,496 --> 00:48:49,586 A:middle
Well it's usually a type
that's involved in one

1041
00:48:49,716 --> 00:48:51,626 A:middle
of the protocol other
requirements,

1042
00:48:51,626 --> 00:48:52,906 A:middle
in this case, Next.

1043
00:48:53,406 --> 00:48:55,656 A:middle
You have to express that,
you know, here's a name

1044
00:48:55,726 --> 00:48:59,816 A:middle
for a type that's going
to come out of Next.

1045

1046
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1047
00:49:00,706 --> 00:49:03,126 A:middle
So let's build a
generator for stack.

1048
00:49:05,086 --> 00:49:05,856 A:middle
Here's the code.

1049
00:49:07,376 --> 00:49:11,356 A:middle
So it's just another
generic struct, right.

1050
00:49:11,446 --> 00:49:12,686 A:middle
It conforms to generator.

1051
00:49:13,286 --> 00:49:17,556 A:middle
And you can see that it
implements all the necessary

1052
00:49:17,556 --> 00:49:19,316 A:middle
parts of the blueprint here.

1053
00:49:19,906 --> 00:49:24,366 A:middle
Now we've written a
little bit more here

1054
00:49:24,366 --> 00:49:25,506 A:middle
than we actually had to.

1055
00:49:26,256 --> 00:49:31,236 A:middle
See when the compiler matches
up that next requirement

1056
00:49:31,676 --> 00:49:32,796 A:middle
with this Next function,

1057
00:49:33,416 --> 00:49:38,046 A:middle
it can see that the
element type has to be T.

1058
00:49:38,376 --> 00:49:40,716 A:middle
So that associated
type is deduced

1059
00:49:40,716 --> 00:49:44,706 A:middle
and we can just leave it out.

1060
00:49:44,986 --> 00:49:45,996 A:middle
That gets really convenient.

1061
00:49:47,266 --> 00:49:48,996 A:middle
The next thing I
need to point out is

1062
00:49:48,996 --> 00:49:50,396 A:middle
that we've used this Slice type.

1063
00:49:50,936 --> 00:49:54,716 A:middle
So Slice is a lot like array, in
fact you make them from arrays

1064
00:49:54,716 --> 00:49:57,296 A:middle
by slicing the array
using this syntax.

1065
00:49:57,716 --> 00:49:59,736 A:middle
So you pass a range to
the subscript operator.

1066

1067
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1068
00:50:00,346 --> 00:50:02,826 A:middle
And Slice differs from array

1069
00:50:02,826 --> 00:50:05,186 A:middle
in that you can efficiently
drop things off the front

1070
00:50:05,186 --> 00:50:07,466 A:middle
of the Slice in order one time.

1071
00:50:08,046 --> 00:50:10,186 A:middle
So that's why we're using it
because we want to go forward

1072
00:50:10,186 --> 00:50:10,976 A:middle
through this sequence.

1073
00:50:12,006 --> 00:50:14,246 A:middle
So, what do we do?

1074
00:50:14,246 --> 00:50:16,006 A:middle
First we check to see
if the Slice is empty,

1075
00:50:16,306 --> 00:50:17,446 A:middle
if it is we return nil,

1076
00:50:18,286 --> 00:50:20,086 A:middle
otherwise we get the
first item off the Slice.

1077
00:50:20,846 --> 00:50:25,236 A:middle
Replace the Slice with the rest
of the elements and return.

1078
00:50:26,686 --> 00:50:27,886 A:middle
And there's our complete
generator.

1079
00:50:28,446 --> 00:50:32,966 A:middle
But we're not done yet because
we haven't implemented sequence.

1080
00:50:33,766 --> 00:50:36,036 A:middle
Right, this is a
two-protocol, protocol.

1081
00:50:38,046 --> 00:50:40,866 A:middle
So sequence has a very similar
structure to that of generator.

1082
00:50:42,436 --> 00:50:44,006 A:middle
The most notable difference is

1083
00:50:44,176 --> 00:50:47,186 A:middle
that its associated
type is constrained here

1084
00:50:47,186 --> 00:50:50,306 A:middle
to be a generator and
that's how Swift knows

1085
00:50:50,306 --> 00:50:53,946 A:middle
that it can call next on the
thing that gets out of generate.

1086
00:50:54,536 --> 00:50:59,626 A:middle
Okay, so let's implement
sequence for our stack.

1087

1088
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1089
00:51:01,496 --> 00:51:02,346 A:middle
Here it is.

1090
00:51:03,336 --> 00:51:06,936 A:middle
Notice first that I've done the
entire implementation inside an

1091
00:51:06,936 --> 00:51:09,606 A:middle
extension that's
dedicated to that protocol.

1092
00:51:09,606 --> 00:51:11,776 A:middle
And this is a really slick way

1093
00:51:11,776 --> 00:51:14,766 A:middle
to partition your code
especially if you have a lot

1094
00:51:14,766 --> 00:51:15,966 A:middle
of protocol conformances.

1095
00:51:16,386 --> 00:51:18,346 A:middle
And that's going to be
pretty common in Swift.

1096
00:51:18,796 --> 00:51:25,256 A:middle
In a lot of ways Swift is
a protocol-based language.

1097
00:51:25,256 --> 00:51:26,766 A:middle
Next, I want you to notice

1098
00:51:26,766 --> 00:51:30,146 A:middle
that I haven't given the
associated type explicitly,

1099
00:51:30,146 --> 00:51:30,396 A:middle
right.

1100
00:51:30,686 --> 00:51:34,036 A:middle
It gets deduced from the
signature of this function,

1101
00:51:34,916 --> 00:51:36,406 A:middle
which returns a stack generator,

1102
00:51:36,406 --> 00:51:41,346 A:middle
which is the thing
we just created.

1103
00:51:41,426 --> 00:51:45,176 A:middle
Lastly, I want to point out
there are some circumstances

1104
00:51:45,176 --> 00:51:46,226 A:middle
where you don't even need

1105
00:51:46,226 --> 00:51:48,796 A:middle
to write the type
parameters on a generic type.

1106
00:51:49,386 --> 00:51:51,716 A:middle
In this case, I'm
returning stack generator

1107
00:51:51,716 --> 00:51:54,526 A:middle
and I haven't written
the T in angled brackets.

1108
00:51:54,896 --> 00:51:56,516 A:middle
That's because the type context,

1109
00:51:56,566 --> 00:51:58,916 A:middle
the fact that we're
returning the stack generator

1110
00:51:58,916 --> 00:52:05,256 A:middle
of T allows the compiler to
deduce what type that is.

1111

1112
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1113
00:51:58,916 --> 00:52:05,256 A:middle
of T allows the compiler to
deduce what type that is.

1114
00:52:05,466 --> 00:52:10,336 A:middle
Okay and now we can finally loop
over the elements of our stack

1115
00:52:10,766 --> 00:52:11,986 A:middle
and Crusty is happy again.

1116
00:52:12,596 --> 00:52:18,086 A:middle
Okay, there is a lot
more I could tell you

1117
00:52:18,086 --> 00:52:19,156 A:middle
about generics and Swift.

1118
00:52:19,536 --> 00:52:20,896 A:middle
And I know this was
pretty intense.

1119
00:52:21,396 --> 00:52:22,846 A:middle
So we're going to stop here.

1120
00:52:23,026 --> 00:52:26,116 A:middle
I wish we had time to cover
the collection protocols,

1121
00:52:26,116 --> 00:52:28,986 A:middle
the index protocol,
protocol refinement.

1122
00:52:29,406 --> 00:52:32,606 A:middle
How to build lazy functional
adapters like we have, like map,

1123
00:52:32,756 --> 00:52:35,576 A:middle
filter, and reverse like we
have in the standard library,

1124
00:52:35,956 --> 00:52:38,906 A:middle
but you know, you can find
all of that stuff if you dig

1125
00:52:38,906 --> 00:52:40,316 A:middle
into the documentation.

1126
00:52:41,086 --> 00:52:43,296 A:middle
If you remember only three
things about this part

1127
00:52:43,296 --> 00:52:45,816 A:middle
of the talk, let it be these.

1128
00:52:46,656 --> 00:52:48,446 A:middle
First, protocols are
what let you hook

1129
00:52:48,446 --> 00:52:51,476 A:middle
into the basic core language
features like for Int,

1130
00:52:51,476 --> 00:52:52,436 A:middle
and string interpolation.

1131
00:52:53,656 --> 00:52:58,436 A:middle
Second, generics offer a
new dimension of speed,

1132
00:52:58,656 --> 00:53:02,866 A:middle
expressivity, and safety for
people coming Objective-C.

1133

1134
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1135
00:52:58,656 --> 00:53:02,866 A:middle
expressivity, and safety for
people coming Objective-C.

1136
00:53:03,146 --> 00:53:05,616 A:middle
You can do really
totally new things.

1137
00:53:06,686 --> 00:53:08,176 A:middle
And lastly, Swift is fun.

1138
00:53:08,726 --> 00:53:12,266 A:middle
I encourage you to dig into
these capabilities and find

1139
00:53:12,266 --> 00:53:13,276 A:middle
out as much as you can.

1140
00:53:13,536 --> 00:53:14,266 A:middle
Experiment.

1141
00:53:14,476 --> 00:53:15,056 A:middle
Play around.

1142
00:53:15,696 --> 00:53:19,756 A:middle
Okay. Now I'm going to bring
up John to close the talk.

1143
00:53:20,106 --> 00:53:22,926 A:middle
He's going to tell you a
bit about the Swift model.

1144
00:53:23,516 --> 00:53:31,026 A:middle
[ Applause ]

1145
00:53:31,526 --> 00:53:33,826 A:middle
>> We talked a lot about what
you can do in Swift and I want

1146
00:53:33,826 --> 00:53:37,116 A:middle
to tie it up by talking about
how Swift actually works

1147
00:53:37,296 --> 00:53:40,726 A:middle
in a couple of quick ways.

1148
00:53:40,936 --> 00:53:43,466 A:middle
Like C, Objective-C, and C++,

1149
00:53:43,946 --> 00:53:46,086 A:middle
Swift is a statically
compiled language

1150
00:53:46,146 --> 00:53:47,976 A:middle
with relatively small
runtime requirements.

1151
00:53:49,356 --> 00:53:51,286 A:middle
That's not a coincidence
and it's not

1152
00:53:51,286 --> 00:53:53,136 A:middle
because we were forced
into it in anyway.

1153
00:53:53,506 --> 00:53:56,316 A:middle
We actually believe very,
very strongly in this model

1154
00:53:56,316 --> 00:53:58,616 A:middle
of programming languages
as a great model for you.

1155
00:53:59,406 --> 00:54:00,766 A:middle
It's really flexible.

1156

1157
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1158
00:53:59,406 --> 00:54:00,766 A:middle
It's really flexible.

1159
00:54:01,396 --> 00:54:02,566 A:middle
It's really predictable.

1160
00:54:02,846 --> 00:54:03,936 A:middle
And it's really efficient.

1161
00:54:04,456 --> 00:54:09,186 A:middle
It's flexible because it allows
really simple interoperation.

1162
00:54:09,556 --> 00:54:12,306 A:middle
You don't have to write
everything in Swift.

1163
00:54:13,176 --> 00:54:15,936 A:middle
Our runtime requirements
are so small

1164
00:54:15,936 --> 00:54:20,206 A:middle
that we can just transparently
interact with your existing C,

1165
00:54:20,466 --> 00:54:25,306 A:middle
Objective-C, or Assembly
-- Ada so on.

1166
00:54:26,626 --> 00:54:27,536 A:middle
Don't write your
code Ada [laughter].

1167
00:54:30,106 --> 00:54:34,726 A:middle
And all of that makes it really
straightforward to deploy Swift

1168
00:54:35,576 --> 00:54:36,896 A:middle
to versions of iOS and OS X

1169
00:54:37,006 --> 00:54:40,246 A:middle
that don't even know
anything about the language.

1170
00:54:40,246 --> 00:54:42,206 A:middle
That were developed
without Swift in mind.

1171
00:54:42,646 --> 00:54:45,986 A:middle
Swift is a really
predictable model.

1172
00:54:45,986 --> 00:54:48,126 A:middle
Because it leaves
you fully in charge

1173
00:54:48,126 --> 00:54:49,566 A:middle
of the code that's
actually going to run

1174
00:54:49,566 --> 00:54:51,306 A:middle
on your users' devices.

1175
00:54:52,146 --> 00:54:55,056 A:middle
The compiler's going to weave
a lot of complicated magic,

1176
00:54:55,056 --> 00:54:58,536 A:middle
making generics work, optimizing
this and that and so on.

1177
00:54:58,536 --> 00:55:01,316 A:middle
But when all of that is
done, when all of it settles,

1178

1179
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1180
00:54:58,536 --> 00:55:01,316 A:middle
But when all of that is
done, when all of it settles,

1181
00:55:01,656 --> 00:55:05,346 A:middle
you see exactly what's left
and you can feel confident

1182
00:55:05,346 --> 00:55:08,226 A:middle
that that -- in how
that's actually going

1183
00:55:08,226 --> 00:55:09,726 A:middle
to run on a device.

1184
00:55:10,736 --> 00:55:13,776 A:middle
There are no extra, just
in time compilation steps

1185
00:55:13,776 --> 00:55:16,646 A:middle
where all the really interesting
optimizations are implemented.

1186
00:55:17,116 --> 00:55:19,796 A:middle
There's no non-deterministic
places

1187
00:55:20,096 --> 00:55:25,586 A:middle
where like a secondary thread is
pausing your entire application

1188
00:55:25,586 --> 00:55:28,796 A:middle
to garbage-collect right in
the middle of a user operation.

1189
00:55:29,706 --> 00:55:32,936 A:middle
You can understand your code
exactly how it was compiled,

1190
00:55:33,136 --> 00:55:35,776 A:middle
and exactly the result
and feel confident

1191
00:55:35,776 --> 00:55:38,856 A:middle
in exactly how it's
going to run.

1192
00:55:39,226 --> 00:55:42,066 A:middle
And finally, it's
really efficient.

1193
00:55:42,636 --> 00:55:44,746 A:middle
Swift generates native code.

1194
00:55:45,016 --> 00:55:47,526 A:middle
Native code that's
ready to run as soon

1195
00:55:47,526 --> 00:55:48,726 A:middle
as you put in on a device.

1196
00:55:49,516 --> 00:55:51,276 A:middle
There are no recompilation

1197
00:55:51,276 --> 00:55:54,396 A:middle
or warm-up delays while
your app launches.

1198
00:55:55,046 --> 00:55:58,726 A:middle
You're free to organize all of
your high-level code in Swift

1199
00:55:59,206 --> 00:56:02,706 A:middle
into clean and easy to maintain
abstractions using powerful

1200

1201
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1202
00:55:59,206 --> 00:56:02,706 A:middle
into clean and easy to maintain
abstractions using powerful

1203
00:56:02,706 --> 00:56:05,646 A:middle
things like generics And because
it's all statically compiled

1204
00:56:05,646 --> 00:56:09,676 A:middle
that abstraction disappears
immediately during compilation

1205
00:56:09,926 --> 00:56:14,666 A:middle
not later when the jet actually
kicks in and lowers it all

1206
00:56:14,666 --> 00:56:16,486 A:middle
down to nothing, hopefully.

1207
00:56:17,786 --> 00:56:19,876 A:middle
And the predictability
of compilation means

1208
00:56:19,876 --> 00:56:21,586 A:middle
that you can really
feel confident

1209
00:56:21,586 --> 00:56:24,306 A:middle
in exactly what is going to
run after all this is done.

1210
00:56:24,706 --> 00:56:28,116 A:middle
So you can feel confident that
you're really tight, efficient,

1211
00:56:28,396 --> 00:56:34,976 A:middle
low-level code will always
do exactly what you expect.

1212
00:56:35,086 --> 00:56:36,166 A:middle
I want to talk a little bit

1213
00:56:36,166 --> 00:56:38,156 A:middle
about the Swift compiler
architecture.

1214
00:56:39,116 --> 00:56:42,596 A:middle
The way that we accomplish
this is very, very similar

1215
00:56:42,596 --> 00:56:45,736 A:middle
to how these [inaudible]
C compilers are structured

1216
00:56:46,216 --> 00:56:48,536 A:middle
with one major modification.

1217
00:56:49,076 --> 00:56:53,476 A:middle
We add an extra step an
extra phase of compilation

1218
00:56:53,556 --> 00:56:55,986 A:middle
for high-level analysis
and optimization.

1219
00:56:56,636 --> 00:56:59,136 A:middle
These are language-specific
analyses.

1220
00:56:59,226 --> 00:57:02,606 A:middle
Things that we know specially
about Swift and its library

1221

1222
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1223
00:56:59,226 --> 00:57:02,606 A:middle
Things that we know specially
about Swift and its library

1224
00:57:02,956 --> 00:57:05,686 A:middle
that allows us to do very
high-level manipulations

1225
00:57:05,686 --> 00:57:07,776 A:middle
and produce really
great code straight off.

1226
00:57:07,776 --> 00:57:11,356 A:middle
I want to talk about three
of those in particular.

1227
00:57:11,956 --> 00:57:16,786 A:middle
The first one is I want to talk
about abstraction penalties.

1228
00:57:17,746 --> 00:57:20,836 A:middle
Suppose that you're writing an
application, and it's got --

1229
00:57:20,836 --> 00:57:23,626 A:middle
and it's talking to a
whole bunch of sensors

1230
00:57:23,626 --> 00:57:25,646 A:middle
and a whole bunch of
different subsystems and some

1231
00:57:25,696 --> 00:57:27,736 A:middle
of them are giving
you values, you know,

1232
00:57:27,736 --> 00:57:30,576 A:middle
values back in one
kind of unit and some

1233
00:57:30,576 --> 00:57:32,056 A:middle
of them are giving
you values back

1234
00:57:32,056 --> 00:57:33,146 A:middle
in a different kind of unit.

1235
00:57:33,356 --> 00:57:35,766 A:middle
And it's really important to
you that you're not app --

1236
00:57:36,066 --> 00:57:39,876 A:middle
not burn up when it re-enters
the Martian atmosphere.

1237
00:57:42,506 --> 00:57:44,836 A:middle
You can use the type
system in Swift to do this.

1238
00:57:45,316 --> 00:57:49,206 A:middle
Structs have zero added
run time extraction costs,

1239
00:57:49,206 --> 00:57:53,796 A:middle
which we've designed Swift from
ground-up to eliminate this kind

1240
00:57:53,796 --> 00:57:55,526 A:middle
of abstraction cost
transparently.

1241
00:57:56,996 --> 00:58:00,796 A:middle
In fact, in Swift even basic
fundamental library types

1242

1243
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1244
00:57:56,996 --> 00:58:00,796 A:middle
In fact, in Swift even basic
fundamental library types

1245
00:58:00,796 --> 00:58:03,716 A:middle
like Int and Float are
actually implemented as Swift

1246
00:58:03,926 --> 00:58:07,256 A:middle
as struct types that are
wrapping even more fundamental

1247
00:58:07,256 --> 00:58:07,896 A:middle
LLVM types.

1248
00:58:07,896 --> 00:58:10,896 A:middle
So you can feel very,
very confident

1249
00:58:10,896 --> 00:58:13,726 A:middle
that we've done an extraordinary
amount of work to make sure

1250
00:58:13,726 --> 00:58:16,646 A:middle
that these things don't
add any extra overhead.

1251
00:58:17,176 --> 00:58:22,466 A:middle
The second thing I want to talk
about is generic specialization.

1252
00:58:23,306 --> 00:58:25,266 A:middle
Some languages implement
generics

1253
00:58:25,306 --> 00:58:30,476 A:middle
by immediately expanding out
your code whenever you use it

1254
00:58:30,476 --> 00:58:32,296 A:middle
with a different set
of generic arguments.

1255
00:58:32,636 --> 00:58:34,776 A:middle
Now that generates
very, very fast code

1256
00:58:34,846 --> 00:58:38,796 A:middle
for this particular
expansion because it means

1257
00:58:39,056 --> 00:58:42,556 A:middle
that like the code generator
never even sees the concept

1258
00:58:42,836 --> 00:58:43,936 A:middle
of a generic function.

1259
00:58:44,866 --> 00:58:49,146 A:middle
But unfortunately, there are
a couple downsides to this.

1260
00:58:49,186 --> 00:58:52,396 A:middle
It's terrible for debug
build times and it ends

1261
00:58:52,396 --> 00:58:55,526 A:middle
up generating a ton of code
that the compiler and the linker

1262
00:58:55,526 --> 00:58:57,636 A:middle
and everything else need
to conspire together

1263
00:58:57,636 --> 00:58:59,156 A:middle
to try to hid at run time.

1264
00:58:59,846 --> 00:59:02,986 A:middle
And it also steals a lot of
flexibility from the compiler

1265

1266
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1267
00:58:59,846 --> 00:59:02,986 A:middle
And it also steals a lot of
flexibility from the compiler

1268
00:59:02,986 --> 00:59:04,686 A:middle
to actually unify these things.

1269
00:59:05,616 --> 00:59:08,236 A:middle
So in Swift, generic
specialization is

1270
00:59:08,236 --> 00:59:09,406 A:middle
an optimization.

1271
00:59:09,446 --> 00:59:13,196 A:middle
It's something that we can do,
but we also maintain the ability

1272
00:59:13,196 --> 00:59:16,446 A:middle
to run generic code
as generic code.

1273
00:59:18,216 --> 00:59:21,106 A:middle
The last thing I want to talk
about is de-virtualization.

1274
00:59:21,636 --> 00:59:23,816 A:middle
De-virtualization is
an incredibly important

1275
00:59:23,816 --> 00:59:25,676 A:middle
optimization in Swift,
because so much

1276
00:59:25,676 --> 00:59:27,216 A:middle
of your code is written
around classes.

1277
00:59:27,476 --> 00:59:31,636 A:middle
It's very important
for us to be able

1278
00:59:31,636 --> 00:59:34,386 A:middle
to take something very
simple and very lightweight

1279
00:59:34,386 --> 00:59:38,646 A:middle
like a getter and turn that into
direct manipulation of memory.

1280
00:59:39,786 --> 00:59:42,126 A:middle
There's a lot of ways that
we can do de-virtualization

1281
00:59:42,126 --> 00:59:42,996 A:middle
in Swift.

1282
00:59:43,146 --> 00:59:45,736 A:middle
We can see where you're actually
constructing the object.

1283
00:59:46,086 --> 00:59:48,096 A:middle
We can do hierarchy
analysis to see

1284
00:59:48,096 --> 00:59:50,066 A:middle
that a class doesn't
have any sub-classes.

1285
00:59:50,066 --> 00:59:54,476 A:middle
But you can also take control of
this manually by marking methods

1286
00:59:54,476 --> 00:59:57,026 A:middle
and classes as final,
in order to tell Swift

1287
00:59:57,026 --> 00:59:59,026 A:middle
that it doesn't have to
worry about the possibility

1288
00:59:59,026 --> 01:00:00,366 A:middle
of it being overridden anywhere.

1289

1290
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00,000

1291
00:59:59,026 --> 01:00:00,366 A:middle
of it being overridden anywhere.

1292
01:00:00,906 --> 01:00:04,256 A:middle
There are a lot of other
high-level optimizations

1293
01:00:04,256 --> 01:00:06,086 A:middle
that I really wish that I
had the time to talk to,

1294
01:00:06,086 --> 01:00:07,976 A:middle
but I'm actually already
two minutes over time.

1295
